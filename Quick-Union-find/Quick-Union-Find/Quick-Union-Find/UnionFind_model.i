#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\Quick-Union-Find\\UnionFind_model.ixx"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\Quick-Union-Find\\pch.h"




#pragma once

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"






















































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"







#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"













#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





























































































































































































































































































































































































































































































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"







#pragma once






















#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"






    
    

#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
        
            
        

#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
    #line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"













#pragma once







































































































































#line 151 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"



#line 155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"





























#line 185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"


#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"

#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"





#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"



#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"











#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"








#line 228 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
#line 229 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






























#line 1586 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
























#line 1611 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"












#line 1624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






































#line 1663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"















































































































#line 1775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






































































































#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"








































































































































































#line 2047 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"





































































































#line 2149 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"



















































































































































































































#line 2361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
extern "C" {




#line 2367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"



































































































































































































































#line 2595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"









































































































































































































































#line 2868 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"









#line 2878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"





#line 2884 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
    
#line 2886 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
#line 2887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






#line 2894 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
#line 2895 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






#line 2902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
#line 2903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"











#line 2915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"

































#line 2949 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"






















}
#line 2973 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"











































































































































































































































































#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"



#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"
















































#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"











































#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"


}
#line 393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"

#line 395 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concurrencysal.h"
#pragma external_header(pop)
#line 2975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sal.h"
#pragma external_header(pop)
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)



    


        
    #line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"
#line 25 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"




    


        
    #line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"



    
#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"




    
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C" {
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"



#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"


    
    
        typedef unsigned __int64  uintptr_t;
    

#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"


    


#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"





#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"



#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"
    
    
#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"











#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"







#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"











#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"





#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"










#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"










#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"

    void __cdecl __va_start(va_list* , ...);

    
    



    

#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"


} 
#line 169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_assert_va_start_is_not_reference
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                "va_start argument must not have reference type and must not be parenthesized");
        };
    } 

    





#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vadefs.h"

#pragma warning(pop) 
#pragma pack(pop)
#pragma external_header(pop)
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )






    



    





















#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    


        
    #line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
















    

#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
        
    #line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    

#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
        
    #line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"





#line 145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
    
    
#line 148 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"




    
#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"








    


#line 166 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



#line 170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
    
#line 172 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"




    
#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
        
    

#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"






    typedef unsigned __int64 size_t;
    typedef __int64          ptrdiff_t;
    typedef __int64          intptr_t;




#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



    
#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"








    
        
    

#line 237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    


#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
    

#line 271 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


#line 274 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
    

#line 281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
    

#line 289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
    

#line 297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"





#line 304 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



#line 308 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



    


        
    

#line 318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    


#line 325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"









    
        
    

#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"









#line 350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    


        




    #line 361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"



#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    
        
    


#line 374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 375 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


    void __cdecl __security_init_cookie(void);

    


#line 383 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"


#line 386 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
        void __cdecl __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(  uintptr_t _StackCookie);
    #line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#line 390 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 404 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime.h"
#pragma external_header(pop)
#line 496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"






























#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 62 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 164 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 182 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 194 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 212 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 230 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 242 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 284 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"






#line 303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 321 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 327 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 333 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 357 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 375 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 381 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 399 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 405 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 429 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 435 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 447 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 453 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 471 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 477 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 489 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 501 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 507 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 513 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"






#line 520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 526 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 538 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"






#line 545 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"







#line 565 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 571 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 577 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"





#line 583 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"



#line 587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"

#line 589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"
#line 590 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xkeycheck.h"
#pragma external_header(pop)
#line 497 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 503 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 505 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"














#line 520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 522 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 523 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 527 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 531 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"













#line 553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"













#line 567 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 582 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 584 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





















































































#line 670 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

































#line 704 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 706 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 714 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 722 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 741 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"














#line 756 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 763 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 768 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 770 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 774 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






































#line 813 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






















#line 836 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 837 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 844 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 845 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 857 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 861 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 862 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 884 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 886 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 890 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


#line 893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


#line 896 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 897 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 901 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 905 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 929 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 946 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 956 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 970 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 978 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 983 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"














#line 998 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1005 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1015 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1026 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"








#line 1035 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1036 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"














#line 1052 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1063 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1076 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"












#line 1090 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"













#line 1118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"















#line 1185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
















#line 1215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
















#line 1232 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"















#line 1249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"












#line 1263 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1275 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"












#line 1288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"












#line 1302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"











#line 1338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1373 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1384 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1408 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1420 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1432 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1453 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


















#line 1473 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1507 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"








#line 1516 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1524 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1528 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1536 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1540 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1544 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1548 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1556 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1563 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 1568 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1574 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"




#line 1583 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"































#line 1615 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


























#line 1642 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1648 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


















#line 1667 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1685 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 1693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1694 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1698 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

















#line 1716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



















#line 1736 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"









#line 1746 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"








#line 1761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1765 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"













#line 1779 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1785 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
















#line 1802 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



























#line 1830 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"










#line 1841 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


#line 1844 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1851 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 1859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1865 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1873 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 1881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"






#line 1888 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1889 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1895 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1901 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1907 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





































#line 1945 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1949 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"



#line 1953 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"












#line 1966 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


#line 1969 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"


#line 1972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1973 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1979 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"







#line 1987 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"





#line 1993 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"

#line 1995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#line 1996 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals_core.h"
#pragma external_header(pop)
#line 9 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cfloat"









#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"








#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"







#pragma once












    


        
    #line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 27 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













    
#line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    











        
    #line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 64 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        
    #line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 72 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    

#line 92 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"




    
#line 99 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    

#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    

#line 108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





    
#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









    
#line 153 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













    


        
    #line 171 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 182 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 184 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;






#line 221 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"










    
        
    #line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"








#line 243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



















    

#line 265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
        
    #line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 268 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 276 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


 
  
   
  

#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
 





#line 291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 292 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"







    

















        
    #line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 320 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
        
    

#line 331 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

























__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const* _Expression,
      wchar_t const* _FunctionName,
      wchar_t const* _FileName,
            unsigned int _LineNo,
            uintptr_t _Reserved);


    



        
        
        
        
        
        
        
        
        
        
        
        

    #line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"












    


#line 405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 409 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        


    #line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"









    






        
    #line 437 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        
    #line 445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 450 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"













#line 464 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"















#line 480 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





    
#line 487 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 491 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    

#line 496 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 497 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        


            
        #line 507 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    #line 508 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 509 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 513 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"





#line 519 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        



    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 530 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
        
    



#line 539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
              
        

#line 556 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    



#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
    



#line 569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

    
        
    



#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 578 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    
#line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 622 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



#line 626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 633 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"



    
#line 639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 643 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        












        












        
















    














#line 813 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"












































































    













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1865 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

        
        
        
        

        

            


            


            


            


            


            


            


            


            



            



            


            


            


            


            


            


            


            


            


            


            



            



            



            


            



            




            

            




            

            




            

            




            

            




            

            




            

            




            

            




            

        











































#line 2055 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
    #line 2056 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt.h"

} __pragma(pack(pop))


#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
    #line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"



















    






        
    #line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#line 63 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
























































































































































#line 216 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"

    

#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141) 

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);















__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );












 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);


      __declspec(dllimport) float __cdecl _scalbf(  float _X,   long _Y);
#line 324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"










    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\float.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cfloat"
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cfloat"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\climits"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"







#pragma once




#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {







    
    



#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"
































    
    
        
    

#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"


    
        
    #line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\climits"

#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\climits"
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\climits"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cwchar"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdio"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"









#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
    
#line 28 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"


    

#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
        
    

#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#line 38 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"














    








#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"

    
        


            #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
        #line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
    #line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"
#line 76 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"






#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"


    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }

    
    
       
    
    __declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"



#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_stdio_config.h"




















} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 33 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);










    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl fgetwc(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    
    __declspec(dllimport) wint_t __cdecl fputwc(
             wchar_t _Character,
          FILE*   _Stream);

    
    __declspec(dllimport) wint_t __cdecl _fputwchar(
          wchar_t _Character
        );

     
    __declspec(dllimport) wint_t __cdecl getwc(
          FILE* _Stream
        );

     
    __declspec(dllimport) wint_t __cdecl getwchar(void);


    
     
    __declspec(dllimport) wchar_t* __cdecl fgetws(
          wchar_t* _Buffer,
                                  int      _BufferCount,
                               FILE*    _Stream
        );

    
    __declspec(dllimport) int __cdecl fputws(
           wchar_t const* _Buffer,
          FILE*          _Stream
        );

    
     
    __declspec(dllimport) wchar_t* __cdecl _getws_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s( wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __declspec(dllimport) wint_t __cdecl putwc(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl putwchar(
          wchar_t _Character
        );

    
    __declspec(dllimport) int __cdecl _putws(
          wchar_t const* _Buffer
        );

    
    __declspec(dllimport) wint_t __cdecl ungetwc(
             wint_t _Character,
          FILE*  _Stream
        );

     
    __declspec(dllimport) FILE * __cdecl _wfdopen(
            int            _FileHandle,
          wchar_t const* _Mode
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _wfopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode
        );

     
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl _wfreopen(
           wchar_t const* _FileName,
           wchar_t const* _Mode,
          FILE*          _OldStream
        );

    
    __declspec(dllimport) errno_t __cdecl _wfreopen_s(
          FILE**         _Stream,
                             wchar_t const* _FileName,
                             wchar_t const* _Mode,
                            FILE*          _OldStream
        );

     
    __declspec(dllimport) FILE* __cdecl _wfsopen(
          wchar_t const* _FileName,
          wchar_t const* _Mode,
            int            _ShFlag
        );

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    

         
        __declspec(dllimport) FILE* __cdecl _wpopen(
              wchar_t const* _Command,
              wchar_t const* _Mode
            );

    #line 181 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __declspec(dllimport) int __cdecl _wremove(
          wchar_t const* _FileName
        );

    
    

     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
          wchar_t const* _Directory,
          wchar_t const* _FilePrefix
        );

    

     
    
    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(
          wchar_t* _Buffer,
                                  size_t   _BufferCount
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wtmpnam_s( wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 209 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _getwc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _putwc_nolock(
             wchar_t _Character,
          FILE*   _Stream
        );

    
    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
             wint_t _Character,
          FILE*  _Stream
        );

    



#line 256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    





    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 308 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 322 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 337 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 353 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 359 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 370 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 388 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 398 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 425 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwprintf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 440 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 444 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 460 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 492 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl fwprintf(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 501 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 510 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_s_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 520 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 529 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwprintf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 540 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 549 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 551 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p_l(
                                          FILE*          const _Stream,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 561 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 570 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwprintf_p(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 579 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 588 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 597 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 606 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl wprintf(
            wchar_t const* const _Format,
        ...)
    

#line 614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 632 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wprintf_s(
                wchar_t const* const _Format,
            ...)
    

#line 651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 660 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 671 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 680 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 688 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 697 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vfwscanf_l(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 729 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vfwscanf(
          FILE*                                const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 743 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vfwscanf_s_l(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 754 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 760 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vfwscanf_s(
                                    FILE*          const _Stream,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 778 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __inline int __cdecl _vwscanf_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 791 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl vwscanf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 800 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 804 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _vwscanf_s_l(
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 814 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 818 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl vwscanf_s(
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 829 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fwscanf_l(
                                         FILE*          const _Stream,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 845 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 854 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fwscanf(
                               FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)
    

#line 863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 872 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _fwscanf_s_l(
                                           FILE*          const _Stream,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl fwscanf_s(
                                     FILE*          const _Stream,
                wchar_t const* const _Format,
            ...)
    

#line 902 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 911 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 913 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _wscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 922 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 931 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl wscanf(
            wchar_t const* const _Format,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    
    __inline int __cdecl _wscanf_s_l(
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 966 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

        
        __inline int __cdecl wscanf_s(
                wchar_t const* const _Format,
            ...)
    

#line 976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 985 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 987 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"



    
    
    
    
    
    
        



    

#line 1003 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                             unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    
    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                             unsigned __int64 _Options,
                     wchar_t*         _Buffer,
                                             size_t           _BufferCount,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
                                                     va_list              _ArgList
        )
    

#line 1061 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1069 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1091 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1108 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
                                                     va_list        _ArgList
        )
    

#line 1129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1133 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1142 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
                                                          va_list              _ArgList
        )
    

#line 1192 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1196 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __vswprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1212 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
                                         va_list              _ArgList
        )
    

#line 1223 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1227 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                          va_list              _ArgList
        )
    

#line 1239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1243 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1264 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl vswprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
                                                          va_list              _ArgList
            )
    

#line 1277 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1283 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
                                                      va_list              _ArgList
        )
    

#line 1304 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
                                                      va_list              _ArgList
        )
    

#line 1324 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1339 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }
    #line 1361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )
    

#line 1372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1380 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _vscwprintf_p(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )
    

#line 1390 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1394 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl __swprintf_l(
                  wchar_t*       const _Buffer,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1405 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1435 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf(
           wchar_t*       const _Buffer,
               wchar_t const* const _Format,
        ...)
    

#line 1445 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1454 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl swprintf(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1465 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1474 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(   wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1483 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(   wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(   wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_s_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1502 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1511 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        __inline int __cdecl swprintf_s(
               wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
            ...)
    

#line 1523 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1532 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1534 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl swprintf_s( wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1541 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p_l(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                  wchar_t const* const _Format,
                                               _locale_t      const _Locale,
        ...)
    

#line 1553 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1562 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_p(
           wchar_t*       const _Buffer,
                                                   size_t         const _BufferCount,
                            wchar_t const* const _Format,
        ...)
    

#line 1573 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1594 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swprintf_c(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1614 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1623 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwprintf_l(
            wchar_t*       const _Buffer,
                                                  size_t         const _BufferCount,
                 wchar_t const* const _Format,
                                              _locale_t      const _Locale,
        ...)
    

#line 1635 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1646 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf(
            wchar_t*       _Buffer,
                                                  size_t         _BufferCount,
                           wchar_t const* _Format,
        ...)
    

#line 1657 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s_l(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                      wchar_t const* const _Format,
                                                   _locale_t      const _Locale,
        ...)
    

#line 1681 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwprintf_s(
           wchar_t*       const _Buffer,
                                                       size_t         const _BufferCount,
                                                       size_t         const _MaxCount,
                                wchar_t const* const _Format,
        ...)
    

#line 1702 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1711 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snwprintf_s( wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1719 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    __inline int __cdecl _scwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1728 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1737 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf(
            wchar_t const* const _Format,
        ...)
    

#line 1746 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1755 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)
    

#line 1765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1774 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     
    __inline int __cdecl _scwprintf_p(
            wchar_t const* const _Format,
        ...)
    

#line 1783 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
        
        
        #pragma warning(push)
        #pragma warning(disable: 4141 6054)

        

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int swprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
                _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl vswprintf(
                           wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                              va_list              _ArgList
                ) throw()
            {
                return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int _swprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                ...) throw()
            {
                int _Result;
                va_list _ArgList;
                ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
                _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
                ((void)(_ArgList = (va_list)0));
                return _Result;
            }

            extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
            inline int __cdecl _vswprintf_l(
                                     wchar_t*       const _Buffer,
                    wchar_t const* const _Format,
                                                 _locale_t      const _Locale,
                                                        va_list              _ArgList
                ) throw()
            {
                return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            }

        #line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

        #pragma warning(pop)
    #line 1856 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    




#line 1863 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"


    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                            unsigned __int64 _Options,
                  wchar_t const*   _Buffer,
                                            size_t           _BufferCount,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     
    
    __inline int __cdecl _vswscanf_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1897 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl vswscanf(
                                 wchar_t const* _Buffer,
            wchar_t const* _Format,
                                      va_list        _ArgList
        )
    

#line 1908 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 1912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vswscanf_s_l(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                               _locale_t      const _Locale,
                                      va_list              _ArgList
        )
    

#line 1924 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl vswscanf_s(
                                     wchar_t const* const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            )
    

#line 1943 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 1949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1957 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )
    

#line 1970 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1976 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _vsnwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
                                                 va_list              _ArgList
        )
    

#line 1989 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }
    #line 1995 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _swscanf_l(
                                          wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                        _locale_t            _Locale,
        ...)
    

#line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2015 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl swscanf(
                                wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)
    

#line 2025 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2034 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _swscanf_s_l(
                                            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2045 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2054 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    

         
        
        __inline int __cdecl swscanf_s(
                                      wchar_t const* const _Buffer,
                wchar_t const* const _Format,
            ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    #line 2077 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf_l(
                  wchar_t const* const _Buffer,
                                            size_t         const _BufferCount,
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)
    

#line 2089 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snwscanf(
            wchar_t const* const _Buffer,
                                      size_t         const _BufferCount,
                wchar_t const* const _Format,
        ...)
    

#line 2111 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s_l(
                    wchar_t const* const _Buffer,
                                              size_t         const _BufferCount,
            wchar_t const* const _Format,
                                          _locale_t      const _Locale,
        ...)
    

#line 2134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

     
    
    __inline int __cdecl _snwscanf_s(
             wchar_t const* const _Buffer,
                                       size_t         const _BufferCount,
               wchar_t const* const _Format,
        ...)
    

#line 2154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

    


#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {































    
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"















    
    
#line 71 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;





    
    __declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
               FILE*   _Stream,
          char*** _Base,
          char*** _Pointer,
          int**   _Count
        );


    
    
    
    
    
    

        
        __declspec(dllimport) errno_t __cdecl clearerr_s(
              FILE* _Stream
            );

        
         
        __declspec(dllimport) errno_t __cdecl fopen_s(
              FILE**      _Stream,
                                     char const* _FileName,
                                     char const* _Mode
            );

        
         
        __declspec(dllimport) size_t __cdecl fread_s(
                void*  _Buffer,
                                    size_t _BufferSize,
                                                                            size_t _ElementSize,
                                                                            size_t _ElementCount,
                                                                         FILE*  _Stream
            );

        
        __declspec(dllimport) errno_t __cdecl freopen_s(
              FILE**      _Stream,
                                 char const* _FileName,
                                 char const* _Mode,
                                FILE*       _OldStream
            );

         
        __declspec(dllimport) char* __cdecl gets_s(
              char*   _Buffer,
                               rsize_t _Size
            );

        
        __declspec(dllimport) errno_t __cdecl tmpfile_s(
                FILE** _Stream
            );

         
        
        __declspec(dllimport) errno_t __cdecl tmpnam_s(
              char*   _Buffer,
                               rsize_t _Size
            );

    #line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl clearerr(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fclose(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fcloseall(void);

     
    __declspec(dllimport) FILE* __cdecl _fdopen(
            int         _FileHandle,
          char const* _Mode
        );

     
    __declspec(dllimport) int __cdecl feof(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl ferror(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl fflush(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl fgetc(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fgetchar(void);

     
    
    __declspec(dllimport) int __cdecl fgetpos(
          FILE*   _Stream,
            fpos_t* _Position
        );

     
    
    __declspec(dllimport) char* __cdecl fgets(
          char* _Buffer,
                               int   _MaxCount,
                            FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl _fileno(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _flushall(void);

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl fopen(
          char const* _FileName,
          char const* _Mode
        );


     
    
    __declspec(dllimport) int __cdecl fputc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _fputchar(
          int _Character
        );

     
    
    __declspec(dllimport) int __cdecl fputs(
           char const* _Buffer,
          FILE*       _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fread(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl freopen(
           char const* _FileName,
           char const* _Mode,
          FILE*       _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _fsopen(
          char const* _FileName,
          char const* _Mode,
            int         _ShFlag
        );

     
    
    __declspec(dllimport) int __cdecl fsetpos(
          FILE*         _Stream,
             fpos_t const* _Position
        );

     
    
    __declspec(dllimport) int __cdecl fseek(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

     
    
    __declspec(dllimport) int __cdecl _fseeki64(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
     
    __declspec(dllimport) long __cdecl ftell(
          FILE* _Stream
        );

     
     
    __declspec(dllimport) __int64 __cdecl _ftelli64(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl fwrite(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

     
     
    __declspec(dllimport) int __cdecl getc(
          FILE* _Stream
        );

     
    __declspec(dllimport) int __cdecl getchar(void);

     
    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) int __cdecl _getw(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl perror(
          char const* _ErrorMessage
        );

    

         
        
        __declspec(dllimport) int __cdecl _pclose(
              FILE* _Stream
            );

         
        __declspec(dllimport) FILE* __cdecl _popen(
              char const* _Command,
              char const* _Mode
            );

    #line 344 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl putc(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl putchar(
          int _Character
        );

    
    __declspec(dllimport) int __cdecl puts(
          char const* _Buffer
        );

     
    
    __declspec(dllimport) int __cdecl _putw(
             int   _Word,
          FILE* _Stream
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFileName,
          char const* _NewFileName
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

    

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

    #line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    __declspec(dllimport) void __cdecl rewind(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl setbuf(
                                                      FILE* _Stream,
            char* _Buffer
        );

    
    __declspec(dllimport) int __cdecl _setmaxstdio(
          int _Maximum
        );

     
    
    __declspec(dllimport) int __cdecl setvbuf(
                               FILE*  _Stream,
            char*  _Buffer,
                                  int    _Mode,
                                  size_t _Size
        );

    


#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
          char const* _DirectoryName,
          char const* _FilePrefix
        );

    

#line 433 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl tmpnam_s( char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 448 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __declspec(dllimport) int __cdecl ungetc(
             int   _Character,
          FILE* _Stream
        );



    
    
    
    
    
    __declspec(dllimport) void __cdecl _lock_file(
          FILE* _Stream
        );

    __declspec(dllimport) void __cdecl _unlock_file(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fclose_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fflush_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fgetc_nolock(
          FILE* _Stream
        );

     
    
    __declspec(dllimport) int __cdecl _fputc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fread_nolock(
          void*  _Buffer,
                                                      size_t _ElementSize,
                                                      size_t _ElementCount,
                                                   FILE*  _Stream
        );

    
     
    __declspec(dllimport) size_t __cdecl _fread_nolock_s(
          void*  _Buffer,
                              size_t _BufferSize,
                                                                      size_t _ElementSize,
                                                                      size_t _ElementCount,
                                                                   FILE*  _Stream
        );

    
    __declspec(dllimport) int __cdecl _fseek_nolock(
          FILE* _Stream,
             long  _Offset,
             int   _Origin
        );

    
    __declspec(dllimport) int __cdecl _fseeki64_nolock(
          FILE*   _Stream,
             __int64 _Offset,
             int     _Origin
        );

     
    __declspec(dllimport) long __cdecl _ftell_nolock(
          FILE* _Stream
        );

     
    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) size_t __cdecl _fwrite_nolock(
          void const* _Buffer,
                                                    size_t      _ElementSize,
                                                    size_t      _ElementCount,
                                                 FILE*       _Stream
        );

    
    __declspec(dllimport) int __cdecl _getc_nolock(
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _putc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    __declspec(dllimport) int __cdecl _ungetc_nolock(
             int   _Character,
          FILE* _Stream
        );

    
    
    
    



    














#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    __declspec(dllimport) int* __cdecl __p__commode(void);

    


        
    #line 596 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    

#line 603 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                             unsigned __int64 _Options,
                                          FILE*            _Stream,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vfprintf_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 644 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 648 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfprintf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 658 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 662 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_s_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 673 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 677 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vfprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 689 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 695 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p_l(
           FILE*       const _Stream,
            char const* const _Format,
          _locale_t   const _Locale,
                 va_list           _ArgList
        )
    

#line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 720 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }
    #line 724 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 734 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 738 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 747 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 751 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 765 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vprintf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 776 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        }
    #line 780 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 792 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }
    #line 796 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 805 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
    #line 809 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 819 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 828 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl fprintf(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 837 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 846 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    __declspec(dllimport) int __cdecl _set_printf_count_output(
          int _Value
        );

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    
    __inline int __cdecl _fprintf_s_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 871 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fprintf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 891 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 893 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p_l(
                                          FILE*       const _Stream,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 903 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 912 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fprintf_p(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 921 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 939 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 948 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl printf(
            char const* const _Format,
        ...)
    

#line 956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_s_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 974 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 983 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl printf_s(
                char const* const _Format,
            ...)
    

#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1002 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1004 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1013 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1022 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _printf_p(
            char const* const _Format,
        ...)
    

#line 1030 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1039 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                            unsigned __int64 _Options,
                                         FILE*            _Stream,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _Arglist
        );

    
    __inline int __cdecl _vfscanf_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1064 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1070 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vfscanf(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1080 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }
    #line 1084 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vfscanf_s_l(
                                FILE*       const _Stream,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1095 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }
    #line 1101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    

        
        __inline int __cdecl vfscanf_s(
                                    FILE*       const _Stream,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1114 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        }
    #line 1118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1120 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1130 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vscanf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1143 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
    #line 1147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscanf_s_l(
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }
    #line 1161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl vscanf_s(
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 1172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        }
    #line 1176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _fscanf_l(
                                         FILE*       const _Stream,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1188 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1197 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl fscanf(
                               FILE*       const _Stream,
            char const* const _Format,
        ...)
    

#line 1206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _fscanf_s_l(
                                           FILE*       const _Stream,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1225 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl fscanf_s(
                                     FILE*       const _Stream,
                char const* const _Format,
            ...)
    

#line 1245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _scanf_l(
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 1265 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1274 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl scanf(
            char const* const _Format,
        ...)
    

#line 1282 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1291 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scanf_s_l(
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 1300 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl scanf_s(
                char const* const _Format,
            ...)
    

#line 1319 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1328 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1330 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    
    
    
    
     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                             unsigned __int64 _Options,
                 char*            _Buffer,
                                             size_t           _BufferCount,
                                             size_t           _MaxCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                             unsigned __int64 _Options,
                     char*            _Buffer,
                                             size_t           _BufferCount,
            char const*      _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsnprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
                                                     va_list           _ArgList
        )
    

#line 1391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf(
            char*       const _Buffer,
                                                 size_t      const _BufferCount,
                          char const* const _Format,
                                                    va_list           _ArgList
        )
    

#line 1411 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1415 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    








#line 1426 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl vsnprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1446 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vsprintf_l(
           char*       const _Buffer,
                                    char const* const _Format,
                                  _locale_t   const _Locale,
                                         va_list           _ArgList
        )
    

#line 1458 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 1462 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl vsprintf(
           char*       const _Buffer,
               char const* const _Format,
                                         va_list           _ArgList
        )
    

#line 1473 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }
    #line 1477 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1490 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1498 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
                                                          va_list           _ArgList
            )
    

#line 1512 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        }
    #line 1516 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s( char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1526 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
                                                      va_list           _ArgList
        )
    

#line 1539 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1547 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
                                                      va_list           _ArgList
        )
    

#line 1559 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
                                                          va_list          _ArgList
        )
    

#line 1577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
                                                          va_list           _ArgList
        )
    

#line 1598 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
    #line 1602 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1611 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl vsnprintf_s(
               char*       const _Buffer,
                                                           size_t      const _BufferCount,
                                                           size_t      const _MaxCount,
                                    char const* const _Format,
                                                              va_list           _ArgList
            )
    

#line 1626 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        }
    #line 1630 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1639 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1641 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1651 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1659 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1668 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }
    #line 1672 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vscprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1682 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _vscprintf_p(
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 1699 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }
    #line 1703 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
                                                va_list           _ArgList
        )
    

#line 1715 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }
    #line 1723 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _vsnprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
                                       va_list           _ArgList
        )
    

#line 1735 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
    #line 1739 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sprintf_l(
                  char*       const _Buffer,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1750 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1761 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl sprintf(
           char*       const _Buffer,
               char const* const _Format,
        ...)
    

#line 1771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1782 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1789 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_s_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1801 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1810 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

         
        
        __inline int __cdecl sprintf_s(
               char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
            ...)
    

#line 1823 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 1832 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 1834 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl sprintf_s( char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p_l(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                  char const* const _Format,
                                               _locale_t   const _Locale,
        ...)
    

#line 1853 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1862 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _sprintf_p(
           char*       const _Buffer,
                                                   size_t      const _BufferCount,
                            char const* const _Format,
        ...)
    

#line 1873 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1882 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snprintf_l(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                 char const* const _Format,
                                              _locale_t   const _Locale,
        ...)
    

#line 1894 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1905 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    








#line 1916 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl snprintf(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                char const* const _Format,
        ...)
    

#line 1927 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1936 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf(
            char*       const _Buffer,
                                                  size_t      const _BufferCount,
                           char const* const _Format,
        ...)
    

#line 1947 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1956 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1965 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                             size_t      const _BufferCount,
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 1977 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 1986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_c(
          char*       const _Buffer,
                                    size_t      const _BufferCount,
             char const* const _Format,
        ...)
    

#line 1997 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2006 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s_l(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                      char const* const _Format,
                                                   _locale_t   const _Locale,
        ...)
    

#line 2019 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2028 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    
    __inline int __cdecl _snprintf_s(
           char*       const _Buffer,
                                                       size_t      const _BufferCount,
                                                       size_t      const _MaxCount,
                                char const* const _Format,
        ...)
    

#line 2040 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2049 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline   int __cdecl _snprintf_s( char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 2057 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2066 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2075 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf(
            char const* const _Format,
        ...)
    

#line 2083 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2092 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _scprintf_p_l(
            char const* const _Format,
                                         _locale_t   const _Locale,
        ...)
    

#line 2101 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2110 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     
    __inline int __cdecl _scprintf_p(
            char const* const _Format,
        ...)
    

#line 2118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    
    
    
    
    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                            unsigned __int64 _Options,
                  char const*      _Buffer,
                                            size_t           _BufferCount,
            char const*      _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

    
    __inline int __cdecl _vsscanf_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2152 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2158 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl vsscanf(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )
    

#line 2168 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }
    #line 2172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _vsscanf_s_l(
                                 char const* const _Buffer,
            char const* const _Format,
                               _locale_t   const _Locale,
                                      va_list           _ArgList
        )
    

#line 2183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }
    #line 2189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        #pragma warning(push)
        #pragma warning(disable: 6530) 

        
        __inline int __cdecl vsscanf_s(
                                     char const* const _Buffer,
                char const* const _Format,
                                          va_list           _ArgList
            )
    

#line 2204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
        }
    #line 2208 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2215 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        #pragma warning(pop)

    #line 2219 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _sscanf_l(
                                          char const* const _Buffer,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl sscanf(
                                char const* const _Buffer,
            char const* const _Format,
        ...)
    

#line 2247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2256 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _sscanf_s_l(
                                            char const* const _Buffer,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2266 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2275 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    

        
        __inline int __cdecl sscanf_s(
                                      char const* const _Buffer,
                char const* const _Format,
            ...)
    

#line 2286 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

            _Result = vsscanf_s(_Buffer, _Format, _ArgList);

            ((void)(_ArgList = (va_list)0));
            return _Result;
        }
    #line 2297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #line 2299 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #pragma warning(push)
    #pragma warning(disable: 6530) 

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf_l(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
            char const* const _Format,
                                        _locale_t   const _Locale,
        ...)
    

#line 2313 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _snscanf(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                      char const* const _Format,
        ...)
    

#line 2336 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"


    
    __inline int __cdecl _snscanf_s_l(
              char const* const _Buffer,
                                              size_t      const _BufferCount,
            char const* const _Format,
                                          _locale_t   const _Locale,
        ...)
    

#line 2361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    
    __inline int __cdecl _snscanf_s(
            char const* const _Buffer,
                                            size_t      const _BufferCount,
                    char const* const _Format,
        ...)
    

#line 2384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
    #line 2397 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

    #pragma warning(pop)

    

#line 2403 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



    
    
    
    
    
    

        

        


#line 2419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
        __declspec(dllimport) char* __cdecl tempnam(
              char const* _Directory,
              char const* _FilePrefix
            );

        

#line 2429 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
              __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

    #line 2441 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#line 2442 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 2449 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdio.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdio"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )
















namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: size_t;
 using :: fpos_t;
 using :: FILE;
 using :: clearerr;
 using :: fclose;
 using :: feof;
 using :: ferror;
 using :: fflush;
 using :: fgetc;
 using :: fgetpos;
 using :: fgets;
 using :: fopen;
 using :: fprintf;
 using :: fputc;
 using :: fputs;
 using :: fread;
 using :: freopen;
 using :: fscanf;
 using :: fseek;
 using :: fsetpos;
 using :: ftell;
 using :: fwrite;
 using :: getc;
 using :: getchar;
 using :: perror;
 using :: putc;
 using :: putchar;
 using :: printf;
 using :: puts;
 using :: remove;
 using :: rename;
 using :: rewind;
 using :: scanf;
 using :: setbuf;
 using :: setvbuf;
 using :: sprintf;
 using :: sscanf;
 using :: tmpfile;
 using :: tmpnam;
 using :: ungetc;
 using :: vfprintf;
 using :: vprintf;
 using :: vsprintf;

 using :: snprintf;
 using :: vsnprintf;
 using :: vfscanf;
 using :: vscanf;
 using :: vsscanf;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdio"
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdio"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cwchar"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"









#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);
#line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"










































    
    
    
    
    
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 138 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\errno.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_string.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )



__pragma(pack(push, 8)) extern "C" {



[[nodiscard]]  
 void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

[[nodiscard]]  
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


 void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

[[nodiscard]]  
 char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

[[nodiscard]]  
 char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

[[nodiscard]]    
 char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

[[nodiscard]]  

 wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]  
 wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

[[nodiscard]]    

 wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_string.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memcpy_s.h"




#pragma warning(pop) 
} __pragma(pack(pop))
#pragma external_header(pop)
#line 16 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 40 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 100 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 109 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 127 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 136 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 154 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 176 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 193 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 202 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 211 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 220 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 255 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 297 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 312 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_l(_Format, 0, _ArgList);
    }
#line 316 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 326 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 332 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 345 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 354 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));

        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 373 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));

        _Result = _vcwscanf_l(_Format, 0, _ArgList);

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 393 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(), ((void)(__va_start(&_ArgList, _Locale)))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 402 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 410 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(), ((void)(__va_start(&_ArgList, _Format)))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 419 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

#line 421 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wconio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 17 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {











    

#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
        
    #line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 45 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"
#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 117 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"


















































































#line 200 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 18 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wdirect.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 19 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"








#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )











    
    
    
    
#line 31 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_share.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {










    
    
#line 32 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 93 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 267 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wio.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 20 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    

        __declspec(dllimport) intptr_t __cdecl _wexecl(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecle(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclp(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexeclpe(
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wexecv(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecve(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvp(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wexecvpe(
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnl(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnle(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlp(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
                int            _Mode,
              wchar_t const* _FileName,
              wchar_t const* _ArgList,
            ...);

        __declspec(dllimport) intptr_t __cdecl _wspawnv(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnve(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvp(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList
            );

        __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                    int                   _Mode,
                  wchar_t const*        _FileName,
                  wchar_t const* const* _ArgList,
              wchar_t const* const* _Env
            );

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

    #line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"
#line 122 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 21 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


































     
    
    __declspec(dllimport) errno_t __cdecl _itow_s(
                                  int      _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 67 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 74 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

     
    
    __declspec(dllimport) errno_t __cdecl _ltow_s(
                                  long     _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 97 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _ultow_s(
                                  unsigned long _Value,
          wchar_t*      _Buffer,
                                  size_t        _BufferCount,
                                  int           _Radix
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 119 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) double __cdecl wcstod(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) double __cdecl _wcstod_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl wcstol(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long __cdecl _wcstol_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl wcstoll(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) long long __cdecl _wcstoll_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long __cdecl wcstoul(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned long long __cdecl wcstoull(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) long double __cdecl wcstold(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) long double __cdecl _wcstold_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) float __cdecl wcstof(
                            wchar_t const* _String,
            wchar_t**      _EndPtr
        );

     
    __declspec(dllimport) float __cdecl _wcstof_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) double __cdecl _wtof(
          wchar_t const* _String
        );

     
    __declspec(dllimport) double __cdecl _wtof_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) int __cdecl _wtoi(
          wchar_t const* _String
        );

     
    __declspec(dllimport) int __cdecl _wtoi_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long __cdecl _wtol(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long __cdecl _wtol_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) long long __cdecl _wtoll(
          wchar_t const* _String
        );

     
    __declspec(dllimport) long long __cdecl _wtoll_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

    
    __declspec(dllimport) errno_t __cdecl _i64tow_s(
                                  __int64  _Value,
          wchar_t* _Buffer,
                                  size_t   _BufferCount,
                                  int      _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _i64tow(
                            __int64  _Value,
            wchar_t* _Buffer,
                            int      _Radix
        );

    
    __declspec(dllimport) errno_t __cdecl _ui64tow_s(
                                  unsigned __int64 _Value,
          wchar_t*         _Buffer,
                                  size_t           _BufferCount,
                                  int              _Radix
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _ui64tow(
                            unsigned __int64 _Value,
            wchar_t*         _Buffer,
                            int              _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64(
          wchar_t const* _String
        );

     
    __declspec(dllimport) __int64 __cdecl _wtoi64_l(
            wchar_t const* _String,
          _locale_t      _Locale
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix
        );

     
    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                            wchar_t const* _String,
            wchar_t**      _EndPtr,
                              int            _Radix,
                          _locale_t      _Locale
        );

    
    

     
     
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
          wchar_t*       _Buffer,
                                    wchar_t const* _Path,
                                      size_t         _BufferCount
        );

    

    
    __declspec(dllimport) errno_t __cdecl _wmakepath_s(
          wchar_t*       _Buffer,
                                  size_t         _BufferCount,
                            wchar_t const* _Drive,
                            wchar_t const* _Dir,
                            wchar_t const* _Filename,
                            wchar_t const* _Ext
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 374 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(dllimport) void __cdecl _wperror(
          wchar_t const* _ErrorMessage
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) void __cdecl _wsplitpath(
                            wchar_t const* _FullPath,
            wchar_t*       _Drive,
            wchar_t*       _Dir,
            wchar_t*       _Filename,
            wchar_t*       _Ext
        );

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                      wchar_t const* _FullPath,
             wchar_t*       _Drive,
                                        size_t         _DriveCount,
               wchar_t*       _Dir,
                                        size_t         _DirCount,
          wchar_t*       _Filename,
                                        size_t         _FilenameCount,
               wchar_t*       _Ext,
                                        size_t         _ExtCount
        );

    extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 404 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

        
        

        
        __declspec(dllimport) errno_t __cdecl _wdupenv_s(
                wchar_t**      _Buffer,
                                                                                size_t*        _BufferCount,
                                                                                   wchar_t const* _VarName
            );

        

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) wchar_t* __cdecl _wgetenv(
              wchar_t const* _VarName
            );

         
        
        __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                         size_t*        _RequiredCount,
              wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                                        wchar_t const* _VarName
            );

        extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 438 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

         
        __declspec(dllimport) int __cdecl _wputenv(
              wchar_t const* _EnvString
            );

        
        __declspec(dllimport) errno_t __cdecl _wputenv_s(
              wchar_t const* _Name,
              wchar_t const* _Value
            );

        __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                    wchar_t const* _Filename,
                                    wchar_t const* _VarName,
              wchar_t*       _Buffer,
                                      size_t         _BufferCount
            );

        extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 463 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 470 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"

        __declspec(dllimport) int __cdecl _wsystem(
              wchar_t const* _Command
            );

#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 23 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );

     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"











#line 81 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 90 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 105 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 118 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 141 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
    
#line 161 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 170 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 177 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 207 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 232 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"
        



    #line 237 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 250 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK."))
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#line 263 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 284 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 303 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 349 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 365 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 372 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 382 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 387 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 400 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 407 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 418 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 423 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 436 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 443 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 555 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"









    


#line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 577 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 634 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wstring.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 66 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 104 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 123 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
       wchar_t* _Buffer,
                                                                                size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 150 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"









    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"
#line 204 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_wtime.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"







#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )



    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 24 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"
#line 25 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 36 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"
#line 37 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\types.h"


#pragma warning(pop) 
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {






struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 102 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 128 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            static_assert((sizeof(struct stat) == sizeof(struct _stat64i32)), "sizeof(struct stat) == sizeof(struct _stat64i32)");
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 245 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"
#line 246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\sys\\stat.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 26 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;





        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wint_t __cdecl btowc(
          int _Ch
        );

    __declspec(dllimport) size_t __cdecl mbrlen(
            char const* _Ch,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

    __declspec(dllimport) size_t __cdecl mbrtowc(
                                  wchar_t*    _DstCh,
            char const* _SrcCh,
                                                    size_t      _SizeInBytes,
                                                 mbstate_t*  _State
        );

     
    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                                  size_t*      _Retval,
                  wchar_t*     _Dst,
                                       size_t       _Size,
                          char const** _PSrc,
                                       size_t       _N,
                                    mbstate_t*   _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcrtomb_s(
                                 size_t*    _Retval,
          char*      _Dst,
                                      size_t     _SizeInBytes,
                                      wchar_t    _Ch,
                               mbstate_t* _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 124 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 131 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

     
    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                                  size_t*         _Retval,
          char*           _Dst,
                                                       size_t          _SizeInBytes,
                                    wchar_t const** _Src,
                                                       size_t          _Size,
                                                mbstate_t*      _State
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 151 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 159 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __declspec(dllimport) int __cdecl wctob(
          wint_t _WCh
        );

    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(suppress: 6386) 
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 279 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"

#line 281 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 287 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\wchar.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cwchar"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




using _Mbstatet = mbstate_t;

namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

using :: _Mbstatet;

 using :: mbstate_t;
 using :: size_t;
 using :: tm;
 using :: wint_t;

 using :: btowc;
 using :: fgetwc;
 using :: fgetws;
 using :: fputwc;
 using :: fputws;
 using :: fwide;
 using :: fwprintf;
 using :: fwscanf;
 using :: getwc;
 using :: getwchar;
 using :: mbrlen;
 using :: mbrtowc;
 using :: mbsrtowcs;
 using :: mbsinit;
 using :: putwc;
 using :: putwchar;
 using :: swprintf;
 using :: swscanf;
 using :: ungetwc;
 using :: vfwprintf;
 using :: vswprintf;
 using :: vwprintf;
 using :: wcrtomb;
 using :: wprintf;
 using :: wscanf;
 using :: wcsrtombs;
 using :: wcstol;
 using :: wcscat;
 using :: wcschr;
 using :: wcscmp;
 using :: wcscoll;
 using :: wcscpy;
 using :: wcscspn;
 using :: wcslen;
 using :: wcsncat;
 using :: wcsncmp;
 using :: wcsncpy;
 using :: wcspbrk;
 using :: wcsrchr;
 using :: wcsspn;
 using :: wcstod;
 using :: wcstoul;
 using :: wcsstr;
 using :: wcstok;
 using :: wcsxfrm;
 using :: wctob;
 using :: wmemchr;
 using :: wmemcmp;
 using :: wmemcpy;
 using :: wmemmove;
 using :: wmemset;
 using :: wcsftime;

 using :: vfwscanf;
 using :: vswscanf;
 using :: vwscanf;
 using :: wcstof;
 using :: wcstold;
 using :: wcstoll;
 using :: wcstoull;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cwchar"
#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cwchar"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )










namespace std {
 template <class _Ty, _Ty _Val>
struct integral_constant {
    static constexpr _Ty value = _Val;

    using value_type = _Ty;
    using type       = integral_constant;

    constexpr operator value_type() const noexcept {
        return value;
    }

    [[nodiscard]] constexpr value_type operator()() const noexcept {
        return value;
    }
};

 template <bool _Val>
using bool_constant = integral_constant<bool, _Val>;

 using true_type  = bool_constant<true>;
 using false_type = bool_constant<false>;

 template <bool _Test, class _Ty = void>
struct enable_if {}; 

template <class _Ty>
struct enable_if<true, _Ty> { 
    using type = _Ty;
};

 template <bool _Test, class _Ty = void>
using enable_if_t = typename enable_if<_Test, _Ty>::type;

 template <bool _Test, class _Ty1, class _Ty2>
struct conditional { 
    using type = _Ty1;
};

template <class _Ty1, class _Ty2>
struct conditional<false, _Ty1, _Ty2> {
    using type = _Ty2;
};

 template <bool _Test, class _Ty1, class _Ty2>
using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;








 template <class, class>
inline constexpr bool is_same_v = false; 
template <class _Ty>
inline constexpr bool is_same_v<_Ty, _Ty> = true;

 template <class _Ty1, class _Ty2>
struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>> {};
#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"

 template <class _Ty>
struct remove_const { 
    using type = _Ty;
};

template <class _Ty>
struct remove_const<const _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_const_t = typename remove_const<_Ty>::type;

 template <class _Ty>
struct remove_volatile { 
    using type = _Ty;
};

template <class _Ty>
struct remove_volatile<volatile _Ty> {
    using type = _Ty;
};

 template <class _Ty>
using remove_volatile_t = typename remove_volatile<_Ty>::type;

 template <class _Ty>
struct remove_cv { 
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = _Fn<_Ty>; 
};

template <class _Ty>
struct remove_cv<const _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = volatile _Fn<_Ty>;
};

template <class _Ty>
struct remove_cv<const volatile _Ty> {
    using type = _Ty;

    template <template <class> class _Fn>
    using _Apply = const volatile _Fn<_Ty>;
};

 template <class _Ty>
using remove_cv_t = typename remove_cv<_Ty>::type;

template <bool _First_value, class _First, class... _Rest>
struct _Disjunction { 
    using type = _First;
};

template <class _False, class _Next, class... _Rest>
struct _Disjunction<false, _False, _Next, _Rest...> { 
    using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct disjunction : false_type {}; 

template <class _First, class... _Rest>
struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool disjunction_v = disjunction<_Traits...>::value;

template <class _Ty, class... _Types>
inline constexpr bool _Is_any_of_v = 

    (is_same_v<_Ty, _Types> || ...);


#line 176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"

[[nodiscard]] constexpr bool _Is_constant_evaluated() noexcept { 
    return __builtin_is_constant_evaluated();
}


 [[nodiscard]] constexpr bool is_constant_evaluated() noexcept {
    return __builtin_is_constant_evaluated();
}
#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"

 template <class _Ty>
inline constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>, bool, char, signed char, unsigned char,
    wchar_t,

    char8_t,
#line 193 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"
    char16_t, char32_t, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long>;

 template <class _Ty>
struct is_integral : bool_constant<is_integral_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

 template <class _Ty>
struct is_floating_point : bool_constant<is_floating_point_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_arithmetic_v = 
    is_integral_v<_Ty> || is_floating_point_v<_Ty>;

 template <class _Ty>
struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>> {};

 template <class _Ty>
struct remove_reference {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty;
};

template <class _Ty>
struct remove_reference<_Ty&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&;
};

template <class _Ty>
struct remove_reference<_Ty&&> {
    using type                 = _Ty;
    using _Const_thru_ref_type = const _Ty&&;
};

 template <class _Ty>
using remove_reference_t = typename remove_reference<_Ty>::type;

template <class _Ty>
using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

template <class _Ty>
using _Remove_cvref_t [[msvc::known_semantics]] = remove_cv_t<remove_reference_t<_Ty>>;


 template <class _Ty>
using remove_cvref_t = _Remove_cvref_t<_Ty>;

 template <class _Ty>
struct remove_cvref {
    using type = remove_cvref_t<_Ty>;
};
#line 247 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"

}







#pragma warning(pop)
#pragma pack(pop)
#line 259 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"
#line 260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtr1common"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.h"












#pragma once





#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"













#pragma once





#pragma warning(push)
#pragma warning(disable:   4514 4820 )



#pragma warning(disable: 28251)


extern "C" {
#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"






























#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"


#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"






#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 81 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"






#line 93 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"




#line 118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"









unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanForward64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
unsigned char _BitScanReverse64(unsigned long * _Index, unsigned __int64 _Mask);

unsigned char _bittest(long const *, long);




long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);



__int64 _InterlockedAnd64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedand64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedAnd8(char volatile * _Value, char _Mask);






long  _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);

short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);



__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);



char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);






unsigned char _InterlockedCompareExchange128(__int64 volatile * _Destination, __int64 _ExchangeHigh, __int64 _ExchangeLow, __int64 * _ComparandResult);



long  _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
__int64 _InterlockedDecrement64(__int64 volatile * _Addend);
__int64 _interlockeddecrement64(__int64 volatile * _Addend);
long  _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);



__int64 _InterlockedExchange64(__int64 volatile * _Target, __int64 _Value);
__int64 _interlockedexchange64(__int64 volatile * _Target, __int64 _Value);



char _InterlockedExchange8(char volatile * _Target, char _Value);



long  _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);



__int64 _InterlockedExchangeAdd64(__int64 volatile * _Addend, __int64 _Value);
__int64 _interlockedexchangeadd64(__int64 volatile * _Addend, __int64 _Value);



char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);









long  _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
__int64 _InterlockedIncrement64(__int64 volatile * _Addend);
__int64 _interlockedincrement64(__int64 volatile * _Addend);

long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);



__int64 _InterlockedOr64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedOr8(char volatile * _Value, char _Mask);






long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);



__int64 _InterlockedXor64(__int64 volatile * _Value, __int64 _Mask);
__int64 _interlockedxor64(__int64 volatile * _Value, __int64 _Mask);



char _InterlockedXor8(char volatile * _Value, char _Mask);






void _ReadWriteBarrier(void);
__int16 __iso_volatile_load16(const volatile __int16 *);
__int32 __iso_volatile_load32(const volatile __int32 *);
__int64 __iso_volatile_load64(const volatile __int64 *);
__int8 __iso_volatile_load8(const volatile __int8 *);
void __iso_volatile_store16(volatile __int16 *, __int16);
void __iso_volatile_store32(volatile __int32 *, __int32);
void __iso_volatile_store64(volatile __int64 *, __int64);
void __iso_volatile_store8(volatile __int8 *, __int8);


void _mm_pause(void);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);
unsigned __int64 __lzcnt64(unsigned __int64);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);
unsigned __int64 __popcnt64(unsigned __int64);
unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
unsigned __int64 __shiftleft128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);

unsigned int _tzcnt_u32(unsigned int);
unsigned __int64 _tzcnt_u64(unsigned __int64);
#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"
unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64 * _HighProduct);

unsigned __int64 __cdecl _udiv128(unsigned __int64 _HighDividend, unsigned __int64 _LowDividend, unsigned __int64 _Divisor, unsigned __int64* _Remainder);
unsigned char __cdecl _addcarry_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
unsigned char __cdecl _subborrow_u64(unsigned char, unsigned __int64, unsigned __int64, unsigned __int64 *);
double __ceil(double);
float __ceilf(float);
double __floor(double);
float __floorf(float);
double __round(double);
float __roundf(float);
double __trunc(double);
float __truncf(float);
double __copysign(double, double);
float __copysignf(float, float);
unsigned __signbitvalue(double);
unsigned __signbitvaluef(float);







#line 313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"











constexpr void * __cdecl __builtin_assume_aligned(const void *, size_t, ...) noexcept;


#line 328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"
#line 329 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"








}
#line 339 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"
#pragma warning(pop) 
#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.inl.h"
#pragma external_header(pop)
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.h"
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\intrin0.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

 enum [[deprecated("warning STL4042: " "std::float_denorm_style, std::numeric_limits::has_denorm, and std::numeric_limits::has_denorm_loss " "are deprecated in C++23. You can define _SILENCE_CXX23_DENORM_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] float_denorm_style {
    denorm_indeterminate = -1,
    denorm_absent        = 0,
    denorm_present       = 1
};

 enum float_round_style { 
    round_indeterminate       = -1,
    round_toward_zero         = 0,
    round_to_nearest          = 1,
    round_toward_infinity     = 2,
    round_toward_neg_infinity = 3
};

struct _Num_base { 
    __pragma(warning(push)) __pragma(warning(disable : 4996))
    [[deprecated("warning STL4042: " "std::float_denorm_style, std::numeric_limits::has_denorm, and std::numeric_limits::has_denorm_loss " "are deprecated in C++23. You can define _SILENCE_CXX23_DENORM_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] static constexpr float_denorm_style has_denorm = denorm_absent;
    [[deprecated("warning STL4042: " "std::float_denorm_style, std::numeric_limits::has_denorm, and std::numeric_limits::has_denorm_loss " "are deprecated in C++23. You can define _SILENCE_CXX23_DENORM_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] static constexpr bool has_denorm_loss          = false;
    __pragma(warning(pop))

    static constexpr bool has_infinity             = false;
    static constexpr bool has_quiet_NaN            = false;
    static constexpr bool has_signaling_NaN        = false;
    static constexpr bool is_bounded               = false;
    static constexpr bool is_exact                 = false;
    static constexpr bool is_iec559                = false;
    static constexpr bool is_integer               = false;
    static constexpr bool is_modulo                = false;
    static constexpr bool is_signed                = false;
    static constexpr bool is_specialized           = false;
    static constexpr bool tinyness_before          = false;
    static constexpr bool traps                    = false;
    static constexpr float_round_style round_style = round_toward_zero;
    static constexpr int digits                    = 0;
    static constexpr int digits10                  = 0;
    static constexpr int max_digits10              = 0;
    static constexpr int max_exponent              = 0;
    static constexpr int max_exponent10            = 0;
    static constexpr int min_exponent              = 0;
    static constexpr int min_exponent10            = 0;
    static constexpr int radix                     = 0;
};

 template <class _Ty>
class numeric_limits : public _Num_base { 
public:
    [[nodiscard]] static constexpr _Ty(min)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty(max)() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty lowest() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty epsilon() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty round_error() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty denorm_min() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty infinity() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept {
        return _Ty();
    }

    [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept {
        return _Ty();
    }
};

template <class _Ty>
class numeric_limits<const _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<volatile _Ty> : public numeric_limits<_Ty> {}; 

template <class _Ty>
class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty> {}; 

struct _Num_int_base : _Num_base { 
    static constexpr bool is_bounded     = true;
    static constexpr bool is_exact       = true;
    static constexpr bool is_integer     = true;
    static constexpr bool is_specialized = true;
    static constexpr int radix           = 2;
};

struct _Num_float_base : _Num_base { 
    __pragma(warning(push)) __pragma(warning(disable : 4996))
    [[deprecated("warning STL4042: " "std::float_denorm_style, std::numeric_limits::has_denorm, and std::numeric_limits::has_denorm_loss " "are deprecated in C++23. You can define _SILENCE_CXX23_DENORM_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] static constexpr float_denorm_style has_denorm = denorm_present;
    __pragma(warning(pop))

    static constexpr bool has_infinity             = true;
    static constexpr bool has_quiet_NaN            = true;
    static constexpr bool has_signaling_NaN        = true;
    static constexpr bool is_bounded               = true;
    static constexpr bool is_iec559                = true;
    static constexpr bool is_signed                = true;
    static constexpr bool is_specialized           = true;
    static constexpr float_round_style round_style = round_to_nearest;
    static constexpr int radix                     = 2;
};

template <>
class numeric_limits<bool> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr bool(min)() noexcept {
        return false;
    }

    [[nodiscard]] static constexpr bool(max)() noexcept {
        return true;
    }

    [[nodiscard]] static constexpr bool lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr bool epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr bool signaling_NaN() noexcept {
        return 0;
    }

    static constexpr int digits = 1;
};

template <>
class numeric_limits<char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = (-128) != 0;
    static constexpr bool is_modulo = (-128) == 0;
    static constexpr int digits     = 8 - ((-128) != 0);
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<signed char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr signed char(min)() noexcept {
        return (-128);
    }

    [[nodiscard]] static constexpr signed char(max)() noexcept {
        return 127;
    }

    [[nodiscard]] static constexpr signed char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr signed char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr signed char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 7;
    static constexpr int digits10   = 2;
};

template <>
class numeric_limits<unsigned char> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned char(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr unsigned char lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned char epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};


template <>
class numeric_limits<char8_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char8_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t(max)() noexcept {
        return 0xff;
    }

    [[nodiscard]] static constexpr char8_t lowest() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char8_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 8;
    static constexpr int digits10   = 2;
};
#line 362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"

template <>
class numeric_limits<char16_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char16_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr char16_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char16_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<char32_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr char32_t(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr char32_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr char32_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<wchar_t> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr wchar_t(min)() noexcept {
        return 0x0000;
    }

    [[nodiscard]] static constexpr wchar_t(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr wchar_t lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr wchar_t epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr short(min)() noexcept {
        return (-32768);
    }

    [[nodiscard]] static constexpr short(max)() noexcept {
        return 32767;
    }

    [[nodiscard]] static constexpr short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 15;
    static constexpr int digits10   = 4;
};

template <>
class numeric_limits<int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr int(min)() noexcept {
        return (-2147483647 - 1);
    }

    [[nodiscard]] static constexpr int(max)() noexcept {
        return 2147483647;
    }

    [[nodiscard]] static constexpr int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long(min)() noexcept {
        return (-2147483647L - 1);
    }

    [[nodiscard]] static constexpr long(max)() noexcept {
        return 2147483647L;
    }

    [[nodiscard]] static constexpr long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
    static constexpr bool is_signed = true;
    static constexpr int digits     = 31;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr long long(min)() noexcept {
        return (-9223372036854775807i64 - 1);
    }

    [[nodiscard]] static constexpr long long(max)() noexcept {
        return 9223372036854775807i64;
    }

    [[nodiscard]] static constexpr long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_signed = true;
    static constexpr int digits     = 63;
    static constexpr int digits10   = 18;
};


template <>
class numeric_limits<unsigned short> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned short(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short(max)() noexcept {
        return 0xffff;
    }

    [[nodiscard]] static constexpr unsigned short lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned short epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 16;
    static constexpr int digits10   = 4;
};
#line 717 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"

template <>
class numeric_limits<unsigned int> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned int(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int(max)() noexcept {
        return 0xffffffff;
    }

    [[nodiscard]] static constexpr unsigned int lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned int epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long(max)() noexcept {
        return 0xffffffffUL;
    }

    [[nodiscard]] static constexpr unsigned long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept {
        return 0;
    }

    static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
    static constexpr bool is_modulo = true;
    static constexpr int digits     = 32;
    static constexpr int digits10   = 9;
};

template <>
class numeric_limits<unsigned long long> : public _Num_int_base {
public:
    [[nodiscard]] static constexpr unsigned long long(min)() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long(max)() noexcept {
        return 0xffffffffffffffffui64;
    }

    [[nodiscard]] static constexpr unsigned long long lowest() noexcept {
        return (min) ();
    }

    [[nodiscard]] static constexpr unsigned long long epsilon() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long round_error() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long infinity() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept {
        return 0;
    }

    [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept {
        return 0;
    }

    static constexpr bool is_modulo = true;
    static constexpr int digits     = 64;
    static constexpr int digits10   = 19;
};

template <>
class numeric_limits<float> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr float(min)() noexcept {
        return 1.175494351e-38F;
    }

    [[nodiscard]] static constexpr float(max)() noexcept {
        return 3.402823466e+38F;
    }

    [[nodiscard]] static constexpr float lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr float epsilon() noexcept {
        return 1.192092896e-07F;
    }

    [[nodiscard]] static constexpr float round_error() noexcept {
        return 0.5F;
    }

    [[nodiscard]] static constexpr float denorm_min() noexcept {
        return 1.401298464e-45F;
    }

    [[nodiscard]] static constexpr float infinity() noexcept {
        return __builtin_huge_valf();
    }

    [[nodiscard]] static constexpr float quiet_NaN() noexcept {
        return __builtin_nanf("0");
    }

    [[nodiscard]] static constexpr float signaling_NaN() noexcept {
        return __builtin_nansf("1");
    }

    static constexpr int digits         = 24;
    static constexpr int digits10       = 6;
    static constexpr int max_digits10   = 9;
    static constexpr int max_exponent   = 128;
    static constexpr int max_exponent10 = 38;
    static constexpr int min_exponent   = (-125);
    static constexpr int min_exponent10 = (-37);
};

template <>
class numeric_limits<double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr double round_error() noexcept {
        return 0.5;
    }

    [[nodiscard]] static constexpr double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 17;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

template <>
class numeric_limits<long double> : public _Num_float_base {
public:
    [[nodiscard]] static constexpr long double(min)() noexcept {
        return 2.2250738585072014e-308;
    }

    [[nodiscard]] static constexpr long double(max)() noexcept {
        return 1.7976931348623158e+308;
    }

    [[nodiscard]] static constexpr long double lowest() noexcept {
        return -(max) ();
    }

    [[nodiscard]] static constexpr long double epsilon() noexcept {
        return 2.2204460492503131e-016;
    }

    [[nodiscard]] static constexpr long double round_error() noexcept {
        return 0.5L;
    }

    [[nodiscard]] static constexpr long double denorm_min() noexcept {
        return 4.9406564584124654e-324;
    }

    [[nodiscard]] static constexpr long double infinity() noexcept {
        return __builtin_huge_val();
    }

    [[nodiscard]] static constexpr long double quiet_NaN() noexcept {
        return __builtin_nan("0");
    }

    [[nodiscard]] static constexpr long double signaling_NaN() noexcept {
        return __builtin_nans("1");
    }

    static constexpr int digits         = 53;
    static constexpr int digits10       = 15;
    static constexpr int max_digits10   = 2 + 53 * 301L / 1000;
    static constexpr int max_exponent   = 1024;
    static constexpr int max_exponent10 = 308;
    static constexpr int min_exponent   = (-1021);
    static constexpr int min_exponent10 = (-307);
};

}


#pragma warning(pop)
#pragma pack(pop)
#line 1001 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"
#line 1002 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\limits"
#pragma external_header(pop)
#line 56 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"







#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



















#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new_debug.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"







#pragma once



#pragma warning(push)
#pragma warning(disable:   4514 4820 )
#pragma warning(disable: 4985) 


extern "C++" {

#pragma pack(push, 8)





namespace std
{
    enum class align_val_t : size_t {};
}
#line 30 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"



    namespace std
    {
        struct nothrow_t {
            explicit nothrow_t() = default;
        };

        


            extern nothrow_t const nothrow;
        #line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"
    }
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t _Size,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void* _Block
    ) noexcept;

void __cdecl operator delete(
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void* _Block
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) noexcept;

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) noexcept;


[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new(
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new(
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;


[[nodiscard]]     __declspec(allocator)
void* __cdecl operator new[](
    size_t             _Size,
    ::std::align_val_t _Al
    );

[[nodiscard]]       __declspec(allocator)
void* __cdecl operator new[](
    size_t                  _Size,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete(
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*                   _Block,
    ::std::align_val_t      _Al,
    ::std::nothrow_t const&
    ) noexcept;

void __cdecl operator delete(
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;

void __cdecl operator delete[](
    void*              _Block,
    size_t             _Size,
    ::std::align_val_t _Al
    ) noexcept;
#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"

#pragma warning(push)
#pragma warning(disable: 4577) 
#pragma warning(disable: 4514) 

    
    [[nodiscard]] [[msvc::constexpr]]      
    inline void* __cdecl operator new(size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }
#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"


    
    [[nodiscard]]      
    inline void* __cdecl operator new[](size_t _Size,
          void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#line 193 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"
#pragma warning(pop)



#pragma pack(pop)

} 
#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new_debug.h"

#pragma warning(push)
#pragma warning(disable:   4514 4820 )


extern "C++" {

#pragma pack(push, 8)






    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    [[nodiscard]]      
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) noexcept;

#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_new_debug.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;



    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
























































































#line 239 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"










    
    
    
    
    
    
    

    
    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

















































































































































































































































































































#line 590 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"











    
    
    
    
    
    
    

















































































#line 690 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"











    

    
        
    #line 706 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
        
    #line 710 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
        
    #line 714 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"

    
    

    
    

    
    

    
    












































#line 771 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"













    
#line 786 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#pragma warning(pop) 
#line 817 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\crtdbg.h"
#pragma external_header(pop)
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"




















    

#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
    #line 26 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"



    

#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
    #line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"



    

#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
    #line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"





    


#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
        
    


#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"


    

#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
            
        

#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
    #line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"


    

#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"

#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
        
    #line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#line 83 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\crtdefs.h"
#pragma external_header(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )












#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"















#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






















































#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"









#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"




#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"


#pragma detect_mismatch("_MSC_VER", "1900")
#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"


#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"




#line 152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")


#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 166 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 181 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"





























#line 211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"





#line 217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"





#line 223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 230 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"
















#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"









#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"




#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "" "")






#line 55 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"

#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"

#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\use_ansi.h"
#pragma external_header(pop)
#line 239 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

















#line 257 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 269 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"












#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"






#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"




#line 316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"










#line 330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

#line 332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 333 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 337 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"



#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

namespace std {
enum _Uninitialized { 
    _Noinit
};

extern "C++" class __declspec(dllimport) _Lockit { 
public:














    __thiscall _Lockit() noexcept;
    explicit __thiscall _Lockit(int) noexcept; 
    __thiscall ~_Lockit() noexcept; 
#line 367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

    static void __cdecl _Lockit_ctor(int) noexcept;
    static void __cdecl _Lockit_dtor(int) noexcept;

private:
    static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
    static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
    static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

public:
     _Lockit(const _Lockit&)            = delete;
    _Lockit&  operator=(const _Lockit&) = delete;

private:
    int _Locktype;
};



































































#line 451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"

















































#line 501 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
}



#pragma warning(pop)
#pragma pack(pop)
#line 508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#line 509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\yvals.h"
#pragma external_header(pop)
#line 9 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdlib"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
    #line 47 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"










#line 59 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
    typedef float  float_t;
    typedef double double_t;
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"















    
        extern double const _HUGE;
    

#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#line 83 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"


    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"


















































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 459 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"





      int       __cdecl abs(  int _X);
      long      __cdecl labs(  long _X);
      long long __cdecl llabs(  long long _X);

      double __cdecl acos(  double _X);
      double __cdecl asin(  double _X);
      double __cdecl atan(  double _X);
      double __cdecl atan2(  double _Y,   double _X);

      double __cdecl cos(  double _X);
      double __cdecl cosh(  double _X);
      double __cdecl exp(  double _X);
       double __cdecl fabs(  double _X);
      double __cdecl fmod(  double _X,   double _Y);
      double __cdecl log(  double _X);
      double __cdecl log10(  double _X);
      double __cdecl pow(  double _X,   double _Y);
      double __cdecl sin(  double _X);
      double __cdecl sinh(  double _X);
       double __cdecl sqrt(  double _X);
      double __cdecl tan(  double _X);
      double __cdecl tanh(  double _X);

      __declspec(dllimport) double    __cdecl acosh(  double _X);
      __declspec(dllimport) double    __cdecl asinh(  double _X);
      __declspec(dllimport) double    __cdecl atanh(  double _X);
      __declspec(dllimport)  double    __cdecl atof(  char const* _String);
      __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
      __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
      __declspec(dllimport) double    __cdecl cbrt(  double _X);
      __declspec(dllimport) double    __cdecl ceil(  double _X);
      __declspec(dllimport) double    __cdecl _chgsign(  double _X);
      __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
      __declspec(dllimport) double    __cdecl erf(  double _X);
      __declspec(dllimport) double    __cdecl erfc(  double _X);
      __declspec(dllimport) double    __cdecl exp2(  double _X);
      __declspec(dllimport) double    __cdecl expm1(  double _X);
      __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl floor(  double _X);
      __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
      __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
      __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
      __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
      __declspec(dllimport) int       __cdecl ilogb(  double _X);
      __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
      __declspec(dllimport) double    __cdecl lgamma(  double _X);
      __declspec(dllimport) long long __cdecl llrint(  double _X);
      __declspec(dllimport) long long __cdecl llround(  double _X);
      __declspec(dllimport) double    __cdecl log1p(  double _X);
      __declspec(dllimport) double    __cdecl log2(  double _X);
      __declspec(dllimport) double    __cdecl logb(  double _X);
      __declspec(dllimport) long      __cdecl lrint(  double _X);
      __declspec(dllimport) long      __cdecl lround(  double _X);

    int __cdecl _matherr(  struct _exception* _Except);

      __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
      __declspec(dllimport) double __cdecl nan(  char const* _X);
      __declspec(dllimport) double __cdecl nearbyint(  double _X);
      __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
      __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
      __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
      __declspec(dllimport) double __cdecl rint(  double _X);
      __declspec(dllimport) double __cdecl round(  double _X);
      __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
      __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
      __declspec(dllimport) double __cdecl tgamma(  double _X);
      __declspec(dllimport) double __cdecl trunc(  double _X);
      __declspec(dllimport) double __cdecl _j0(  double _X );
      __declspec(dllimport) double __cdecl _j1(  double _X );
      __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
      __declspec(dllimport) double __cdecl _y0(  double _X);
      __declspec(dllimport) double __cdecl _y1(  double _X);
      __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

      __declspec(dllimport) float     __cdecl acoshf(  float _X);
      __declspec(dllimport) float     __cdecl asinhf(  float _X);
      __declspec(dllimport) float     __cdecl atanhf(  float _X);
      __declspec(dllimport) float     __cdecl cbrtf(  float _X);
      __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
      __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
      __declspec(dllimport) float     __cdecl erff(  float _X);
      __declspec(dllimport) float     __cdecl erfcf(  float _X);
      __declspec(dllimport) float     __cdecl expm1f(  float _X);
      __declspec(dllimport) float     __cdecl exp2f(  float _X);
      __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
      __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
      __declspec(dllimport) int       __cdecl ilogbf(  float _X);
      __declspec(dllimport) float     __cdecl lgammaf(  float _X);
      __declspec(dllimport) long long __cdecl llrintf(  float _X);
      __declspec(dllimport) long long __cdecl llroundf(  float _X);
      __declspec(dllimport) float     __cdecl log1pf(  float _X);
      __declspec(dllimport) float     __cdecl log2f(  float _X);
      __declspec(dllimport) float     __cdecl logbf(  float _X);
      __declspec(dllimport) long      __cdecl lrintf(  float _X);
      __declspec(dllimport) long      __cdecl lroundf(  float _X);
      __declspec(dllimport) float     __cdecl nanf(  char const* _X);
      __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
      __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
      __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
      __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
      __declspec(dllimport) float     __cdecl rintf(  float _X);
      __declspec(dllimport) float     __cdecl roundf(  float _X);
      __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
      __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
      __declspec(dllimport) float     __cdecl tgammaf(  float _X);
      __declspec(dllimport) float     __cdecl truncf(  float _X);

    



#line 586 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl _logbf(  float _X);
          __declspec(dllimport) float __cdecl _nextafterf(  float _X,   float _Y);
          __declspec(dllimport) int   __cdecl _finitef(  float _X);
          __declspec(dllimport) int   __cdecl _isnanf(  float _X);
          __declspec(dllimport) int   __cdecl _fpclassf(  float _X);

          __declspec(dllimport) int   __cdecl _set_FMA3_enable(  int _Flag);
          __declspec(dllimport) int   __cdecl _get_FMA3_enable(void);

    




#line 604 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"



    

          __declspec(dllimport) float __cdecl acosf(  float _X);
          __declspec(dllimport) float __cdecl asinf(  float _X);
          __declspec(dllimport) float __cdecl atan2f(  float _Y,   float _X);
          __declspec(dllimport) float __cdecl atanf(  float _X);
          __declspec(dllimport) float __cdecl ceilf(  float _X);
          __declspec(dllimport) float __cdecl cosf(  float _X);
          __declspec(dllimport) float __cdecl coshf(  float _X);
          __declspec(dllimport) float __cdecl expf(  float _X);

    









































#line 661 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    



#line 667 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

          __inline float __cdecl fabsf(  float _X)
        {
            return (float)fabs(_X);
        }

    #line 674 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

    

          __declspec(dllimport) float __cdecl floorf(  float _X);
          __declspec(dllimport) float __cdecl fmodf(  float _X,   float _Y);

    











#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

      __inline float __cdecl frexpf(  float _X,   int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

      __inline float __cdecl hypotf(  float _X,   float _Y)
    {
        return _hypotf(_X, _Y);
    }

      __inline float __cdecl ldexpf(  float _X,   int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    

          __declspec(dllimport) float  __cdecl log10f(  float _X);
          __declspec(dllimport) float  __cdecl logf(  float _X);
          __declspec(dllimport) float  __cdecl modff(  float _X,   float *_Y);
          __declspec(dllimport) float  __cdecl powf(  float _X,   float _Y);
          __declspec(dllimport) float  __cdecl sinf(  float _X);
          __declspec(dllimport) float  __cdecl sinhf(  float _X);
          __declspec(dllimport) float  __cdecl sqrtf(  float _X);
          __declspec(dllimport) float  __cdecl tanf(  float _X);
          __declspec(dllimport) float  __cdecl tanhf(  float _X);

    

















































#line 772 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

      __declspec(dllimport) long double __cdecl acoshl(  long double _X);

      __inline long double __cdecl acosl(  long double _X)
    {
        return acos((double)_X);
    }

      __declspec(dllimport) long double __cdecl asinhl(  long double _X);

      __inline long double __cdecl asinl(  long double _X)
    {
        return asin((double)_X);
    }

      __inline long double __cdecl atan2l(  long double _Y,   long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

      __declspec(dllimport) long double __cdecl atanhl(  long double _X);

      __inline long double __cdecl atanl(  long double _X)
    {
        return atan((double)_X);
    }

      __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

      __inline long double __cdecl ceill(  long double _X)
    {
        return ceil((double)_X);
    }

      __inline long double __cdecl _chgsignl(  long double _X)
    {
        return _chgsign((double)_X);
    }

      __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

      __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

      __inline long double __cdecl coshl(  long double _X)
    {
        return cosh((double)_X);
    }

      __inline long double __cdecl cosl(  long double _X)
    {
        return cos((double)_X);
    }

      __declspec(dllimport) long double __cdecl erfl(  long double _X);
      __declspec(dllimport) long double __cdecl erfcl(  long double _X);

      __inline long double __cdecl expl(  long double _X)
    {
        return exp((double)_X);
    }

      __declspec(dllimport) long double __cdecl exp2l(  long double _X);
      __declspec(dllimport) long double __cdecl expm1l(  long double _X);

      __inline long double __cdecl fabsl(  long double _X)
    {
        return fabs((double)_X);
    }

      __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

      __inline long double __cdecl floorl(  long double _X)
    {
        return floor((double)_X);
    }

      __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
      __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

      __inline long double __cdecl fmodl(  long double _X,   long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

      __inline long double __cdecl frexpl(  long double _X,   int *_Y)
    {
        return frexp((double)_X, _Y);
    }

      __declspec(dllimport) int __cdecl ilogbl(  long double _X);

      __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl hypotl(  long double _X,   long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

      __inline long double __cdecl ldexpl(  long double _X,   int _Y)
    {
        return ldexp((double)_X, _Y);
    }

      __declspec(dllimport) long double __cdecl lgammal(  long double _X);
      __declspec(dllimport) long long __cdecl llrintl(  long double _X);
      __declspec(dllimport) long long __cdecl llroundl(  long double _X);

      __inline long double __cdecl logl(  long double _X)
    {
        return log((double)_X);
    }

      __inline long double __cdecl log10l(  long double _X)
    {
        return log10((double)_X);
    }

      __declspec(dllimport) long double __cdecl log1pl(  long double _X);
      __declspec(dllimport) long double __cdecl log2l(  long double _X);
      __declspec(dllimport) long double __cdecl logbl(  long double _X);
      __declspec(dllimport) long __cdecl lrintl(  long double _X);
      __declspec(dllimport) long __cdecl lroundl(  long double _X);

      __inline long double __cdecl modfl(  long double _X,   long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

      __declspec(dllimport) long double __cdecl nanl(  char const* _X);
      __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
      __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

      __inline long double __cdecl powl(  long double _X,   long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

      __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
      __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
      __declspec(dllimport) long double __cdecl rintl(  long double _X);
      __declspec(dllimport) long double __cdecl roundl(  long double _X);
      __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
      __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

      __inline long double __cdecl sinhl(  long double _X)
    {
        return sinh((double)_X);
    }

      __inline long double __cdecl sinl(  long double _X)
    {
        return sin((double)_X);
    }

      __inline long double __cdecl sqrtl(  long double _X)
    {
        return sqrt((double)_X);
    }

      __inline long double __cdecl tanhl(  long double _X)
    {
        return tanh((double)_X);
    }

      __inline long double __cdecl tanl(  long double _X)
    {
        return tan((double)_X);
    }

      __declspec(dllimport) long double __cdecl tgammal(  long double _X);
      __declspec(dllimport) long double __cdecl truncl(  long double _X);

    



#line 960 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"



    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 978 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

#line 988 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#line 993 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_math.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\math.h"




#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdlib"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"








#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





































#line 56 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict) 
void* __cdecl calloc(
       size_t _Count,
       size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator) 
void* __cdecl _expand(
                void*  _Block,
       size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport) 
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict) 
void* __cdecl malloc(
       size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize_base(
      void* _Block
    );

 
__declspec(dllimport) 
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict) 
void* __cdecl realloc(
        void*  _Block,
              size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc_base(
        void*  _Block,
                                size_t _Count,
                                size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
       size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
       size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
              size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
              size_t _Count,
              size_t _Size,
                                size_t _Alignment
    );


















#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"










#pragma once


#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 30 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"





    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"









#line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
    
#line 54 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))

#pragma warning(pop) 
#line 65 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stddef.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"

#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {


    typedef int (__cdecl* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (__cdecl* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
                            _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                    void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                         void*   _Context
        );

#line 48 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
                     _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
                             _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
                          _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );




















































































#line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
                              _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
        );

#line 213 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 15 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {




    
#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );













    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);
#line 62 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    

    typedef int (__cdecl* _onexit_t)(void);
    


#line 82 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


    
    
#line 87 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 147 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );

    
     _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

     _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 190 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"












#line 203 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);




    __declspec(dllimport) int* __cdecl _errno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);
    

    __declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);

    
    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);
    

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);
    

    __declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);
#line 238 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);








    
    
    
#line 257 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning(push)
#pragma warning(disable: 6540)

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning(pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 357 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 384 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 414 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 640 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 647 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 663 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 670 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 686 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 693 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 758 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 787 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 812 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 833 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
        
    #line 835 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    


        
    #line 841 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);
#line 848 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String,
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 923 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 930 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 949 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 958 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 986 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh,
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1011 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1018 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1037 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1046 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1094 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1103 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }




 
__declspec(dllimport) errno_t __cdecl getenv_s(
                                 size_t*     _RequiredCount,
      char*       _Buffer,
                                  rsize_t     _BufferCount,
                                char const* _VarName
    );

#line 1140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"




__declspec(dllimport) int*       __cdecl __p___argc (void);
__declspec(dllimport) char***    __cdecl __p___argv (void);
__declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);






    
    
    
#line 1157 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

__declspec(dllimport) char***    __cdecl __p__environ (void);
__declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);


    
#line 1164 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"







    
    
#line 1174 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1194 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    


#line 1199 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1210 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning(push)
    #pragma warning(disable: 6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1246 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1253 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1272 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"









    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
    __declspec(dllimport) int __cdecl putenv(
          char const* _EnvString
        );

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1356 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 1363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\stdlib.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdlib"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )





[[nodiscard]]   inline double abs(  double _Xx) noexcept  {
    return :: fabs(_Xx);
}

[[nodiscard]]   inline float abs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline long double abs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

namespace std {
 using :: size_t;
 using :: div_t;
 using :: ldiv_t;
 using :: abort;
 using :: abs;
 using :: atexit;
 using :: atof;
 using :: atoi;
 using :: atol;
 using :: bsearch;
 using :: calloc;
 using :: div;
 using :: exit;
 using :: free;
 using :: labs;
 using :: ldiv;
 using :: malloc;
 using :: mblen;
 using :: mbstowcs;
 using :: mbtowc;
 using :: qsort;
 using :: rand;
 using :: realloc;
 using :: srand;
 using :: strtod;
 using :: strtol;
 using :: strtoul;
 using :: wcstombs;
 using :: wctomb;

 using :: lldiv_t;

 using :: getenv;
 using :: system;

 using :: atoll;
 using :: llabs;
 using :: lldiv;
 using :: strtof;
 using :: strtold;
 using :: strtoll;
 using :: strtoull;

 using :: _Exit;
 using :: at_quick_exit;
 using :: quick_exit;
}



#pragma warning(pop)
#pragma pack(pop)

#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdlib"
#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdlib"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"






#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"



#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_iter_core.hpp"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\initializer_list"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstddef"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )










namespace std {
 using :: ptrdiff_t;
 using :: size_t;
 using max_align_t = double; 
 using nullptr_t   = decltype(nullptr);


 enum class byte : unsigned char {};

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator<<(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) << _Shift));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] constexpr byte operator>>(const byte _Arg, const _IntType _Shift) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(static_cast<unsigned int>(_Arg) >> _Shift));
}

 [[nodiscard]] constexpr byte operator|(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) | static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator&(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) & static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator^(const byte _Left, const byte _Right) noexcept {
    
    return static_cast<byte>(
        static_cast<unsigned char>(static_cast<unsigned int>(_Left) ^ static_cast<unsigned int>(_Right)));
}

 [[nodiscard]] constexpr byte operator~(const byte _Arg) noexcept {
    
    return static_cast<byte>(static_cast<unsigned char>(~static_cast<unsigned int>(_Arg)));
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator<<=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg << _Shift;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
constexpr byte& operator>>=(byte& _Arg, const _IntType _Shift) noexcept {
    return _Arg = _Arg >> _Shift;
}

 constexpr byte& operator|=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left | _Right;
}

 constexpr byte& operator&=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left & _Right;
}

 constexpr byte& operator^=(byte& _Left, const byte _Right) noexcept {
    return _Left = _Left ^ _Right;
}

 template <class _IntType, enable_if_t<is_integral_v<_IntType>, int> = 0>
[[nodiscard]] [[msvc::intrinsic]] constexpr _IntType to_integer(const byte _Arg) noexcept {
    return static_cast<_IntType>(_Arg);
}
#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstddef"

}

using ::std:: max_align_t; 







#pragma warning(pop)
#pragma pack(pop)

#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstddef"
#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstddef"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\initializer_list"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 template <class _Elem>
class initializer_list {
public:
    using value_type      = _Elem;
    using reference       = const _Elem&;
    using const_reference = const _Elem&;
    using size_type       = size_t;

    using iterator       = const _Elem*;
    using const_iterator = const _Elem*;

    constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr) {}

    constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg) {}

    [[nodiscard]] constexpr const _Elem* begin() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr const _Elem* end() const noexcept {
        return _Last;
    }

    [[nodiscard]] constexpr size_t size() const noexcept {
        return static_cast<size_t>(_Last - _First);
    }

private:
    const _Elem* _First;
    const _Elem* _Last;
};

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.end();
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\initializer_list"
#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\initializer_list"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdint"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdint.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;










































    
    
    




#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdint.h"







































#pragma warning(pop) 

#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdint.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdint"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 using :: int8_t;
 using :: int16_t;
 using :: int32_t;
 using :: int64_t;
 using :: uint8_t;
 using :: uint16_t;
 using :: uint32_t;
 using :: uint64_t;

 using :: int_least8_t;
 using :: int_least16_t;
 using :: int_least32_t;
 using :: int_least64_t;
 using :: uint_least8_t;
 using :: uint_least16_t;
 using :: uint_least32_t;
 using :: uint_least64_t;

 using :: int_fast8_t;
 using :: int_fast16_t;
 using :: int_fast32_t;
 using :: int_fast64_t;
 using :: uint_fast8_t;
 using :: uint_fast16_t;
 using :: uint_fast32_t;
 using :: uint_fast64_t;

 using :: intmax_t;
 using :: intptr_t;
 using :: uintmax_t;
 using :: uintptr_t;



































#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdint"
}



#pragma warning(pop)
#pragma pack(pop)

#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdint"
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstdint"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )












namespace std {
template <class>

inline constexpr bool _Always_false = false;

template <bool _First_value, class _First, class... _Rest>
struct _Conjunction { 
    using type = _First;
};

template <class _True, class _Next, class... _Rest>
struct _Conjunction<true, _True, _Next, _Rest...> { 
    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
};

 template <class... _Traits>
struct conjunction : true_type {}; 

template <class _First, class... _Rest>
struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type {
    
};

 template <class... _Traits>
inline constexpr bool conjunction_v = conjunction<_Traits...>::value;

 template <class _Trait>
struct negation : bool_constant<!static_cast<bool>(_Trait::value)> {}; 

 template <class _Trait>
inline constexpr bool negation_v = negation<_Trait>::value;

 template <class _Ty>
inline constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

 template <class _Ty>
struct is_void : bool_constant<is_void_v<_Ty>> {};

 template <class... _Types>
using void_t = void;

template <class _Ty>
struct _Identity {
    using type = _Ty;
};
template <class _Ty>
using _Identity_t [[msvc::known_semantics]] = typename _Identity<_Ty>::type;


 template <class _Ty>
struct add_const { 
    using type = const _Ty;
};

 template <class _Ty>
using add_const_t = typename add_const<_Ty>::type;

 template <class _Ty>
struct add_volatile { 
    using type = volatile _Ty;
};

 template <class _Ty>
using add_volatile_t = typename add_volatile<_Ty>::type;

 template <class _Ty>
struct add_cv { 
    using type = const volatile _Ty;
};

 template <class _Ty>
using add_cv_t = typename add_cv<_Ty>::type;

template <class _Ty, class = void>
struct _Add_reference { 
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template <class _Ty>
struct _Add_reference<_Ty, void_t<_Ty&>> { 
    using _Lvalue = _Ty&;
    using _Rvalue = _Ty&&;
};

 template <class _Ty>
struct add_lvalue_reference {
    using type = typename _Add_reference<_Ty>::_Lvalue;
};

 template <class _Ty>
using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

 template <class _Ty>
struct add_rvalue_reference {
    using type = typename _Add_reference<_Ty>::_Rvalue;
};

 template <class _Ty>
using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

 template <class _Ty>
add_rvalue_reference_t<_Ty> declval() noexcept {
    static_assert(_Always_false<_Ty>, "Calling declval is ill-formed, see N4950 [declval]/2.");
}

 template <class _Ty>
struct remove_extent { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_extent<_Ty[_Ix]> {
    using type = _Ty;
};

template <class _Ty>
struct remove_extent<_Ty[]> {
    using type = _Ty;
};

 template <class _Ty>
using remove_extent_t = typename remove_extent<_Ty>::type;

 template <class _Ty>
struct remove_all_extents { 
    using type = _Ty;
};

template <class _Ty, size_t _Ix>
struct remove_all_extents<_Ty[_Ix]> {
    using type = typename remove_all_extents<_Ty>::type;
};

template <class _Ty>
struct remove_all_extents<_Ty[]> {
    using type = typename remove_all_extents<_Ty>::type;
};

 template <class _Ty>
using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

 template <class _Ty>
struct remove_pointer {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty*> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* volatile> {
    using type = _Ty;
};

template <class _Ty>
struct remove_pointer<_Ty* const volatile> {
    using type = _Ty;
};

 template <class _Ty>
using remove_pointer_t = typename remove_pointer<_Ty>::type;

template <class _Ty, class = void>
struct _Add_pointer { 
    using type = _Ty;
};

template <class _Ty>
struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>> { 
    using type = remove_reference_t<_Ty>*;
};

 template <class _Ty>
struct add_pointer {
    using type = typename _Add_pointer<_Ty>::type;
};

 template <class _Ty>
using add_pointer_t = typename _Add_pointer<_Ty>::type;

 template <class>
inline constexpr bool is_array_v = false; 

template <class _Ty, size_t _Nx>
inline constexpr bool is_array_v<_Ty[_Nx]> = true;

template <class _Ty>
inline constexpr bool is_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_array : bool_constant<is_array_v<_Ty>> {};


 template <class>
inline constexpr bool is_bounded_array_v = false;

template <class _Ty, size_t _Nx>
inline constexpr bool is_bounded_array_v<_Ty[_Nx]> = true;

 template <class _Ty>
struct is_bounded_array : bool_constant<is_bounded_array_v<_Ty>> {};

 template <class>
inline constexpr bool is_unbounded_array_v = false;

template <class _Ty>
inline constexpr bool is_unbounded_array_v<_Ty[]> = true;

 template <class _Ty>
struct is_unbounded_array : bool_constant<is_unbounded_array_v<_Ty>> {};
#line 248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class>
inline constexpr bool is_lvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_lvalue_reference_v<_Ty&> = true;

 template <class _Ty>
struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_rvalue_reference_v = false; 

template <class _Ty>
inline constexpr bool is_rvalue_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_reference_v = false; 

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&> = true;

template <class _Ty>
inline constexpr bool is_reference_v<_Ty&&> = true;

 template <class _Ty>
struct is_reference : bool_constant<is_reference_v<_Ty>> {};

 template <class>
inline constexpr bool is_pointer_v = false; 

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty*> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* volatile> = true;

template <class _Ty>
inline constexpr bool is_pointer_v<_Ty* const volatile> = true;

 template <class _Ty>
struct is_pointer : bool_constant<is_pointer_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_null_pointer_v =
    is_same_v<remove_cv_t<_Ty>, nullptr_t>; 

 template <class _Ty>
struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>> {};

 template <class _Ty>
struct is_union : bool_constant<__is_union(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_union_v = __is_union(_Ty);

 template <class _Ty>
struct is_class : bool_constant<__is_class(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_class_v = __is_class(_Ty);

 template <class _Ty>
inline constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_fundamental : bool_constant<is_fundamental_v<_Ty>> {}; 

 template <class _From, class _To>
struct is_convertible : bool_constant<__is_convertible_to(_From, _To)> {
    
};

 template <class _From, class _To>
inline constexpr bool is_convertible_v = __is_convertible_to(_From, _To);


template <class _Ty>
struct is_convertible<_Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<_Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
struct is_convertible<volatile _Ty&, const volatile _Ty&> : true_type {};

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<_Ty&, const volatile _Ty&> = true;

template <class _Ty>
inline constexpr bool is_convertible_v<volatile _Ty&, const volatile _Ty&> = true;
#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_enum : bool_constant<__is_enum(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_enum_v = __is_enum(_Ty);


 template <class _Ty>
inline constexpr bool is_scoped_enum_v = conjunction_v<is_enum<_Ty>, negation<is_convertible<_Ty, int>>>;

 template <class _Ty>
struct is_scoped_enum : bool_constant<is_scoped_enum_v<_Ty>> {};
#line 369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_compound : bool_constant<!is_fundamental_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_compound_v = !is_fundamental_v<_Ty>;







#line 383 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"




#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

#line 390 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"







#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"






#line 405 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

























#line 431 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"


























#line 458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"









































#line 500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class... _Types>
struct _Arg_types {}; 

template <class _Ty1>
struct _Arg_types<_Ty1> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty1;
};

template <class _Ty1, class _Ty2>
struct _Arg_types<_Ty1, _Ty2> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty1;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty2;
};

template <class _Ty>
struct _Is_memfunptr { 
    using _Bool_type = false_type; 
};











template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && > : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && > : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && > : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && > : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)   noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)   noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const  noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const  noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile  noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile  noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile  noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile  noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int , int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  & noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const & noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile & noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile & noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  && noexcept> : _Arg_types< _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const && noexcept> : _Arg_types<const _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile && noexcept> : _Arg_types<volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };     template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile && noexcept> : _Arg_types<const volatile _Arg0*, _Types...> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<!is_same_v<int &&, int&&>, _Ret(_Types...)>; };












template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) & noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) && noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; }; template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&& noexcept> { using _Bool_type = true_type; using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; using _Class_type = _Arg0; using _Guide_type = enable_if<false>; };










template <class _Ret, class _Self, class... _Args> struct _Is_memfunptr<_Ret(__cdecl*)(_Self, _Args...) > { using _Bool_type = false_type; using _Guide_type = _Identity<_Ret(_Args...)>; };    template <class _Ret, class _Self, class... _Args> struct _Is_memfunptr<_Ret(__vectorcall*)(_Self, _Args...) > { using _Bool_type = false_type; using _Guide_type = _Identity<_Ret(_Args...)>; };

template <class _Ret, class _Self, class... _Args> struct _Is_memfunptr<_Ret(__cdecl*)(_Self, _Args...) noexcept> { using _Bool_type = false_type; using _Guide_type = _Identity<_Ret(_Args...)>; };    template <class _Ret, class _Self, class... _Args> struct _Is_memfunptr<_Ret(__vectorcall*)(_Self, _Args...) noexcept> { using _Bool_type = false_type; using _Guide_type = _Identity<_Ret(_Args...)>; };
#line 558 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"


#line 561 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"





 template <class _Ty>
inline constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;
#line 569 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>> {};

 template <class>
inline constexpr bool is_const_v = false; 

template <class _Ty>
inline constexpr bool is_const_v<const _Ty> = true;

 template <class _Ty>
struct is_const : bool_constant<is_const_v<_Ty>> {};

 template <class>
inline constexpr bool is_volatile_v = false; 

template <class _Ty>
inline constexpr bool is_volatile_v<volatile _Ty> = true;

 template <class _Ty>
struct is_volatile : bool_constant<is_volatile_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_function_v = 
    !is_const_v<const _Ty> && !is_reference_v<_Ty>;

 template <class _Ty>
struct is_function : bool_constant<is_function_v<_Ty>> {};

 template <class _Ty>
inline constexpr bool is_object_v = 
    is_const_v<const _Ty> && !is_void_v<_Ty>;

 template <class _Ty>
struct is_object : bool_constant<is_object_v<_Ty>> {};

template <class>
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template <class _Ty1, class _Ty2>
struct _Is_member_object_pointer<_Ty1 _Ty2::*> {
    static constexpr bool value = !is_function_v<_Ty1>;
    using _Class_type           = _Ty2;
};





 template <class _Ty>
inline constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;
#line 623 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>> {};





 template <class _Ty>
inline constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;
#line 634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>> {}; 

 template <class _Ty>
inline constexpr bool is_scalar_v = 
    is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

 template <class _Ty>
struct is_scalar : bool_constant<is_scalar_v<_Ty>> {};

 template <class _Ty>
struct [[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] is_pod : bool_constant<__is_pod(_Ty)> {}; 

 template <class _Ty>
[[deprecated("warning STL4025: " "std::is_pod and std::is_pod_v are deprecated in C++20. " "The std::is_trivially_copyable and/or std::is_standard_layout traits likely suit your use case. " "You can define _SILENCE_CXX20_IS_POD_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] inline constexpr bool is_pod_v = __is_pod(_Ty);

 template <class _Ty>
struct is_empty : bool_constant<__is_empty(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_empty_v = __is_empty(_Ty);

 template <class _Ty>
struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

 template <class _Ty>
struct is_abstract : bool_constant<__is_abstract(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_abstract_v = __is_abstract(_Ty);

 template <class _Ty>
struct is_final : bool_constant<__is_final(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_final_v = __is_final(_Ty);

 template <class _Ty>
struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)> {}; 

 template <class _Ty>
inline constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);









#line 690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"


 template <class _Ty>
struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);






#line 706 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

 template <class _Ty>
struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);


 template <class _Ty>
struct has_unique_object_representations : bool_constant<__has_unique_object_representations(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);











 template <class _Ty>
struct is_aggregate : bool_constant<__is_aggregate(_Ty)> {};

 template <class _Ty>
inline constexpr bool is_aggregate_v = __is_aggregate(_Ty);
#line 748 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
#line 749 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty, class... _Args>
struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_default_constructible : bool_constant<__is_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_default_constructible_v = __is_constructible(_Ty);

template <class _Ty, class = void>
struct _Is_implicitly_default_constructible : false_type {
    
};

template <class _Ty>
void _Implicitly_default_construct(const _Ty&);

template <class _Ty>
struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type {
};

 template <class _Ty>
struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_assignable : bool_constant<__is_assignable(_To, _From)> {}; 

 template <class _To, class _From>
inline constexpr bool is_assignable_v = __is_assignable(_To, _From);


template <class _To, class _From>
struct _Is_assignable_no_precondition_check : bool_constant<__is_assignable_no_precondition_check(_To, _From)> {};



#line 807 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_copy_assignable
    : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_copy_assignable_v =
    __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);


template <class _Ty>
struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(
          add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {};

template <class _Ty>
inline constexpr bool _Is_copy_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);






#line 834 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);


template <class _Ty>
struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)> {};

template <class _Ty>
inline constexpr bool _Is_move_assignable_unchecked_v =
    __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);






#line 858 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
struct is_destructible : bool_constant<__is_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_destructible_v = __is_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_constructible_v =
    __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

 template <class _Ty>
struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

 template <class _Ty>
struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_copy_assignable_v =
    __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

 template <class _Ty, class... _Args>
struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)> {
    
};

 template <class _Ty, class... _Args>
inline constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

 template <class _Ty>
struct is_nothrow_copy_constructible
    : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_constructible_v =
    __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

 template <class _Ty>
struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

 template <class _To, class _From>
struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)> {
    
};

 template <class _To, class _From>
inline constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

 template <class _Ty>
struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_copy_assignable_v =
    __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

 template <class _Ty>
struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)> {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

 template <class _Ty>
struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)> {
    
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

template <class _Ty, bool = is_integral_v<_Ty>>
struct _Sign_base { 
    using _Uty = remove_cv_t<_Ty>;

    static constexpr bool _Signed   = static_cast<_Uty>(-1) < static_cast<_Uty>(0);
    static constexpr bool _Unsigned = !_Signed;
};

template <class _Ty>
struct _Sign_base<_Ty, false> { 
                                
    static constexpr bool _Signed   = is_floating_point_v<_Ty>;
    static constexpr bool _Unsigned = false;
};

 template <class _Ty>
struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed> {}; 

 template <class _Ty>
inline constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

 template <class _Ty>
struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned> {}; 

 template <class _Ty>
inline constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

template <class _Ty>
inline constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

template <bool>
struct _Select { 
    template <class _Ty1, class>
    using _Apply = _Ty1;
};

template <>
struct _Select<false> {
    template <class, class _Ty2>
    using _Apply = _Ty2;
};

template <size_t>
struct _Make_signed2; 

template <>
struct _Make_signed2<1> {
    template <class>
    using _Apply = signed char;
};

template <>
struct _Make_signed2<2> {
    template <class>
    using _Apply = short;
};

template <>
struct _Make_signed2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
};

template <>
struct _Make_signed2<8> {
    template <class>
    using _Apply = long long;
};

template <class _Ty>
using _Make_signed1 = 
    typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_signed { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_signed<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
};

 template <class _Ty>
using make_signed_t = typename make_signed<_Ty>::type;

template <size_t>
struct _Make_unsigned2; 

template <>
struct _Make_unsigned2<1> {
    template <class>
    using _Apply = unsigned char;
};

template <>
struct _Make_unsigned2<2> {
    template <class>
    using _Apply = unsigned short;
};

template <>
struct _Make_unsigned2<4> {
    template <class _Ty>
    using _Apply = 
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long,
            unsigned int>;
};

template <>
struct _Make_unsigned2<8> {
    template <class>
    using _Apply = unsigned long long;
};

template <class _Ty>
using _Make_unsigned1 = 
    typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

 template <class _Ty>
struct make_unsigned { 
    static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
        "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
};

 template <class _Ty>
using make_unsigned_t = typename make_unsigned<_Ty>::type;

template <class _Rep>
constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val) { 
    return static_cast<make_unsigned_t<_Rep>>(_Val);
}

 template <class _Ty>
struct alignment_of : integral_constant<size_t, alignof(_Ty)> {}; 

 template <class _Ty>
inline constexpr size_t alignment_of_v = alignof(_Ty);

template <class _Ty, size_t _Len>
union _Align_type { 
    _Ty _Val;
    char _Pad[_Len];
};

template <size_t _Len, size_t _Align, class _Ty, bool _Ok>
struct _Aligned; 

template <size_t _Len, size_t _Align, class _Ty>
struct _Aligned<_Len, _Align, _Ty, true> {
    using type = _Align_type<_Ty, _Len>;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, double, false> {






    static_assert(_Always_false<_Aligned>,
        "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
        "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "To suppress this error, please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to confirm that you want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to get the old non-conforming behavior.");
#line 1179 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
    using type = _Align_type<max_align_t, _Len>;
#line 1181 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, int, false> {
    using _Next                 = double;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, short, false> {
    using _Next                 = int;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align>
struct _Aligned<_Len, _Align, char, false> {
    using _Next                 = short;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};


template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct _Aligned_storage { 
    using _Next                 = char;
    static constexpr bool _Fits = _Align <= alignof(_Next);
    using type                  = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
};

template <size_t _Len, size_t _Align = alignof(max_align_t)>
using _Aligned_storage_t = typename _Aligned_storage<_Len, _Align>::type;

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
struct [[deprecated("warning STL4034: " "std::aligned_storage and std::aligned_storage_t are deprecated in C++23. " "Prefer alignas(T) std::byte t_buff[sizeof(T)]. " "You can define _SILENCE_CXX23_ALIGNED_STORAGE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] aligned_storage { 
    using type = _Aligned_storage_t<_Len, _Align>;
};

 template <size_t _Len, size_t _Align = alignof(max_align_t)>
using aligned_storage_t [[deprecated("warning STL4034: " "std::aligned_storage and std::aligned_storage_t are deprecated in C++23. " "Prefer alignas(T) std::byte t_buff[sizeof(T)]. " "You can define _SILENCE_CXX23_ALIGNED_STORAGE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] = _Aligned_storage_t<_Len, _Align>;

template <size_t... _Vals>
struct _Maximum;

template <>
struct _Maximum<> : integral_constant<size_t, 0> {}; 

template <size_t _Val>
struct _Maximum<_Val> : integral_constant<size_t, _Val> {}; 

template <size_t _First, size_t _Second, size_t... _Rest>
struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type {
    
};

 template <size_t _Len, class... _Types>
struct [[deprecated("warning STL4035: " "std::aligned_union and std::aligned_union_t are deprecated in C++23. " "Prefer alignas(Ts...) std::byte t_buff[std::max({sizeof(Ts)...})]. " "You can define _SILENCE_CXX23_ALIGNED_UNION_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] aligned_union {
    
    static constexpr size_t _Max_len        = _Maximum<_Len, sizeof(_Types)...>::value; 
    static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

    using type = _Aligned_storage_t<_Max_len, alignment_value>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <size_t _Len, class... _Types>
using aligned_union_t [[deprecated("warning STL4035: " "std::aligned_union and std::aligned_union_t are deprecated in C++23. " "Prefer alignas(Ts...) std::byte t_buff[std::max({sizeof(Ts)...})]. " "You can define _SILENCE_CXX23_ALIGNED_UNION_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] = typename aligned_union<_Len, _Types...>::type;
__pragma(warning(pop))

template <class _Ty, bool = is_enum_v<_Ty>>
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template <class _Ty>
struct _Underlying_type<_Ty, false> {};

 template <class _Ty>
struct underlying_type : _Underlying_type<_Ty> {}; 

 template <class _Ty>
using underlying_type_t = typename _Underlying_type<_Ty>::type;

 template <class _Ty>
inline constexpr size_t rank_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

template <class _Ty>
inline constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

 template <class _Ty>
struct rank : integral_constant<size_t, rank_v<_Ty>> {};

 template <class _Ty, unsigned int _Ix = 0>
inline constexpr size_t extent_v = 0; 

template <class _Ty, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

template <class _Ty, unsigned int _Ix, size_t _Nx>
inline constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

template <class _Ty, unsigned int _Ix>
inline constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

 template <class _Ty, unsigned int _Ix = 0>
struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>> {};

 template <class _Base, class _Derived>
struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)> {
    
};

 template <class _Base, class _Derived>
inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

 template <class _Ty>
struct decay { 
    using _Ty1 = remove_reference_t<_Ty>;
    using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
    using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
};

 template <class _Ty>
using decay_t = typename decay<_Ty>::type;

template <class _Ty1, class _Ty2>
using _Conditional_type = decltype(false ? ::std:: declval<_Ty1>() : ::std:: declval<_Ty2>());


template <class _Ty1, class _Ty2, class = void>
struct _Const_lvalue_cond_oper {};



template <class _Ty1, class _Ty2>
struct _Const_lvalue_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<const _Ty1&, const _Ty2&>>> {
    using type = remove_cvref_t<_Conditional_type<const _Ty1&, const _Ty2&>>;
};

template <class _Ty1, class _Ty2, class = void>
struct _Decayed_cond_oper : _Const_lvalue_cond_oper<_Ty1, _Ty2> {};



#line 1330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Ty1, class _Ty2>
struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>> {
    using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
};

 template <class... _Ty>
struct common_type;

 template <class... _Ty>
using common_type_t = typename common_type<_Ty...>::type;

template <>
struct common_type<> {};

template <class _Ty1>
struct common_type<_Ty1> : common_type<_Ty1, _Ty1> {};

template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
struct _Common_type2 : common_type<_Decayed1, _Decayed2> {};

template <class _Ty1, class _Ty2>
struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2> {};

template <class _Void, class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3 {};

template <class _Ty1, class _Ty2, class... _Rest>
struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...> {};

template <class _Ty1, class _Ty2, class... _Rest>
struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...> {};

template <class _Ty>
_Ty _Returns_exactly() noexcept; 


 template <class, class, template <class> class, template <class> class>
struct basic_common_reference {};

template <class _From>
struct _Copy_cv_impl {
    template <class _To>
    using _Apply = _To;
};
template <class _From>
struct _Copy_cv_impl<const _From> {
    template <class _To>
    using _Apply = const _To;
};
template <class _From>
struct _Copy_cv_impl<volatile _From> {
    template <class _To>
    using _Apply = volatile _To;
};
template <class _From>
struct _Copy_cv_impl<const volatile _From> {
    template <class _To>
    using _Apply = const volatile _To;
};
template <class _From, class _To>
using _Copy_cv = 
    _Copy_cv_impl<_From>::template _Apply<_To>;

template <class _Ty1>
struct _Add_qualifiers { 
    template <class _Ty2>
    using _Apply = _Copy_cv<_Ty1, _Ty2>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&> {
    template <class _Ty2>
    using _Apply = add_lvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};
template <class _Ty1>
struct _Add_qualifiers<_Ty1&&> {
    template <class _Ty2>
    using _Apply = add_rvalue_reference_t<_Copy_cv<_Ty1, _Ty2>>;
};


template <class _Ty1, class _Ty2>
using _Cond_res_if_right = 
    decltype(false ? _Returns_exactly<_Ty1>() : _Returns_exactly<_Ty2>());

template <class _Ty>
using _Is_scalar_or_array = disjunction<is_scalar<_Ty>, is_array<_Ty>>;

template <class _Ty1, class _Ty2, class = void>
struct _Cond_res_workaround {};

template <class _Ty1, class _Ty2>
struct _Cond_res_workaround<_Ty1, _Ty2, void_t<_Cond_res_if_right<_Ty1, _Ty2>>> {
    using _Uty = remove_cvref_t<_Ty1>;
    using type = conditional_t<conjunction_v<is_same<_Uty, remove_cvref_t<_Ty2>>, _Is_scalar_or_array<_Uty>,
                                   disjunction<conjunction<is_lvalue_reference<_Ty1>, is_rvalue_reference<_Ty2>>,
                                       conjunction<is_rvalue_reference<_Ty1>, is_lvalue_reference<_Ty2>>>>,
        decay_t<_Copy_cv<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>>, _Cond_res_if_right<_Ty1, _Ty2>>;
};

template <class _Ty1, class _Ty2>
using _Cond_res = _Cond_res_workaround<_Ty1, _Ty2>::type;




#line 1441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class...>
struct common_reference;

 template <class... _Types>
using common_reference_t = common_reference<_Types...>::type;


template <>
struct common_reference<> {};


template <class _Ty>
struct common_reference<_Ty> {
    using type = _Ty;
};





template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2C : common_type<_Ty1, _Ty2> {};


template <class _Ty1, class _Ty2>
struct _Common_reference2C<_Ty1, _Ty2, void_t<_Cond_res<_Ty1, _Ty2>>> {
    using type = _Cond_res<_Ty1, _Ty2>;
};


template <class _Ty1, class _Ty2>
using _Basic_specialization = basic_common_reference<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>,
    _Add_qualifiers<_Ty1>::template _Apply, _Add_qualifiers<_Ty2>::template _Apply>::type;

template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2B : _Common_reference2C<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2>
struct _Common_reference2B<_Ty1, _Ty2, void_t<_Basic_specialization<_Ty1, _Ty2>>> {
    using type = _Basic_specialization<_Ty1, _Ty2>;
};




template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2A : _Common_reference2B<_Ty1, _Ty2> {};

template <class _Ty1, class _Ty2, class _Result = _Cond_res<_Copy_cv<_Ty1, _Ty2>&, _Copy_cv<_Ty2, _Ty1>&>,
    enable_if_t<is_lvalue_reference_v<_Result>, int> = 0>
using _LL_common_ref = _Result;

template <class _Ty1, class _Ty2, class = void>
struct _Common_reference2AX {};

template <class _Ty1, class _Ty2>
struct _Common_reference2AX<_Ty1&, _Ty2&, void_t<_LL_common_ref<_Ty1, _Ty2>>> {
    using type = _LL_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2AX<_Ty1&&, _Ty2&, enable_if_t<is_convertible_v<_Ty1&&, _LL_common_ref<const _Ty1, _Ty2>>>> {
    using type = _LL_common_ref<const _Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
struct _Common_reference2AX<_Ty1&, _Ty2&&, enable_if_t<is_convertible_v<_Ty2&&, _LL_common_ref<const _Ty2, _Ty1>>>> {
    using type = _LL_common_ref<const _Ty2, _Ty1>; 
};

template <class _Ty1, class _Ty2>
using _RR_common_ref = remove_reference_t<_LL_common_ref<_Ty1, _Ty2>>&&;

template <class _Ty1, class _Ty2>
struct _Common_reference2AX<_Ty1&&, _Ty2&&,
    enable_if_t<is_convertible_v<_Ty1&&, _RR_common_ref<_Ty1, _Ty2>>
                && is_convertible_v<_Ty2&&, _RR_common_ref<_Ty1, _Ty2>>>> {
    using type = _RR_common_ref<_Ty1, _Ty2>; 
};

template <class _Ty1, class _Ty2>
using _Common_ref_2AX_t = _Common_reference2AX<_Ty1, _Ty2>::type;

template <class _Ty1, class _Ty2>
struct _Common_reference2A<_Ty1, _Ty2,
    enable_if_t<is_convertible_v<add_pointer_t<_Ty1>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>>
                && is_convertible_v<add_pointer_t<_Ty2>, add_pointer_t<_Common_ref_2AX_t<_Ty1, _Ty2>>>>> {
    using type = _Common_ref_2AX_t<_Ty1, _Ty2>;
};

template <class _Ty1, class _Ty2>
struct common_reference<_Ty1, _Ty2> : _Common_reference2A<_Ty1, _Ty2> {};


template <class _Void, class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference {};
template <class _Ty1, class _Ty2, class... _Types>
struct _Fold_common_reference<void_t<common_reference_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Types...>
    : common_reference<common_reference_t<_Ty1, _Ty2>, _Types...> {};

template <class _Ty1, class _Ty2, class _Ty3, class... _Rest>
struct common_reference<_Ty1, _Ty2, _Ty3, _Rest...> : _Fold_common_reference<void, _Ty1, _Ty2, _Ty3, _Rest...> {};

 template <class _Ty>
struct type_identity {
    using type = _Ty;
};
 template <class _Ty>
using type_identity_t = type_identity<_Ty>::type;
#line 1552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Type, template <class...> class _Template>
inline constexpr bool _Is_specialization_v = false; 
template <template <class...> class _Template, class... _Types>
inline constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

template <class _Type, template <class...> class _Template>
struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>> {};

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept {
    static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
    return static_cast<_Ty&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {
    return static_cast<remove_reference_t<_Ty>&&>(_Arg);
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr 
    conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept {
    return ::std:: move(_Arg);
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept {
    return __builtin_addressof(_Val);
}

 template <class _Ty>
const _Ty* addressof(const _Ty&&) = delete;

#pragma warning(push)
#pragma warning(disable : 5215) 
#pragma warning(disable : 5216) 






template <class _Ty>
[[nodiscard]] _Ty _Fake_copy_init(_Ty) noexcept;









#pragma warning(pop)

 template <class _Ty>
class reference_wrapper;





enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template <class _Callable, class... _Types>
    static constexpr auto _Call(_Callable&& _Obj, _Types&&... _Args) noexcept(
        noexcept(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)))
        -> decltype(static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...)) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Types&&>(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (static_cast<_Ty1&&>(_Arg1).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template <class _Decayed, class _Refwrap, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&&... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype((_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template <class _Decayed, class _Ty1, class... _Types2>
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)))
        -> decltype(((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...)) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Pmf)(static_cast<_Types2&&>(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept -> decltype(static_cast<_Ty1&&>(_Arg1).*_Pmd) {
        return static_cast<_Ty1&&>(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template <class _Decayed, class _Refwrap>
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -> decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template <class _Decayed, class _Ty1>
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*static_cast<_Ty1&&>(_Arg1)).*_Pmd))
        -> decltype((*static_cast<_Ty1&&>(_Arg1)).*_Pmd) {
        return (*static_cast<_Ty1&&>(_Arg1)).*_Pmd;
    }
};

template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>,
    bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>,
    bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
struct _Invoker1;

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_same_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
                        || is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
          _Invoker_pmf_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<
          is_same_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>
              || is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, _Remove_cvref_t<_Ty1>>,
          _Invoker_pmd_object,
          conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer>> {}; 

template <class _Callable, class _Ty1, class _Removed_cvref>
struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor {};

 template <class _Callable>
constexpr auto invoke(_Callable&& _Obj) noexcept(noexcept(static_cast<_Callable&&>(_Obj)()))
    -> decltype(static_cast<_Callable&&>(_Obj)()) {
    return static_cast<_Callable&&>(_Obj)();
}

 template <class _Callable, class _Ty1, class... _Types2>
constexpr auto invoke(_Callable&& _Obj, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
    noexcept(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)))
    -> decltype(_Invoker1<_Callable, _Ty1>::_Call(
        static_cast<_Callable&&>(_Obj), static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...)) {
    if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast<_Callable&&>(_Obj)(static_cast<_Ty1&&>(_Arg1), static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast<_Ty1&&>(_Arg1).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast<_Ty1&&>(_Arg1)).*_Obj)(static_cast<_Types2&&>(_Args2)...);
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast<_Ty1&&>(_Arg1).*_Obj;
    } else if constexpr (_Invoker1<_Callable, _Ty1>::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        ;
        return (*static_cast<_Ty1&&>(_Arg1)).*_Obj;
    }
}

#pragma warning(push)
#pragma warning(disable : 4242) 
#pragma warning(disable : 4244) 
#pragma warning(disable : 4365) 

template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
inline constexpr bool _Is_nothrow_convertible_v = noexcept(_Fake_copy_init<_To>(::std:: declval<_From>()));

#pragma warning(pop)

template <class _From, class _To, bool _IsVoid>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

template <class _From, class _To>
inline constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

template <class _From, class _To>
struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>> {
    
};


 template <class _From, class _To>
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v<_From, _To>;

 template <class _From, class _To>
using is_nothrow_convertible = _Is_nothrow_convertible<_From, _To>;
#line 1786 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _From, class _To, class = void>
struct _Invoke_convertible : false_type {};

template <class _From, class _To>
struct _Invoke_convertible<_From, _To, void_t<decltype(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))>>
    : true_type {};

template <class _From, class _To>
struct _Invoke_nothrow_convertible
    : bool_constant<noexcept(::std:: _Fake_copy_init<_To>(::std:: _Returns_exactly<_From>()))> {};

template <class _Result, bool _Nothrow>
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant<_Nothrow>;
    template <class _Rx>
    using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, _Invoke_convertible<type, _Rx>>>;
    template <class _Rx>
    using _Is_nothrow_invocable_r = bool_constant<conjunction_v<_Is_nothrow_invocable,
        disjunction<is_void<_Rx>,
            conjunction<_Invoke_convertible<type, _Rx>, _Invoke_nothrow_convertible<type, _Rx>>>>>;
};

template <class _Void, class _Callable>
struct _Invoke_traits_zero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable>
using _Decltype_invoke_zero = decltype(::std:: declval<_Callable>()());

template <class _Callable>
struct _Invoke_traits_zero<void_t<_Decltype_invoke_zero<_Callable>>, _Callable>
    : _Invoke_traits_common<_Decltype_invoke_zero<_Callable>, noexcept(::std:: declval<_Callable>()())> {};

template <class _Void, class... _Types>
struct _Invoke_traits_nonzero {
    
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template <class _Rx>
    using _Is_invocable_r = false_type;
    template <class _Rx>
    using _Is_nothrow_invocable_r = false_type;
};

template <class _Callable, class _Ty1, class... _Types2>
using _Decltype_invoke_nonzero = decltype(_Invoker1<_Callable, _Ty1>::_Call(
    ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...));

template <class _Callable, class _Ty1, class... _Types2>
struct _Invoke_traits_nonzero<void_t<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>>, _Callable, _Ty1,
    _Types2...> : _Invoke_traits_common<_Decltype_invoke_nonzero<_Callable, _Ty1, _Types2...>,
                      noexcept(_Invoker1<_Callable, _Ty1>::_Call(
                          ::std:: declval<_Callable>(), ::std:: declval<_Ty1>(), ::std:: declval<_Types2>()...))> {};

template <class _Callable, class... _Args>
using _Select_invoke_traits = conditional_t<sizeof...(_Args) == 0, _Invoke_traits_zero<void, _Callable>,
    _Invoke_traits_nonzero<void, _Callable, _Args...>>;





















#line 1875 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Callable, class... _Args>
using _Invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

template <class _Rx, class _Callable, class... _Args>
using _Is_invocable_r_ = typename _Select_invoke_traits<_Callable, _Args...>::template _Is_invocable_r<_Rx>;

template <class _Rx, class _Callable, class... _Args>
struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};


 template <class _Callable, class... _Args>
struct invoke_result : _Select_invoke_traits<_Callable, _Args...> {
    
};

 template <class _Callable, class... _Args>
using invoke_result_t = typename _Select_invoke_traits<_Callable, _Args...>::type;

 template <class _Callable, class... _Args>
struct is_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_invocable::value;

 template <class _Callable, class... _Args>
struct is_nothrow_invocable : _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable {
    
};

 template <class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_v = _Select_invoke_traits<_Callable, _Args...>::_Is_nothrow_invocable::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_invocable_r_v = _Is_invocable_r_<_Rx, _Callable, _Args...>::value;

 template <class _Rx, class _Callable, class... _Args>
struct is_nothrow_invocable_r : _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx> {
    
};

 template <class _Rx, class _Callable, class... _Args>
inline constexpr bool is_nothrow_invocable_r_v =
    _Select_invoke_traits<_Callable, _Args...>::template _Is_nothrow_invocable_r<_Rx>::value;
#line 1929 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"



 template <class _Ty1, class _Ty2>
struct is_layout_compatible : bool_constant<__is_layout_compatible(_Ty1, _Ty2)> {};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_layout_compatible_v = __is_layout_compatible(_Ty1, _Ty2);

 template <class _Base, class _Derived>
struct is_pointer_interconvertible_base_of : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)> {};

 template <class _Base, class _Derived>
inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of(_Base, _Derived);

 template <class _ClassTy, class _MemberTy>
[[nodiscard]] constexpr bool is_pointer_interconvertible_with_class(_MemberTy _ClassTy::*_Pm) noexcept {
    return __is_pointer_interconvertible_with_class(_ClassTy, _Pm);
}

 template <class _ClassTy1, class _ClassTy2, class _MemberTy1, class _MemberTy2>
[[nodiscard]] constexpr bool is_corresponding_member(_MemberTy1 _ClassTy1::*_Pm1, _MemberTy2 _ClassTy2::*_Pm2) noexcept {
    return __is_corresponding_member(_ClassTy1, _ClassTy2, _Pm1, _Pm2);
}
#line 1954 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
#line 1955 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Ty>
struct _Function_args {}; 







template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)   > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)   > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile  > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && > : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)   noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)   noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile  noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile & noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...)  && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...)  && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret __cdecl(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };    template <class _Ret, class... _Types> struct _Function_args<_Ret __vectorcall(_Types...) const volatile && noexcept> : _Arg_types<_Types...> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };








template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) > { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) &&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&&> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) & noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) && noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; }; template <class _Ret, class... _Types> struct _Function_args<_Ret(_Types..., ...) const volatile&& noexcept> { using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ret; };


template <class _Ty, class = void>
struct _Weak_result_type {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>> { 
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::result_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_argument_type : _Weak_result_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty> {
    
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::argument_type;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Weak_binary_args : _Weak_argument_type<_Ty> {}; 

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty> { 
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = typename _Ty::first_argument_type;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = typename _Ty::second_argument_type;
};
__pragma(warning(pop))

template <class _Ty>
using _Weak_types = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Function_args<remove_pointer_t<_Ty>>,
    conditional_t<is_member_function_pointer_v<_Ty>, _Is_memfunptr<remove_cv_t<_Ty>>, _Weak_binary_args<_Ty>>>;

template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept; 
template <class _Ty>
void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

template <class _Ty, class _Uty, class = void>
struct _Refwrap_has_ctor_from : false_type {};

template <class _Ty, class _Uty>
struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))>>
    : true_type {}; 

 template <class _Ty>
class reference_wrapper


#line 2032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
{
public:
    static_assert(is_object_v<_Ty> || is_function_v<_Ty>,
        "reference_wrapper<T> requires T to be an object type or a function type.");

    using type = _Ty;

    template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>,
                                          _Refwrap_has_ctor_from<_Ty, _Uty>>,
                              int> = 0>
    constexpr reference_wrapper(_Uty&& _Val) noexcept(
        noexcept(::std:: _Refwrap_ctor_fun<_Ty>(::std:: declval<_Uty>()))) { 
        _Ty& _Ref = static_cast<_Uty&&>(_Val);
        _Ptr      = ::std:: addressof(_Ref);
    }

    constexpr operator _Ty&() const noexcept {
        return *_Ptr;
    }

    [[nodiscard]] constexpr _Ty& get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template <class... _Types>
    constexpr auto operator()(_Types&&... _Args) const
        noexcept(noexcept(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)))
            -> decltype(::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...)) {
        return ::std:: invoke(*_Ptr, static_cast<_Types&&>(_Args)...);
    }
};


template <class _Ty>
reference_wrapper(_Ty&) -> reference_wrapper<_Ty>;
#line 2072 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(_Ty& _Val) noexcept {
    return reference_wrapper<_Ty>(_Val);
}

 template <class _Ty>
void ref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept {
    return reference_wrapper<const _Ty>(_Val);
}

 template <class _Ty>
void cref(const _Ty&&) = delete;

 template <class _Ty>
[[nodiscard]] constexpr reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept {
    return _Val;
}


 template <class _Ty>
struct unwrap_reference {
    using type = _Ty;
};
template <class _Ty>
struct unwrap_reference<reference_wrapper<_Ty>> {
    using type = _Ty&;
};
 template <class _Ty>
using unwrap_reference_t = unwrap_reference<_Ty>::type;

 template <class _Ty>
using unwrap_ref_decay_t = unwrap_reference_t<decay_t<_Ty>>;
 template <class _Ty>
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t<_Ty>;
};
#line 2118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Ty>
struct _Is_swappable;

template <class _Ty>
struct _Is_nothrow_swappable;


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> = 0>


#line 2130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
constexpr void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
constexpr void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

template <class _Ty1, class _Ty2, class = void>
struct _Swappable_with_helper : false_type {}; 

template <class _Ty1, class _Ty2>
struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
    : true_type {}; 

template <class _Ty1, class _Ty2>
struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>> {
    
};

template <class _Ty>
struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};

template <class _Ty1, class _Ty2>
struct _Swap_cannot_throw : bool_constant<noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
                                          && noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()))> {
    
    
};

template <class _Ty1, class _Ty2>
struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>> {
    
    
};

template <class _Ty>
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type {
    
};


 template <class _Ty1, class _Ty2>
struct is_swappable_with : _Is_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_swappable_with_v =
    conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>;

 template <class _Ty>
struct is_swappable : _Is_swappable<_Ty>::type {}; 

 template <class _Ty>
inline constexpr bool is_swappable_v = _Is_swappable<_Ty>::value;

 template <class _Ty1, class _Ty2>
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with<_Ty1, _Ty2>::type {
    
    
};

 template <class _Ty1, class _Ty2>
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with<_Ty1, _Ty2>::value;

 template <class _Ty>
struct is_nothrow_swappable : _Is_nothrow_swappable<_Ty>::type {
    
};

 template <class _Ty>
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable<_Ty>::value;
#line 2207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

namespace _Has_ADL_swap_detail {


#line 2212 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
    void swap();
#line 2214 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

    template <class, class = void>
    struct _Has_ADL_swap : false_type {};
    template <class _Ty>
    struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std:: declval<_Ty&>(), ::std:: declval<_Ty&>()))>> : true_type {};
} 
using _Has_ADL_swap_detail::_Has_ADL_swap;

template <class _Ty>
inline constexpr bool _Is_trivially_swappable_v = conjunction_v<is_trivially_destructible<_Ty>,
    is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;


template <>
inline constexpr bool _Is_trivially_swappable_v<byte> = true;
#line 2230 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

template <class _Ty>
struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>> {
    
};


 template <class _From, class _To>
concept convertible_to =

    is_convertible_v<_From, _To>


#line 2244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
    && requires { static_cast<_To>(::std:: declval<_From>()); };

template <class _RefWrap, class _Ty, class _RefWrapQ, class _TyQ>
concept _Ref_wrap_common_reference_exists_with = _Is_specialization_v<_RefWrap, reference_wrapper> && requires {
    typename common_reference_t<typename _RefWrap::type&, _TyQ>;
} && convertible_to<_RefWrapQ, common_reference_t<typename _RefWrap::type&, _TyQ>>;

template <class _RefWrap, class _Ty, template <class> class _RefWrapQual, template <class> class _TyQual>
    requires (_Ref_wrap_common_reference_exists_with<_RefWrap, _Ty, _RefWrapQual<_RefWrap>, _TyQual<_Ty>>
              && !_Ref_wrap_common_reference_exists_with<_Ty, _RefWrap, _TyQual<_Ty>, _RefWrapQual<_RefWrap>>)
struct basic_common_reference<_RefWrap, _Ty, _RefWrapQual, _TyQual> {
    using type = common_reference_t<typename _RefWrap::type&, _TyQual<_Ty>>;
};

template <class _Ty, class _RefWrap, template <class> class _TyQual, template <class> class _RefWrapQual>
    requires (_Ref_wrap_common_reference_exists_with<_RefWrap, _Ty, _RefWrapQual<_RefWrap>, _TyQual<_Ty>>
              && !_Ref_wrap_common_reference_exists_with<_Ty, _RefWrap, _TyQual<_Ty>, _RefWrapQual<_RefWrap>>)
struct basic_common_reference<_Ty, _RefWrap, _TyQual, _RefWrapQual> {
    using type = common_reference_t<typename _RefWrap::type&, _TyQual<_Ty>>;
};
#line 2265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"


































template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) != _Bitmask{};
}

template <class _Bitmask>
[[nodiscard]] constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {
    return (_Left & _Elements) == _Elements;
}




inline constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
inline constexpr size_t _FNV_prime        = 1099511628211ULL;



#line 2318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

[[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { 
    for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {
        _Val ^= static_cast<size_t>(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template <class _Ty>
[[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { 
    static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
    const auto _Lastb  = reinterpret_cast<const unsigned char*>(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
}

template <class _Kty>
[[nodiscard]] size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty& _Keyval) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
}

template <class _Kty>
[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept { 
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

template <class _Kty>
[[nodiscard]] size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { 
    static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
}

 template <class _Kty>
struct hash;

template <class _Kty, bool _Enabled>
struct _Conditionally_enabled_hash { 
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Kty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const _Kty& _Keyval) const
        noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))  {
        return hash<_Kty>::_Do_hash(_Keyval);
    }
};

template <class _Kty>
struct _Conditionally_enabled_hash<_Kty, false> { 
    _Conditionally_enabled_hash()                                              = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&)            = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&&)                 = delete;
    _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
    _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&)      = delete;
};

 template <class _Kty>
struct hash : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty>
                                                    && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)> {
    
    static size_t _Do_hash(const _Kty& _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template <>
struct hash<float> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = float;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); 
    }
};

template <>
struct hash<double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); 
    }
};

template <>
struct hash<long double> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = long double;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); 
    }
};

template <>
struct hash<nullptr_t> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = nullptr_t;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;
    [[nodiscard]] size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

template <class _Kty, class = void>
struct _Is_nothrow_hashable : false_type {}; 

template <class _Kty>
struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std:: declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std:: declval<const _Kty&>()))> {};

 template <class _Ty = void>
struct less {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left < _Right)))  {
        return _Left < _Right;
    }
};

template <>
struct less<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};



template <class _FloatingType>
struct _Floating_type_traits;

template <>
struct _Floating_type_traits<float> {
    static constexpr int32_t _Mantissa_bits           = 24; 
    static constexpr int32_t _Exponent_bits           = 8; 
    static constexpr int32_t _Maximum_binary_exponent = 127; 
    static constexpr int32_t _Minimum_binary_exponent = -126; 
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; 
    static constexpr int32_t _Exponent_shift          = 23; 

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; 
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; 
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; 
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; 
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; 
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; 
};

template <>
struct _Floating_type_traits<double> {
    static constexpr int32_t _Mantissa_bits           = 53; 
    static constexpr int32_t _Exponent_bits           = 11; 
    static constexpr int32_t _Maximum_binary_exponent = 1023; 
    static constexpr int32_t _Minimum_binary_exponent = -1022; 
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; 
    static constexpr int32_t _Exponent_shift          = 52; 

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; 
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; 
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; 
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; 
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; 
};

template <>
struct _Floating_type_traits<long double> : _Floating_type_traits<double> {};



template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To _Bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}


































































#line 2582 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"

}








#pragma warning(pop)
#pragma pack(pop)

#line 2596 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
#line 2597 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\type_traits"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"
















#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

template <class _Ty1, class _Ty2>
concept _Same_impl = 



    is_same_v<_Ty1, _Ty2>;
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept same_as = _Same_impl<_Ty1, _Ty2> && _Same_impl<_Ty2, _Ty1>;

 template <class _Derived, class _Base>
concept derived_from = __is_base_of(_Base, _Derived)
    && __is_convertible_to(const volatile _Derived*, const volatile _Base*);

template <class _From, class _To>
concept _Implicitly_convertible_to = is_convertible_v<_From, _To>;

 template <class _Ty1, class _Ty2>
concept common_reference_with =
    requires {
        typename common_reference_t<_Ty1, _Ty2>;
        typename common_reference_t<_Ty2, _Ty1>;
    }
    && same_as<common_reference_t<_Ty1, _Ty2>, common_reference_t<_Ty2, _Ty1>>
    && convertible_to<_Ty1, common_reference_t<_Ty1, _Ty2>>
    && convertible_to<_Ty2, common_reference_t<_Ty1, _Ty2>>;

 template <class _Ty1, class _Ty2>
concept common_with =
    requires {
        typename common_type_t<_Ty1, _Ty2>;
        typename common_type_t<_Ty2, _Ty1>;
    }
    && same_as<common_type_t<_Ty1, _Ty2>, common_type_t<_Ty2, _Ty1>>
    && requires {
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty1>());
        static_cast<common_type_t<_Ty1, _Ty2>>(::std:: declval<_Ty2>());
    }
    && common_reference_with<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>
    && common_reference_with<add_lvalue_reference_t<common_type_t<_Ty1, _Ty2>>,
        common_reference_t<add_lvalue_reference_t<const _Ty1>, add_lvalue_reference_t<const _Ty2>>>;

 template <class _Ty>
concept integral = is_integral_v<_Ty>;

 template <class _Ty>
concept signed_integral = integral<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);

 template <class _Ty>
concept unsigned_integral = integral<_Ty> && !signed_integral<_Ty>;

 template <class _Ty>
concept floating_point = is_floating_point_v<_Ty>;

 template <class _LTy, class _RTy>
concept assignable_from = is_lvalue_reference_v<_LTy>
    && common_reference_with<const remove_reference_t<_LTy>&, const remove_reference_t<_RTy>&>
    && requires(_LTy _Left, _RTy&& _Right) {
        { _Left = static_cast<_RTy&&>(_Right) } -> same_as<_LTy>;
    };



 template <class _Ty>
concept destructible = __is_nothrow_destructible(_Ty);

 template <class _Ty, class... _ArgTys>
concept constructible_from = destructible<_Ty>
    && __is_constructible(_Ty, _ArgTys...);

 template <class _Ty>
concept default_initializable = constructible_from<_Ty>
    && requires {
        _Ty{};
        ::new (static_cast<void*>(nullptr)) _Ty; 
    };

 template <class _Ty>
concept move_constructible = constructible_from<_Ty, _Ty> && convertible_to<_Ty, _Ty>;

template <class _Ty>
concept _Has_class_or_enum_type = __is_class(remove_reference_t<_Ty>) || __is_enum(remove_reference_t<_Ty>)
    || __is_union(remove_reference_t<_Ty>);

namespace ranges {
    namespace _Swap {
        template <class _Ty>
        void swap(_Ty&, _Ty&) = delete;

        template <class _Ty1, class _Ty2>
        concept _Use_ADL_swap = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t, _Ty2&& __u) {
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            };

        struct _Cpo {
            template <class _Ty1, class _Ty2>
                requires _Use_ADL_swap<_Ty1, _Ty2>
            constexpr void operator()(_Ty1&& __t, _Ty2&& __u) const
                noexcept(noexcept(swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)))) { 
                swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u)); 
            }

            template <class _Ty>
                requires (!_Use_ADL_swap<_Ty&, _Ty&> && move_constructible<_Ty> && assignable_from<_Ty&, _Ty>)
            constexpr void operator()(_Ty& __x, _Ty& __y) const
                noexcept(is_nothrow_move_constructible_v<_Ty> && is_nothrow_move_assignable_v<_Ty>) {
                _Ty __tmp(static_cast<_Ty&&>(__x));
                __x = static_cast<_Ty&&>(__y);
                __y = static_cast<_Ty&&>(__tmp);
            }

            template <class _Ty1, class _Ty2, size_t _Size>
            constexpr void operator()(_Ty1 (&__t)[_Size], _Ty2 (&__u)[_Size]) const
                noexcept(noexcept((*this)(__t[0], __u[0])))
                requires requires { (*this)(__t[0], __u[0]); } {
                for (size_t __i = 0; __i < _Size; ++__i) {
                    (*this)(__t[__i], __u[__i]);
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Swap::_Cpo swap;
    }
} 

 template <class _Ty>
concept swappable = requires(_Ty& __x, _Ty& __y) {
    ::std::ranges:: swap(__x, __y);
};

 template <class _Ty1, class _Ty2>
concept swappable_with = common_reference_with<_Ty1, _Ty2>
    && requires(_Ty1&& __t, _Ty2&& __u) {
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty1&&>(__t));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty1&&>(__t), static_cast<_Ty2&&>(__u));
        ::std::ranges:: swap(static_cast<_Ty2&&>(__u), static_cast<_Ty1&&>(__t));
    };

 template <class _Ty>
concept copy_constructible = move_constructible<_Ty>
    && constructible_from<_Ty, _Ty&> && convertible_to<_Ty&, _Ty>
    && constructible_from<_Ty, const _Ty&> && convertible_to<const _Ty&, _Ty>
    && constructible_from<_Ty, const _Ty> && convertible_to<const _Ty, _Ty>;

template <class _Ty>
concept _Boolean_testable_impl = convertible_to<_Ty, bool>;

template <class _Ty>
concept _Boolean_testable = _Boolean_testable_impl<_Ty>
    && requires(_Ty&& __t) {
        { !static_cast<_Ty&&>(__t) } -> _Boolean_testable_impl;
    };

template <class _Ty1, class _Ty2>
concept _Half_equality_comparable =
    requires(const remove_reference_t<_Ty1>& __x, const remove_reference_t<_Ty2>& __y) {
        { __x == __y } -> _Boolean_testable;
        { __x != __y } -> _Boolean_testable;
    };

template <class _Ty1, class _Ty2>
concept _Weakly_equality_comparable_with =
    _Half_equality_comparable<_Ty1, _Ty2> && _Half_equality_comparable<_Ty2, _Ty1>;

 template <class _Ty>
concept equality_comparable = _Half_equality_comparable<_Ty, _Ty>;


template <class _Ty1, class _Ty2, class _Ref = common_reference_t<const _Ty1&, const _Ty2&>>
concept _Comparison_common_type_with_impl =
    same_as<_Ref, common_reference_t<const _Ty2&, const _Ty1&>>
    && requires {
           requires convertible_to<const _Ty1&, const _Ref&> || convertible_to<_Ty1, const _Ref&>;
           requires convertible_to<const _Ty2&, const _Ref&> || convertible_to<_Ty2, const _Ref&>;
       };

template <class _Ty1, class _Ty2>
concept _Comparison_common_type_with = _Comparison_common_type_with_impl<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>>;
#line 210 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"

 template <class _Ty1, class _Ty2>
concept equality_comparable_with = equality_comparable<_Ty1> && equality_comparable<_Ty2>

    && _Comparison_common_type_with<_Ty1, _Ty2>


#line 218 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"
    && equality_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2>;

template <class _Ty1, class _Ty2>
concept _Half_ordered = requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
    { __t <  __u } -> _Boolean_testable;
    { __t >  __u } -> _Boolean_testable;
    { __t <= __u } -> _Boolean_testable;
    { __t >= __u } -> _Boolean_testable;
};

template <class _Ty1, class _Ty2>
concept _Partially_ordered_with = _Half_ordered<_Ty1, _Ty2> && _Half_ordered<_Ty2, _Ty1>;

 template <class _Ty>
concept totally_ordered = equality_comparable<_Ty> && _Half_ordered<_Ty, _Ty>;

 template <class _Ty1, class _Ty2>
concept totally_ordered_with = totally_ordered<_Ty1> && totally_ordered<_Ty2>
    && equality_comparable_with<_Ty1, _Ty2>
    && totally_ordered<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>>
    && _Partially_ordered_with<_Ty1, _Ty2>;

 template <class _Ty>
concept movable = is_object_v<_Ty>
    && move_constructible<_Ty>
    && assignable_from<_Ty&, _Ty>
    && swappable<_Ty>;

 template <class _Ty>
concept copyable = copy_constructible<_Ty>
    && movable<_Ty>
    && assignable_from<_Ty&, _Ty&>
    && assignable_from<_Ty&, const _Ty&>
    && assignable_from<_Ty&, const _Ty>;

 template <class _Ty>
concept semiregular = copyable<_Ty> && default_initializable<_Ty>;

 template <class _Ty>
concept regular = semiregular<_Ty> && equality_comparable<_Ty>;

 template <class _FTy, class... _ArgTys>
concept invocable = requires(_FTy&& _Fn, _ArgTys&&... _Args) {
    ::std:: invoke(static_cast<_FTy&&>(_Fn), static_cast<_ArgTys&&>(_Args)...);
};

 template <class _FTy, class... _ArgTys>
concept regular_invocable = invocable<_FTy, _ArgTys...>;

 template <class _FTy, class... _ArgTys>
concept predicate = regular_invocable<_FTy, _ArgTys...>
    && _Boolean_testable<invoke_result_t<_FTy, _ArgTys...>>;

 template <class _FTy, class _Ty1, class _Ty2>
concept relation =
       predicate<_FTy, _Ty1, _Ty1>
    && predicate<_FTy, _Ty2, _Ty2>
    && predicate<_FTy, _Ty1, _Ty2>
    && predicate<_FTy, _Ty2, _Ty1>;

 template <class _FTy, class _Ty1, class _Ty2>
concept equivalence_relation = relation<_FTy, _Ty1, _Ty2>;

 template <class _FTy, class _Ty1, class _Ty2>
concept strict_weak_order = relation<_FTy, _Ty1, _Ty2>;



template <class _Ty>
struct _Choice_t {
    _Ty _Strategy  = _Ty{};
    bool _No_throw = false;
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"
#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"
#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\concepts"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"




#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
void _Literal_zero_is_expected();

struct _Literal_zero {
    template <class _Ty, enable_if_t<is_same_v<_Ty, int>, int> = 0>
    consteval _Literal_zero(_Ty _Zero) noexcept {
        
        if (_Zero != 0) {
            _Literal_zero_is_expected();
        }
    }
};

using _Compare_t = signed char;


enum class _Compare_eq : _Compare_t { equal = 0, equivalent = equal };
enum class _Compare_ord : _Compare_t { less = -1, greater = 1 };
enum class _Compare_ncmp : _Compare_t { unordered = -128 };

 struct partial_ordering {
    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;

    [[nodiscard]] friend constexpr bool operator==(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == static_cast<_Compare_t>(_Compare_ord::less);
    }

    [[nodiscard]] friend constexpr bool operator>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const partial_ordering _Val, _Literal_zero) noexcept {
        
        
        
        return static_cast<signed char>(0 - static_cast<unsigned int>(_Val._Value)) >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const partial_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(const partial_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr partial_ordering operator<=>(_Literal_zero, const partial_ordering _Val) noexcept {
        
        
        
        return {static_cast<_Compare_t>(0 - static_cast<unsigned int>(_Val._Value))};
    }

    _Compare_t _Value;
};

inline constexpr partial_ordering partial_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr partial_ordering partial_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr partial_ordering partial_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};
inline constexpr partial_ordering partial_ordering::unordered{static_cast<_Compare_t>(_Compare_ncmp::unordered)};

 struct weak_ordering {
    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const weak_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(const weak_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr weak_ordering operator<=>(_Literal_zero, const weak_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr weak_ordering weak_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr weak_ordering weak_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr weak_ordering weak_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 struct strong_ordering {
    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    constexpr operator partial_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    constexpr operator weak_ordering() const noexcept {
        return {static_cast<_Compare_t>(_Value)};
    }

    [[nodiscard]] friend constexpr bool operator==(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value == 0;
    }

    [[nodiscard]] friend constexpr bool operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]] friend constexpr bool operator<(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value < 0;
    }

    [[nodiscard]] friend constexpr bool operator>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value > 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value <= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val._Value >= 0;
    }

    [[nodiscard]] friend constexpr bool operator<(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val > 0;
    }

    [[nodiscard]] friend constexpr bool operator>(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val < 0;
    }

    [[nodiscard]] friend constexpr bool operator<=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val >= 0;
    }

    [[nodiscard]] friend constexpr bool operator>=(_Literal_zero, const strong_ordering _Val) noexcept {
        return _Val <= 0;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(const strong_ordering _Val, _Literal_zero) noexcept {
        return _Val;
    }

    [[nodiscard]] friend constexpr strong_ordering operator<=>(_Literal_zero, const strong_ordering _Val) noexcept {
        return {static_cast<_Compare_t>(-_Val._Value)};
    }

    _Compare_t _Value;
};

inline constexpr strong_ordering strong_ordering::less{static_cast<_Compare_t>(_Compare_ord::less)};
inline constexpr strong_ordering strong_ordering::equal{static_cast<_Compare_t>(_Compare_eq::equal)};
inline constexpr strong_ordering strong_ordering::equivalent{static_cast<_Compare_t>(_Compare_eq::equivalent)};
inline constexpr strong_ordering strong_ordering::greater{static_cast<_Compare_t>(_Compare_ord::greater)};

 [[nodiscard]] constexpr bool is_eq(const partial_ordering _Comp) noexcept {
    return _Comp == 0;
}

 [[nodiscard]] constexpr bool is_neq(const partial_ordering _Comp) noexcept {
    return _Comp != 0;
}

 [[nodiscard]] constexpr bool is_lt(const partial_ordering _Comp) noexcept {
    return _Comp < 0;
}

 [[nodiscard]] constexpr bool is_lteq(const partial_ordering _Comp) noexcept {
    return _Comp <= 0;
}

 [[nodiscard]] constexpr bool is_gt(const partial_ordering _Comp) noexcept {
    return _Comp > 0;
}

 [[nodiscard]] constexpr bool is_gteq(const partial_ordering _Comp) noexcept {
    return _Comp >= 0;
}

enum _Comparison_category : unsigned char {
    _Comparison_category_none    = 1,
    _Comparison_category_partial = 2,
    _Comparison_category_weak    = 4,
    _Comparison_category_strong  = 0,
};

template <class... _Types>
inline constexpr unsigned char _Classify_category =
    _Comparison_category{(_Classify_category<_Types> | ... | _Comparison_category_strong)};
template <class _Ty>
inline constexpr unsigned char _Classify_category<_Ty> = _Comparison_category_none;
template <>
inline constexpr unsigned char _Classify_category<partial_ordering> = _Comparison_category_partial;
template <>
inline constexpr unsigned char _Classify_category<weak_ordering> = _Comparison_category_weak;
template <>
inline constexpr unsigned char _Classify_category<strong_ordering> = _Comparison_category_strong;

 template <class... _Types>
using common_comparison_category_t =
    conditional_t<(_Classify_category<_Types...> & _Comparison_category_none) != 0, void,
        conditional_t<(_Classify_category<_Types...> & _Comparison_category_partial) != 0, partial_ordering,
            conditional_t<(_Classify_category<_Types...> & _Comparison_category_weak) != 0, weak_ordering,
                strong_ordering>>>;

 template <class... _Types>
struct common_comparison_category {
    using type = common_comparison_category_t<_Types...>;
};


template <class _Ty, class _Cat>
concept _Compares_as = same_as<common_comparison_category_t<_Ty, _Cat>, _Cat>;

 template <class _Ty, class _Cat = partial_ordering>
concept three_way_comparable = _Half_equality_comparable<_Ty, _Ty> && _Half_ordered<_Ty, _Ty>
                            && requires(const remove_reference_t<_Ty>& __a, const remove_reference_t<_Ty>& __b) {
                                   { __a <=> __b } -> _Compares_as<_Cat>;
                               };

 template <class _Ty1, class _Ty2, class _Cat = partial_ordering>
concept three_way_comparable_with =
    three_way_comparable<_Ty1, _Cat> && three_way_comparable<_Ty2, _Cat>

    && _Comparison_common_type_with<_Ty1, _Ty2>


#line 316 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    && three_way_comparable<common_reference_t<const remove_reference_t<_Ty1>&, const remove_reference_t<_Ty2>&>, _Cat>
    && _Weakly_equality_comparable_with<_Ty1, _Ty2> && _Partially_ordered_with<_Ty1, _Ty2>
    && requires(const remove_reference_t<_Ty1>& __t, const remove_reference_t<_Ty2>& __u) {
           { __t <=> __u } -> _Compares_as<_Cat>;
           { __u <=> __t } -> _Compares_as<_Cat>;
       };

 template <class _Ty1, class _Ty2 = _Ty1>
using compare_three_way_result_t =
    decltype(::std:: declval<const remove_reference_t<_Ty1>&>() <=> ::std:: declval<const remove_reference_t<_Ty2>&>());

 template <class _Ty1, class _Ty2 = _Ty1>
struct compare_three_way_result {};

template <class _Ty1, class _Ty2>
    requires requires { typename compare_three_way_result_t<_Ty1, _Ty2>; }
struct compare_three_way_result<_Ty1, _Ty2> {
    using type = compare_three_way_result_t<_Ty1, _Ty2>;
};

 struct compare_three_way {
    template <class _Ty1, class _Ty2>
        requires three_way_comparable_with<_Ty1, _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right)))  {
        return ::std:: forward<_Ty1>(_Left) <=> ::std:: forward<_Ty2>(_Right);
    }

    using is_transparent = int;
};

struct _Synth_three_way {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(const _Ty1& _Left, const _Ty2& _Right) const
        requires requires {
            { _Left < _Right } -> _Boolean_testable;
            { _Right < _Left } -> _Boolean_testable;
        }
    {
        if constexpr (three_way_comparable_with<_Ty1, _Ty2>) {
            return _Left <=> _Right;
        } else {
            if (_Left < _Right) {
                return weak_ordering::less;
            } else if (_Right < _Left) {
                return weak_ordering::greater;
            } else {
                return weak_ordering::equivalent;
            }
        }
    }
};

template <class _Ty1, class _Ty2 = _Ty1>
using _Synth_three_way_result = decltype(_Synth_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()));



namespace _Strong_order {


#line 378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    void strong_order();
#line 380 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
        static_cast<strong_ordering>(strong_order(_Left, _Right)); 
    };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<strong_ordering>(compare_three_way{}(_Left, _Right)); };

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<strong_ordering>(
                                       strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<strong_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<strong_ordering>(strong_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                const auto _Left_uint  = _Bit_cast<_Uint_type>(_Left);
                const auto _Right_uint = _Bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return strong_ordering::equal;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_ones_complement_uint  = _Left_uint ^ _Left_xor;
                const _Uint_type _Right_ones_complement_uint = _Right_uint ^ _Right_xor;

                const auto _Left_ones_complement  = static_cast<_Sint_type>(_Left_ones_complement_uint);
                const auto _Right_ones_complement = static_cast<_Sint_type>(_Right_ones_complement_uint);

                
                return _Left_ones_complement <=> _Right_ones_complement;
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<strong_ordering>(compare_three_way{}(_Left, _Right));
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Strong_order::_Cpo strong_order;
}

namespace _Weak_order {


#line 474 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    void weak_order();
#line 476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
        static_cast<weak_ordering>(weak_order(_Left, _Right)); 
    };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<weak_ordering>(compare_three_way{}(_Left, _Right)); };

    


#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    void strong_order();
#line 492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Floating, _Three, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<weak_ordering>(
                                       weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (floating_point<decay_t<_Ty1>>) {
                return {_St::_Floating, true};
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<weak_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<weak_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<weak_ordering>(weak_order(_Left, _Right)); 
            } else if constexpr (_Strat == _St::_Floating) {
                using _Floating_type = decay_t<_Ty1>;
                using _Traits        = _Floating_type_traits<_Floating_type>;
                using _Uint_type     = _Traits::_Uint_type;
                using _Sint_type     = make_signed_t<_Uint_type>;

                auto _Left_uint  = _Bit_cast<_Uint_type>(_Left);
                auto _Right_uint = _Bit_cast<_Uint_type>(_Right);

                
                if (_Left_uint == _Right_uint) {
                    return weak_ordering::equivalent;
                }

                
                const _Uint_type _Left_shifted_sign  = _Left_uint & _Traits::_Shifted_sign_mask;
                const _Uint_type _Right_shifted_sign = _Right_uint & _Traits::_Shifted_sign_mask;

                
                
                constexpr _Uint_type _Infinity_plus_one = _Traits::_Shifted_exponent_mask + 1;

                const _Uint_type _Left_magnitude  = _Left_uint & ~_Traits::_Shifted_sign_mask;
                const _Uint_type _Right_magnitude = _Right_uint & ~_Traits::_Shifted_sign_mask;

                if (_Left_magnitude > _Infinity_plus_one) {
                    _Left_uint = _Left_shifted_sign | _Infinity_plus_one;
                }

                if (_Right_magnitude > _Infinity_plus_one) {
                    _Right_uint = _Right_shifted_sign | _Infinity_plus_one;
                }

                
                
                
                const _Uint_type _Left_sign  = _Left_shifted_sign >> _Traits::_Sign_shift;
                const _Uint_type _Right_sign = _Right_shifted_sign >> _Traits::_Sign_shift;

                const _Uint_type _Left_xor  = _Left_shifted_sign - _Left_sign;
                const _Uint_type _Right_xor = _Right_shifted_sign - _Right_sign;

                const _Uint_type _Left_twos_complement_uint  = (_Left_uint ^ _Left_xor) + _Left_sign;
                const _Uint_type _Right_twos_complement_uint = (_Right_uint ^ _Right_xor) + _Right_sign;

                const auto _Left_twos_complement  = static_cast<_Sint_type>(_Left_twos_complement_uint);
                const auto _Right_twos_complement = static_cast<_Sint_type>(_Right_twos_complement_uint);

                
                return static_cast<weak_ordering>(_Left_twos_complement <=> _Right_twos_complement);
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<weak_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<weak_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Weak_order::_Cpo weak_order;
}

namespace _Partial_order {


#line 600 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    void partial_order();
#line 602 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

    template <class _Ty1, class _Ty2>
    concept _Has_ADL = requires(_Ty1& _Left, _Ty2& _Right) {
        static_cast<partial_ordering>(partial_order(_Left, _Right)); 
    };

    template <class _Ty1, class _Ty2>
    concept _Can_compare_three_way =
        requires(_Ty1& _Left, _Ty2& _Right) { static_cast<partial_ordering>(compare_three_way{}(_Left, _Right)); };

    
    



#line 618 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
    void weak_order();
    void strong_order();
#line 621 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

    class _Cpo {
    private:
        enum class _St { _None, _Adl, _Three, _Weak, _Strong };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                return {_St::_Adl, noexcept(static_cast<partial_ordering>(partial_order(
                                       ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))}; 
            } else if constexpr (_Can_compare_three_way<_Ty1, _Ty2>) {
                return {_St::_Three, noexcept(static_cast<partial_ordering>(
                                         compare_three_way{}(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>())))};
            } else if constexpr (_Weak_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Weak, noexcept(static_cast<partial_ordering>(static_cast<weak_ordering>(
                                        weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else if constexpr (_Strong_order::_Has_ADL<_Ty1, _Ty2>) {
                
                return {_St::_Strong, noexcept(static_cast<partial_ordering>(static_cast<strong_ordering>(strong_order(
                                          ::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))))}; 
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Adl) {
                return static_cast<partial_ordering>( partial_order(_Left, _Right));
            } else if constexpr (_Strat == _St::_Three) {
                return static_cast<partial_ordering>(compare_three_way{}(_Left, _Right));
            } else if constexpr (_Strat == _St::_Weak) {
                
                return static_cast<partial_ordering>(
                    static_cast<weak_ordering>(weak_order(_Left, _Right))); 
            } else if constexpr (_Strat == _St::_Strong) {
                
                return static_cast<partial_ordering>(
                    static_cast<strong_ordering>(strong_order(_Left, _Right))); 
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Partial_order::_Cpo partial_order;
}

template <class _Ty1, class _Ty2>
concept _Can_fallback_eq_lt = requires(_Ty1& _Left, _Ty2& _Right) {
    { _Left == _Right } -> _Boolean_testable;
    { _Left < _Right } -> _Boolean_testable;
};

template <class _Ty1, class _Ty2>
concept _Can_strong_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: strong_order(_Left, _Right); };

namespace _Compare_strong_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Strong, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_strong_order<_Ty1, _Ty2>) {
                return {_St::_Strong, noexcept(::std:: strong_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? strong_ordering::equal
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? strong_ordering::less
                                                                             : strong_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr strong_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Strong) {
                return ::std:: strong_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? strong_ordering::equal
                     : _Left < _Right  ? strong_ordering::less
                                       : strong_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_strong_order_fallback::_Cpo compare_strong_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_weak_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: weak_order(_Left, _Right); };

namespace _Compare_weak_order_fallback {
    class _Cpo {
    private:
        enum class _St { _None, _Weak, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_weak_order<_Ty1, _Ty2>) {
                return {_St::_Weak, noexcept(::std:: weak_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt<_Ty1, _Ty2>) {
                return {
                    _St::_Fallback, noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? weak_ordering::equivalent
                                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? weak_ordering::less
                                                                                             : weak_ordering::greater)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr weak_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Weak) {
                return ::std:: weak_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? weak_ordering::equivalent
                     : _Left < _Right  ? weak_ordering::less
                                       : weak_ordering::greater;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_weak_order_fallback::_Cpo compare_weak_order_fallback;
}

template <class _Ty1, class _Ty2>
concept _Can_partial_order = requires(_Ty1& _Left, _Ty2& _Right) { ::std:: partial_order(_Left, _Right); };

namespace _Compare_partial_order_fallback {
    template <class _Ty1, class _Ty2>
    concept _Can_fallback_eq_lt_twice = requires(_Ty1& _Left, _Ty2& _Right) {
        { _Left == _Right } -> _Boolean_testable;
        { _Left < _Right } -> _Boolean_testable;
        { _Right < _Left } -> _Boolean_testable;
    };

    class _Cpo {
    private:
        enum class _St { _None, _Partial, _Fallback };

        template <class _Ty1, class _Ty2>
        [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
            if constexpr (!same_as<decay_t<_Ty1>, decay_t<_Ty2>>) {
                return {_St::_None};
            } else if constexpr (_Can_partial_order<_Ty1, _Ty2>) {
                return {_St::_Partial, noexcept(::std:: partial_order(::std:: declval<_Ty1&>(), ::std:: declval<_Ty2&>()))};
            } else if constexpr (_Can_fallback_eq_lt_twice<_Ty1, _Ty2>) {
                return {_St::_Fallback,
                    noexcept(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>()  ? partial_ordering::equivalent
                             : ::std:: declval<_Ty1&>() < ::std:: declval<_Ty2&>() ? partial_ordering::less
                             : ::std:: declval<_Ty2&>() < ::std:: declval<_Ty1&>() ? partial_ordering::greater
                                                                             : partial_ordering::unordered)};
            } else {
                return {_St::_None};
            }
        }

        template <class _Ty1, class _Ty2>
        static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

    public:
        template <class _Ty1, class _Ty2>
            requires (_Choice<_Ty1&, _Ty2&>._Strategy != _St::_None)
        [[nodiscard]] constexpr partial_ordering operator()(_Ty1&& _Left, _Ty2&& _Right) const
            noexcept(_Choice<_Ty1&, _Ty2&>._No_throw) {
            constexpr _St _Strat = _Choice<_Ty1&, _Ty2&>._Strategy;
            if constexpr (_Strat == _St::_Partial) {
                return ::std:: partial_order(_Left, _Right);
            } else if constexpr (_Strat == _St::_Fallback) {
                return _Left == _Right ? partial_ordering::equivalent
                     : _Left < _Right  ? partial_ordering::less
                     : _Right < _Left  ? partial_ordering::greater
                                       : partial_ordering::unordered;
            } else {
                static_assert(_Always_false<_Ty1>, "should be unreachable");
            }
        }
    };
} 

inline namespace _Cpos {
     inline constexpr _Compare_partial_order_fallback::_Cpo compare_partial_order_fallback;
}

#line 847 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
}



#pragma warning(pop)
#pragma pack(pop)
#line 854 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"

#line 856 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
#line 857 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\compare"
#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"



#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )












namespace std {
 template <class _Ty, _Ty... _Vals>
struct integer_sequence { 
    static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

    using value_type = _Ty;

    [[nodiscard]] static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

 template <class _Ty, _Ty _Size>
using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

 template <size_t... _Vals>
using index_sequence = integer_sequence<size_t, _Vals...>;

 template <size_t _Size>
using make_index_sequence = make_integer_sequence<size_t, _Size>;

 template <class... _Types>
using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(max) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Left, _Right)))  {
    
    return _Pred(_Left, _Right) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))  {
    
    return _Left < _Right ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty>); 

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty&(min) (const _Ty& _Left, const _Ty& _Right, _Pr _Pred) noexcept(
    noexcept(_Pred(_Right, _Left)))  {
    
    return _Pred(_Right, _Left) ? _Right : _Left;
}

#pragma warning(push)
#pragma warning(disable : 28285) 
 template <class _Ty>
[[nodiscard]]   constexpr const _Ty& 
    (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))  {
    
    return _Right < _Left ? _Right : _Left;
}
#pragma warning(pop)

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>, _Pr); 

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty>); 

 template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> >
constexpr void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value) {
    if (&_Left != &_Right) {
        _Ty* _First1 = _Left;
        _Ty* _Last1  = _First1 + _Size;
        _Ty* _First2 = _Right;
        for (; _First1 != _Last1; ++_First1, ++_First2) {
            swap(*_First1, *_First2); 
        }
    }
}


 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_move_assignable_v<_Ty>, int> >


#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
constexpr void swap(_Ty& _Left, _Ty& _Right) noexcept(
    is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {
    _Ty _Tmp = ::std:: move(_Left);
    _Left    = ::std:: move(_Right);
    _Right   = ::std:: move(_Tmp);
}

 struct piecewise_construct_t { 
    explicit piecewise_construct_t() = default;
};

 inline constexpr piecewise_construct_t piecewise_construct{};

 template <class... _Types>
class tuple;

 template <class _Ty1, class _Ty2>
struct pair;

 template <class _Ty, size_t _Size>
class array;

 template <class _Tuple>
struct tuple_size;

 template <class _Ty>
inline constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

 template <size_t _Index, class _Tuple>
struct tuple_element;

 template <size_t _Index, class _Tuple>
using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

  template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

 template <size_t _Idx, class _Ty, size_t _Size>
[[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;


template <class _Ty1, class _Ty2>
concept _Different_from = !same_as<remove_cvref_t<_Ty1>, remove_cvref_t<_Ty2>>;

template <class>
inline constexpr bool _Is_std_array_v = false;

template <class _Ty, size_t _Size>
inline constexpr bool _Is_std_array_v<array<_Ty, _Size>> = true;

template <class>
inline constexpr bool _Is_subrange_v = false;


template <class _Ty>
inline constexpr bool _Tuple_like_impl =
    _Is_specialization_v<_Ty, tuple> || _Is_specialization_v<_Ty, pair> || _Is_std_array_v<_Ty> || _Is_subrange_v<_Ty>;

template <class _Ty>
concept _Tuple_like = _Tuple_like_impl<remove_cvref_t<_Ty>>;

template <class _Ty>
concept _Pair_like = _Tuple_like<_Ty> && tuple_size_v<remove_cvref_t<_Ty>> == 2;







#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

 template <class _Ty1, class _Ty2>
struct pair { 
    using first_type  = _Ty1;
    using second_type = _Ty2;

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_Uty1>, _Is_implicitly_default_constructible<_Uty2>>)
        pair() noexcept(
            is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>) 
        : first(), second() {}

    template <class _Uty1 = _Ty1, class _Uty2 = _Ty2,
        enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Uty1&, _Uty1>, is_convertible<const _Uty2&, _Uty2>>)
        pair(const _Ty1& _Val1, const _Ty2& _Val2) noexcept(
            is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>) 
        : first(_Val1), second(_Val2) {}


    template <class _Other1 = _Ty1, class _Other2 = _Ty2,


#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(_Other1&& _Val1, _Other2&& _Val2) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Val1)), second(::std:: forward<_Other2>(_Val2)) {
    }

    pair(const pair&) = default;
    pair(pair&&)      = default;


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1&>, is_constructible<_Ty2, _Other2&>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1&, _Ty1>, is_convertible<_Other2&, _Ty2>>)
        pair(pair<_Other1, _Other2>& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1&>&& is_nothrow_constructible_v<_Ty2, _Other2&>) 
        : first(_Right.first), second(_Right.second) {}
#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>,
            int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1&, _Ty1>, is_convertible<const _Other2&, _Ty2>>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1&>&&
                is_nothrow_constructible_v<_Ty2, const _Other2&>) 
        : first(_Right.first), second(_Right.second) {}

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
    constexpr explicit(!conjunction_v<is_convertible<_Other1, _Ty1>, is_convertible<_Other2, _Ty2>>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(
            is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>) 
        : first(::std:: forward<_Other1>(_Right.first)), second(::std:: forward<_Other2>(_Right.second)) {}


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1>, is_constructible<_Ty2, const _Other2>>, int> =
            0>
    constexpr explicit(!conjunction_v<is_convertible<const _Other1, _Ty1>, is_convertible<const _Other2, _Ty2>>)
        pair(const pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, const _Other1>&&
                is_nothrow_constructible_v<_Ty2, const _Other2>) 
        : first(::std:: forward<const _Other1>(_Right.first)), second(::std:: forward<const _Other2>(_Right.second)) {}





    template <_Pair_like _Other>
        requires conjunction_v<bool_constant<!_Is_subrange_v<remove_cvref_t<_Other>>>,
                     is_constructible<_Ty1, decltype(::std:: get<0>(::std:: declval<_Other>()))>,
                     is_constructible<_Ty2, decltype(::std:: get<1>(::std:: declval<_Other>()))>>
#line 298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
    constexpr explicit(!conjunction_v<is_convertible<decltype(::std:: get<0>(::std:: declval<_Other>())), _Ty1>,
                       is_convertible<decltype(::std:: get<1>(::std:: declval<_Other>())), _Ty2>>)
        pair(_Other&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, decltype(::std:: get<0>(::std:: declval<_Other>()))>&&
                is_nothrow_constructible_v<_Ty2, decltype(::std:: get<1>(::std:: declval<_Other>()))>) 
        : first(::std:: get<0>(::std:: forward<_Other>(_Right))), second(::std:: get<1>(::std:: forward<_Other>(_Right))) {
    }
#line 305 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 306 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    template <class _Tuple1, class _Tuple2, size_t... _Indices1, size_t... _Indices2>
    constexpr pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indices1...>, index_sequence<_Indices2...>)
        : first(_Tuple_get<_Indices1>(::std:: move(_Val1))...), second(_Tuple_get<_Indices2>(::std:: move(_Val2))...) {}

    template <class... _Types1, class... _Types2>
    constexpr pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
        : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

    pair& operator=(const volatile pair&) = delete;

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }


    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<const typename _Myself::first_type>,
                        _Is_copy_assignable_no_precondition_check<const typename _Myself::second_type>>,
            int>            = 0>
    constexpr const pair& operator=(_Identity_t<const _Myself&> _Right) const
        noexcept(conjunction_v<is_nothrow_copy_assignable<const _Ty1>,
            is_nothrow_copy_assignable<const _Ty2>>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>,
                        _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>,
            int>            = 0>
    constexpr pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)  {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }


    template <class _Myself = pair,
        enable_if_t<conjunction_v<_Is_assignable_no_precondition_check<const typename _Myself::first_type&, _Ty1>,
                        _Is_assignable_no_precondition_check<const typename _Myself::second_type&, _Ty2>>,
            int>            = 0>
    constexpr const pair& operator=(_Identity_t<_Myself&&> _Right) const
        noexcept(conjunction_v<is_nothrow_assignable<const _Ty1&, _Ty1>,
            is_nothrow_assignable<const _Ty2&, _Ty2>>)  {
        first  = ::std:: forward<_Ty1>(_Right.first);
        second = ::std:: forward<_Ty2>(_Right.second);
        return *this;
    }
#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>,
                        is_assignable<_Ty2&, const _Other2&>>,
            int> = 0>
    constexpr pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&&
            is_nothrow_assignable_v<_Ty2&, const _Other2&>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>,
                        is_assignable<const _Ty1&, const _Other1&>, is_assignable<const _Ty2&, const _Other2&>>,
            int> = 0>
    constexpr const pair& operator=(const pair<_Other1, _Other2>& _Right) const
        noexcept(is_nothrow_assignable_v<const _Ty1&, const _Other1&>&&
                is_nothrow_assignable_v<const _Ty2&, const _Other2&>)  {
        first  = _Right.first;
        second = _Right.second;
        return *this;
    }
#line 392 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>,
                        is_assignable<_Ty2&, _Other2>>,
            int> = 0>
    constexpr pair& operator=(pair<_Other1, _Other2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)  {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }


    template <class _Other1, class _Other2,
        enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<const _Ty1&, _Other1>,
                        is_assignable<const _Ty2&, _Other2>>,
            int> = 0>
    constexpr const pair& operator=(pair<_Other1, _Other2>&& _Right) const
        noexcept(is_nothrow_assignable_v<const _Ty1&, _Other1>&&
                is_nothrow_assignable_v<const _Ty2&, _Other2>)  {
        first  = ::std:: forward<_Other1>(_Right.first);
        second = ::std:: forward<_Other2>(_Right.second);
        return *this;
    }


    template <_Pair_like _Other>
        requires _Different_from<_Other, pair> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && is_assignable_v<_Ty1&, decltype(::std:: get<0>(::std:: declval<_Other>()))>
              && is_assignable_v<_Ty2&, decltype(::std:: get<1>(::std:: declval<_Other>()))>
    constexpr pair& operator=(_Other&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, decltype(::std:: get<0>(::std:: declval<_Other>()))>&&
            is_nothrow_assignable_v<_Ty2&, decltype(::std:: get<1>(::std:: declval<_Other>()))>)  {
        first  = ::std:: get<0>(::std:: forward<_Other>(_Right));
        second = ::std:: get<1>(::std:: forward<_Other>(_Right));
        return *this;
    }

    template <_Pair_like _Other>
        requires _Different_from<_Other, pair> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && is_assignable_v<const _Ty1&, decltype(::std:: get<0>(::std:: declval<_Other>()))>
              && is_assignable_v<const _Ty2&, decltype(::std:: get<1>(::std:: declval<_Other>()))>
    constexpr const pair& operator=(_Other&& _Right) const noexcept(
        is_nothrow_assignable_v<const _Ty1&, decltype(::std:: get<0>(::std:: declval<_Other>()))>&&
            is_nothrow_assignable_v<const _Ty2&, decltype(::std:: get<1>(::std:: declval<_Other>()))>)  {
        first  = ::std:: get<0>(::std:: forward<_Other>(_Right));
        second = ::std:: get<1>(::std:: forward<_Other>(_Right));
        return *this;
    }
#line 442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 443 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    constexpr void swap(pair& _Right) noexcept(
        _Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value) {
        using ::std:: swap;
        if (this != ::std:: addressof(_Right)) {
            swap(first, _Right.first); 
            swap(second, _Right.second); 
        }
    }


    template <int = 0> 
    constexpr void swap(const pair& _Right) const
        noexcept(is_nothrow_swappable_v<const _Ty1>&& is_nothrow_swappable_v<const _Ty2>) {
        using ::std:: swap;
        if (this != ::std:: addressof(_Right)) {
            swap(first, _Right.first); 
            swap(second, _Right.second); 
        }
    }
#line 464 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

    _Ty1 first; 
    _Ty2 second; 
};


template <class _Ty1, class _Ty2>
pair(_Ty1, _Ty2) -> pair<_Ty1, _Ty2>;
#line 473 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

 template <class _Ty1, class _Ty2,
    enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
constexpr void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class _Ty1, class _Ty2,
    enable_if_t<is_swappable_v<const _Ty1> && is_swappable_v<const _Ty2>, int> = 0>
constexpr void swap(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#line 488 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

 template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    return _Left.first == _Right.first && _Left.second == _Right.second;
}


 template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
[[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_Ty1, _Uty1>,
    _Synth_three_way_result<_Ty2, _Uty2>>
    operator<=>(const pair<_Ty1, _Ty2>& _Left, const pair<_Uty1, _Uty2>& _Right) {
    if (auto _Result = _Synth_three_way{}(_Left.first, _Right.first); _Result != 0) {
        return _Result;
    }
    return _Synth_three_way{}(_Left.second, _Right.second);
}



























#line 532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"


template <class _Ty1, class _Ty2, class _Uty1, class _Uty2, template <class> class _TQual,
    template <class> class _UQual>
    requires requires {
        typename pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
    }
struct basic_common_reference<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>, _TQual, _UQual> {
    using type = pair<common_reference_t<_TQual<_Ty1>, _UQual<_Uty1>>, common_reference_t<_TQual<_Ty2>, _UQual<_Uty2>>>;
};

template <class _Ty1, class _Ty2, class _Uty1, class _Uty2>
    requires requires { typename pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>; }
struct common_type<pair<_Ty1, _Ty2>, pair<_Uty1, _Uty2>> {
    using type = pair<common_type_t<_Ty1, _Uty1>, common_type_t<_Ty2, _Uty2>>;
};
#line 549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

template <class _Ty>
struct _Unrefwrap_helper { 
    using type = _Ty;
};

template <class _Ty>
struct _Unrefwrap_helper<reference_wrapper<_Ty>> { 
    using type = _Ty&;
};


template <class _Ty>
using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&&
        is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)  {
    
    using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
    return _Mypair(::std:: forward<_Ty1>(_Val1), ::std:: forward<_Ty2>(_Val2));
}

namespace [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] rel_ops {
     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left == _Right);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right) {
        return _Right < _Left;
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Right < _Left);
    }

     template <class _Ty>
    [[deprecated("warning STL4027: " "The namespace std::rel_ops and its contents are deprecated in C++20. " "Their use is superseded by C++20's <=> operator and automatic rewrites of relational expressions. " "You can define _SILENCE_CXX20_REL_OPS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right) {
        return !(_Left < _Right);
    }
} 

template <class _Tuple, class = void>
struct _Tuple_size_sfinae {}; 

template <class _Tuple>
struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value> {}; 

template <class _Tuple>
struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple> {}; 

template <size_t _Index, class _Tuple>
struct [[msvc::known_semantics]] tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_const_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_volatile_t<typename _Mybase::type>;
};

template <size_t _Index, class _Tuple>
struct [[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[msvc::known_semantics]] tuple_element<_Index, const volatile _Tuple>
    : tuple_element<_Index, _Tuple> {
    using _Mybase = tuple_element<_Index, _Tuple>;
    using type    = add_cv_t<typename _Mybase::type>;
};

template <class _Ty, size_t _Size>
struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size> {}; 

template <size_t _Idx, class _Ty, size_t _Size>
struct [[msvc::known_semantics]] tuple_element<_Idx, array<_Ty, _Size>> {
    static_assert(_Idx < _Size, "array index out of bounds");

    using type = _Ty;
};

template <class... _Types>
struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)> {}; 

template <size_t _Index>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<>> { 
    static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
};

template <class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<0, tuple<_This, _Rest...>> { 
    using type = _This;
    
    using _Ttype = tuple<_This, _Rest...>;
};

template <size_t _Index, class _This, class... _Rest>
struct [[msvc::known_semantics]] tuple_element<_Index, tuple<_This, _Rest...>>
    : tuple_element<_Index - 1, tuple<_Rest...>> {}; 

template <class _Ty1, class _Ty2>
struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2> {}; 

template <size_t _Idx, class _Ty1, class _Ty2>
struct [[msvc::known_semantics]] tuple_element<_Idx, pair<_Ty1, _Ty2>> {
    static_assert(_Idx < 2, "pair index out of bounds");

    using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
};

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return _Pr.first;
    } else {
        return _Pr.second;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.first;
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept {
    
    return _Pr.second;
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<_Ty1>(_Pr.first);
    } else {
        return ::std:: forward<_Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<_Ty2>(_Pr.second);
}

 template <size_t _Idx, class _Ty1, class _Ty2>
[[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    if constexpr (_Idx == 0) {
        return ::std:: forward<const _Ty1>(_Pr.first);
    } else {
        return ::std:: forward<const _Ty2>(_Pr.second);
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty1>(_Pr.first);
}

 template <class _Ty2, class _Ty1>
[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept {
    
    return ::std:: forward<const _Ty2>(_Pr.second);
}

 template <class _Ty, class _Other = _Ty>
constexpr _Ty exchange(_Ty& _Val, _Other&& _New_val) noexcept(
    conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {
    
    _Ty _Old_val = static_cast<_Ty&&>(_Val);
    _Val         = static_cast<_Other&&>(_New_val);
    return _Old_val;
}

 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept { 
    return _Val;
}

 template <class _Ty>
void as_const(const _Ty&&) = delete;


 struct in_place_t { 
    explicit in_place_t() = default;
};
 inline constexpr in_place_t in_place{};

 template <class>
struct in_place_type_t { 
    explicit in_place_type_t() = default;
};
 template <class _Ty>
inline constexpr in_place_type_t<_Ty> in_place_type{};

 template <size_t>
struct in_place_index_t { 
    explicit in_place_index_t() = default;
};
 template <size_t _Idx>
inline constexpr in_place_index_t<_Idx> in_place_index{};
#line 795 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"


template <class _Ty>
inline constexpr bool _Is_standard_integer = is_integral_v<_Ty>
                                          && !_Is_any_of_v<remove_cv_t<_Ty>, bool, char,

                                              wchar_t,
#line 803 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

                                              char8_t,
#line 806 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
                                              char16_t, char32_t>;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left == _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Left == static_cast<make_unsigned_t<_Ty2>>(_Right) && _Right >= 0;
    } else {
        return static_cast<make_unsigned_t<_Ty1>>(_Left) == _Right && _Left >= 0;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_not_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_equal(_Left, _Right);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    static_assert(_Is_standard_integer<_Ty1> && _Is_standard_integer<_Ty2>,
        "The integer comparison functions only accept standard and extended integer types.");
    if constexpr (is_signed_v<_Ty1> == is_signed_v<_Ty2>) {
        return _Left < _Right;
    } else if constexpr (is_signed_v<_Ty2>) {
        return _Right > 0 && _Left < static_cast<make_unsigned_t<_Ty2>>(_Right);
    } else {
        return _Left < 0 || static_cast<make_unsigned_t<_Ty1>>(_Left) < _Right;
    }
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return ::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_less_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Right, _Left);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool cmp_greater_equal(const _Ty1 _Left, const _Ty2 _Right) noexcept {
    return !::std:: cmp_less(_Left, _Right);
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Min_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>((_Unsigned_max >> 1) + 1); 
    } else {
        return 0;
    }
}

template <class _Ty>
[[nodiscard]] consteval _Ty _Max_limit() noexcept { 
    static_assert(_Is_standard_integer<_Ty>); 
    if constexpr (is_signed_v<_Ty>) {
        constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);
        return static_cast<_Ty>(_Unsigned_max >> 1);
    } else {
        return static_cast<_Ty>(-1);
    }
}

 template <class _Rx, class _Ty>
[[nodiscard]] constexpr bool in_range(const _Ty _Value) noexcept {
    static_assert(_Is_standard_integer<_Rx> && _Is_standard_integer<_Ty>,
        "The integer comparison functions only accept standard and extended integer types.");

    constexpr auto _Ty_min = _Min_limit<_Ty>();
    constexpr auto _Rx_min = _Min_limit<_Rx>();

    if constexpr (::std:: cmp_less(_Ty_min, _Rx_min)) {
        if (_Value < _Ty{_Rx_min}) {
            return false;
        }
    }

    constexpr auto _Ty_max = _Max_limit<_Ty>();
    constexpr auto _Rx_max = _Max_limit<_Rx>();

    if constexpr (::std:: cmp_greater(_Ty_max, _Rx_max)) {
        if (_Value > _Ty{_Rx_max}) {
            return false;
        }
    }

    return true;
}


template <class _Ty>
using _With_reference = _Ty&;

template <class _Ty>
concept _Can_reference = requires { typename _With_reference<_Ty>; };






#line 915 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 916 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"


 template <class _Ty>
[[nodiscard]] [[msvc::intrinsic]] constexpr underlying_type_t<_Ty> to_underlying(_Ty _Value) noexcept {
    return static_cast<underlying_type_t<_Ty>>(_Value);
}

 [[noreturn]] __forceinline void unreachable() noexcept  {
    __assume(false);



}

 template <class _Ty, class _Uty>
[[nodiscard]] [[msvc::intrinsic]] constexpr auto&& forward_like(_Uty&& _Ux) noexcept {
    static_assert(_Can_reference<_Ty>, "std::forward_like's first template argument must be a referenceable type.");

    using _UnrefT = remove_reference_t<_Ty>;
    using _UnrefU = remove_reference_t<_Uty>;
    if constexpr (is_const_v<_UnrefT>) {
        if constexpr (is_lvalue_reference_v<_Ty>) {
            return static_cast<const _UnrefU&>(_Ux);
        } else {
            return static_cast<const _UnrefU&&>(_Ux);
        }
    } else {
        if constexpr (is_lvalue_reference_v<_Ty>) {
            return static_cast<_UnrefU&>(_Ux);
        } else {
            return static_cast<_UnrefU&&>(_Ux);
        }
    }
}

template <class _Ty, class _Uty>
using _Forward_like_t = decltype(::std:: forward_like<_Ty>(::std:: declval<_Uty&>()));
#line 954 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"







#line 962 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"

}








#pragma warning(pop)
#pragma pack(pop)
#line 975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#line 976 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\utility"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_iter_core.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Ty, class _Alloc, class = void>
struct _Has_allocator_type : false_type {}; 

template <class _Ty, class _Alloc>
struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type {};

 struct allocator_arg_t { 
    explicit allocator_arg_t() = default;
};

 inline constexpr allocator_arg_t allocator_arg{};

 template <class _Ty, class _Alloc>
struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type {};

 template <class _Ty, class _Alloc>
inline constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;


 struct input_iterator_tag {};

 struct output_iterator_tag {};

 struct forward_iterator_tag : input_iterator_tag {};

 struct bidirectional_iterator_tag : forward_iterator_tag {};

 struct random_access_iterator_tag : bidirectional_iterator_tag {};


 struct contiguous_iterator_tag : random_access_iterator_tag {};

template <class _Ty>
concept _Dereferenceable = requires(_Ty& __t) {
    { *__t } -> _Can_reference;
};

template <class _Ty>
concept _Has_member_iterator_concept = requires { typename _Ty::iterator_concept; };

template <class _Ty>
concept _Has_member_iterator_category = requires { typename _Ty::iterator_category; };

template <class _Ty>
concept _Has_member_value_type = requires { typename _Ty::value_type; };

template <class _Ty>
concept _Has_member_element_type = requires { typename _Ty::element_type; };

template <class _Ty>
concept _Has_member_difference_type = requires { typename _Ty::difference_type; };

template <class _Ty>
concept _Has_member_pointer = requires { typename _Ty::pointer; };

template <class _Ty>
concept _Has_member_reference = requires { typename _Ty::reference; };

 template <class>
struct incrementable_traits {};

template <class _Ty>
    requires is_object_v<_Ty>
struct incrementable_traits<_Ty*> {
    using difference_type = ptrdiff_t;
};

template <class _Ty>
struct incrementable_traits<const _Ty> : incrementable_traits<_Ty> {};

template <_Has_member_difference_type _Ty>
struct incrementable_traits<_Ty> {
    using difference_type = typename _Ty::difference_type;
};

template <class _Ty>
concept _Can_difference = requires(const _Ty& __a, const _Ty& __b) {
    { __a - __b } -> integral;
};

template <class _Ty>
    requires (!_Has_member_difference_type<_Ty> && _Can_difference<_Ty>)
struct incrementable_traits<_Ty> {
    using difference_type = make_signed_t<decltype(::std:: declval<_Ty>() - ::std:: declval<_Ty>())>;
};

template <class _Ty>
concept _Is_from_primary = _Same_impl<typename _Ty::_From_primary, _Ty>;

 template <class>
struct iterator_traits;

 template <class _Ty>
using iter_difference_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    incrementable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::difference_type;

template <class>
struct _Cond_value_type {};

template <class _Ty>
    requires is_object_v<_Ty>
struct _Cond_value_type<_Ty> {
    using value_type = remove_cv_t<_Ty>;
};

 template <class>
struct indirectly_readable_traits {};

template <class _Ty>
struct indirectly_readable_traits<_Ty*> : _Cond_value_type<_Ty> {};

template <class _Ty>
    requires is_array_v<_Ty>
struct indirectly_readable_traits<_Ty> {
    using value_type = remove_cv_t<remove_extent_t<_Ty>>;
};

template <class _Ty>
struct indirectly_readable_traits<const _Ty> : indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

template <_Has_member_element_type _Ty>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::element_type> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
struct indirectly_readable_traits<_Ty> {};

template <_Has_member_value_type _Ty>
    requires _Has_member_element_type<_Ty>
          && same_as<remove_cv_t<typename _Ty::value_type>, remove_cv_t<typename _Ty::element_type>>
struct indirectly_readable_traits<_Ty> : _Cond_value_type<typename _Ty::value_type> {};

 template <class _Ty>
using iter_value_t = typename conditional_t<_Is_from_primary<iterator_traits<remove_cvref_t<_Ty>>>,
    indirectly_readable_traits<remove_cvref_t<_Ty>>, iterator_traits<remove_cvref_t<_Ty>>>::value_type;

 template <_Dereferenceable _Ty>
using iter_reference_t = decltype(*::std:: declval<_Ty&>());

template <class>
struct _Iterator_traits_base {};

template <class _It>
concept _Has_iter_types = _Has_member_difference_type<_It> && _Has_member_value_type<_It> && _Has_member_reference<_It>
                       && _Has_member_iterator_category<_It>;

template <bool _Has_member_typedef>
struct _Old_iter_traits_pointer {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Old_iter_traits_pointer<false> {
    template <class>
    using _Apply = void;
};

template <_Has_iter_types _It>
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _It::iterator_category;
    using value_type        = typename _It::value_type;
    using difference_type   = typename _It::difference_type;
    using pointer           = typename _Old_iter_traits_pointer<_Has_member_pointer<_It>>::template _Apply<_It>;
    using reference         = typename _It::reference;
};

template <bool _Has_member_typedef>
struct _Iter_traits_difference {
    template <class _It>
    using _Apply = typename incrementable_traits<_It>::difference_type;
};

template <>
struct _Iter_traits_difference<false> {
    template <class>
    using _Apply = void;
};


template <class _It>
concept _Cpp17_iterator =
    requires(_It __i) {
        { *__i } -> _Can_reference;
        { ++__i } -> same_as<_It&>;
        { *__i++ } -> _Can_reference;
    }
    && copyable<_It>;

template <class _It>
concept _Cpp17_input_iterator = _Cpp17_iterator<_It>
    && equality_comparable<_It>
    && _Has_member_difference_type<incrementable_traits<_It>>
    && _Has_member_value_type<indirectly_readable_traits<_It>>
    && requires(_It __i) {
        typename common_reference_t<iter_reference_t<_It>&&, typename indirectly_readable_traits<_It>::value_type&>;
        typename common_reference_t<decltype(*__i++)&&, typename indirectly_readable_traits<_It>::value_type&>;
        requires signed_integral<typename incrementable_traits<_It>::difference_type>;
    };

template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_iterator<_It> && !_Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = output_iterator_tag;
    using value_type = void;
    using difference_type =
        typename _Iter_traits_difference<_Has_member_difference_type<incrementable_traits<_It>>>::template _Apply<_It>;
    using pointer    = void;
    using reference  = void;
};


enum class _Itraits_pointer_strategy { _Use_void, _Use_member, _Use_decltype };

template <_Itraits_pointer_strategy>
struct _Iter_traits_pointer;

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_void> {
    template <class>
    using _Apply = void;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_member> {
    template <class _It>
    using _Apply = typename _It::pointer;
};

template <>
struct _Iter_traits_pointer<_Itraits_pointer_strategy::_Use_decltype> {
    template <class _It>
    using _Apply = decltype(::std:: declval<_It&>().operator->());
};

template <class _Ty>
concept _Has_member_arrow = requires(_Ty&& __t) { static_cast<_Ty&&>(__t).operator->(); };

template <bool _Has_member_typedef>
struct _Iter_traits_reference {
    template <class _It>
    using _Apply = typename _It::reference;
};

template <>
struct _Iter_traits_reference<false> {
    template <class _It>
    using _Apply = iter_reference_t<_It>;
};

template <bool _Is_random>
struct _Iter_traits_category4 {
    using type = random_access_iterator_tag;
};

template <>
struct _Iter_traits_category4<false> {
    using type = bidirectional_iterator_tag;
};


template <class _It>
concept _Cpp17_random_delta = totally_ordered<_It>
    && requires(_It __i, typename incrementable_traits<_It>::difference_type __n) {
        { __i += __n } -> same_as<_It&>;
        { __i -= __n } -> same_as<_It&>;
        { __i +  __n } -> same_as<_It>;
        { __n +  __i } -> same_as<_It>;
        { __i -  __n } -> same_as<_It>;
        { __i -  __i } -> same_as<decltype(__n)>;
        {  __i[__n]  } -> convertible_to<iter_reference_t<_It>>;
    };


template <bool _Is_bidi>
struct _Iter_traits_category3 {
    template <class _It>
    using _Apply = typename _Iter_traits_category4<_Cpp17_random_delta<_It>>::type;
};

template <>
struct _Iter_traits_category3<false> {
    template <class>
    using _Apply = forward_iterator_tag;
};

template <class _It>
concept _Cpp17_bidi_delta = requires(_It __i) {
    { --__i } -> same_as<_It&>;
    { __i-- } -> convertible_to<const _It&>;
    requires same_as<decltype(*__i--), iter_reference_t<_It>>;
};

template <bool _Is_forward>
struct _Iter_traits_category2 {
    template <class _It>
    using _Apply = typename _Iter_traits_category3<_Cpp17_bidi_delta<_It>>::template _Apply<_It>;
};

template <>
struct _Iter_traits_category2<false> {
    template <class>
    using _Apply = input_iterator_tag;
};


template <class _It>
concept _Cpp17_forward_delta = constructible_from<_It> && is_reference_v<iter_reference_t<_It>>
    && same_as<remove_cvref_t<iter_reference_t<_It>>, typename indirectly_readable_traits<_It>::value_type>
    && requires(_It __i) {
        { __i++ } -> convertible_to<const _It&>;
        requires same_as<decltype(*__i++), iter_reference_t<_It>>;
    };


template <bool _Has_member_typedef>
struct _Iter_traits_category {
    template <class _It>
    using _Apply = typename _It::iterator_category;
};

template <>
struct _Iter_traits_category<false> {
    template <class _It>
    using _Apply = typename _Iter_traits_category2<_Cpp17_forward_delta<_It>>::template _Apply<_It>;
};


template <class _It>
    requires (!_Has_iter_types<_It> && _Cpp17_input_iterator<_It>)
struct _Iterator_traits_base<_It> {
    using iterator_category = typename _Iter_traits_category<_Has_member_iterator_category<_It>>::template _Apply<_It>;
    using value_type        = typename indirectly_readable_traits<_It>::value_type;
    using difference_type   = typename incrementable_traits<_It>::difference_type;
    using pointer           = typename _Iter_traits_pointer<(
        _Has_member_pointer<_It> ? _Itraits_pointer_strategy::_Use_member
                                 : _Has_member_arrow<_It&> ? _Itraits_pointer_strategy::_Use_decltype
                                                       : _Itraits_pointer_strategy::_Use_void)>::template _Apply<_It>;
    using reference         = typename _Iter_traits_reference<_Has_member_reference<_It>>::template _Apply<_It>;
};


 template <class _Ty>
struct iterator_traits : _Iterator_traits_base<_Ty> {
    using _From_primary = iterator_traits;
};

template <class _Ty>
    requires is_object_v<_Ty>
struct iterator_traits<_Ty*> {
    using iterator_concept  = contiguous_iterator_tag;
    using iterator_category = random_access_iterator_tag;
    using value_type        = remove_cv_t<_Ty>;
    using difference_type   = ptrdiff_t;
    using pointer           = _Ty*;
    using reference         = _Ty&;
};

template <class _Ty>
inline constexpr bool _Integer_class = requires {
    typename _Ty::_Signed_type;
    typename _Ty::_Unsigned_type;
};

template <class _Ty>
concept _Integer_like = _Is_nonbool_integral<remove_cv_t<_Ty>> || _Integer_class<_Ty>;

template <class _Ty>
concept _Signed_integer_like = _Integer_like<_Ty> && static_cast<_Ty>(-1) < static_cast<_Ty>(0);


 template <class _Ty>
concept weakly_incrementable = movable<_Ty>
    && requires(_Ty __i) {
        typename iter_difference_t<_Ty>;
        requires _Signed_integer_like<iter_difference_t<_Ty>>;
        { ++__i } -> same_as<_Ty&>;
        __i++;
    }



    ;

 template <class _It>
concept input_or_output_iterator = requires(_It __i) { { *__i } -> _Can_reference; }
    && weakly_incrementable<_It>;

 template <class _Se, class _It>
concept sentinel_for = semiregular<_Se>
    && input_or_output_iterator<_It>
    && _Weakly_equality_comparable_with<_Se, _It>;


 template <class _Se, class _It>
inline constexpr bool disable_sized_sentinel_for = false;


 template <class _Se, class _It>
concept sized_sentinel_for = sentinel_for<_Se, _It>
    && !disable_sized_sentinel_for<remove_cv_t<_Se>, remove_cv_t<_It>>
    && requires(const _It& __i, const _Se& __s) {
        { __s - __i } -> same_as<iter_difference_t<_It>>;
        { __i - __s } -> same_as<iter_difference_t<_It>>;
    };


 struct default_sentinel_t {};

 inline constexpr default_sentinel_t default_sentinel{};

namespace ranges {
     enum class subrange_kind : bool { unsized, sized };

     template <input_or_output_iterator _It, sentinel_for<_It> _Se = _It,
        subrange_kind _Ki = sized_sentinel_for<_Se, _It> ? subrange_kind::sized : subrange_kind::unsized>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val);

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val);
} 

 using ranges::get;

template <class _It, class _Se, ranges::subrange_kind _Ki>
inline constexpr bool _Is_subrange_v<ranges::subrange<_It, _Se, _Ki>> = true;

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_size<ranges::subrange<_It, _Se, _Ki>> : integral_constant<size_t, 2> {};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<0, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _It;
};

template <class _It, class _Se, ranges::subrange_kind _Ki>
struct tuple_element<1, const ranges::subrange<_It, _Se, _Ki>> {
    using type = _Se;
};

































#line 513 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_iter_core.hpp"
}



#pragma warning(pop)
#pragma pack(pop)
#line 520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_iter_core.hpp"
#line 521 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_iter_core.hpp"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstring"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"







#pragma once




#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"










#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 60 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

    












#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

#line 77 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"





    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"





    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }

#line 115 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 121 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_memory.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 75 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 88 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 96 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

#line 98 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 261 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 269 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 333 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 341 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 

#line 347 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

#line 351 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 363 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
    
#line 367 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 376 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 391 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 399 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 422 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 428 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 451 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 456 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 469 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 476 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 524 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"





    
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );
    

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 585 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 592 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#line 593 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\string.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
#pragma warning(push)
#pragma warning(disable : 4995) 

 using :: size_t;
 using :: memchr;
 using :: memcmp;
 using :: memcpy;
 using :: memmove;
 using :: memset;
 using :: strcat;
 using :: strchr;
 using :: strcmp;
 using :: strcoll;
 using :: strcpy;
 using :: strcspn;
 using :: strerror;
 using :: strlen;
 using :: strncat;
 using :: strncmp;
 using :: strncpy;
 using :: strpbrk;
 using :: strrchr;
 using :: strspn;
 using :: strstr;
 using :: strtok;
 using :: strxfrm;

#pragma warning(pop)
}



#pragma warning(pop)
#pragma pack(pop)

#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstring"
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cstring"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




















#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"






#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


extern "C" {







__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
__declspec(noalias) void __cdecl __std_swap_ranges_trivially_swappable_noalias(
    void* _First1, void* _Last1, void* _First2) noexcept;

__declspec(noalias) size_t
    __stdcall __std_count_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
__declspec(noalias) size_t
    __stdcall __std_count_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_1(const void* _First, const void* _Last, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_2(const void* _First, const void* _Last, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_4(const void* _First, const void* _Last, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_8(const void* _First, const void* _Last, uint64_t _Val) noexcept;

const void* __stdcall __std_find_trivial_unsized_1(const void* _First, uint8_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_2(const void* _First, uint16_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_4(const void* _First, uint32_t _Val) noexcept;
const void* __stdcall __std_find_trivial_unsized_8(const void* _First, uint64_t _Val) noexcept;

const void* __stdcall __std_min_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_min_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;

const void* __stdcall __std_max_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
const void* __stdcall __std_max_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
}

template <class _Ty, class _TVal>
__declspec(noalias) size_t __std_count_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_count_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return __std_count_trivial_1(_First, _Last, static_cast<uint8_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 2) {
        return __std_count_trivial_2(_First, _Last, static_cast<uint16_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 4) {
        return __std_count_trivial_4(_First, _Last, static_cast<uint32_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 8) {
        return __std_count_trivial_8(_First, _Last, static_cast<uint64_t>(_Val));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty, class _TVal>
_Ty* __std_find_trivial_unsized(_Ty* _First, const _TVal _Val) noexcept {
    if constexpr (::std:: is_pointer_v<_TVal> || ::std:: is_null_pointer_v<_TVal>) {
        return __std_find_trivial_unsized(_First, reinterpret_cast<uintptr_t>(_Val));
    } else if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_1(_First, static_cast<uint8_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_2(_First, static_cast<uint16_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_4(_First, static_cast<uint32_t>(_Val))));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(
            static_cast<const _Ty*>(__std_find_trivial_unsized_8(_First, static_cast<uint64_t>(_Val))));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_min_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_min_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

template <class _Ty>
_Ty* __std_max_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    if constexpr (sizeof(_Ty) == 1) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_1(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 2) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_2(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_4(_First, _Last, _Signed)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return const_cast<_Ty*>(static_cast<const _Ty*>(__std_max_element_8(_First, _Last, _Signed)));
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }
}

#line 191 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

namespace std {

template <class _Ty>
struct _Get_first_parameter;

template <template <class, class...> class _Ty, class _First, class... _Rest>
struct _Get_first_parameter<_Ty<_First, _Rest...>> { 
    using type = _First;
};

template <class _Newfirst, class _Ty>
struct _Replace_first_parameter;

template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>> { 
    using type = _Ty<_Newfirst, _Rest...>;
};

template <class _Ty, class = void>
struct _Get_ptr_difference_type {
    using type = ptrdiff_t;
};

template <class _Ty>
struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class _Other, class = void>
struct _Get_rebind_alias {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

template <class _Ty, class _Other>
struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>> {
    using type = typename _Ty::template rebind<_Other>;
};








 template <class _Ty, class... _Types,
    void_t<decltype(::new(static_cast<void*>(::std:: declval<_Ty*>())) _Ty(::std:: declval<_Types>()...))>* = nullptr>
#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
constexpr _Ty* construct_at(_Ty* const _Location, _Types&&... _Args) noexcept(
    noexcept(::new(static_cast<void*>(_Location)) _Ty(::std:: forward<_Types>(_Args)...)))  {
    [[msvc::constexpr]] return ::new (static_cast<void*>(_Location)) _Ty(::std:: forward<_Types>(_Args)...);
}
#line 245 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Ty, class... _Types>
constexpr void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_constructible_v<_Ty, _Types...>) {

    if (::std:: is_constant_evaluated()) {
        ::std:: construct_at(::std:: addressof(_Obj), ::std:: forward<_Types>(_Args)...);
    } else
#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    {
        ::new (static_cast<void*>(::std:: addressof(_Obj))) _Ty(::std:: forward<_Types>(_Args)...);
    }
}

template <class _Ty>
void _Default_construct_in_place(_Ty& _Obj) noexcept(is_nothrow_default_constructible_v<_Ty>) {
    ::new (static_cast<void*>(::std:: addressof(_Obj))) _Ty;
}

template <class _Ty, class _Elem>
struct _Ptr_traits_base {
    using pointer         = _Ty;
    using element_type    = _Elem;
    using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

    template <class _Other>
    using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

    using _Reftype = conditional_t<is_void_v<_Elem>, char, _Elem>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept(
        noexcept(_Ty::pointer_to(_Val)))  { 
        return _Ty::pointer_to(_Val);
    }
};

template <class, class = void, class = void>
struct _Ptr_traits_sfinae_layer {};

template <class _Ty, class _Uty>
struct _Ptr_traits_sfinae_layer<_Ty, _Uty, void_t<typename _Get_first_parameter<_Ty>::type>>
    : _Ptr_traits_base<_Ty, typename _Get_first_parameter<_Ty>::type> {};

template <class _Ty>
struct _Ptr_traits_sfinae_layer<_Ty, void_t<typename _Ty::element_type>, void>
    : _Ptr_traits_base<_Ty, typename _Ty::element_type> {};

 template <class _Ty>
struct pointer_traits : _Ptr_traits_sfinae_layer<_Ty> {};

template <class _Ty>
struct pointer_traits<_Ty*> {
    using pointer         = _Ty*;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    template <class _Other>
    using rebind = _Other*;

    using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

    [[nodiscard]] static constexpr pointer pointer_to(_Reftype _Val) noexcept {
        return ::std:: addressof(_Val);
    }
};



template <class _Ty>
concept _Has_to_address = requires(const _Ty& _Val) {
    typename pointer_traits<_Ty>;
    pointer_traits<_Ty>::to_address(_Val);
};







#line 326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Ty>
[[nodiscard]] constexpr _Ty* to_address(_Ty* const _Val) noexcept {
    static_assert(!is_function_v<_Ty>, "N4950 [pointer.conversion]/1: Mandates: T is not a function type.");
    return _Val;
}

 template <class _Ptr>
[[nodiscard]] constexpr auto to_address(const _Ptr& _Val) noexcept {
    if constexpr (_Has_to_address<_Ptr>) {
        return pointer_traits<_Ptr>::to_address(_Val);
    } else {
        return ::std:: to_address(_Val.operator->()); 
    }
}

 struct identity {
    template <class _Ty>
    [[nodiscard]] constexpr _Ty&& operator()(_Ty&& _Left) const noexcept {
        return ::std:: forward<_Ty>(_Left);
    }

    using is_transparent = int;
};
#line 351 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Ty = void>
struct plus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left + _Right;
    }
};

 template <class _Ty = void>
struct minus {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left - _Right;
    }
};

 template <class _Ty = void>
struct multiplies {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = _Ty;

    [[nodiscard]] constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const {
        return _Left * _Right;
    }
};

 template <class _Ty = void>
struct equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left == _Right)))  {
        return _Left == _Right;
    }
};

 template <class _Ty = void>
struct not_equal_to {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left != _Right)))  {
        return _Left != _Right;
    }
};

 template <class _Ty = void>
struct greater {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left > _Right)))  {
        return _Left > _Right;
    }
};

 template <class _Ty = void>
struct greater_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left >= _Right)))  {
        return _Left >= _Right;
    }
};

 template <class _Ty = void>
struct less_equal {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = _Ty;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = _Ty;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Left <= _Right)))  {
        return _Left <= _Right;
    }
};

template <>
struct plus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct minus<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct multiplies<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct not_equal_to<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct greater_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <>
struct less_equal<void> {
    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))) 
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)) {
        return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
    }

    using is_transparent = int;
};

template <class _Fx>
struct _Ref_fn { 
    template <class... _Args>
    constexpr decltype(auto) operator()(_Args&&... _Vals) { 
        if constexpr (is_member_pointer_v<_Fx>) {
            return ::std:: invoke(_Fn, ::std:: forward<_Args>(_Vals)...);
        } else {
            return _Fn(::std:: forward<_Args>(_Vals)...);
        }
    }

    _Fx& _Fn;
};

template <class _Fn>
[[nodiscard]] constexpr auto _Pass_fn(_Fn& _Func) noexcept {
    constexpr bool _Pass_by_value = conjunction_v<bool_constant<sizeof(_Fn) <= sizeof(void*)>,
        is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;
    if constexpr (_Pass_by_value) {
        return _Func;
    } else {
        return _Ref_fn<_Fn>{_Func}; 
    }
}


 template <class _Result_type, class _Callable, class... _Types,
    enable_if_t<is_invocable_r_v<_Result_type, _Callable, _Types...>, int> = 0>
[[nodiscard]] constexpr _Result_type invoke_r(_Callable&& _Obj, _Types&&... _Args) noexcept(
    is_nothrow_invocable_r_v<_Result_type, _Callable, _Types...>) {
    if constexpr (is_void_v<_Result_type>) {
        (void) ::std:: invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
    } else {
        return ::std:: invoke(static_cast<_Callable&&>(_Obj), static_cast<_Types&&>(_Args)...);
    }
}
#line 578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

struct _Unused_parameter { 
    constexpr _Unused_parameter() noexcept = default;
    template <class _Ty>
    constexpr _Unused_parameter(_Ty&&) noexcept {}
};

template <class _Ty>
using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;


template <class _Ty>
concept _Destructible_object = is_object_v<_Ty> && destructible<_Ty>;

template <template <class...> class _Template, class... _Args>
void _Derived_from_specialization_impl(const _Template<_Args...>&);

template <class _Ty, template <class...> class _Template>
concept _Derived_from_specialization_of = requires(const _Ty& _Obj) {
    ::std:: _Derived_from_specialization_impl<_Template>(_Obj); 
};

namespace ranges {
    namespace _Iter_move {


#line 605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void iter_move();
#line 607 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        
        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty&& __t) {
            iter_move(static_cast<_Ty&&>(__t)); 
        };

        template <class _Ty>
        concept _Can_deref = requires(_Ty&& __t) {
            *static_cast<_Ty&&>(__t);
        };
        

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Fallback };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Custom, noexcept(iter_move(::std:: declval<_Ty>()))}; 
                } else if constexpr (_Can_deref<_Ty>) {
                    return {_St::_Fallback, noexcept(*::std:: declval<_Ty>())};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty>._Strategy != _St::_None)
            [[nodiscard]] constexpr decltype(auto) operator()(_Ty&& _Val) const noexcept(_Choice<_Ty>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    return iter_move(static_cast<_Ty&&>(_Val)); 
                } else if constexpr (_Strat == _St::_Fallback) {
                    using _Ref = decltype(*static_cast<_Ty&&>(_Val));
                    if constexpr (is_lvalue_reference_v<_Ref>) {
                        return ::std:: move(*static_cast<_Ty&&>(_Val));
                    } else {
                        return *static_cast<_Ty&&>(_Val);
                    }
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_move::_Cpo iter_move;
    }
} 




 template <class _Ty>
    requires _Dereferenceable<_Ty> && requires(_Ty& __t) {
        { ::std::ranges:: iter_move(__t) } -> _Can_reference;
    }
using iter_rvalue_reference_t = decltype(::std::ranges:: iter_move(::std:: declval<_Ty&>()));


template <class _It>
concept _Indirectly_readable_impl =
    requires(const _It __i) {
        typename iter_value_t<_It>;
        typename iter_reference_t<_It>;
        typename iter_rvalue_reference_t<_It>;
        { *__i } -> same_as<iter_reference_t<_It>>;
        { ::std::ranges:: iter_move(__i) } -> same_as<iter_rvalue_reference_t<_It>>;
    } && common_reference_with<iter_reference_t<_It>&&, iter_value_t<_It>&>
    && common_reference_with<iter_reference_t<_It>&&, iter_rvalue_reference_t<_It>&&>
    && common_reference_with<iter_rvalue_reference_t<_It>&&, const iter_value_t<_It>&>;

 template <class _It>
concept indirectly_readable = _Indirectly_readable_impl<remove_cvref_t<_It>>;

template <class _Ty>
struct _Indirect_value_impl {
    using type = iter_value_t<_Ty>&;
};

template <indirectly_readable _It>
using _Indirect_value_t = _Indirect_value_impl<_It>::type;

 template <indirectly_readable _Ty>
using iter_common_reference_t = common_reference_t<iter_reference_t<_Ty>, _Indirect_value_t<_Ty>>;

 template <class _It, class _Ty>
concept indirectly_writable = requires(_It&& __i, _Ty&& __t) {
    *__i                                                                = static_cast<_Ty&&>(__t);
    *static_cast<_It&&>(__i)                                            = static_cast<_Ty&&>(__t);
    const_cast<const iter_reference_t<_It>&&>(*__i)                     = static_cast<_Ty&&>(__t);
    const_cast<const iter_reference_t<_It>&&>(*static_cast<_It&&>(__i)) = static_cast<_Ty&&>(__t);
};

template <bool _Is_integer_class>
struct _Make_unsigned_like_impl {
    template <class _Ty>
    using _Apply = _Ty::_Unsigned_type;
};
template <>
struct _Make_unsigned_like_impl<false> {
    template <class _Ty>
    using _Apply = make_unsigned_t<_Ty>;
};

template <class _Ty>
using _Make_unsigned_like_t = _Make_unsigned_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

template <_Integer_like _Ty>
[[nodiscard]] constexpr auto _To_unsigned_like(const _Ty _Value) noexcept {
    return static_cast<_Make_unsigned_like_t<_Ty>>(_Value);
}

template <bool _Is_integer_class>
struct _Make_signed_like_impl {
    template <class _Ty>
    using _Apply = _Ty::_Signed_type;
};
template <>
struct _Make_signed_like_impl<false> {
    template <class _Ty>
    using _Apply = make_signed_t<_Ty>;
};

template <class _Ty>
using _Make_signed_like_t = _Make_signed_like_impl<_Integer_class<_Ty>>::template _Apply<_Ty>;

 template <class _Ty>
concept incrementable = regular<_Ty> && weakly_incrementable<_Ty> && requires(_Ty __t) {
    { __t++ } -> same_as<_Ty>;
};

template <bool _Iterator_category_present>
struct _Iter_concept_impl2 {
    template <class _It, class _Traits>
    using _Apply = _Traits::iterator_category;
};
template <>
struct _Iter_concept_impl2<false> {
    template <class _It, class _Traits>
        requires _Is_from_primary<iterator_traits<_It>>
    using _Apply = random_access_iterator_tag;
};

template <bool _Iterator_concept_present>
struct _Iter_concept_impl1 {
    template <class _It, class _Traits>
    using _Apply = _Traits::iterator_concept;
};
template <>
struct _Iter_concept_impl1<false> {
    template <class _It, class _Traits>
    using _Apply = _Iter_concept_impl2<_Has_member_iterator_category<_Traits>>::template _Apply<_It, _Traits>;
};

template <class _It, class _Traits = conditional_t<_Is_from_primary<iterator_traits<_It>>, _It, iterator_traits<_It>>>
using _Iter_concept = _Iter_concept_impl1<_Has_member_iterator_concept<_Traits>>::template _Apply<_It, _Traits>;


 template <class _It>
concept input_iterator = input_or_output_iterator<_It> && indirectly_readable<_It>
    && requires { typename _Iter_concept<_It>; }
    && derived_from<_Iter_concept<_It>, input_iterator_tag>;

 template <class _It, class _Ty>
concept output_iterator = input_or_output_iterator<_It> && indirectly_writable<_It, _Ty>
    && requires(_It __i, _Ty&& __t) {
        *__i++ = static_cast<_Ty&&>(__t);
    };

 template <class _It>
concept forward_iterator = input_iterator<_It> && derived_from<_Iter_concept<_It>, forward_iterator_tag>
    && incrementable<_It> && sentinel_for<_It, _It>;

 template <class _It>
concept bidirectional_iterator = forward_iterator<_It> && derived_from<_Iter_concept<_It>, bidirectional_iterator_tag>
    && requires(_It __i) {
        { --__i } -> same_as<_It&>;
        { __i-- } -> same_as<_It>;
    };

 template <class _It>
concept random_access_iterator = bidirectional_iterator<_It>
    && derived_from<_Iter_concept<_It>, random_access_iterator_tag> && totally_ordered<_It>
    && sized_sentinel_for<_It, _It> && requires(_It __i, const _It __j, const iter_difference_t<_It> __n) {
        { __i += __n } -> same_as<_It&>;
        { __j + __n } -> same_as<_It>;
        { __n + __j } -> same_as<_It>;
        { __i -= __n } -> same_as<_It&>;
        { __j - __n } -> same_as<_It>;
        { __j[__n] } -> same_as<iter_reference_t<_It>>;
    };

 template <class _It>
concept contiguous_iterator = random_access_iterator<_It>
    && derived_from<_Iter_concept<_It>, contiguous_iterator_tag>
    && is_lvalue_reference_v<iter_reference_t<_It>>
    && same_as<iter_value_t<_It>, remove_cvref_t<iter_reference_t<_It>>>
    && requires(const _It& __i) {
        { ::std:: to_address(__i) } -> same_as<add_pointer_t<iter_reference_t<_It>>>;
    };


 template <class _Fn, class _It>
concept indirectly_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fn> && invocable<_Fn&, _Indirect_value_t<_It>>
    && invocable<_Fn&, iter_reference_t<_It>> && invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirectly_regular_unary_invocable =
    indirectly_readable<_It> && copy_constructible<_Fn> && regular_invocable<_Fn&, _Indirect_value_t<_It>>
    && regular_invocable<_Fn&, iter_reference_t<_It>> && regular_invocable<_Fn&, iter_common_reference_t<_It>>
    && common_reference_with<invoke_result_t<_Fn&, _Indirect_value_t<_It>>,
        invoke_result_t<_Fn&, iter_reference_t<_It>>>;

 template <class _Fn, class _It>
concept indirect_unary_predicate =
    indirectly_readable<_It> && copy_constructible<_Fn> && predicate<_Fn&, _Indirect_value_t<_It>>
    && predicate<_Fn&, iter_reference_t<_It>> && predicate<_Fn&, iter_common_reference_t<_It>>;

 template <class _Fn, class _It1, class _It2>
concept indirect_binary_predicate = indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
                                 && predicate<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
                                 && predicate<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
                                 && predicate<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
                                 && predicate<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
                                 && predicate<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_equivalence_relation =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
    && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
    && equivalence_relation<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
    && equivalence_relation<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && equivalence_relation<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class _It1, class _It2 = _It1>
concept indirect_strict_weak_order =
    indirectly_readable<_It1> && indirectly_readable<_It2> && copy_constructible<_Fn>
    && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, _Indirect_value_t<_It2>>
    && strict_weak_order<_Fn&, _Indirect_value_t<_It1>, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, _Indirect_value_t<_It2>>
    && strict_weak_order<_Fn&, iter_reference_t<_It1>, iter_reference_t<_It2>>
    && strict_weak_order<_Fn&, iter_common_reference_t<_It1>, iter_common_reference_t<_It2>>;

 template <class _Fn, class... _Its>
    requires (indirectly_readable<_Its> && ...) && invocable<_Fn, iter_reference_t<_Its>...>
using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Its>...>;

template <class _It>
struct _Projected_difference_type_impl {
    struct _Base {};
};

template <weakly_incrementable _It>
struct _Projected_difference_type_impl<_It> {
    struct _Base {
        using difference_type = iter_difference_t<_It>;
    };
};

template <class _It, class _Proj>
struct _Projected_impl {
    struct _Type : _Projected_difference_type_impl<_It>::_Base {
        using _Iterator   = _It;
        using _Projection = _Proj;

        using value_type = remove_cvref_t<indirect_result_t<_Proj&, _It>>;
        [[noreturn]] indirect_result_t<_Proj&, _It> operator*() const {
            :: abort(); 
        }
    };
};

 template <indirectly_readable _It, indirectly_regular_unary_invocable<_It> _Proj>
using projected = _Projected_impl<_It, _Proj>::_Type;

template <class _Ty>
concept _Projected_specialization = same_as<_Ty, projected<typename _Ty::_Iterator, typename _Ty::_Projection>>;

template <_Projected_specialization _ProjTy>
struct _Indirect_value_impl<_ProjTy> {
    using type = invoke_result_t<typename _ProjTy::_Projection&, _Indirect_value_t<typename _ProjTy::_Iterator>>;
};

 template <class _In, class _Out>
concept indirectly_movable = indirectly_readable<_In> && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_movable_storable = indirectly_movable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>>
    && movable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In> >;


 template <class _In, class _Out>
concept indirectly_copyable = indirectly_readable<_In> && indirectly_writable<_Out, iter_reference_t<_In>>;


 template <class _In, class _Out>
concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
    && indirectly_writable<_Out, iter_value_t<_In>&>
    && indirectly_writable<_Out, const iter_value_t<_In>&>
    && indirectly_writable<_Out, iter_value_t<_In>&&>
    && indirectly_writable<_Out, const iter_value_t<_In>&&>
    && copyable<iter_value_t<_In>>
    && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
    && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;


namespace ranges {
    namespace _Iter_swap {
        template <class _Ty1, class _Ty2>
        void iter_swap(_Ty1, _Ty2) = delete;

        
        template <class _Ty1, class _Ty2>
        concept _Has_ADL = (_Has_class_or_enum_type<_Ty1> || _Has_class_or_enum_type<_Ty2>)
            && requires(_Ty1&& __t1, _Ty2&& __t2) {
                iter_swap(static_cast<_Ty1&&>(__t1), static_cast<_Ty2&&>(__t2)); 
            };

        template <class _Ty1, class _Ty2>
        concept _Can_swap_references = indirectly_readable<remove_reference_t<_Ty1>>
            && indirectly_readable<remove_reference_t<_Ty2>>
            && swappable_with<iter_reference_t<_Ty1>, iter_reference_t<_Ty2>>;

        template <class _Ty1, class _Ty2>
        concept _Symmetric_indirectly_movable_storable =
               indirectly_movable_storable<remove_reference_t<_Ty1>, remove_reference_t<_Ty2>>
            && indirectly_movable_storable<remove_reference_t<_Ty2>, remove_reference_t<_Ty1>>;
        

        template <class _Xty, class _Yty>
        [[nodiscard]] constexpr iter_value_t<remove_reference_t<_Xty>> _Iter_exchange_move(_Xty&& _XVal,
            _Yty&& _YVal) noexcept(noexcept(iter_value_t<remove_reference_t<_Xty>>(::std::ranges:: iter_move(_XVal)))) {
            iter_value_t<remove_reference_t<_Xty>> _Tmp(::std::ranges:: iter_move(_XVal));
            *_XVal = ::std::ranges:: iter_move(_YVal);
            return _Tmp;
        }

        class _Cpo {
        private:
            enum class _St { _None, _Custom, _Swap, _Exchange };

            template <class _Ty1, class _Ty2>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                if constexpr (_Has_ADL<_Ty1, _Ty2>) {
                    return {_St::_Custom,
                        noexcept(iter_swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))}; 
                } else if constexpr (_Can_swap_references<_Ty1, _Ty2>) {
                    return {_St::_Swap, noexcept(::std::ranges:: swap(*::std:: declval<_Ty1>(), *::std:: declval<_Ty2>()))};
                } else if constexpr (_Symmetric_indirectly_movable_storable<_Ty1, _Ty2>) {
                    constexpr auto _Nothrow = noexcept(*::std:: declval<_Ty1>() = _Iter_swap::_Iter_exchange_move(
                                                           ::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));
                    return {_St::_Exchange, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty1, class _Ty2>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty1, _Ty2>();

        public:
            template <class _Ty1, class _Ty2>
                requires (_Choice<_Ty1, _Ty2>._Strategy != _St::_None)
            constexpr void operator()(_Ty1&& _Val1, _Ty2&& _Val2) const noexcept(_Choice<_Ty1, _Ty2>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty1, _Ty2>._Strategy;

                if constexpr (_Strat == _St::_Custom) {
                    (void) iter_swap(static_cast<_Ty1&&>(_Val1), static_cast<_Ty2&&>(_Val2)); 
                } else if constexpr (_Strat == _St::_Swap) {
                    ::std::ranges:: swap(*static_cast<_Ty1&&>(_Val1), *static_cast<_Ty2&&>(_Val2));
                } else if constexpr (_Strat == _St::_Exchange) {
                    *static_cast<_Ty1&&>(_Val1) =
                        _Iter_swap::_Iter_exchange_move(static_cast<_Ty2&&>(_Val2), static_cast<_Ty1&&>(_Val1));
                } else {
                    static_assert(_Always_false<_Ty1>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Iter_swap::_Cpo iter_swap;
    }
} 


 template <class _It1, class _It2 = _It1>
concept indirectly_swappable = indirectly_readable<_It1> && indirectly_readable<_It2>
    && requires(const _It1 __i1, const _It2 __i2) {
        ::std::ranges:: iter_swap(__i1, __i1);
        ::std::ranges:: iter_swap(__i2, __i2);
        ::std::ranges:: iter_swap(__i1, __i2);
        ::std::ranges:: iter_swap(__i2, __i1);
    };


 template <class _It1, class _It2, class _Rel, class _Proj1 = identity, class _Proj2 = identity>
concept indirectly_comparable = indirect_binary_predicate<_Rel, projected<_It1, _Proj1>, projected<_It2, _Proj2>>;

 template <class _It>
concept permutable = forward_iterator<_It> && indirectly_movable_storable<_It, _It> && indirectly_swappable<_It, _It>;

namespace ranges {
     struct less;
} 

 template <class _It1, class _It2, class _Out, class _Pr = ranges::less, class _Pj1 = identity,
    class _Pj2 = identity>
concept mergeable =
    input_iterator<_It1> && input_iterator<_It2> && weakly_incrementable<_Out> && indirectly_copyable<_It1, _Out>
    && indirectly_copyable<_It2, _Out> && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>;

 template <class _It, class _Pr = ranges::less, class _Proj = identity>
concept sortable = permutable<_It> && indirect_strict_weak_order<_Pr, projected<_It, _Proj>>;

template <class _Iter>
using _Iter_ref_t = iter_reference_t<_Iter>;

template <class _Iter>
using _Iter_value_t = iter_value_t<_Iter>;

template <class _Iter>
using _Iter_diff_t = iter_difference_t<_Iter>;













#line 1061 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class... _Iters>
using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

template <class _Iter>
using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

template <class _Ty, class = void>
inline constexpr bool _Is_iterator_v = false;

template <class _Ty>
inline constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

template <class _Ty>
struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>> {};

template <class _Iter>
inline constexpr bool _Is_cpp17_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_input_iter_v =

    (input_iterator<_Iter> && sentinel_for<_Iter, _Iter>) ||
#line 1085 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    _Is_cpp17_input_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_fwd_iter_v =

    forward_iterator<_Iter> ||
#line 1095 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    _Is_cpp17_fwd_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_bidi_iter_v =

    bidirectional_iterator<_Iter> ||
#line 1105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    _Is_cpp17_bidi_iter_v<_Iter>;

template <class _Iter>
inline constexpr bool _Is_cpp17_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

template <class _Iter>
inline constexpr bool _Is_ranges_random_iter_v =

    random_access_iterator<_Iter> ||
#line 1115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    _Is_cpp17_random_iter_v<_Iter>;









template <class, class = void>
struct _Is_checked_helper {}; 







#line 1135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Iter, class = void>
inline constexpr bool _Allow_inheriting_unwrap_v = true;

template <class _Iter>
inline constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> =
    is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

template <class _Iter, class _Sentinel = _Iter, class = void>
inline constexpr bool _Range_verifiable_v = false;

template <class _Iter, class _Sentinel>
inline constexpr bool _Range_verifiable_v<_Iter, _Sentinel,
    void_t<decltype(_Verify_range(::std:: declval<const _Iter&>(), ::std:: declval<const _Sentinel&>()))>> =
    _Allow_inheriting_unwrap_v<_Iter>;

template <class _Iter, class _Sentinel>
constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {
    
    if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
        _Verify_range(_First, _Last);
    }
}

template <class _Iter, class = void>
inline constexpr bool _Unwrappable_v = false;

template <class _Iter>
inline constexpr bool _Unwrappable_v<_Iter,
    void_t<decltype(::std:: declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std:: declval<_Iter>()._Unwrapped()))>> =
    _Allow_inheriting_unwrap_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class = void>
inline constexpr bool _Has_nothrow_unwrapped = false;
template <class _Iter>
inline constexpr bool _Has_nothrow_unwrapped<_Iter, void_t<decltype(::std:: declval<_Iter>()._Unwrapped())>> =
    noexcept(::std:: declval<_Iter>()._Unwrapped());

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) noexcept(
    !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std:: declval<_Iter>()))>;

template <class _Iter, class = bool>
inline constexpr bool _Do_unwrap_when_unverified_v = false;

template <class _Iter>
inline constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> =
        static_cast<bool>(_Iter::_Unwrap_when_unverified);

template <class _Iter>
inline constexpr bool _Unwrappable_for_unverified_v =
    _Unwrappable_v<_Iter> && _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

template <class _Iter>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {
    
    if constexpr (is_pointer_v<decay_t<_Iter>>) { 
        return _It + 0;
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter>
using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std:: declval<_Iter>()))>;

struct _Distance_unknown {
    constexpr _Distance_unknown operator-() const noexcept {
        return {};
    }
};

template <class _Diff>
inline constexpr _Diff _Max_possible_v{static_cast<_Make_unsigned_like_t<_Diff>>(-1) >> 1};

template <class _Diff>
inline constexpr _Diff _Min_possible_v{-_Max_possible_v<_Diff> - 1};

template <class _Iter, class = void>
inline constexpr bool _Offset_verifiable_v = false;

template <class _Iter>
inline constexpr bool
    _Offset_verifiable_v<_Iter, void_t<decltype(::std:: declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> =
        true;

template <class _Iter>
inline constexpr bool _Unwrappable_for_offset_v =
    _Unwrappable_v<_Iter> && _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

template <class _Iter, class _Diff>
[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off) {
    if constexpr (is_pointer_v<decay_t<_Iter>>) {
        return _It + 0;
    } else if constexpr (_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>) {
        
        using _IDiff     = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
        using _CDiff     = common_type_t<_Diff, _IDiff>;
        const auto _COff = static_cast<_CDiff>(_Off);

        ;
#line 1253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        (void) _COff;

        _It._Verify_offset(static_cast<_IDiff>(_Off));
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
        
        return static_cast<_Iter&&>(_It)._Unwrapped();
    } else {
        
        return static_cast<_Iter&&>(_It);
    }
}

template <class _Iter, class _UIter, class = void>
inline constexpr bool _Wrapped_seekable_v = false;

template <class _Iter, class _UIter>
inline constexpr bool
    _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std:: declval<_Iter&>()._Seek_to(::std:: declval<_UIter>()))>> =
        true;

template <class _Iter, class _UIter>
constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {
    if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
        _It._Seek_to(::std:: forward<_UIter>(_UIt));
    } else {
        _It = ::std:: forward<_UIter>(_UIt);
    }
}


template <class _Ty, class = void>
struct _Is_allocator : false_type {}; 

template <class _Ty>
struct _Is_allocator<_Ty, void_t<typename _Ty::value_type, decltype(::std:: declval<_Ty&>().deallocate(
                                                               ::std:: declval<_Ty&>().allocate(size_t{1}), size_t{1}))>>
    : true_type {}; 


template <class _Iter>
using _Guide_key_t =

    remove_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>;


#line 1300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Iter>
using _Guide_val_t =

    tuple_element_t<1, typename iterator_traits<_Iter>::value_type>;


#line 1308 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Iter>
using _Guide_pair_t =

    pair<add_const_t<tuple_element_t<0, typename iterator_traits<_Iter>::value_type>>,
        tuple_element_t<1, typename iterator_traits<_Iter>::value_type>>;



#line 1318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Ty>
struct is_execution_policy : false_type {};

 template <class _Ty>
inline constexpr bool is_execution_policy_v = is_execution_policy<_Ty>::value;



template <class _ExPo>
using _Enable_if_execution_policy_t = typename remove_reference_t<_ExPo>::_Standard_execution_policy;




#line 1334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Checked, class _Iter>
[[nodiscard]] constexpr auto _Idl_distance(const _Iter& _First, const _Iter& _Last) {
    
    if constexpr (_Is_ranges_random_iter_v<_Iter>) {
        return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
    } else {
        return _Distance_unknown{};
    }
}

template <class _Elem, bool _Is_enum = is_enum_v<_Elem>>
struct _Unwrap_enum { 
    using type = underlying_type_t<_Elem>;
};

template <class _Elem>
struct _Unwrap_enum<_Elem, false> { 
    using type = _Elem;
};

template <class _Elem>
using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;



















































#line 1409 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


 template <class _InIt, class _Diff>
constexpr void advance(_InIt& _Where, _Diff _Off) { 
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        _Where += _Off;
    } else {
        if constexpr (is_signed_v<_Diff> && !_Is_ranges_bidi_iter_v<_InIt>) {
            ;
        }

        decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
        constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

        if constexpr (is_signed_v<_Diff> && _Is_ranges_bidi_iter_v<_InIt>) {
            for (; _Off < 0; ++_Off) {
                --_UWhere;
            }
        }

        for (; 0 < _Off; --_Off) {
            ++_UWhere;
        }

        if constexpr (_Need_rewrap) {
            _Seek_wrapped(_Where, ::std:: move(_UWhere));
        }
    }
}

 template <class _InIt>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {
    if constexpr (_Is_ranges_random_iter_v<_InIt>) {
        return _Last - _First; 
    } else {
        _Adl_verify_range(_First, _Last);
        auto _UFirst             = _Get_unwrapped(_First);
        const auto _ULast        = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Off = 0;
        for (; _UFirst != _ULast; ++_UFirst) {
            ++_Off;
        }

        return _Off;
    }
}

template <class _InIt>
constexpr _InIt _Next_iter(_InIt _First) { 
    return ++_First;
}

 template <class _InIt>
[[nodiscard]] constexpr _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1) { 
    static_assert(_Is_ranges_input_iter_v<_InIt>, "next requires input iterator");

    ::std:: advance(_First, _Off);
    return _First;
}

template <class _BidIt>
constexpr _BidIt _Prev_iter(_BidIt _First) { 
    return --_First;
}

 template <class _BidIt>
[[nodiscard]] constexpr _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1) { 
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

    ::std:: advance(_First, -_Off);
    return _First;
}

template <class _Iter, class _Pointer, bool = is_pointer_v<_Remove_cvref_t<_Iter>>>
inline constexpr bool _Has_nothrow_operator_arrow = _Is_nothrow_convertible_v<_Iter, _Pointer>;

template <class _Iter, class _Pointer>
inline constexpr bool _Has_nothrow_operator_arrow<_Iter, _Pointer, false> =
    noexcept(_Fake_copy_init<_Pointer>(::std:: declval<_Iter>().operator->()));

 template <class _BidIt>
class reverse_iterator {
public:
    using iterator_type = _BidIt;


    using iterator_concept =
        conditional_t<random_access_iterator<_BidIt>, random_access_iterator_tag, bidirectional_iterator_tag>;
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_BidIt>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_BidIt>>;


#line 1502 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    using value_type      = _Iter_value_t<_BidIt>;
    using difference_type = _Iter_diff_t<_BidIt>;
    using pointer         = typename iterator_traits<_BidIt>::pointer;
    using reference       = _Iter_ref_t<_BidIt>;

    template <class>
    friend class reverse_iterator;

    constexpr reverse_iterator() = default;

    constexpr explicit reverse_iterator(_BidIt _Right) noexcept(
        is_nothrow_move_constructible_v<_BidIt>) 
        : current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
#line 1521 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    constexpr reverse_iterator(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_BidIt, const _Other&>) 
        : current(_Right.current) {}

    template <class _Other>

        requires (!is_same_v<_Other, _BidIt>) && convertible_to<const _Other&, _BidIt>
            && assignable_from<_BidIt&, const _Other&>
#line 1530 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    constexpr reverse_iterator& operator=(const reverse_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_BidIt&, const _Other&>)  {
        current = _Right.current;
        return *this;
    }
    

    [[nodiscard]] constexpr _BidIt base() const noexcept(is_nothrow_copy_constructible_v<_BidIt>)  {
        return current;
    }

    [[nodiscard]] constexpr reference operator*() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(*--(::std:: declval<_BidIt&>())))  {
        _BidIt _Tmp = current;
        return *--_Tmp;
    }

    [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--(::std:: declval<_BidIt&>()))
                 && _Has_nothrow_operator_arrow<_BidIt&, pointer>) 

        requires (is_pointer_v<_BidIt> || requires(const _BidIt __i) { __i.operator->(); })
#line 1553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    {
        _BidIt _Tmp = current;
        --_Tmp;
        if constexpr (is_pointer_v<_BidIt>) {
            return _Tmp;
        } else {
            return _Tmp.operator->();
        }
    }

    constexpr reverse_iterator& operator++() noexcept(noexcept(--current))  {
        --current;
        return *this;
    }

    constexpr reverse_iterator operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(--current))  {
        reverse_iterator _Tmp = *this;
        --current;
        return _Tmp;
    }

    constexpr reverse_iterator& operator--() noexcept(noexcept(++current))  {
        ++current;
        return *this;
    }

    constexpr reverse_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(++current))  {
        reverse_iterator _Tmp = *this;
        ++current;
        return _Tmp;
    }

    [[nodiscard]] constexpr reverse_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current - _Off)))  {
        return reverse_iterator(current - _Off);
    }

    constexpr reverse_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(current -= _Off))  {
        current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reverse_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(reverse_iterator(current + _Off)))  {
        return reverse_iterator(current + _Off);
    }

    constexpr reverse_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(current += _Off))  {
        current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const
        noexcept(noexcept(_Fake_copy_init<reference>(current[_Off])))  {
        return current[static_cast<difference_type>(-_Off - 1)];
    }


    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_BidIt> iter_move(const reverse_iterator& _It) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& noexcept(::std::ranges:: iter_move(--::std:: declval<_BidIt&>()))) {
        auto _Tmp = _It.current;
        --_Tmp;
        return ::std::ranges:: iter_move(_Tmp);
    }

    template <indirectly_swappable<_BidIt> _BidIt2>
    friend constexpr void iter_swap(const reverse_iterator& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        is_nothrow_copy_constructible_v<_BidIt>&& is_nothrow_copy_constructible_v<_BidIt2>&& noexcept(
            ::std::ranges:: iter_swap(--::std:: declval<_BidIt&>(), --::std:: declval<_BidIt2&>()))) {
        auto _LTmp = _Left.current;
        auto _RTmp = _Right.base();
        --_LTmp;
        --_RTmp;
        ::std::ranges:: iter_swap(_LTmp, _RTmp);
    }
#line 1633 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    using _Prevent_inheriting_unwrap = reverse_iterator;

    template <class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    friend constexpr void _Verify_range(
        const reverse_iterator& _First, const reverse_iterator<_BidIt2>& _Last) noexcept {
        _Verify_range(_Last._Get_current(), _First.current); 
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        do { if (_Off != _Min_possible_v<difference_type>) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        current._Verify_offset(-_Off);
    }

    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
    }
    template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<_BidIt2>, int> = 0>
    [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<_BidIt2>> _Unwrapped() && noexcept(
        noexcept(static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped()))) {
        return static_cast<reverse_iterator<_Unwrapped_t<_BidIt2>>>(::std:: move(current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, const _Src&>, int> = 0>
    constexpr void _Seek_to(const reverse_iterator<_Src>& _It) noexcept(noexcept(current._Seek_to(_It.current))) {
        current._Seek_to(_It.current);
    }

    [[nodiscard]] constexpr const _BidIt& _Get_current() const noexcept {
        return current;
    }

protected:
    _BidIt current{};
};

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() == _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() == _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1685 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() == _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() != _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() != _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1700 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() != _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() > _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() > _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1715 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() > _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() < _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() < _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() < _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() >= _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() >= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() >= _Right._Get_current();
}

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr bool
    operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left._Get_current() <= _Right._Get_current()))) 

    
    requires requires {
        { _Left._Get_current() <= _Right._Get_current() } -> _Implicitly_convertible_to<bool>;
    }

#line 1760 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left._Get_current() <= _Right._Get_current();
}


 template <class _BidIt1, three_way_comparable_with<_BidIt1> _BidIt2>
[[nodiscard]] constexpr compare_three_way_result_t<_BidIt1, _BidIt2>
    operator<=>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() <=> _Left._Get_current()))  {
    return _Right._Get_current() <=> _Left._Get_current();
}
#line 1772 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr auto
    operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right) noexcept(
        noexcept(_Right._Get_current() - _Left._Get_current())) 
    -> decltype(_Right._Get_current() - _Left._Get_current()) {
    return _Right._Get_current() - _Left._Get_current();
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> operator+(typename reverse_iterator<_BidIt>::difference_type _Off,
    const reverse_iterator<_BidIt>& _Right) noexcept(noexcept(_Right + _Off))  {
    return _Right + _Off;
}

 template <class _BidIt>
[[nodiscard]] constexpr reverse_iterator<_BidIt> make_reverse_iterator(_BidIt _Iter) noexcept(
    is_nothrow_move_constructible_v<_BidIt>)  {
    return reverse_iterator<_BidIt>(::std:: move(_Iter));
}


template <class _BidIt1, class _BidIt2>
    requires (!sized_sentinel_for<_BidIt1, _BidIt2>)
inline constexpr bool disable_sized_sentinel_for<reverse_iterator<_BidIt1>, reverse_iterator<_BidIt2>> = true;
#line 1798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Container>
[[nodiscard]] constexpr auto begin(_Container& _Cont) noexcept(noexcept(_Cont.begin())) 
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto begin(const _Container& _Cont) noexcept(noexcept(_Cont.begin())) 
    -> decltype(_Cont.begin()) {
    return _Cont.begin();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(_Container& _Cont) noexcept(noexcept(_Cont.end())) 
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Container>
[[nodiscard]] constexpr auto end(const _Container& _Cont) noexcept(noexcept(_Cont.end())) 
    -> decltype(_Cont.end()) {
    return _Cont.end();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept {
    return _Array + _Size;
}

 template <class _Container>
[[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std:: begin(_Cont)))
    -> decltype(::std:: begin(_Cont)) {
    return ::std:: begin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std:: end(_Cont)))
    -> decltype(::std:: end(_Cont)) {
    return ::std:: end(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(_Container& _Cont) noexcept(noexcept(_Cont.rbegin())) 
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rbegin(const _Container& _Cont) noexcept(noexcept(_Cont.rbegin())) 
    -> decltype(_Cont.rbegin()) {
    return _Cont.rbegin();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(_Container& _Cont) noexcept(noexcept(_Cont.rend())) 
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Container>
[[nodiscard]] constexpr auto rend(const _Container& _Cont) noexcept(noexcept(_Cont.rend())) 
    -> decltype(_Cont.rend()) {
    return _Cont.rend();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size]) noexcept  {
    return reverse_iterator<_Ty*>(_Array + _Size);
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size]) noexcept  {
    return reverse_iterator<_Ty*>(_Array);
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist) noexcept
 {
    return reverse_iterator<const _Elem*>(_Ilist.end());
}

 template <class _Elem>
[[nodiscard]] constexpr reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist) noexcept
 {
    return reverse_iterator<const _Elem*>(_Ilist.begin());
}

 template <class _Container>
[[nodiscard]] constexpr auto crbegin(const _Container& _Cont) noexcept(noexcept(::std:: rbegin(_Cont))) 
    -> decltype(::std:: rbegin(_Cont)) {
    return ::std:: rbegin(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto crend(const _Container& _Cont) noexcept(noexcept(::std:: rend(_Cont))) 
    -> decltype(::std:: rend(_Cont)) {
    return ::std:: rend(_Cont);
}

 template <class _Container>
[[nodiscard]] constexpr auto size(const _Container& _Cont) noexcept(noexcept(_Cont.size())) 
    -> decltype(_Cont.size()) {
    return _Cont.size();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept {
    return _Size;
}


 template <class _Container>
[[nodiscard]] constexpr auto ssize(const _Container& _Cont) noexcept(noexcept(
    static_cast<common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>>(_Cont.size()))) 
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>> {
    using _Common = common_type_t<ptrdiff_t, make_signed_t<decltype(_Cont.size())>>;
    return static_cast<_Common>(_Cont.size());
}

 template <class _Ty, ptrdiff_t _Size>
[[nodiscard]] constexpr ptrdiff_t ssize(const _Ty (&)[_Size]) noexcept {
    return _Size;
}
#line 1928 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Container>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr auto empty(const _Container& _Cont) noexcept(
    noexcept(_Cont.empty())) 
    -> decltype(_Cont.empty()) {
    return _Cont.empty();
}

 template <class _Ty, size_t _Size>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(const _Ty (&)[_Size]) noexcept {
    return false;
}

 template <class _Elem>
[[nodiscard("This function returns a bool indicating whether the container or container-like object is empty and " "has no other effects. It is not useful to call this function and discard the return value.")]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.size() == 0;
}

 template <class _Container>
[[nodiscard]] constexpr auto data(_Container& _Cont) noexcept(noexcept(_Cont.data())) 
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Container>
[[nodiscard]] constexpr auto data(const _Container& _Cont) noexcept(noexcept(_Cont.data())) 
    -> decltype(_Cont.data()) {
    return _Cont.data();
}

 template <class _Ty, size_t _Size>
[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept {
    return _Array;
}

 template <class _Elem>
[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept {
    return _Ilist.begin();
}



 template <indirectly_readable _Ty>
using iter_const_reference_t = common_reference_t<const iter_value_t<_Ty>&&, iter_reference_t<_Ty>>;

template <indirectly_readable _Iter>
using _Iter_const_rvalue_reference_t = common_reference_t<const iter_value_t<_Iter>&&, iter_rvalue_reference_t<_Iter>>;

template <class _Ty>
concept _Constant_iterator = input_iterator<_Ty> && same_as<iter_const_reference_t<_Ty>, iter_reference_t<_Ty>>;

 template <input_iterator _Iter>
class basic_const_iterator;

 template <input_iterator _Iter>
using const_iterator = conditional_t<_Constant_iterator<_Iter>, _Iter, basic_const_iterator<_Iter>>;

template <class _Sent>
struct _Const_sentinel {
    using type = _Sent;
};

template <input_iterator _Sent>
struct _Const_sentinel<_Sent> {
    using type = const_iterator<_Sent>;
};

 template <semiregular _Sent>
using const_sentinel = _Const_sentinel<_Sent>::type;

template <class _Ty>
concept _Not_a_const_iterator = !_Is_specialization_v<_Ty, basic_const_iterator>;

template <class>
struct _Basic_const_iterator_category {};

template <forward_iterator _Iter>
struct _Basic_const_iterator_category<_Iter> {
    using iterator_category = iterator_traits<_Iter>::iterator_category;
};

 template <input_iterator _Iter>
class basic_const_iterator : public _Basic_const_iterator_category<_Iter> {
private:
     _Iter _Current{};

    using _Reference        = iter_const_reference_t<_Iter>;
    using _Rvalue_reference = _Iter_const_rvalue_reference_t<_Iter>;

    [[nodiscard]] static consteval auto _Get_iter_concept() noexcept {
        if constexpr (contiguous_iterator<_Iter>) {
            return contiguous_iterator_tag{};
        } else if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());
    using value_type       = iter_value_t<_Iter>;
    using difference_type  = iter_difference_t<_Iter>;

    
    basic_const_iterator() requires default_initializable<_Iter> = default;
    

    constexpr basic_const_iterator(_Iter _Current_) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Current_)) {}

    template <convertible_to<_Iter> _Other>
    constexpr basic_const_iterator(basic_const_iterator<_Other> _Current_) noexcept(
        is_nothrow_constructible_v<_Iter, _Other>) 
        : _Current(::std:: move(_Current_._Current)) {}

    template <_Different_from<basic_const_iterator> _Other>
        requires convertible_to<_Other, _Iter>
    constexpr basic_const_iterator(_Other&& _Current_) noexcept(
        is_nothrow_constructible_v<_Iter, _Other>) 
        : _Current(::std:: forward<_Other>(_Current_)) {}

    [[nodiscard]] constexpr const _Iter& base() const& noexcept {
        return _Current;
    }

    [[nodiscard]] constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>)  {
        return ::std:: move(_Current);
    }

    [[nodiscard]] constexpr _Reference operator*() const
        noexcept(noexcept(static_cast<_Reference>(*_Current)))  {
        return static_cast<_Reference>(*_Current);
    }

    [[nodiscard]] constexpr const auto* operator->() const
        noexcept(contiguous_iterator<_Iter> || noexcept(*_Current)) 
        requires is_lvalue_reference_v<iter_reference_t<_Iter>>
              && same_as<remove_cvref_t<iter_reference_t<_Iter>>, value_type>
    {
        if constexpr (contiguous_iterator<_Iter>) {
            return ::std:: to_address(_Current);
        } else {
            return ::std:: addressof(*_Current);
        }
    }

    constexpr basic_const_iterator& operator++() noexcept(noexcept(++_Current))  {
        ++_Current;
        return *this;
    }

    constexpr void operator++(int) noexcept(noexcept(++_Current))  {
        ++_Current;
    }

    constexpr basic_const_iterator operator++(int) noexcept(
        noexcept(++*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) 
        requires forward_iterator<_Iter>
    {
        auto _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr basic_const_iterator& operator--() noexcept(noexcept(--_Current)) 
        requires bidirectional_iterator<_Iter>
    {
        --_Current;
        return *this;
    }

    constexpr basic_const_iterator operator--(int) noexcept(
        noexcept(--*this) && is_nothrow_copy_constructible_v<basic_const_iterator>) 
        requires bidirectional_iterator<_Iter>
    {
        auto _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr basic_const_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off)) 
        requires random_access_iterator<_Iter>
    {
        _Current += _Off;
        return *this;
    }

    constexpr basic_const_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off)) 
        requires random_access_iterator<_Iter>
    {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr _Reference operator[](const difference_type _Idx) const
        noexcept(noexcept(static_cast<_Reference>(_Current[_Idx]))) 
        requires random_access_iterator<_Iter>
    {
        return static_cast<_Reference>(_Current[_Idx]);
    }

    template <sentinel_for<_Iter> _Sent>
    [[nodiscard]] constexpr bool operator==(const _Sent& _Se) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current == _Se)))  {
        return _Current == _Se;
    }

    [[nodiscard]] constexpr bool operator<(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current < _Right._Current))) 
        requires random_access_iterator<_Iter>
    {
        return _Current < _Right._Current;
    }

    [[nodiscard]] constexpr bool operator>(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current > _Right._Current))) 
        requires random_access_iterator<_Iter>
    {
        return _Current > _Right._Current;
    }

    [[nodiscard]] constexpr bool operator<=(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current <= _Right._Current))) 
        requires random_access_iterator<_Iter>
    {
        return _Current <= _Right._Current;
    }

    [[nodiscard]] constexpr bool operator>=(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current >= _Right._Current))) 
        requires random_access_iterator<_Iter>
    {
        return _Current >= _Right._Current;
    }

    [[nodiscard]] constexpr auto operator<=>(const basic_const_iterator& _Right) const
        noexcept(noexcept(_Current <=> _Right._Current)) 
        requires random_access_iterator<_Iter> && three_way_comparable<_Iter>
    {
        return _Current <=> _Right._Current;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] constexpr bool operator<(const _Other& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current < _Right)))  {
        return _Current < _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] constexpr bool operator>(const _Other& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current > _Right)))  {
        return _Current > _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] constexpr bool operator<=(const _Other& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current <= _Right)))  {
        return _Current <= _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] constexpr bool operator>=(const _Other& _Right) const
        noexcept(noexcept(_Fake_copy_init<bool>(_Current >= _Right)))  {
        return _Current >= _Right;
    }

    template <_Different_from<basic_const_iterator> _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
              && three_way_comparable_with<_Iter, _Other>
    [[nodiscard]] constexpr auto operator<=>(const _Other& _Right) const
        noexcept(noexcept(_Current <=> _Right))  {
        return _Current <=> _Right;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] friend constexpr bool operator<(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left < _Right._Current)))  {
        return _Left < _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] friend constexpr bool operator>(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left > _Right._Current)))  {
        return _Left > _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] friend constexpr bool operator<=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left <= _Right._Current)))  {
        return _Left <= _Right._Current;
    }

    template <_Not_a_const_iterator _Other>
        requires random_access_iterator<_Iter> && totally_ordered_with<_Iter, _Other>
    [[nodiscard]] friend constexpr bool operator>=(const _Other& _Left, const basic_const_iterator& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left >= _Right._Current)))  {
        return _Left >= _Right._Current;
    }

    [[nodiscard]] friend constexpr basic_const_iterator operator+(const basic_const_iterator& _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) 
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{_It._Current + _Off};
    }

    [[nodiscard]] friend constexpr basic_const_iterator operator+(const difference_type _Off,
        const basic_const_iterator& _It) noexcept(noexcept(basic_const_iterator{_It._Current + _Off})) 
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{_It._Current + _Off};
    }

    [[nodiscard]] friend constexpr basic_const_iterator operator-(const basic_const_iterator& _It,
        const difference_type _Off) noexcept(noexcept(basic_const_iterator{_It._Current - _Off})) 
        requires random_access_iterator<_Iter>
    {
        return basic_const_iterator{_It._Current - _Off};
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] constexpr difference_type operator-(const _Sent& _Se) const
        noexcept(noexcept(_Current - _Se))  {
        return _Current - _Se;
    }

    template <_Not_a_const_iterator _Sent>
        requires sized_sentinel_for<_Sent, _Iter>
    [[nodiscard]] friend constexpr difference_type operator-(const _Sent& _Se, const basic_const_iterator& _It) noexcept(
        noexcept(_Se - _It._Current))  {
        return _Se - _It._Current;
    }

    [[nodiscard]] friend constexpr _Rvalue_reference iter_move(const basic_const_iterator& _It) noexcept(
        noexcept(static_cast<_Rvalue_reference>(::std::ranges:: iter_move(_It._Current)))) {
        return static_cast<_Rvalue_reference>(::std::ranges:: iter_move(_It._Current));
    }
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<basic_const_iterator<_Ty1>, _Ty2> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<_Ty2, basic_const_iterator<_Ty1>> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

template <class _Ty1, common_with<_Ty1> _Ty2>
    requires input_iterator<common_type_t<_Ty1, _Ty2>>
struct common_type<basic_const_iterator<_Ty1>, basic_const_iterator<_Ty2>> {
    using type = basic_const_iterator<common_type_t<_Ty1, _Ty2>>;
};

 template <input_iterator _Iter>
[[nodiscard]] constexpr const_iterator<_Iter> make_const_iterator(_Iter _It) noexcept(
    is_nothrow_constructible_v<const_iterator<_Iter>, _Iter&>)  {
    return _It;
}

 template <semiregular _Sent>
[[nodiscard]] constexpr const_sentinel<_Sent> make_const_sentinel(_Sent _Se) noexcept(
    is_nothrow_constructible_v<const_sentinel<_Sent>, _Sent&>)  {
    return _Se;
}
#line 2311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

namespace ranges {
    template <class>
    inline constexpr bool _Has_complete_elements = false;

    template <class _Ty>
        requires requires(_Ty& __t) { sizeof(__t[0]); }
    inline constexpr bool _Has_complete_elements<_Ty> = true;

     template <class>
    inline constexpr bool enable_borrowed_range = false;

    template <class _Rng>
    concept _Should_range_access = is_lvalue_reference_v<_Rng> || enable_borrowed_range<remove_cvref_t<_Rng>>;

    namespace _Begin {


#line 2330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void begin();
#line 2332 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _Fake_copy_init(__t.begin()) } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _Fake_copy_init(begin(__t)) } -> input_or_output_iterator; 
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (is_array_v<remove_reference_t<_Ty>>) {
                    static_assert(_Has_complete_elements<_Ty>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    return {_St::_Array, true};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().begin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(begin(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    return _Val;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.begin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return begin(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Begin::_Cpo begin;
    }

     template <class _Ty>
    using iterator_t = decltype(::std::ranges:: begin(::std:: declval<_Ty&>()));

    namespace _End {


#line 2398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void end();
#line 2400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _Fake_copy_init(__t.end()) } -> sentinel_for<iterator_t<_Ty>>;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _Fake_copy_init(end(__t)) } -> sentinel_for<iterator_t<_Ty>>; 
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                using _UnRef = remove_reference_t<_Ty>;

                if constexpr (is_array_v<_UnRef>) {
                    static_assert(_Has_complete_elements<_UnRef>,
                        "The range access customization point objects "
                        "std::ranges::begin, std::ranges::end, std::ranges::rbegin, std::ranges::rend, "
                        "and std::ranges::data do not accept arrays with incomplete element types.");
                    if constexpr (extent_v<_UnRef> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().end()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(end(::std:: declval<_Ty>())))}; 
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return _Val + extent_v<remove_reference_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.end();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return end(_Val); 
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _End::_Cpo end;
    }

     template <class _Rng>
    concept range = requires(_Rng& __r) {
        ::std::ranges:: begin(__r);
        ::std::ranges:: end(__r);
    };

     template <class _Rng>
    concept input_range = range<_Rng> && input_iterator<iterator_t<_Rng>>;

     template <range _Rng>
    using sentinel_t = decltype(::std::ranges:: end(::std:: declval<_Rng&>()));

    template <class _Wrapped>
    concept _Weakly_unwrappable = _Allow_inheriting_unwrap_v<remove_cvref_t<_Wrapped>>
                               && requires(_Wrapped&& _Wr) { ::std:: forward<_Wrapped>(_Wr)._Unwrapped(); };

    template <class _Sent>
    concept _Weakly_unwrappable_sentinel = _Weakly_unwrappable<const remove_reference_t<_Sent>&>;

    template <class _Iter>
    concept _Weakly_unwrappable_iterator =
        _Weakly_unwrappable<_Iter> && requires(_Iter&& _It, remove_cvref_t<_Iter>& _MutIt) {
            _MutIt._Seek_to(::std:: forward<_Iter>(_It)._Unwrapped());
        };

    template <class _Sent, class _Iter>
    concept _Unwrappable_sentinel_for = _Weakly_unwrappable_sentinel<_Sent> && _Weakly_unwrappable_iterator<_Iter>
                                     && requires(_Iter&& _It, const remove_reference_t<_Sent>& _Se) {
                                            {
                                                _Se._Unwrapped()
                                            } -> sentinel_for<decltype(::std:: forward<_Iter>(_It)._Unwrapped())>;
                                        };

    template <class _Sent, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_iter(_Iter&& _It) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Iter>) {
        ;
        if constexpr (is_pointer_v<remove_cvref_t<_Iter>>) {
            return _It + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        } else {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_sent(_Sent&& _Se) noexcept(
        !_Unwrappable_sentinel_for<_Sent, _Iter> || _Has_nothrow_unwrapped<_Sent>) {
        ;
        if constexpr (is_pointer_v<remove_cvref_t<_Sent>>) {
            return _Se + 0;
        } else if constexpr (_Unwrappable_sentinel_for<_Sent, _Iter>) {
            return static_cast<_Sent&&>(_Se)._Unwrapped();
        } else {
            return static_cast<_Sent&&>(_Se);
        }
    }

    template <range _Rng, class _Iter>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_iter(_Iter&& _It) noexcept(
        noexcept(_Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It)))) {
        ;
        return _Unwrap_iter<sentinel_t<_Rng>>(static_cast<_Iter&&>(_It));
    }

    template <range _Rng, class _Sent>
    [[nodiscard]] constexpr decltype(auto) _Unwrap_range_sent(_Sent&& _Se) noexcept(
        noexcept(_Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se)))) {
        ;
        return _Unwrap_sent<iterator_t<_Rng>>(static_cast<_Sent&&>(_Se));
    }

    template <class _Iter, class _Sent>
    using _Unwrap_iter_t = remove_cvref_t<decltype(_Unwrap_iter<_Sent>(::std:: declval<_Iter>()))>;
    template <class _Sent, class _Iter>
    using _Unwrap_sent_t = remove_cvref_t<decltype(_Unwrap_sent<_Iter>(::std:: declval<_Sent>()))>;

    template <range _Rng>
    using _Unwrapped_iterator_t = _Unwrap_iter_t<iterator_t<_Rng>, sentinel_t<_Rng>>;
    template <range _Rng>
    using _Unwrapped_sentinel_t = _Unwrap_sent_t<sentinel_t<_Rng>, iterator_t<_Rng>>;

    namespace _Unchecked_begin {
        template <class _Ty>
        concept _Has_member = requires(_Ty& __t) {
            { __t._Unchecked_begin() } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Can_begin = requires(_Ty& __t) { _Unwrap_range_iter<_Ty>(::std::ranges:: begin(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (_Has_member<_Ty>) {
                    ;
#line 2568 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>()._Unchecked_begin()))};
                } else if constexpr (_Can_begin<_Ty>) {
                    return {_St::_Unwrap,
                        noexcept(_Fake_copy_init(_Unwrap_range_iter<_Ty>(::std::ranges:: begin(::std:: declval<_Ty>()))))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_begin();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_iter<_Ty>(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_begin::_Cpo _Ubegin;
    }

    namespace _Unchecked_end {
        template <class _Ty>
        concept _Has_member = _Unchecked_begin::_Has_member<_Ty> && requires(_Ty& __t) {
            __t._Unchecked_begin(); 
            { __t._Unchecked_end() } -> sentinel_for<decltype(__t._Unchecked_begin())>;
        };

        template <class _Ty>
        concept _Can_end = requires(_Ty& __t) { _Unwrap_range_sent<_Ty>(::std::ranges:: end(__t)); };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Unwrap };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>()._Unchecked_end())};
                } else if constexpr (_Can_end<_Ty>) {
                    return {_St::_Unwrap, noexcept(_Unwrap_range_sent<_Ty>(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val._Unchecked_end();
                } else if constexpr (_Strat == _St::_Unwrap) {
                    return _Unwrap_range_sent<_Ty>(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "Should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
        inline constexpr _Unchecked_end::_Cpo _Uend;
    }

     template <class _Rng>
    concept borrowed_range = range<_Rng> && _Should_range_access<_Rng>;

     template <range _Rng>
    using range_difference_t = iter_difference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_value_t = iter_value_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_reference_t = iter_reference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_rvalue_reference_t = iter_rvalue_reference_t<iterator_t<_Rng>>;

     template <range _Rng>
    using range_common_reference_t = iter_common_reference_t<iterator_t<_Rng>>;


     template <class _Rng>
    concept constant_range = input_range<_Rng> && _Constant_iterator<iterator_t<_Rng>>;

    template <input_range _Rng>
    [[nodiscard]] [[msvc::intrinsic]] constexpr auto& _Possibly_const_range(_Rng& _Range) noexcept {
        if constexpr (constant_range<const _Rng> && !constant_range<_Rng>) {
            return ::std:: as_const(_Range);
        } else {
            return _Range;
        }
    }

    template <class _Ty>
    [[nodiscard]] [[msvc::intrinsic]] constexpr auto _As_const_pointer(const _Ty* _Ptr) noexcept {
        return _Ptr;
    }
#line 2687 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    struct _Cbegin_fn {

        template <class _Ty>
        using _Begin_on_const = decltype(::std::ranges:: begin(::std::ranges:: _Possibly_const_range(::std:: declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
                typename _Begin_on_const<_Ty>;
                typename const_iterator<_Begin_on_const<_Ty>>;
                const_iterator<_Begin_on_const<_Ty>>{::std::ranges:: begin(::std::ranges:: _Possibly_const_range(_Val))};
            }
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(
            noexcept(const_iterator<_Begin_on_const<_Ty>>{::std::ranges:: begin(::std::ranges:: _Possibly_const_range(_Val))})) {
            return const_iterator<_Begin_on_const<_Ty>>{::std::ranges:: begin(::std::ranges:: _Possibly_const_range(_Val))};
        }








#line 2712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cbegin_fn cbegin;
    }

    struct _Cend_fn {

        template <class _Ty>
        using _End_on_const = decltype(::std::ranges:: end(::std::ranges:: _Possibly_const_range(::std:: declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
                typename _End_on_const<_Ty>;
                typename const_sentinel<_End_on_const<_Ty>>;
                const_sentinel<_End_on_const<_Ty>>{::std::ranges:: end(::std::ranges:: _Possibly_const_range(_Val))};
            }
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(const_sentinel<_End_on_const<_Ty>>{::std::ranges:: end(::std::ranges:: _Possibly_const_range(_Val))})) {
            return const_sentinel<_End_on_const<_Ty>>{::std::ranges:: end(::std::ranges:: _Possibly_const_range(_Val))};
        }








#line 2742 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cend_fn cend;
    }

    namespace _Rbegin {


#line 2752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void rbegin();
#line 2754 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _Fake_copy_init(__t.rbegin()) } -> input_or_output_iterator;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            { _Fake_copy_init(rbegin(__t)) } -> input_or_output_iterator; 
        };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
            { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
            { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rbegin()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {
                        _St::_Non_member, noexcept(_Fake_copy_init(rbegin(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {_St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: end(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rbegin();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rbegin(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rbegin::_Cpo rbegin;
    }

    namespace _Rend {


#line 2820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void rend();
#line 2822 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _Fake_copy_init(__t.rend()) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
        };

        template <class _Ty>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && requires(_Ty __t) {
            
            { _Fake_copy_init(rend(__t)) } -> sentinel_for<decltype(::std::ranges:: rbegin(__t))>;
        };

        template <class _Ty>
        concept _Can_make_reverse = requires(_Ty __t) {
            { ::std::ranges:: begin(__t) } -> bidirectional_iterator;
            { ::std::ranges:: end(__t) } -> same_as<decltype(::std::ranges:: begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Non_member, _Make_reverse };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().rend()))};
                } else if constexpr (_Has_ADL<_Ty>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(rend(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_make_reverse<_Ty>) {
                    return {
                        _St::_Make_reverse, noexcept(::std:: make_reverse_iterator(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.rend();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return rend(_Val); 
                } else if constexpr (_Strat == _St::_Make_reverse) {
                    return ::std:: make_reverse_iterator(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Rend::_Cpo rend;
    }

    struct _Crbegin_fn {

        template <class _Ty>
        using _Rbegin_on_const = decltype(::std::ranges:: rbegin(::std::ranges:: _Possibly_const_range(::std:: declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
                typename _Rbegin_on_const<_Ty>;
                typename const_iterator<_Rbegin_on_const<_Ty>>;
                const_iterator<_Rbegin_on_const<_Ty>>{::std::ranges:: rbegin(::std::ranges:: _Possibly_const_range(_Val))};
            }
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(
            noexcept(const_iterator<_Rbegin_on_const<_Ty>>{::std::ranges:: rbegin(::std::ranges:: _Possibly_const_range(_Val))})) {
            return const_iterator<_Rbegin_on_const<_Ty>>{::std::ranges:: rbegin(::std::ranges:: _Possibly_const_range(_Val))};
        }








#line 2909 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crbegin_fn crbegin;
    }

    struct _Crend_fn {

        template <class _Ty>
        using _Rend_on_const = decltype(::std::ranges:: rend(::std::ranges:: _Possibly_const_range(::std:: declval<_Ty&>())));

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) {
                typename _Rend_on_const<_Ty>;
                typename const_sentinel<_Rend_on_const<_Ty>>;
                const_sentinel<_Rend_on_const<_Ty>>{::std::ranges:: rend(::std::ranges:: _Possibly_const_range(_Val))};
            }
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(const_sentinel<_Rend_on_const<_Ty>>{::std::ranges:: rend(::std::ranges:: _Possibly_const_range(_Val))})) {
            return const_sentinel<_Rend_on_const<_Ty>>{::std::ranges:: rend(::std::ranges:: _Possibly_const_range(_Val))};
        }








#line 2939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Crend_fn crend;
    }

     template <class>
    inline constexpr bool disable_sized_range = false;

    namespace _Size {


#line 2952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        void size();
#line 2954 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        template <class _Ty, class _UnCV>
        concept _Has_member = !disable_sized_range<_UnCV> && requires(_Ty __t) {
            { _Fake_copy_init(__t.size()) } -> _Integer_like;
        };

        template <class _Ty, class _UnCV>
        concept _Has_ADL = _Has_class_or_enum_type<_Ty> && !disable_sized_range<_UnCV> && requires(_Ty __t) {
            { _Fake_copy_init(size(__t)) } -> _Integer_like; 
        };

        template <class _Ty>
        concept _Can_difference = requires(_Ty __t) {
            { ::std::ranges:: begin(__t) } -> forward_iterator;
            { ::std::ranges:: end(__t) } -> sized_sentinel_for<decltype(::std::ranges:: begin(__t))>;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Array, _Member, _Non_member, _Subtract };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                using _UnCV = remove_cvref_t<_Ty>;

                if constexpr (is_array_v<_UnCV>) {
                    if constexpr (extent_v<_UnCV> != 0) {
                        return {_St::_Array, true};
                    } else {
                        return {_St::_None};
                    }
                } else if constexpr (_Has_member<_Ty, _UnCV>) {
                    return {_St::_Member, noexcept(_Fake_copy_init(::std:: declval<_Ty>().size()))};
                } else if constexpr (_Has_ADL<_Ty, _UnCV>) {
                    return {_St::_Non_member, noexcept(_Fake_copy_init(size(::std:: declval<_Ty>())))}; 
                } else if constexpr (_Can_difference<_Ty>) {
                    return {_St::_Subtract,
                        noexcept(::std::ranges:: end(::std:: declval<_Ty>()) - ::std::ranges:: begin(::std:: declval<_Ty>()))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Array) {
                    
                    return extent_v<remove_cvref_t<_Ty&>>;
                } else if constexpr (_Strat == _St::_Member) {
                    return _Val.size();
                } else if constexpr (_Strat == _St::_Non_member) {
                    return size(_Val); 
                } else if constexpr (_Strat == _St::_Subtract) {
                    const auto _Delta = ::std::ranges:: end(_Val) - ::std::ranges:: begin(_Val);
                    return static_cast<_Make_unsigned_like_t<remove_cv_t<decltype(_Delta)>>>(_Delta);
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Size::_Cpo size;
    }

    namespace _Empty {
        template <class _Ty>
        concept _Has_member = requires(_Ty __t) { static_cast<bool>(__t.empty()); };

        template <class _Ty>
        concept _Has_size = requires(_Ty __t) { ::std::ranges:: size(__t); };

        template <class _Ty>
        concept _Can_begin_end = requires(_Ty __t) {
            { ::std::ranges:: begin(__t) } -> forward_iterator;
            ::std::ranges:: end(__t);
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Size, _Compare };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (is_unbounded_array_v<remove_reference_t<_Ty>>) {
                    return {_St::_None};
                } else if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(static_cast<bool>(::std:: declval<_Ty>().empty()))};
                } else if constexpr (_Has_size<_Ty>) {
                    return {_St::_Size, noexcept(::std::ranges:: size(::std:: declval<_Ty>()))};
                } else if constexpr (_Can_begin_end<_Ty>) {
                    constexpr auto _Nothrow = noexcept(
                        static_cast<bool>(::std::ranges:: begin(::std:: declval<_Ty>()) == ::std::ranges:: end(::std:: declval<_Ty>())));
                    return {_St::_Compare, _Nothrow};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            
            template <class _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr bool operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return static_cast<bool>(_Val.empty());
                } else if constexpr (_Strat == _St::_Size) {
                    return ::std::ranges:: size(_Val) == 0;
                } else if constexpr (_Strat == _St::_Compare) {
                    return static_cast<bool>(::std::ranges:: begin(_Val) == ::std::ranges:: end(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
            
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Empty::_Cpo empty;
    }

    namespace _Data {
        template <class _Ty>
        concept _Points_to_object = is_pointer_v<_Ty> && is_object_v<remove_pointer_t<_Ty>>;

        template <class _Ty>
        concept _Has_member = requires(_Ty __t) {
            { _Fake_copy_init(__t.data()) } -> _Points_to_object;
        };

        template <class _Ty>
        concept _Has_contiguous_iterator = requires(_Ty __t) {
            { ::std::ranges:: begin(__t) } -> contiguous_iterator;
        };

        class _Cpo {
        private:
            enum class _St { _None, _Member, _Address };

            template <class _Ty>
            [[nodiscard]] static consteval _Choice_t<_St> _Choose() noexcept {
                ;
                if constexpr (_Has_member<_Ty>) {
                    return {_St::_Member, noexcept(::std:: declval<_Ty>().data())};
                } else if constexpr (_Has_contiguous_iterator<_Ty>) {
                    return {_St::_Address, noexcept(::std:: to_address(::std::ranges:: begin(::std:: declval<_Ty>())))};
                } else {
                    return {_St::_None};
                }
            }

            template <class _Ty>
            static constexpr _Choice_t<_St> _Choice = _Choose<_Ty>();

        public:
            template <_Should_range_access _Ty>
                requires (_Choice<_Ty&>._Strategy != _St::_None)
            [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const noexcept(_Choice<_Ty&>._No_throw) {
                constexpr _St _Strat = _Choice<_Ty&>._Strategy;

                if constexpr (_Strat == _St::_Member) {
                    return _Val.data();
                } else if constexpr (_Strat == _St::_Address) {
                    return ::std:: to_address(::std::ranges:: begin(_Val));
                } else {
                    static_assert(_Always_false<_Ty>, "should be unreachable");
                }
            }
        };
    } 

    inline namespace _Cpos {
         inline constexpr _Data::_Cpo data;
    }

    struct _Cdata_fn {

        template <_Should_range_access _Ty>
            requires requires(_Ty& _Val) { 
                ::std::ranges:: _As_const_pointer(::std::ranges:: data(::std::ranges:: _Possibly_const_range(_Val)));
            }
        [[nodiscard]] constexpr auto operator()(_Ty&& _Val) const
            noexcept(noexcept(::std::ranges:: data(::std::ranges:: _Possibly_const_range(_Val)))) {
            return ::std::ranges:: _As_const_pointer(::std::ranges:: data(::std::ranges:: _Possibly_const_range(_Val)));
        }








#line 3164 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    };

    inline namespace _Cpos {
         inline constexpr _Cdata_fn cdata;
    }

     template <class _Rng>
    concept sized_range = range<_Rng> && requires(_Rng& __r) { ::std::ranges:: size(__r); };

     template <sized_range _Rng>
    using range_size_t = decltype(::std::ranges:: size(::std:: declval<_Rng&>()));

     struct view_base {};

    template <class _Ty, template <class...> class _Template>
    concept _Strictly_derived_from_specialization_of =
        is_object_v<_Ty> && _Derived_from_specialization_of<_Ty, _Template>;

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

     template <class _Ty>
    inline constexpr bool enable_view =
        derived_from<_Ty, view_base> || _Strictly_derived_from_specialization_of<_Ty, view_interface>;

     template <class _Ty>
    concept view = range<_Ty> && movable<_Ty> && enable_view<_Ty>;

     template <class _Rng, class _Ty>
    concept output_range = range<_Rng> && output_iterator<iterator_t<_Rng>, _Ty>;

     template <class _Rng>
    concept forward_range = range<_Rng> && forward_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept bidirectional_range = range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept random_access_range = range<_Rng> && random_access_iterator<iterator_t<_Rng>>;

     template <class _Rng>
    concept contiguous_range = range<_Rng> && contiguous_iterator<iterator_t<_Rng>> && requires(_Rng& __r) {
        { ::std::ranges:: data(__r) } -> same_as<add_pointer_t<range_reference_t<_Rng>>>;
    };

    class _Not_quite_object {
    public:
        
        
        
        
        

        struct _Construct_tag {
            explicit _Construct_tag() = default;
        };

        _Not_quite_object() = delete;

        constexpr explicit _Not_quite_object(_Construct_tag) noexcept {}

        _Not_quite_object(const _Not_quite_object&)            = delete;
        _Not_quite_object& operator=(const _Not_quite_object&) = delete;

        void operator&() const = delete;

    protected:
        ~_Not_quite_object() = default;
    };

    class _Advance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        constexpr void operator()(_It& _Where, iter_difference_t<_It> _Off) const {
            if constexpr (random_access_iterator<_It>) {
                _Where += _Off;
            } else {
                if constexpr (!bidirectional_iterator<_It>) {
                    ;
                }

                decltype(auto) _UWhere      = _Get_unwrapped_n(::std:: move(_Where), _Off);
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std:: move(_Where), _Off))>;

                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0; ++_Off) {
                        --_UWhere;
                    }
                }

                for (; _Off > 0; --_Off) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr void operator()(_It& _Where, _Se _Last) const {
            if constexpr (assignable_from<_It&, _Se>) {
                _Where = static_cast<_Se&&>(_Last);
            } else if constexpr (sized_sentinel_for<_Se, _It>) {
                (*this)(_Where, _Last - _Where);
            } else {
                _Adl_verify_range(_Where, _Last);

                decltype(auto) _UWhere      = _Unwrap_iter<_Se>(static_cast<_It&&>(_Where));
                constexpr bool _Need_rewrap = !is_reference_v<decltype(_Unwrap_iter<_Se>(static_cast<_It&&>(_Where)))>;
                decltype(auto) _ULast       = _Unwrap_sent<_It>(static_cast<_Se&&>(_Last));

                while (_UWhere != _ULast) {
                    ++_UWhere;
                }

                if constexpr (_Need_rewrap) {
                    _Seek_wrapped(_Where, ::std:: move(_UWhere));
                }
            }
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        constexpr iter_difference_t<_It> operator()(_It& _Where, iter_difference_t<_It> _Off, _Se _Last) const {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                const iter_difference_t<_It> _Delta = _Last - _Where;
                if ((_Off < 0 && _Off <= _Delta) || (_Off > 0 && _Off >= _Delta)) {
                    if constexpr (assignable_from<_It&, _Se>) {
                        _Where = static_cast<_Se&&>(_Last);
                    } else {
                        (*this)(_Where, _Delta);
                    }
                    return _Off - _Delta;
                }

                (*this)(_Where, _Off);
                return 0;
            } else {
                
                if constexpr (bidirectional_iterator<_It>) {
                    for (; _Off < 0 && _Where != _Last; ++_Off) {
                        --_Where;
                    }
                } else {
                    ;
                }

                for (; _Off > 0 && _Where != _Last; --_Off) {
                    ++_Where;
                }

                return _Off;
            }
        }
    };

     inline constexpr _Advance_fn advance{_Not_quite_object::_Construct_tag{}};

    class _Distance_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _It, sentinel_for<_It> _Se>
            requires (!sized_sentinel_for<_Se, _It>)
        [[nodiscard]] constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last) const
            noexcept(noexcept(_Distance_unchecked(
                _Get_unwrapped(::std:: move(_First)), _Get_unwrapped(::std:: move(_Last)))))  {
            _Adl_verify_range(_First, _Last);
            return _Distance_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));
        }

        template <class _It, sized_sentinel_for<decay_t<_It>> _Se>
        [[nodiscard]] constexpr iter_difference_t<decay_t<_It>> operator()(_It&& _First, const _Se _Last) const
            noexcept(noexcept(_Last - static_cast<const decay_t<_It>&>(_First)))  {
            return _Last - static_cast<const decay_t<_It>&>(_First);
        }

        template <range _Rng>
        [[nodiscard]] constexpr range_difference_t<_Rng> operator()(_Rng&& _Range) const
            noexcept(_Nothrow_size<_Rng>)  {
            if constexpr (sized_range<_Rng>) {
                return static_cast<range_difference_t<_Rng>>(::std::ranges:: size(_Range));
            } else {
                return _Distance_unchecked(_Ubegin(_Range), _Uend(_Range));
            }
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static constexpr iter_difference_t<_It> _Distance_unchecked(_It _First, const _Se _Last) noexcept(
            noexcept(++_First != _Last)) {
            ;

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                ++_Count;
            }

            return _Count;
        }

        template <class _Rng>
        static constexpr bool _Nothrow_size =
            noexcept(_Distance_unchecked(_Ubegin(::std:: declval<_Rng&>()), _Uend(::std:: declval<_Rng&>())));

        template <sized_range _Rng>
        static constexpr bool _Nothrow_size<_Rng> = noexcept(::std::ranges:: size(::std:: declval<_Rng&>()));
    };

     inline constexpr _Distance_fn distance{_Not_quite_object::_Construct_tag{}};

    class _Ssize_fn {
    public:
        
        template <class _Rng>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range) const requires requires { ::std::ranges:: size(_Range); } {
            using _Sty = _Make_signed_like_t<decltype(::std::ranges:: size(_Range))>;
            using _Ty  = common_type_t<conditional_t<is_integral_v<_Sty>, ptrdiff_t, _Sty>, _Sty>;
            return static_cast<_Ty>(::std::ranges:: size(_Range));
        }
        
    };

    inline namespace _Cpos {
         inline constexpr _Ssize_fn ssize;
    }

    class _Next_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            ++_Where;
            return _Where;
        }

        template <input_or_output_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
            ::std::ranges:: advance(_Where, _Off);
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, _Se _Last) const {
            ::std::ranges:: advance(_Where, static_cast<_Se&&>(_Last));
            return _Where;
        }

        template <input_or_output_iterator _It, sentinel_for<_It> _Se>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _Se _Last) const {
            ::std::ranges:: advance(_Where, _Off, static_cast<_Se&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Next_fn next{_Not_quite_object::_Construct_tag{}};

    class _Prev_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where) const {
            --_Where;
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off) const {
            ;
            ::std::ranges:: advance(_Where, -_Off);
            return _Where;
        }

        template <bidirectional_iterator _It>
        [[nodiscard]] constexpr _It operator()(_It _Where, const iter_difference_t<_It> _Off, _It _Last) const {
            ;
            ::std::ranges:: advance(_Where, -_Off, static_cast<_It&&>(_Last));
            return _Where;
        }
    };

     inline constexpr _Prev_fn prev{_Not_quite_object::_Construct_tag{}};

    template <forward_iterator _It, sentinel_for<_It> _Se>
    [[nodiscard]] constexpr _It _Find_last_iterator(
        const _It& _First, const _Se& _Last, const iter_difference_t<_It> _Count) {
        
        ;
        if constexpr (is_same_v<_It, _Se>) {
            return _Last;
        } else {
            return ::std::ranges:: next(_First, _Count);
        }
    }

     struct equal_to {
        
        template <class _Ty1, class _Ty2>
            requires equality_comparable_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))))  {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct less {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))))  {
            return static_cast<bool>(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right));
        }
        

        using is_transparent = int;
    };

     struct greater {
        
        template <class _Ty1, class _Ty2>
            requires totally_ordered_with<_Ty1, _Ty2>
        [[nodiscard]] constexpr bool operator()(_Ty1&& _Left, _Ty2&& _Right) const noexcept(noexcept(
            static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left))))  {
            return static_cast<bool>(static_cast<_Ty2&&>(_Right) < static_cast<_Ty1&&>(_Left));
        }
        

        using is_transparent = int;
    };

     template <class _Rng>
    concept common_range = range<_Rng> && same_as<iterator_t<_Rng>, sentinel_t<_Rng>>;

    template <class _It, class _Se>
    concept _Bidi_common = is_same_v<_It, _Se> && bidirectional_iterator<_It>;
    template <class _Rng>
    concept _Bidi_common_range = common_range<_Rng> && bidirectional_iterator<iterator_t<_Rng>>;

    template <class _Ty>
    concept _Can_empty = requires(_Ty __t) { ::std::ranges:: empty(__t); };

     template <class _Derived>
        requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface {
    private:
        [[nodiscard]] constexpr _Derived& _Cast() noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> "
                "(N4950 [view.interface.general]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
            return static_cast<_Derived&>(*this);
        }

        [[nodiscard]] constexpr const _Derived& _Cast() const noexcept {
            static_assert(derived_from<_Derived, view_interface>,
                "view_interface's template argument D must derive from view_interface<D> "
                "(N4950 [view.interface.general]/2).");
            static_assert(view<_Derived>,
                "view_interface's template argument must model the view concept (N4950 [view.interface.general]/2).");
            return static_cast<const _Derived&>(*this);
        }

    public:
        [[nodiscard]] constexpr bool empty()
            requires sized_range<_Derived> || forward_range<_Derived>
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<_Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }

        [[nodiscard]] constexpr bool empty() const
            requires sized_range<const _Derived> || forward_range<const _Derived>
        {
            auto& _Self = _Cast();
            if constexpr (sized_range<const _Derived>) {
                return ::std::ranges:: size(_Self) == 0;
            } else {
                return ::std::ranges:: begin(_Self) == ::std::ranges:: end(_Self);
            }
        }


        [[nodiscard]] constexpr auto cbegin()
            requires input_range<_Derived>
        {
            return ::std::ranges:: cbegin(_Cast());
        }

        [[nodiscard]] constexpr auto cbegin() const
            requires input_range<const _Derived>
        {
            return ::std::ranges:: cbegin(_Cast());
        }

        [[nodiscard]] constexpr auto cend()
            requires input_range<_Derived>
        {
            return ::std::ranges:: cend(_Cast());
        }

        [[nodiscard]] constexpr auto cend() const
            requires input_range<const _Derived>
        {
            return ::std::ranges:: cend(_Cast());
        }
#line 3585 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        constexpr explicit operator bool()
            requires _Can_empty<_Derived>
        {
            return !::std::ranges:: empty(_Cast());
        }

        constexpr explicit operator bool() const
            requires _Can_empty<const _Derived>
        {
            return !::std::ranges:: empty(_Cast());
        }

        [[nodiscard]] constexpr auto data()
            requires contiguous_iterator<iterator_t<_Derived>>
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }

        [[nodiscard]] constexpr auto data() const
            requires range<const _Derived> && contiguous_iterator<iterator_t<const _Derived>>
        {
            return ::std:: to_address(::std::ranges:: begin(_Cast()));
        }

        [[nodiscard]] constexpr auto size()
            requires forward_range<_Derived> && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }

        [[nodiscard]] constexpr auto size() const
            requires forward_range<const _Derived>
                  && sized_sentinel_for<sentinel_t<const _Derived>, iterator_t<const _Derived>>
        {
            auto& _Self = _Cast();
            return ::std:: _To_unsigned_like(::std::ranges:: end(_Self) - ::std::ranges:: begin(_Self));
        }

        [[nodiscard]] constexpr decltype(auto) front()
            requires forward_range<_Derived>
        {
            auto& _Self = _Cast();


#line 3632 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }

        [[nodiscard]] constexpr decltype(auto) front() const
            requires forward_range<const _Derived>
        {
            auto& _Self = _Cast();


#line 3642 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return *::std::ranges:: begin(_Self);
        }

        [[nodiscard]] constexpr decltype(auto) back()
            requires bidirectional_range<_Derived> && common_range<_Derived>
        {
            auto& _Self = _Cast();


#line 3652 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }

        [[nodiscard]] constexpr decltype(auto) back() const
            requires bidirectional_range<const _Derived> && common_range<const _Derived>
        {
            auto& _Self = _Cast();


#line 3663 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            auto _Last = ::std::ranges:: end(_Self);
            return *--_Last;
        }

        template <random_access_range _Rng = _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) {
            auto& _Self = _Cast();






#line 3677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }

        template <random_access_range _Rng = const _Derived>
        [[nodiscard]] constexpr decltype(auto) operator[](const range_difference_t<_Rng> _Idx) const {
            auto& _Self = _Cast();






#line 3690 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return ::std::ranges:: begin(_Self)[_Idx];
        }
    };
} 

namespace ranges {
    template <class _From, class _To>
    concept _Uses_nonqualification_pointer_conversion =
        is_pointer_v<_From> && is_pointer_v<_To>
        && !convertible_to<remove_pointer_t<_From> (*)[], remove_pointer_t<_To> (*)[]>;

    template <class _From, class _To>
    concept _Convertible_to_non_slicing =
        convertible_to<_From, _To> && !_Uses_nonqualification_pointer_conversion<decay_t<_From>, decay_t<_To>>;











#line 3716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    template <class _Ty, class _First, class _Second>
    concept _Pair_like_convertible_from = !range<_Ty>

                                       && !is_reference_v<_Ty>
#line 3722 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
                                       && _Pair_like<_Ty> && constructible_from<_Ty, _First, _Second>
                                       && _Convertible_to_non_slicing<_First, tuple_element_t<0, _Ty>>
                                       && convertible_to<_Second, tuple_element_t<1, _Ty>>;

    template <class _It, class _Se, subrange_kind _Ki>
    concept _Store_size = (_Ki == subrange_kind::sized) && !sized_sentinel_for<_Se, _It>;

    template <class _It, class _Se, subrange_kind _Ki>
    class _Subrange_base : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type&) noexcept {}
    };

    template <class _It, class _Se, subrange_kind _Ki>
        requires _Store_size<_It, _Se, _Ki>
    class _Subrange_base<_It, _Se, _Ki> : public view_interface<subrange<_It, _Se, _Ki>> {
    protected:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

        _Size_type _Size = 0;

    public:
        _Subrange_base() = default;
        constexpr explicit _Subrange_base(const _Size_type& _Size_) noexcept : _Size(_Size_) {}
    };


#pragma warning(push)
#pragma warning(disable : 4324) 
#line 3756 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
     template <input_or_output_iterator _It, sentinel_for<_It> _Se, subrange_kind _Ki>
        requires (_Ki == subrange_kind::sized || !sized_sentinel_for<_Se, _It>)
    class subrange : public _Subrange_base<_It, _Se, _Ki> {
    private:
        using _Size_type = _Make_unsigned_like_t<iter_difference_t<_It>>;

        
         _It _First{};
         _Se _Last{};
        

        template <class _Rng>
        constexpr subrange(true_type, _Rng&& _Val)
            : subrange(::std:: forward<_Rng>(_Val), static_cast<_Size_type>(::std::ranges:: size(_Val))) {
            
            ;
        }

        template <class _Rng>
        constexpr subrange(false_type, _Rng&& _Val) : subrange(::std::ranges:: begin(_Val), ::std::ranges:: end(_Val)) {
            
            ;
        }

    public:
        
        subrange() requires default_initializable<_It> = default;
        

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_)
            requires (!_Store_size<_It, _Se, _Ki>)
            : _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {}

        template <_Convertible_to_non_slicing<_It> _It2>
        constexpr subrange(_It2 _First_, _Se _Last_, const _Size_type _Size_)
            requires (_Ki == subrange_kind::sized)
            : _Subrange_base<_It, _Se, _Ki>(_Size_), _First(::std:: move(_First_)), _Last(::std:: move(_Last_)) {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                ;
#line 3798 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            }
        }

        template <_Different_from<subrange> _Rng>
            requires (borrowed_range<_Rng> && _Convertible_to_non_slicing<iterator_t<_Rng>, _It>
                      && convertible_to<sentinel_t<_Rng>, _Se>)
        constexpr subrange(_Rng&& _Val)
            requires (!_Store_size<_It, _Se, _Ki> || sized_range<_Rng>)
            : subrange{bool_constant<_Store_size<_It, _Se, _Ki>>{}, ::std:: forward<_Rng>(_Val)} {}

        template <borrowed_range _Rng>
            requires (_Convertible_to_non_slicing<iterator_t<_Rng>, _It> && convertible_to<sentinel_t<_Rng>, _Se>)
        constexpr subrange(_Rng&& _Val, const _Size_type _Count)
            requires (_Ki == subrange_kind::sized)
            : subrange{::std::ranges:: begin(_Val), ::std::ranges:: end(_Val), _Count} {}

        template <_Different_from<subrange> _Pair_like>
            requires _Pair_like_convertible_from<_Pair_like, const _It&, const _Se&>
        constexpr operator _Pair_like() const {
            return _Pair_like(_First, _Last);
        }

        [[nodiscard]] constexpr _It begin() const
            requires copyable<_It>
        {
            return _First;
        }
        [[nodiscard]] constexpr _It begin()
            requires (!copyable<_It>)
        {
            return ::std:: move(_First);
        }

        [[nodiscard]] constexpr _Se end() const {
            return _Last;
        }

        [[nodiscard]] constexpr bool empty() const {
            return _First == _Last;
        }

        [[nodiscard]] constexpr _Size_type size() const
            requires (_Ki == subrange_kind::sized)
        {
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                return this->_Size;
            } else {
                return static_cast<_Size_type>(_Last - _First);
            }
        }

        [[nodiscard]] constexpr subrange next() const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            if (_Tmp._First != _Tmp._Last) {
                ++_Tmp._First;
                if constexpr (_Store_size<_It, _Se, _Ki>) {
                    --_Tmp._Size;
                }
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) const&
            requires forward_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(_Count);
            return _Tmp;
        }

        [[nodiscard]] constexpr subrange next() && {
            if (_First != _Last) {
                ++_First;
                if constexpr (_Store_size<_It, _Se, _Ki>) {
                    --this->_Size;
                }
            }
            return ::std:: move(*this);
        }
        [[nodiscard]] constexpr subrange next(const iter_difference_t<_It> _Count) && {
            advance(_Count);
            return ::std:: move(*this);
        }

        [[nodiscard]] constexpr subrange prev() const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            --_Tmp._First;
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                ++_Tmp._Size;
            }
            return _Tmp;
        }
        [[nodiscard]] constexpr subrange prev(const iter_difference_t<_It> _Count) const
            requires bidirectional_iterator<_It>
        {
            auto _Tmp = *this;
            _Tmp.advance(-_Count);
            return _Tmp;
        }

        constexpr subrange& advance(const iter_difference_t<_It> _Count) {
            if constexpr (bidirectional_iterator<_It>) {
                if (_Count < 0) {
                    ::std::ranges:: advance(_First, _Count);
                    if constexpr (_Store_size<_It, _Se, _Ki>) {
                        this->_Size += static_cast<_Size_type>(-_Count);
                    }
                    return *this;
                }
            }

            const auto _Remainder = ::std::ranges:: advance(_First, _Count, _Last);
            if constexpr (_Store_size<_It, _Se, _Ki>) {
                this->_Size -= static_cast<_Size_type>(_Count - _Remainder);
            }
            return *this;
        }
    };

#pragma warning(pop)
#line 3922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se) -> subrange<_It, _Se>;

    template <input_or_output_iterator _It, sentinel_for<_It> _Se>
    subrange(_It, _Se, _Make_unsigned_like_t<iter_difference_t<_It>>) -> subrange<_It, _Se, subrange_kind::sized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&) -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
        (sized_range<_Rng> || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>) ? subrange_kind::sized
                                                                                      : subrange_kind::unsized>;

    template <borrowed_range _Rng>
    subrange(_Rng&&, _Make_unsigned_like_t<range_difference_t<_Rng>>)
        -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

    template <class _It, class _Se, subrange_kind _Ki>
    inline constexpr bool enable_borrowed_range<subrange<_It, _Se, _Ki>> = true;

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires ((_Idx == 0 && copyable<_It>) || _Idx == 1)
    [[nodiscard]] constexpr auto get(const subrange<_It, _Se, _Ki>& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     template <size_t _Idx, class _It, class _Se, subrange_kind _Ki>
        requires (_Idx < 2)
    [[nodiscard]] constexpr auto get(subrange<_It, _Se, _Ki>&& _Val) {
        if constexpr (_Idx == 0) {
            return _Val.begin();
        } else {
            return _Val.end();
        }
    }

     struct dangling {
        constexpr dangling() noexcept = default;
        template <class... _Args>
        constexpr dangling(_Args&&...) noexcept {}
    };

     template <range _Rng>
    using borrowed_iterator_t = conditional_t<borrowed_range<_Rng>, iterator_t<_Rng>, dangling>;

     template <range _Rng>
    using borrowed_subrange_t = conditional_t<borrowed_range<_Rng>, subrange<iterator_t<_Rng>>, dangling>;
} 
#line 3974 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

struct _Container_proxy;
struct _Iterator_base12;

struct _Default_sentinel {}; 


 template <semiregular>
class move_sentinel;

template <class>
struct _Move_iterator_category {};


template <class _Iter>
    requires requires { typename _Iter_cat_t<_Iter>; }
struct _Move_iterator_category<_Iter> {
    using iterator_category = conditional_t<derived_from<_Iter_cat_t<_Iter>, random_access_iterator_tag>,
        random_access_iterator_tag, _Iter_cat_t<_Iter>>;
};






#line 4001 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Iter>
class move_iterator : public _Move_iterator_category<_Iter> {
public:
    using iterator_type   = _Iter;
    using value_type      = _Iter_value_t<_Iter>;
    using difference_type = _Iter_diff_t<_Iter>;
    using pointer         = _Iter;


private:
    static constexpr auto _Get_iter_concept() {
        if constexpr (random_access_iterator<_Iter>) {
            return random_access_iterator_tag{};
        } else if constexpr (bidirectional_iterator<_Iter>) {
            return bidirectional_iterator_tag{};
        } else if constexpr (forward_iterator<_Iter>) {
            return forward_iterator_tag{};
        } else {
            return input_iterator_tag{};
        }
    }

public:
    using iterator_concept = decltype(_Get_iter_concept());

    using reference = iter_rvalue_reference_t<_Iter>;



#line 4032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    constexpr move_iterator() = default;

    constexpr explicit move_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)) {}

    
    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
#line 4043 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    constexpr move_iterator(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()) {}

    template <class _Other>

        requires (!is_same_v<_Other, _Iter>) && convertible_to<const _Other&, _Iter>
            && assignable_from<_Iter&, const _Other&>
#line 4052 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    constexpr move_iterator& operator=(const move_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)  {
        _Current = _Right.base();
        return *this;
    }
    


    [[nodiscard]] constexpr const iterator_type& base() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type base() && noexcept(is_nothrow_move_constructible_v<_Iter>)  {
        return ::std:: move(_Current);
    }





#line 4072 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    [[nodiscard]] constexpr reference operator*() const

        noexcept(noexcept(::std::ranges:: iter_move(_Current)))  {
        return ::std::ranges:: iter_move(_Current);
    }




#line 4083 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    [[deprecated("warning STL4031: " "std::move_iterator::operator->() is deprecated in C++20. " "You can define _SILENCE_CXX20_MOVE_ITERATOR_ARROW_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] constexpr pointer operator->() const
        noexcept(is_nothrow_copy_constructible_v<_Iter>)  {
        return _Current;
    }

    constexpr move_iterator& operator++() noexcept(noexcept(++_Current))  {
        ++_Current;
        return *this;
    }

    constexpr auto operator++(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(++_Current))  {

        if constexpr (forward_iterator<_Iter>) {
#line 4099 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            move_iterator _Tmp = *this;
            ++_Current;
            return _Tmp;

        } else {
            ++_Current;
        }
#line 4107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    }

    constexpr move_iterator& operator--() noexcept(noexcept(--_Current))  {
        --_Current;
        return *this;
    }

    constexpr move_iterator operator--(int) noexcept(
        is_nothrow_copy_constructible_v<_Iter>&& noexcept(--_Current))  {
        move_iterator _Tmp = *this;
        --_Current;
        return _Tmp;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() == _Sentinel) {
        return _Current == _Sentinel;
    }

    template <class _Iter2 = _Iter>
    [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std:: declval<const _Iter2&>() != _Sentinel) {
        return _Current != _Sentinel;
    }

    [[nodiscard]] constexpr move_iterator operator+(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current + _Off)))  {
        return move_iterator(_Current + _Off);
    }

    constexpr move_iterator& operator+=(const difference_type _Off) noexcept(
        noexcept(_Current += _Off))  {
        _Current += _Off;
        return *this;
    }

    [[nodiscard]] constexpr move_iterator operator-(const difference_type _Off) const
        noexcept(noexcept(move_iterator(_Current - _Off)))  {
        return move_iterator(_Current - _Off);
    }

    constexpr move_iterator& operator-=(const difference_type _Off) noexcept(
        noexcept(_Current -= _Off))  {
        _Current -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const

        noexcept(noexcept(::std::ranges:: iter_move(_Current + _Off)))  {
        return ::std::ranges:: iter_move(_Current + _Off);



#line 4163 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    }


    template <sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr bool
        operator==(const move_iterator& _Left, const move_sentinel<_Sent>& _Right) noexcept(
            noexcept(_Fake_copy_init<bool>(_Left._Current == _Right._Get_last())))  {
        return _Left._Current == _Right._Get_last();
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_sentinel<_Sent>& _Left,
        const move_iterator& _Right) noexcept(noexcept(_Left._Get_last() - _Right._Current))  {
        return _Left._Get_last() - _Right._Current;
    }

    template <sized_sentinel_for<_Iter> _Sent>
    [[nodiscard]] friend constexpr difference_type operator-(const move_iterator& _Left,
        const move_sentinel<_Sent>& _Right) noexcept(noexcept(_Left._Current - _Right._Get_last()))  {
        return _Left._Current - _Right._Get_last();
    }

    [[nodiscard]] friend constexpr reference iter_move(const move_iterator& _It) noexcept(
        noexcept(::std::ranges:: iter_move(_It._Current))) {
        return ::std::ranges:: iter_move(_It._Current);
    }

    template <indirectly_swappable<_Iter> _Iter2>
    friend constexpr void iter_swap(const move_iterator& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(::std::ranges:: iter_swap(_Left._Current, _Right.base()))) {
        ::std::ranges:: iter_swap(_Left._Current, _Right.base());
    }
#line 4196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_current());
    }

    template <sentinel_for<_Iter> _Sent, enable_if_t<_Range_verifiable_v<_Iter, _Sent>, int> = 0>
    friend constexpr void _Verify_range(const move_iterator& _First, const move_sentinel<_Sent>& _Last) noexcept {
        _Verify_range(_First._Current, _Last._Get_last());
    }
#line 4207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    using _Prevent_inheriting_unwrap = move_iterator;

    template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        _Current._Verify_offset(_Off);
    }

    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const& noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(_Current._Unwrapped());
    }
    template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<_Iter2>, int> = 0>
    [[nodiscard]] constexpr move_iterator<_Unwrapped_t<_Iter2>> _Unwrapped() && noexcept(
        noexcept(static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped()))) {
        return static_cast<move_iterator<_Unwrapped_t<_Iter2>>>(::std:: move(_Current)._Unwrapped());
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, const _Src&>, int> = 0>
    constexpr void _Seek_to(const move_iterator<_Src>& _It) noexcept(noexcept(_Current._Seek_to(_It._Get_current()))) {
        _Current._Seek_to(_It._Get_current());
    }
    template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
    constexpr void _Seek_to(move_iterator<_Src>&& _It) noexcept(
        noexcept(_Current._Seek_to(::std:: move(_It)._Get_current()))) {
        _Current._Seek_to(::std:: move(_It)._Get_current());
    }

    [[nodiscard]] constexpr const iterator_type& _Get_current() const& noexcept {
        return _Current;
    }
    [[nodiscard]] constexpr iterator_type&& _Get_current() && noexcept {
        return ::std:: move(_Current);
    }

private:
    iterator_type _Current{};
};

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() == _Right.base()))) 

    
    requires requires {
        { _Left.base() == _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left.base() == _Right.base();
}







#line 4271 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool
    operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right) noexcept(
        noexcept(_Fake_copy_init<bool>(_Left.base() < _Right.base()))) 

    
    requires requires {
        { _Left.base() < _Right.base() } -> _Implicitly_convertible_to<bool>;
    }

#line 4283 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Left.base() < _Right.base();
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) 

    requires requires { _Right < _Left; }
#line 4293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return _Right < _Left;
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator<=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Right < _Left)) 

    requires requires { _Right < _Left; }
#line 4303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return !(_Right < _Left);
}

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr bool operator>=(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left < _Right)) 

    requires requires { _Left < _Right; }
#line 4313 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return !(_Left < _Right);
}


 template <class _Iter1, three_way_comparable_with<_Iter1> _Iter2>
[[nodiscard]] constexpr compare_three_way_result_t<_Iter1, _Iter2> operator<=>(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() <=> _Right.base()))  {
    return _Left.base() <=> _Right.base();
}
#line 4324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Iter1, class _Iter2>
[[nodiscard]] constexpr auto operator-(const move_iterator<_Iter1>& _Left,
    const move_iterator<_Iter2>& _Right) noexcept(noexcept(_Left.base() - _Right.base())) 
    -> decltype(_Left.base() - _Right.base()) {
    return _Left.base() - _Right.base();
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter>
    operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right) noexcept(
        noexcept(move_iterator<_Iter>(_Right.base() + _Off))) 

    
    requires requires {
        { _Right.base() + _Off } -> same_as<_Iter>;
    }

#line 4343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
{
    return move_iterator<_Iter>(_Right.base() + _Off);
}

 template <class _Iter>
[[nodiscard]] constexpr move_iterator<_Iter> make_move_iterator(_Iter _It) noexcept(
    is_nothrow_move_constructible_v<_Iter>)  {
    return move_iterator<_Iter>(::std:: move(_It));
}


template <class _Iter1, class _Iter2>
    requires (!sized_sentinel_for<_Iter1, _Iter2>)
inline constexpr bool disable_sized_sentinel_for<move_iterator<_Iter1>, move_iterator<_Iter2>> = true;

 struct unreachable_sentinel_t;
namespace _Unreachable_sentinel_detail {
    struct _Base {
        template <weakly_incrementable _Winc>
        [[nodiscard]] friend constexpr bool operator==(const unreachable_sentinel_t&, const _Winc&) noexcept {
            return false;
        }
    };
} 
 struct unreachable_sentinel_t : _Unreachable_sentinel_detail::_Base {}; 

 inline constexpr unreachable_sentinel_t unreachable_sentinel{};
#line 4371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"






template <class _Iter>
inline constexpr bool _Iterator_is_contiguous = contiguous_iterator<_Iter>;

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const _Iter& _Val) noexcept {
    ;
    return ::std:: to_address(_Val);
}










#line 4396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Iter>
[[nodiscard]] constexpr auto _To_address(const move_iterator<_Iter>& _Val) noexcept {
    return _To_address(_Val.base());
}



template <class _Iter1, class _Iter2>
inline constexpr bool _Iterators_are_contiguous =
    _Iterator_is_contiguous<_Iter1> && _Iterator_is_contiguous<_Iter2>;

template <class _Iter>
inline constexpr bool _Iterator_is_volatile = is_volatile_v<remove_reference_t<_Iter_ref_t<_Iter>>>;

template <class _Source, class _Dest>
inline constexpr bool _Is_pointer_address_convertible = is_void_v<_Source>
                                                          || is_void_v<_Dest>
                                                          
                                                          || is_same_v<remove_cv_t<_Source>, remove_cv_t<_Dest>>

                                                          || is_pointer_interconvertible_base_of_v<_Dest, _Source>
#line 4419 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    ;

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat {
    using _USource = _Unwrap_enum_t<_Source>;
    using _UDest   = _Unwrap_enum_t<_Dest>;

    static constexpr bool _Same_size_and_compatible =
        sizeof(_Source) == sizeof(_Dest)
        
        
        
        && is_same_v<bool, _USource> >= is_same_v<bool, _UDest>
        && (is_same_v<_USource, _UDest> || (is_integral_v<_USource> && is_integral_v<_UDest>)
            || (is_floating_point_v<_USource> && is_floating_point_v<_UDest>) );

    static constexpr bool _Bitcopy_constructible =
        _Same_size_and_compatible && is_trivially_constructible_v<_Dest, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Same_size_and_compatible && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

template <class _Source, class _Dest, class _SourceRef, class _DestRef>
struct _Trivial_cat<_Source*, _Dest*, _SourceRef, _DestRef> {
    static constexpr bool _Bitcopy_constructible =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_constructible_v<_Dest*, _SourceRef>;

    static constexpr bool _Bitcopy_assignable =
        _Is_pointer_address_convertible<_Source, _Dest> && is_trivially_assignable_v<_DestRef, _SourceRef>;
};

struct _False_trivial_cat {
    static constexpr bool _Bitcopy_constructible = false;
    static constexpr bool _Bitcopy_assignable    = false;
};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
                        && !_Iterator_is_volatile<_DestIt>>
struct _Iter_move_cat : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>,
                            remove_reference_t<_Iter_ref_t<_SourceIt>>&&, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_move_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _SourceIt, class _DestIt,
    bool _Are_contiguous = _Iterators_are_contiguous<_SourceIt, _DestIt> && !_Iterator_is_volatile<_SourceIt>
                        && !_Iterator_is_volatile<_DestIt>>
struct _Iter_copy_cat
    : _Trivial_cat<_Iter_value_t<_SourceIt>, _Iter_value_t<_DestIt>, _Iter_ref_t<_SourceIt>, _Iter_ref_t<_DestIt>> {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<_SourceIt, _DestIt, false> : _False_trivial_cat {};

template <class _SourceIt, class _DestIt>
struct _Iter_copy_cat<move_iterator<_SourceIt>, _DestIt, false> : _Iter_move_cat<_SourceIt, _DestIt> {};

template <class _Iter1, class _Sent1, class _Iter2>
constexpr void _Verify_ranges_do_not_overlap(const _Iter1& _First1, const _Sent1& _Last1, const _Iter2& _First2) {























#line 4506 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    (void) _First1;
    (void) _Last1;
    (void) _First2;
#line 4510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    :: memmove(_Dest_ch, _First_ch, _Count);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);
    } else {
        return _Dest + (_LastPtr - _FirstPtr);
    }
}

template <class _CtgIt, class _OutCtgIt>
_OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Count, _OutCtgIt _Dest) {
    const auto _Result = _Copy_memmove(_First, _First + _Count, _Dest);
    if constexpr (is_pointer_v<_OutCtgIt>) {
        return _Result;
    } else { 
        return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Count);
    }
}

template <class _It, bool _RequiresMutable = false>
inline constexpr bool _Is_vb_iterator = false;

template <class _InIt, class _SizeTy, class _OutIt>
constexpr _OutIt _Copy_n_unchecked4(_InIt _First, _SizeTy _Count, _OutIt _Dest) {
    
    

    ;
#line 4549 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    if constexpr (_Iter_copy_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4554 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);
        }
    }

    for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {
        *_Dest = *_First;
    }

    return _Dest;
}

template <class _InIt, class _Sent, class _OutIt>
using _Sent_copy_cat = conditional_t<

    is_same_v<_Sent, _InIt> || sized_sentinel_for<_Sent, _InIt>,


#line 4573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
    _Iter_copy_cat<_InIt, _OutIt>, _False_trivial_cat>;

template <class _InIt, class _Sent, class _OutIt>
constexpr _OutIt _Copy_unchecked(_InIt _First, _Sent _Last, _OutIt _Dest) {
    
    
    if constexpr (_Sent_copy_cat<_InIt, _Sent, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4583 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {

            if constexpr (is_same_v<_InIt, _Sent>)
#line 4587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            {
                return _Copy_memmove(_First, _Last, _Dest);
            }

            else {
                return _Copy_memmove_n(_First, static_cast<size_t>(_Last - _First), _Dest);
            }
#line 4595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = *_First;
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: copy(_First, _Last, _Dest);
}
#line 4625 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


namespace ranges {
    template <class _To, class _From>
    concept _Convertible_from = convertible_to<_From, _To>;

     template <class _In, class _Out>
    struct in_out_result {
         _In in;
         _Out out;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out&> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() const& {
            return {in, out};
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Out> _OOut>
        constexpr operator in_out_result<_IIn, _OOut>() && {
            return {::std:: move(in), ::std:: move(out)};
        }
    };

    template <forward_iterator _It, class _Se>
        requires sentinel_for<remove_cvref_t<_Se>, _It>
    [[nodiscard]] constexpr _Unwrap_iter_t<_It, _Se> _Get_final_iterator_unwrapped(
        const _Unwrap_iter_t<_It, _Se>& _UFirst, _Se&& _Last) {
        
        
        if constexpr (is_same_v<_Unwrap_iter_t<_It, _Se>, _Unwrap_sent_t<_Se, _It>>) {
            return _Unwrap_sent<_It>(::std:: forward<_Se>(_Last));
        } else {
            return ::std::ranges:: next(_UFirst, _Unwrap_sent<_It>(::std:: forward<_Se>(_Last)));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range) {
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            return ::std::ranges:: next(_Ubegin(_Range), ::std::ranges:: distance(_Range));
        } else {
            return ::std::ranges:: next(_Ubegin(_Range), _Uend(_Range));
        }
    }

    template <forward_range _Rng>
    [[nodiscard]] constexpr auto _Get_final_iterator_unwrapped(_Rng& _Range, const _Unwrapped_iterator_t<_Rng>& _Mid) {
        
        
        if constexpr (common_range<_Rng>) {
            if constexpr (same_as<decltype(_Uend(_Range)), _Unwrapped_iterator_t<_Rng>>) {
                return _Uend(_Range);
            } else {
                return _Unwrap_range_sent<_Rng>(::std::ranges:: end(_Range));
            }
        } else if constexpr (sized_range<_Rng>) {
            const auto _Dist = ::std::ranges:: distance(_Range);
            if constexpr (sized_sentinel_for<_Unwrapped_iterator_t<_Rng>, _Unwrapped_iterator_t<_Rng>>) {
                return ::std::ranges:: next(_Mid, _Dist - (_Mid - _Ubegin(_Range)));
            } else {
                return ::std::ranges:: next(_Ubegin(_Range), _Dist);
            }
        } else {
            return ::std::ranges:: next(_Mid, _Uend(_Range));
        }
    }


     template <class _Out, class _Ty>
    struct out_value_result {
         _Out out;
         _Ty value;

        template <_Convertible_from<const _Out&> _OOut, _Convertible_from<const _Ty&> _TTy>
        constexpr operator out_value_result<_OOut, _TTy>() const& {
            return {out, value};
        }

        template <_Convertible_from<_Out> _OOut, _Convertible_from<_Ty> _TTy>
        constexpr operator out_value_result<_OOut, _TTy>() && {
            return {::std:: move(out), ::std:: move(value)};
        }
    };
#line 4715 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

     template <class _In, class _Out>
    using copy_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
        requires indirectly_copyable<_It, _Out>
    [[nodiscard]] constexpr copy_result<_It, _Out> _Copy_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Sent_copy_cat<_It, _Se, _Out>::_Bitcopy_assignable) {
            if (!::std:: is_constant_evaluated()) {
                if constexpr (is_same_v<_It, _Se>) {
                    _Result = _Copy_memmove(::std:: move(_First), _Last, ::std:: move(_Result));
                    return {::std:: move(_Last), ::std:: move(_Result)};
                } else {
                    const auto _Count = static_cast<size_t>(_Last - _First);
                    _Result           = _Copy_memmove_n(_First, _Count, ::std:: move(_Result));
                    _First += _Count;
                    return {::std:: move(_First), ::std:: move(_Result)};
                }
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = *_First;
        }

        return {::std:: move(_First), ::std:: move(_Result)};
    }

    class _Copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Copy_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
            auto _First = ::std::ranges:: begin(_Range);
            auto _UResult =
                ::std::ranges:: _Copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), ::std:: move(_Result));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }
    };

     inline constexpr _Copy_fn copy{_Not_quite_object::_Construct_tag {}};
} 
#line 4771 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt, class _Diff, class _OutIt>
constexpr _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
        if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_assignable) {

            if (!::std:: is_constant_evaluated())
#line 4783 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            {
                _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
                _Seek_wrapped(_Dest, _UDest);
                return _Dest;
            }
        }

        for (;;) {
            *_UDest = *_UFirst;
            ++_UDest;
            --_Count;
            if (_Count == 0) { 
                               
                break;
            }

            ++_UFirst;
        }

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _Diff, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy_n(_ExPo&&, _FwdIt1 _First, _Diff _Count_raw, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: copy_n(_First, _Count_raw, _Dest);
}
#line 4818 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _CtgIt1, class _CtgIt2>
_CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {
    
    auto _FirstPtr              = _To_address(_First);
    auto _LastPtr               = _To_address(_Last);
    auto _DestPtr               = _To_address(_Dest);
    const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
    const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
    char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
    const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);
    auto _Result                = :: memmove(_Dest_ch - _Count, _First_ch, _Count);
    if constexpr (is_pointer_v<_CtgIt2>) {
        return static_cast<_CtgIt2>(_Result);
    } else {
        return _Dest - (_LastPtr - _FirstPtr);
    }
}

template <class _BidIt1, class _BidIt2>
_BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest) {
    return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
}

template <class _BidIt1, class _BidIt2>
[[nodiscard]] constexpr _BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    if constexpr (_Iter_copy_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4849 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = *--_Last;
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Copy_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _OutIt>
constexpr _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    
    if constexpr (_Iter_move_cat<_InIt, _OutIt>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4880 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    for (; _First != _Last; ++_Dest, (void) ++_First) {
        *_Dest = ::std:: move(*_First);
    }

    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 move(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt1>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: move(_First, _Last, _Dest);
}
#line 4913 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    
    if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {

        if (!::std:: is_constant_evaluated())
#line 4922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
    }

    while (_First != _Last) {
        *--_Dest = ::std:: move(*--_Last);
    }

    return _Dest;
}

 template <class _BidIt1, class _BidIt2>
constexpr _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _Ty>
struct _Is_character : false_type {}; 

template <>
struct _Is_character<char> : true_type {}; 

template <>
struct _Is_character<signed char> : true_type {}; 

template <>
struct _Is_character<unsigned char> : true_type {}; 


template <>
struct _Is_character<char8_t> : true_type {}; 
#line 4961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Ty>
struct _Is_character_or_bool : _Is_character<_Ty>::type {};

template <>
struct _Is_character_or_bool<bool> : true_type {};

template <class _Ty>
struct _Is_character_or_byte_or_bool : _Is_character_or_bool<_Ty>::type {};


template <>
struct _Is_character_or_byte_or_bool<byte> : true_type {};
#line 4975 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"



template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_memset_is_safe = conjunction_v<is_scalar<_Ty>,
    _Is_character_or_byte_or_bool<_Unwrap_enum_t<remove_reference_t<_Iter_ref_t<_FwdIt>>>>,
    negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _FwdIt, class _Ty, bool = _Iterator_is_contiguous<_FwdIt>>
inline constexpr bool _Fill_zero_memset_is_safe =
    conjunction_v<is_scalar<_Ty>, is_scalar<_Iter_value_t<_FwdIt>>, negation<is_member_pointer<_Iter_value_t<_FwdIt>>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_FwdIt>>>>, is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

template <class _FwdIt, class _Ty>
inline constexpr bool _Fill_zero_memset_is_safe<_FwdIt, _Ty, false> = false;

template <class _CtgIt, class _Ty>
void _Fill_memset(_CtgIt _Dest, const _Ty _Val, const size_t _Count) {
    
    _Iter_value_t<_CtgIt> _Dest_val = _Val;
    :: memset(_To_address(_Dest), static_cast<unsigned char>(_Dest_val), _Count);
}

template <class _CtgIt>
void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {
    :: memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));
}

template <class _Ty>
[[nodiscard]] bool _Is_all_bits_zero(const _Ty& _Val) {
    
    ;
    if constexpr (is_same_v<_Ty, nullptr_t>) {
        return true;
    } else {
        constexpr _Ty _Zero{};
        return :: memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;
    }
}

 template <class _FwdIt, class _Ty>
constexpr void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_FwdIt, true>) {
        _Fill_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        if (!::std:: is_constant_evaluated())
#line 5030 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
                return;
            } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                if (_Is_all_bits_zero(_Val)) {
                    _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                    return;
                }
            }
        }

        for (; _UFirst != _ULast; ++_UFirst) {
            *_UFirst = _Val;
        }
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void fill(_ExPo&&, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: fill(_First, _Last, _Val);
}
#line 5057 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _OutIt, class _Diff, class _Ty>
constexpr _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        if constexpr (_Is_vb_iterator<_OutIt, true>) {
            const auto _Last = _Dest + static_cast<typename _OutIt::difference_type>(_Count);
            _Fill_vbool(_Dest, _Last, _Val);
            return _Last;
        } else {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);

            if (!::std:: is_constant_evaluated())
#line 5072 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            {
                if constexpr (_Fill_memset_is_safe<decltype(_UDest), _Ty>) {
                    _Fill_memset(_UDest, _Val, static_cast<size_t>(_Count));
                    _Seek_wrapped(_Dest, _UDest + _Count);
                    return _Dest;
                } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UDest), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UDest, static_cast<size_t>(_Count));
                        _Seek_wrapped(_Dest, _UDest + _Count);
                        return _Dest;
                    }
                }
            }

            for (; 0 < _Count; --_Count, (void) ++_UDest) {
                *_UDest = _Val;
            }

            _Seek_wrapped(_Dest, _UDest);
        }
    }
    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt fill_n(_ExPo&&, _FwdIt _Dest, _Diff _Count_raw, const _Ty& _Val) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: fill_n(_Dest, _Count_raw, _Val);
}
#line 5105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


namespace ranges {
    class _Fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, output_iterator<const _Ty&> _It>
        constexpr _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Value) const {
            if (_Count > 0) {
                auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
                if (!::std:: is_constant_evaluated()) {
                    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                        _Fill_memset(_UFirst, _Value, static_cast<size_t>(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count); 
                        return _First;
                    } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                        if (_Is_all_bits_zero(_Value)) {
                            _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                            _Seek_wrapped(_First, _UFirst + _Count); 
                            return _First;
                        }
                    }
                }

                for (; _Count > 0; ++_UFirst, (void) --_Count) {
                    *_UFirst = _Value;
                }

                _Seek_wrapped(_First, ::std:: move(_UFirst));
            }

            return _First;
        }
    };

     inline constexpr _Fill_n_fn fill_n{_Not_quite_object::_Construct_tag {}};
} 
#line 5144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Ty1, class _Ty2, class = void>
inline constexpr bool _Can_compare_with_operator_equal = false;

template <class _Ty1, class _Ty2>
inline constexpr bool
    _Can_compare_with_operator_equal<_Ty1, _Ty2, void_t<decltype(::std:: declval<_Ty1&>() == ::std:: declval<_Ty2&>())>> =
        true;

template <class _Ty1, class _Ty2>
inline constexpr bool _Is_pointer_address_comparable =
    _Can_compare_with_operator_equal<_Ty1*, _Ty2*>
    && (_Is_pointer_address_convertible<_Ty1, _Ty2> || _Is_pointer_address_convertible<_Ty2, _Ty1>);








#pragma warning(push)
#pragma warning(disable : 4806) 
template <class _Elem1, class _Elem2,
    bool = sizeof(_Elem1) == sizeof(_Elem2) && is_integral_v<_Elem1>&& is_integral_v<_Elem2>>
inline constexpr bool _Can_memcmp_elements =
    is_same_v<_Elem1, bool> || is_same_v<_Elem2, bool> || static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1);
#pragma warning(pop)





template <>
inline constexpr bool _Can_memcmp_elements<byte, byte, false> = true;
#line 5180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"



template <class _Ty1, class _Ty2>
inline constexpr bool _Can_memcmp_elements<_Ty1*, _Ty2*, false> = _Is_pointer_address_comparable<_Ty1, _Ty2>;

template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements<_Elem1, _Elem2, false> = false;




template <class _Elem1, class _Elem2, class _Pr>
inline constexpr bool _Can_memcmp_elements_with_pred = false;



template <class _Elem1, class _Elem2, class _Elem3>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<_Elem3>> =
    _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible
    && _Can_memcmp_elements<remove_cv_t<_Elem3>, remove_cv_t<_Elem3>>;


template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, equal_to<>> =
    _Can_memcmp_elements<_Elem1, _Elem2>;



template <class _Elem1, class _Elem2>
inline constexpr bool _Can_memcmp_elements_with_pred<_Elem1, _Elem2, ::std::ranges:: equal_to> =
    _Can_memcmp_elements<_Elem1, _Elem2>;
#line 5213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"




template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe_helper =
    _Iterators_are_contiguous<_Iter1, _Iter2> && !_Iterator_is_volatile<_Iter1> && !_Iterator_is_volatile<_Iter2>
    && _Can_memcmp_elements_with_pred<_Iter_value_t<_Iter1>, _Iter_value_t<_Iter2>, _Pr>;

template <class _Iter1, class _Iter2, class _Pr>
inline constexpr bool _Equal_memcmp_is_safe =
    _Equal_memcmp_is_safe_helper<remove_const_t<_Iter1>, remove_const_t<_Iter2>, _Pr>;

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_ranges(_CtgIt1 _First1, _CtgIt1 _Last1, _CtgIt2 _First2) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _Last1_ch  = reinterpret_cast<const char*>(_To_address(_Last1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, static_cast<size_t>(_Last1_ch - _First1_ch));
}

template <class _CtgIt1, class _CtgIt2>
[[nodiscard]] int _Memcmp_count(_CtgIt1 _First1, _CtgIt2 _First2, const size_t _Count) {
    ;
    const auto _First1_ch = reinterpret_cast<const char*>(_To_address(_First1));
    const auto _First2_ch = reinterpret_cast<const char*>(_To_address(_First2));
    return :: memcmp(_First1_ch, _First2_ch, _Count * sizeof(_Iter_value_t<_CtgIt1>));
}

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    if constexpr (_Equal_memcmp_is_safe<decltype(_UFirst1), decltype(_UFirst2), _Pr>) {

        if (!::std:: is_constant_evaluated())
#line 5254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            return _Memcmp_ranges(_UFirst1, _ULast1, _UFirst2) == 0;
        }
    }

    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) {
        if (!_Pred(*_UFirst1, *_UFirst2)) {
            return false;
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2,
    _Pr _Pred) noexcept; 
#line 5273 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: equal(_First1, _Last1, _First2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept
 {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
}
#line 5288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        return ::std:: equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    } else {
        for (;;) {
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) {
                return false;
            }

            ++_UFirst1;
            ++_UFirst2;
        }
    }
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; 
#line 5330 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool equal(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: equal(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool equal(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept  {
    
    return ::std:: equal(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 5346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


namespace ranges {
    template <forward_range _Rng, class _It>
    [[nodiscard]] constexpr iterator_t<_Rng> _Rewrap_iterator(_Rng&& _Range, _It&& _Val) {
        ;

        if constexpr (is_same_v<remove_cvref_t<_It>, iterator_t<_Rng>>) {
            return ::std:: forward<_It>(_Val);
        } else {
            auto _Result = ::std::ranges:: begin(_Range);
            _Result._Seek_to(::std:: forward<_It>(_Val));
            return _Result;
        }
    }

     template <class _In1, class _In2>
    struct in_in_result {
         _In1 in1;
         _In2 in2;

        template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() const& {
            return {in1, in2};
        }

        template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2>
        constexpr operator in_in_result<_IIn1, _IIn2>() && {
            return {::std:: move(in1), ::std:: move(in2)};
        }
    };

     template <class _In1, class _In2>
    using mismatch_result = in_in_result<_In1, _In2>;

    
    template <input_iterator _It1, input_iterator _It2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_n(
        _It1 _First1, _It2 _First2, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        ;
        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr,
        class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr mismatch_result<_It1, _It2> _Mismatch_4(
        _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {

        for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                break;
            }
        }

        return {::std:: move(_First1), ::std:: move(_First2)};
    }

    class _Mismatch_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1,
            _It2 _First2, _Se2 _Last2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                iter_difference_t<_It1> _Count1       = _Last1 - _First1;
                const iter_difference_t<_It2> _Count2 = _Last2 - _First2;
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<decltype(_Count1)>(_Count2);
                }

                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                    _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                    _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr mismatch_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                range_difference_t<_Rng1> _Count1       = ::std::ranges:: distance(_Range1);
                const range_difference_t<_Rng2> _Count2 = ::std::ranges:: distance(_Range2);
                if (_Count1 > _Count2) {
                    _Count1 = static_cast<range_difference_t<_Rng1>>(_Count2);
                }

                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_n(_Get_unwrapped(::std:: move(_First1)),
                    _Get_unwrapped(::std:: move(_First2)), _Count1, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            } else {
                auto _First1 = ::std::ranges:: begin(_Range1);
                auto _First2 = ::std::ranges:: begin(_Range2);
                auto _Result = ::std::ranges:: _Mismatch_4(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                    _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
                    _Pass_fn(_Proj2));
                _Seek_wrapped(_First1, ::std:: move(_Result.in1));
                _Seek_wrapped(_First2, ::std:: move(_Result.in2));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }
        }
    };

     inline constexpr _Mismatch_fn mismatch{_Not_quite_object::_Construct_tag {}};
} 
#line 5483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Elem1, class _Elem2>
inline constexpr bool _Lex_compare_memcmp_classify_elements = conjunction_v<_Is_character_or_bool<_Elem1>,
    _Is_character_or_bool<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>;


template <>
inline constexpr bool _Lex_compare_memcmp_classify_elements<byte, byte> = true;
#line 5492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Elem1, class _Elem2, class _Pr>
struct _Lex_compare_memcmp_classify_pred {
    using _Pred = void;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, less<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2, class _Elem3>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<_Elem3>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem3, _Elem3>
                                    && _Iter_copy_cat<_Elem1*, _Elem3*>::_Bitcopy_constructible
                                    && _Iter_copy_cat<_Elem2*, _Elem3*>::_Bitcopy_constructible,
        greater<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, greater<>> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};


template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: less> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, less<int>, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_memcmp_classify_pred<_Elem1, _Elem2, ::std::ranges:: greater> {
    using _Pred = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>, greater<int>, void>;
};
#line 5535 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _It1, class _It2, class _Pr>
using _Lex_compare_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_memcmp_classify_pred<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Pr>::_Pred, void>;

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Pr>;
    if constexpr (!is_void_v<_Memcmp_pred>) {

        if (!::std:: is_constant_evaluated())
#line 5557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            return _Memcmp_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
        }
    }

    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1, (void) ++_UFirst2) { 
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) {
            return true;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            return false;
        }
    }

    return _UFirst1 == _ULast1 && _UFirst2 != _ULast2;
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool lexicographical_compare(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool lexicographical_compare(_ExPo&&, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: lexicographical_compare(_First1, _Last1, _First2, _Last2);
}
#line 5604 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


template <class _Elem1, class _Elem2, class _Cmp>
struct _Lex_compare_three_way_memcmp_classify_comp {
    using _Comp = void;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, compare_three_way> {
    using _Comp = conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2>
                                    && three_way_comparable_with<const _Elem1&, const _Elem2&>,
        compare_three_way, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Strong_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_strong_order<_Elem1, _Elem2>,
            _Strong_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Weak_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_weak_order<_Elem1, _Elem2>,
            _Weak_order::_Cpo, void>;
};

template <class _Elem1, class _Elem2>
struct _Lex_compare_three_way_memcmp_classify_comp<_Elem1, _Elem2, _Partial_order::_Cpo> {
    using _Comp =
        conditional_t<_Lex_compare_memcmp_classify_elements<_Elem1, _Elem2> && _Can_partial_order<_Elem1, _Elem2>,
            _Partial_order::_Cpo, void>;
};

template <class _It1, class _It2, class _Cmp>
using _Lex_compare_three_way_memcmp_classify =
    conditional_t<_Iterators_are_contiguous<_It1, _It2> && !_Iterator_is_volatile<_It1> && !_Iterator_is_volatile<_It2>,
        typename _Lex_compare_three_way_memcmp_classify_comp<_Iter_value_t<_It1>, _Iter_value_t<_It2>, _Cmp>::_Comp,
        void>;

 template <class _InIt1, class _InIt2, class _Cmp>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(const _InIt1 _First1, const _InIt1 _Last1,
    const _InIt2 _First2, const _InIt2 _Last2, _Cmp _Comp) -> decltype(_Comp(*_First1, *_First2)) {
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);

    using _Memcmp_pred = _Lex_compare_three_way_memcmp_classify<decltype(_UFirst1), decltype(_UFirst2), _Cmp>;
    if constexpr (!is_void_v<_Memcmp_pred>) {
        if (!::std:: is_constant_evaluated()) {
            const auto _Num1 = static_cast<size_t>(_ULast1 - _UFirst1);
            const auto _Num2 = static_cast<size_t>(_ULast2 - _UFirst2);
            const int _Ans   = _Memcmp_count(_UFirst1, _UFirst2, (::std:: min)(_Num1, _Num2));
            if (_Ans == 0) {
                return _Num1 <=> _Num2;
            } else {
                return _Memcmp_pred{}(_Ans, 0);
            }
        }
    }

    for (;;) {
        if (_UFirst1 == _ULast1) {
            return _UFirst2 == _ULast2 ? strong_ordering::equal : strong_ordering::less;
        }

        if (_UFirst2 == _ULast2) {
            return strong_ordering::greater;
        }

        if (const auto _CmpResult = _Comp(*_UFirst1, *_UFirst2); _CmpResult != 0) {
            return _CmpResult;
        }

        ++_UFirst1;
        ++_UFirst2;
    }
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr auto lexicographical_compare_three_way(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2) {
    return ::std:: lexicographical_compare_three_way(_First1, _Last1, _First2, _Last2, compare_three_way{});
}
#line 5693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Ty, class _Elem>
struct _Vector_alg_in_find_is_safe_object_pointers : false_type {};
template <class _Ty1, class _Ty2>
struct _Vector_alg_in_find_is_safe_object_pointers<_Ty1*, _Ty2*>
    : conjunction<
          
          disjunction<is_object<_Ty1>, is_void<_Ty1>>,
          
          disjunction<is_object<_Ty2>, is_void<_Ty2>>,
          
          disjunction<is_same<remove_cv_t<_Ty1>, remove_cv_t<_Ty2>>, is_void<_Ty1>, is_void<_Ty2>>> {};


template <class _Iter, class _Ty, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Vector_alg_in_find_is_safe =
    
    _Iterator_is_contiguous<_Iter>
    
    && !_Iterator_is_volatile<_Iter>
    
    && disjunction_v<

        
        conjunction<is_same<_Ty, byte>, is_same<_Elem, byte>>,
#line 5719 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
       
       
        conjunction<is_integral<_Ty>, is_integral<_Elem>>,
        
        conjunction<is_pointer<_Ty>, is_same<_Ty, _Elem>>,
        
        conjunction<is_same<_Ty, nullptr_t>, is_pointer<_Elem>>,
        
        
        
        _Vector_alg_in_find_is_safe_object_pointers<_Ty, _Elem>>;

template <class _InIt, class _Ty>
[[nodiscard]] constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {
    
    ;

    if constexpr (disjunction_v<

                      is_same<_Ty, byte>,
#line 5740 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
                      is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
        return true;
    } else {
        using _Elem = _Iter_value_t<_InIt>;
        ;

        if constexpr (is_same_v<_Elem, bool>) {
            return _Val == true || _Val == false;
        } else if constexpr (is_signed_v<_Elem>) {
            
            constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * 8 - 1));
            constexpr _Elem _Max = static_cast<_Elem>(~_Min);

            if constexpr (is_signed_v<_Ty>) {
                
                return _Min <= _Val && _Val <= _Max;
            } else {
                
                if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
                    
                    return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
                } else {
                    
                    return _Val <= _Max;
                }
            }
        } else {
            constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});

            if constexpr (is_unsigned_v<_Ty>) {
                
                return _Val <= _Max;
            } else {
                
                if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
                    
                    return _Val <= _Max;
                } else {
                    
                    return 0 <= _Val && _Val <= _Max;
                }
            }
        }
    }
}

template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    
    if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {

        if (!::std:: is_constant_evaluated())
#line 5794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            if (!::std:: _Could_compare_equal_to_value_type<_InIt>(_Val)) {
                return _Last;
            }

            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);
            if constexpr (is_pointer_v<_InIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }












#line 5819 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        }
    }

    for (; _First != _Last; ++_First) {
        if (*_First == _Val) {
            break;
        }
    }

    return _First;
}

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { 
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Find_vbool(_First, _Last, _Val);
    } else {
        _Seek_wrapped(_First, ::std:: _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 5846 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


namespace ranges {
    template <class _Se, class _It>
    concept _Sized_or_unreachable_sentinel_for = sized_sentinel_for<_Se, _It> || same_as<_Se, unreachable_sentinel_t>;

    template <class _Rng>
    concept _Sized_or_infinite_range =
        range<_Rng> && (sized_range<_Rng> || same_as<sentinel_t<_Rng>, unreachable_sentinel_t>);

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
        requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
    [[nodiscard]] constexpr _It _Find_unchecked(_It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj = {}) {
        constexpr bool _Is_sized = sized_sentinel_for<_Se, _It>;
        if constexpr (_Vector_alg_in_find_is_safe<_It, _Ty> && _Sized_or_unreachable_sentinel_for<_Se, _It>
                      && same_as<_Pj, identity>) {
            if (!::std:: is_constant_evaluated()) {
                if (!::std:: _Could_compare_equal_to_value_type<_It>(_Val)) {
                    if constexpr (_Is_sized) {
                        return ::std::ranges:: next(::std:: move(_First), _Last);
                    } else {
                        ;
#line 5870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
                    }
                }

                using _Ptr_t = remove_reference_t<_Iter_ref_t<_It>>*;

                const auto _First_ptr = _To_address(_First);

                _Ptr_t _Result;

                if constexpr (_Is_sized) {
                    const auto _Last_ptr = _First_ptr + (_Last - _First);

                    _Result = __std_find_trivial(_First_ptr, _Last_ptr, _Val);
                } else {
                    _Result = __std_find_trivial_unsized(_First_ptr, _Val);
                }

                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return ::std::ranges:: next(::std:: move(_First), _Result - _First_ptr);
                }



























#line 5920 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            }
        }

        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Proj, *_First) == _Val) {
                break;
            }
        }

        return _First;
    }

    class _Find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_fn find{_Not_quite_object::_Construct_tag {}};
} 
#line 5965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt, class _Ty>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
        return _Count_vbool(_First, _Last, _Val);
    } else {
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);


        if constexpr (_Vector_alg_in_find_is_safe<decltype(_UFirst), _Ty>) {

            if (!::std:: is_constant_evaluated())
#line 5981 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            {
                if (!::std:: _Could_compare_equal_to_value_type<decltype(_UFirst)>(_Val)) {
                    return 0;
                }

                return static_cast<_Iter_diff_t<_InIt>>(
                    __std_count_trivial(_To_address(_UFirst), _To_address(_ULast), _Val));
            }
        }
#line 5991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        _Iter_diff_t<_InIt> _Count = 0;

        for (; _UFirst != _ULast; ++_UFirst) {
            if (*_UFirst == _Val) {
                ++_Count;
            }
        }

        return _Count;
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _Iter_diff_t<_FwdIt> count(
    _ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; 
#line 6009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _InIt _Find_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            break;
        }
    }

    return _First;
}

template <class _InIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> _Count_pr(_InIt _First, const _InIt _Last, const _Ty& _Val, _Pr _Pred) {
    _Iter_diff_t<_InIt> _Count = 0;

    for (; _First != _Last; ++_First) {
        if (_Pred(*_First, _Val)) {
            ++_Count;
        }
    }

    return _Count;
}

enum class _TrimResult : unsigned char { _KeepTrimming, _HaveWorkAfterTrimming, _ReturnFalse, _ReturnTrue };

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_equal(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
    ;
    ;
    if (_Pred(*_First1, *_First2)) {
        do {
            ++_First1;
            ++_First2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_First2));
    } else {
        if (!_Pred(*_Back1, *_Back2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        --_Back2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_Back2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        --_Back2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_reversed(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    
    ;
    ;
    if (_Pred(*_First1, *_Back2)) {
        do {
            ++_First1;
            --_Back2;
            if (_First1 == _Back1) {
                
                return _Pred(*_First1, *_First2) ? _TrimResult::_ReturnTrue : _TrimResult::_ReturnFalse;
            }
        } while (_Pred(*_First1, *_Back2));
    } else {
        if (!_Pred(*_Back1, *_First2)) {
            
            return _TrimResult::_HaveWorkAfterTrimming;
        }
        --_Back1;
        ++_First2;
    }

    for (;;) {
        if (_First1 == _Back1) {
            
            return _TrimResult::_ReturnFalse;
        }

        if (!_Pred(*_Back1, *_First2)) {
            return _TrimResult::_KeepTrimming;
        }
        --_Back1;
        ++_First2;
    }
}

template <class _BidIt1, class _BidIt2, class _Pr>
[[nodiscard]] constexpr _TrimResult _Trim_completely(
    _BidIt1& _First1, _BidIt1& _Back1, _BidIt2& _First2, _BidIt2& _Back2, _Pr _Pred) {
    
    _TrimResult _Res = _TrimResult::_KeepTrimming;

    for (bool _Check_reversed = true; _Res == _TrimResult::_KeepTrimming; _Check_reversed = !_Check_reversed) {
        if (_Check_reversed) {
            _Res = _Trim_reversed(_First1, _Back1, _First2, _Back2, _Pred);
        } else {
            _Res = _Trim_equal(_First1, _Back1, _First2, _Back2, _Pred);
        }
    }

    return _Res;
}

template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr bool _Check_match_counts(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    ;
    ;
    if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        do { 
            --_Last1;
            --_Last2;
        } while (_Pred(*_Last1, *_Last2));

        if (_First1 == _Last1) {
            return false;
        }

        const _TrimResult _Res = _Trim_completely(_First1, _Last1, _First2, _Last2, _Pred);

        if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
            return _Res == _TrimResult::_ReturnTrue;
        }

        ++_Last1;
        ++_Last2;
    }

    for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1) {
        if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred)) { 
            _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
            if (_Count2 == 0) {
                return false; 
            }

            _FwdIt1 _Skip1                = _Next_iter(_Next1);
            _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
            if (_Count2 != _Count1) {
                return false; 
            }
        }
    }

    return true;
}

 template <class _BidIt>
constexpr void reverse(const _BidIt _First, const _BidIt _Last) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);

    using _Elem                         = remove_reference_t<_Iter_ref_t<decltype(_UFirst)>>;
    constexpr bool _Allow_vectorization = conjunction_v<bool_constant<_Iterator_is_contiguous<decltype(_UFirst)>>,
        _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {

        if (!::std:: is_constant_evaluated())
#line 6190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_trivially_swappable_1(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 2) {
                __std_reverse_trivially_swappable_2(_To_address(_UFirst), _To_address(_ULast));
            } else if constexpr (_Nx == 4) {
                __std_reverse_trivially_swappable_4(_To_address(_UFirst), _To_address(_ULast));
            } else {
                __std_reverse_trivially_swappable_8(_To_address(_UFirst), _To_address(_ULast));
            }

            return;
        }
    }
#line 6205 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    for (; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst) {
        swap(*_UFirst, *_ULast); 
    }
}


 template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void reverse(_ExPo&&, _BidIt _First, _BidIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_bidi_iter_v<_BidIt>, "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.");
    return ::std:: reverse(_First, _Last);
}
#line 6220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _BidIt>
constexpr pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last) {
    
    while (_First != _Sentinel && _Last != _Sentinel) {
        swap(*_First, *--_Last); 
        ++_First;
    }

    return pair<_BidIt, _BidIt>(_First, _Last);
}

 template <class _FwdIt>
constexpr _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last) {
    
    
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    auto _UMid        = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _UMid) {
        return _Last;
    }

    if (_UMid == _ULast) {
        return _First;
    }

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        ::std:: reverse(_UFirst, _ULast);
        _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
    } else if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        ::std:: reverse(_UFirst, _UMid);
        ::std:: reverse(_UMid, _ULast);
        auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
        ::std:: reverse(_Tmp.first, _Tmp.second);
        _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
    } else {
        auto _UNext = _UMid;
        do { 
            swap(*_UFirst, *_UNext); 
            ++_UFirst;
            ++_UNext;
            if (_UFirst == _UMid) {
                _UMid = _UNext;
            }
        } while (_UNext != _ULast);
        _Seek_wrapped(_First, _UFirst);
        while (_UMid != _ULast) { 
            _UNext = _UMid;
            do {
                swap(*_UFirst, *_UNext); 
                ++_UFirst;
                ++_UNext;
                if (_UFirst == _UMid) {
                    _UMid = _UNext;
                }
            } while (_UNext != _ULast);
        }
    }

    return _First;
}


 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt rotate(_ExPo&&, _FwdIt _First, _FwdIt _Mid, _FwdIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: rotate(_First, _Mid, _Last);
}
#line 6297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


namespace ranges {
    template <class _Result, class _Wrapped, class _Unwrapped>
    [[nodiscard]] constexpr _Result _Rewrap_subrange(_Wrapped& _Val, subrange<_Unwrapped>&& _UResult) {
        
        if constexpr (is_same_v<_Result, dangling>) {
            return dangling{};
        } else if constexpr (is_same_v<_Result, subrange<_Unwrapped>>) {
            return ::std:: move(_UResult);
        } else if constexpr (range<_Wrapped>) {
            ;
            ;
            ;

            auto _First = ::std::ranges:: begin(_Val);
            auto _Last  = _First;
            _First._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_First), ::std:: move(_Last)};
        } else {
            ;
            ;

            auto _Last = _Val;
            _Val._Seek_to(_UResult.begin());
            _Last._Seek_to(_UResult.end());
            return _Result{::std:: move(_Val), ::std:: move(_Last)};
        }
    }

    
    template <input_iterator _It, sentinel_for<_It> _Se, class _Pj, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
    [[nodiscard]] constexpr _It _Find_if_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        for (; _First != _Last; ++_First) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                break;
            }
        }

        return _First;
    }

    class _Find_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = ::std::ranges:: _Find_if_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }
    };

     inline constexpr _Find_if_fn find_if{_Not_quite_object::_Construct_tag {}};

    class _Find_if_not_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Find_if_not_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);

            auto _UResult = _Find_if_not_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Find_if_not_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    break;
                }
            }

            return _First;
        }
    };

     inline constexpr _Find_if_not_fn find_if_not{_Not_quite_object::_Construct_tag {}};

    class _Adjacent_find_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_binary_predicate<projected<_It, _Pj>, projected<_It, _Pj>> _Pr = ranges::equal_to>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _Adjacent_find_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_binary_predicate<projected<iterator_t<_Rng>, _Pj>, projected<iterator_t<_Rng>, _Pj>> _Pr =
                ranges::equal_to>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Adjacent_find_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Adjacent_find_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            if (_First == _Last) {
                return _First;
            }

            for (auto _Next = _First;; ++_First) {
                if (++_Next == _Last) {
                    return _Next;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Next))) {
                    return _First;
                }
            }
        }
    };

     inline constexpr _Adjacent_find_fn adjacent_find{_Not_quite_object::_Construct_tag {}};

    
    template <class _It1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
    concept _Equal_rev_pred_can_memcmp = is_same_v<_Pj1, identity> && is_same_v<_Pj2, identity>
        && sized_sentinel_for<_Se2, _It2> && _Equal_memcmp_is_safe<_It1, _It2, _Pr>;

    template <input_iterator _It1, input_iterator _It2, sentinel_for<_It2> _Se2, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr pair<bool, _It1> _Equal_rev_pred(
        _It1 _First1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        
        
        constexpr bool _Optimize = _Equal_rev_pred_can_memcmp<_It1, _It2, _Se2, _Pr, _Pj1, _Pj2>;
        if constexpr (_Optimize) {
            if (!::std:: is_constant_evaluated()) {
                bool _Ans;
                if constexpr (same_as<_It2, _Se2>) {
                    _Ans = _Memcmp_ranges(_First2, _Last2, _First1) == 0;
                } else {
                    _Ans = _Memcmp_count(_First1, _First2, static_cast<size_t>(_Last2 - _First2)) == 0;
                }

                if (_Ans) {
                    _First1 += (_Last2 - _First2);
                    return {true, ::std:: move(_First1)};
                } else {
                    return {false, _It1 {}};
                }
            }
        }

        for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                return {false, _It1 {}};
            }
        }

        return {true, ::std:: move(_First1)};
    }

    class _Search_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Search_sized(::std:: move(_UFirst1), ::std:: move(_ULast1), _Count1, ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                const auto _Count1 = ::std::ranges:: distance(_Range1);
                const auto _Count2 = ::std::ranges:: distance(_Range2);
                auto _UResult      = _Search_sized(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2),
                         _Uend(_Range2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_sized(_It1 _First1, const _Se1 _Last1,
            iter_difference_t<_It1> _Count1, _It2 _First2, const _Se2 _Last2, const iter_difference_t<_It2> _Count2,
            _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;
            ;

            for (; _Count1 >= _Count2; ++_First1, (void) --_Count1) {
                auto [_Match, _Mid1] = ::std::ranges:: _Equal_rev_pred(_First1, _First2, _Last2, _Pred, _Proj1, _Proj2);
                if (_Match) {
                    return {::std:: move(_First1), ::std:: move(_Mid1)};
                }
            }

            _First1 = _Find_last_iterator(_First1, _Last1, _Count1);
            return {_First1, _First1};
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Search_unsized(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            for (;; ++_First1) {
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2;; ++_Mid1, (void) ++_Mid2) {
                    if (_Mid2 == _Last2) { 
                        return {::std:: move(_First1), ::std:: move(_Mid1)};
                    }

                    if (_Mid1 == _Last1) { 
                        return {_Mid1, _Mid1};
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Mid1), ::std:: invoke(_Proj2, *_Mid2))) { 
                        break;
                    }
                }
            }
        }
    };

     inline constexpr _Search_fn search{_Not_quite_object::_Construct_tag {}};
} 
#line 6624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _Iter, class _Pr, class _Elem = _Iter_value_t<_Iter>>
inline constexpr bool _Is_min_max_optimization_safe = 
    _Iterator_is_contiguous<_Iter> 
    && !_Iterator_is_volatile<_Iter> 
    && conjunction_v<disjunction<is_integral<_Elem>, is_pointer<_Elem>>, 
        disjunction< 

            is_same<_Pr, ::std::ranges:: less>, 
#line 6634 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            is_same<_Pr, less<>>, is_same<_Pr, less<_Elem>>>>; 

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_max_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_Found, *_First))) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Max_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt max_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: max_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: max_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt max_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: max_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Max_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        ;
        ;
        ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_max_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Found), ::std:: invoke(_Proj, *_First))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Max_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Max_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult =
                ::std::ranges:: _Max_element_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Max_element_fn max_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6756 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
#line 6757 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(max)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: max)(_Ilist, less<>{});
}


namespace ranges {
    template <class _It>
    concept _Prefer_iterator_copies = 
                                      
        sizeof(_It) <= 2 * sizeof(iter_value_t<_It>)
        && (is_trivially_copyable_v<_It> || !is_trivially_copyable_v<iter_value_t<_It>>);

    class _Max_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Left), ::std:: invoke(_Proj, _Right))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            ;
#line 6801 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return *::std::ranges:: _Max_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            ;
#line 6812 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Max_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Found), ::std:: invoke(_Proj, *_UFirst))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Max_fn max{_Not_quite_object::_Construct_tag {}};
} 
#line 6831 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

template <class _FwdIt, class _Pr>
constexpr _FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_min_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return _First + (_Result - _First_ptr);
            }
        }
    }
#line 6847 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    _FwdIt _Found = _First;
    if (_First != _Last) {
        while (++_First != _Last) {
            if (static_cast<bool>(_Pred(*_First, *_Found))) {
                _Found = _First;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, ::std:: _Min_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt min_element(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: min_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: min_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt min_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: min_element(_First, _Last);
}


namespace ranges {
    template <class _It, class _Se, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Min_element_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        ;
        ;
        ;


        if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                      && sized_sentinel_for<_Se, _It>) {
            if (!::std:: is_constant_evaluated()) {
                const auto _First_ptr = ::std:: to_address(_First);
                const auto _Last_ptr  = _First_ptr + (_Last - _First);
                const auto _Result    = __std_min_element(_First_ptr, _Last_ptr);
                if constexpr (is_pointer_v<_It>) {
                    return _Result;
                } else {
                    return _First + (_Result - _First_ptr);
                }
            }
        }
#line 6912 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

        auto _Found = _First;
        if (_First == _Last) {
            return _Found;
        }

        while (++_First != _Last) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found))) {
                _Found = _First;
            }
        }

        return _Found;
    }

    class _Min_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, ::std::ranges:: _Min_element_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult =
                ::std::ranges:: _Min_element_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Min_element_fn min_element{_Not_quite_object::_Construct_tag {}};
} 
#line 6952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
#line 6953 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    const _Ty* _Res = ::std:: _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return *_Res;
}

 template <class _Ty>
[[nodiscard]] constexpr _Ty(min)(initializer_list<_Ty> _Ilist) {
    
    return (::std:: min)(_Ilist, less<>{});
}


namespace ranges {
    class _Min_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Left, const _Ty& _Right, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Right), ::std:: invoke(_Proj, _Left))) {
                return _Right;
            } else {
                return _Left;
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _Ty operator()(initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            ;
#line 6991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            return *::std::ranges:: _Min_element_unchecked(_First, _Last, _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr range_value_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Uend(_Range);
            ;
#line 7002 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return static_cast<range_value_t<_Rng>>(*::std::ranges:: _Min_element_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj)));
            } else {
                range_value_t<_Rng> _Found(*_UFirst);
                while (++_UFirst != _ULast) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Found))) {
                        _Found = *_UFirst;
                    }
                }

                return _Found;
            }
        }
    };

     inline constexpr _Min_fn min{_Not_quite_object::_Construct_tag {}};
} 
#line 7021 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid                   = ::std:: next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: lower_bound(_First, _Last, _Val, less<>{});
}

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t<_FwdIt> _Count = ::std:: distance(_UFirst, _Get_unwrapped(_Last));

    while (0 < _Count) { 
        _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
        const auto _UMid             = ::std:: next(_UFirst, _Count2);
        if (_Pred(_Val, *_UMid)) {
            _Count = _Count2;
        } else { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: upper_bound(_First, _Last, _Val, less<>{});
}

template <class _FwdIt1, class _FwdIt2>
constexpr _FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    


    using _Elem1 = remove_reference_t<_Iter_ref_t<_FwdIt1>>;
    using _Elem2 = remove_reference_t<_Iter_ref_t<_FwdIt2>>;
    if constexpr (is_same_v<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1>
                  && _Iterators_are_contiguous<_FwdIt1, _FwdIt2>) {

        if (!::std:: is_constant_evaluated())
#line 7090 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
        {
            __std_swap_ranges_trivially_swappable_noalias(
                _To_address(_First1), _To_address(_Last1), _To_address(_First2));
            return _First2 + (_Last1 - _First1);
        }
    }
#line 7097 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

    for (; _First1 != _Last1; ++_First1, (void) ++_First2) {
        swap(*_First1, *_First2); 
    }

    return _First2;
}

extern "C++" [[noreturn]]  void __cdecl _Xbad_alloc();
extern "C++" [[noreturn]]  void __cdecl _Xinvalid_argument(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xlength_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xout_of_range(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xoverflow_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _Xruntime_error(  const char*);
extern "C++" [[noreturn]]  void __cdecl _XGetLastError();

 template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*,
    class _Reference = _Ty&>
struct [[deprecated( "warning STL4015: " "The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. " "(The <iterator> header is NOT deprecated.) The C++ Standard has never required user-defined iterators to " "derive from std::iterator. To fix this warning, stop deriving from std::iterator and start providing " "publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. " "Note that value_type is required to be non-const, even for constant iterators. " "You can define _SILENCE_CXX17_ITERATOR_BASE_CLASS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] iterator { 
    using iterator_category = _Category;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = _Pointer;
    using reference         = _Reference;
};

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr auto _Float_abs_bits(const _Ty& _Xx) noexcept {
    using _Traits    = _Floating_type_traits<_Ty>;
    using _Uint_type = typename _Traits::_Uint_type;
    const auto _Bits = _Bit_cast<_Uint_type>(_Xx);
    return _Bits & ~_Traits::_Shifted_sign_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_abs(const _Ty _Xx) noexcept { 
    return _Bit_cast<_Ty>(_Float_abs_bits(_Xx));
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty _Float_copysign(const _Ty _Magnitude, const _Ty _Sign) { 
    using _Traits       = _Floating_type_traits<_Ty>;
    using _Uint_type    = typename _Traits::_Uint_type;
    const auto _Signbit = _Bit_cast<_Uint_type>(_Sign) & _Traits::_Shifted_sign_mask;
    return _Bit_cast<_Ty>(_Float_abs_bits(_Magnitude) | _Signbit);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_nan(const _Ty _Xx) noexcept { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) > _Traits::_Shifted_exponent_mask;
}





template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_signaling_nan(const _Ty& _Xx) noexcept { 
    using _Traits        = _Floating_type_traits<_Ty>;
    const auto _Abs_bits = _Float_abs_bits(_Xx);
    return _Abs_bits > _Traits::_Shifted_exponent_mask && ((_Abs_bits & _Traits::_Special_nan_mantissa_mask) == 0);
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_inf(const _Ty _Xx) noexcept { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) == _Traits::_Shifted_exponent_mask;
}

template <class _Ty, enable_if_t<is_floating_point_v<_Ty>, int> = 0>
[[nodiscard]] constexpr bool _Is_finite(const _Ty _Xx) noexcept { 
    using _Traits = _Floating_type_traits<_Ty>;
    return _Float_abs_bits(_Xx) < _Traits::_Shifted_exponent_mask;
}


 struct monostate {};
#line 7176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"


template <_Integer_like _Int>
[[nodiscard]] constexpr bool _Add_overflow(const _Int _Left, const _Int _Right, _Int& _Out) {





    {
        if constexpr (!_Signed_integer_like<_Int>) {
            _Out = static_cast<_Int>(_Left + _Right);
            return _Out < _Left || _Out < _Right;
        } else {
            using _UInt = _Make_unsigned_like_t<_Int>;
            _Out        = static_cast<_Int>(static_cast<_UInt>(_Left) + static_cast<_UInt>(_Right));
            return (_Left > 0 && _Right > 0 && _Out <= 0) || (_Left < 0 && _Right < 0 && _Out >= 0);
        }
    }
}

template <_Integer_like _Int>
[[nodiscard]] constexpr bool _Mul_overflow(const _Int _Left, const _Int _Right, _Int& _Out) {





    {
        if constexpr (!_Signed_integer_like<_Int>) {
            
            constexpr auto _UInt_max = static_cast<_Int>(-1);
            const bool _Overflow     = _Left != 0 && _Right > _UInt_max / _Left;
            if (!_Overflow) {
                _Out = static_cast<_Int>(_Left * _Right);
            }
            return _Overflow;
        } else {
            
            
            
            
            
            
            
            
            
            using _UInt = _Make_unsigned_like_t<_Int>;
            const _UInt _ULeft =
                static_cast<_UInt>(_Left < 0 ? (0 - static_cast<_UInt>(_Left)) : static_cast<_UInt>(_Left));
            const _UInt _URight =
                static_cast<_UInt>(_Right < 0 ? (0 - static_cast<_UInt>(_Right)) : static_cast<_UInt>(_Right));
            const _UInt _UResult = static_cast<_UInt>(_ULeft * _URight);

            const bool _Negative = (_Left < 0) != (_Right < 0);
            _Out                 = static_cast<_Int>(_Negative ? (0 - _UResult) : _UResult);
            if (_ULeft == 0 || _URight == 0) {
                return false;
            }

            
            constexpr auto _Int_max = static_cast<_UInt>(static_cast<_UInt>(-1) / 2);
            if (_Negative) {
                return _ULeft > (_Int_max + _UInt{1}) / _URight;
            } else {
                return _ULeft > _Int_max / _URight;
            }
            
        }
    }
}
#line 7248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"

}







#pragma warning(pop)
#pragma pack(pop)
#line 7260 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
#line 7261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xutility"
#pragma external_header(pop)
#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
#line 28 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




[[nodiscard]]   inline float acos(  float _Xx) noexcept  {
    return :: acosf(_Xx);
}

[[nodiscard]]   inline float acosh(  float _Xx) noexcept  {
    return :: acoshf(_Xx);
}

[[nodiscard]]   inline float asin(  float _Xx) noexcept  {
    return :: asinf(_Xx);
}

[[nodiscard]]   inline float asinh(  float _Xx) noexcept  {
    return :: asinhf(_Xx);
}

[[nodiscard]]   inline float atan(  float _Xx) noexcept  {
    return :: atanf(_Xx);
}

[[nodiscard]]   inline float atanh(  float _Xx) noexcept  {
    return :: atanhf(_Xx);
}

[[nodiscard]]   inline float atan2(  float _Yx,   float _Xx) noexcept  {
    return :: atan2f(_Yx, _Xx);
}

[[nodiscard]]   inline float cbrt(  float _Xx) noexcept  {
    return :: cbrtf(_Xx);
}

[[nodiscard]]   inline float ceil(  float _Xx) noexcept  {

    return __ceilf(_Xx);




#line 76 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline float copysign(  float _Number,   float _Sign) noexcept  {

    return __copysignf(_Number, _Sign);




#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline float cos(  float _Xx) noexcept  {
    return :: cosf(_Xx);
}

[[nodiscard]]   inline float cosh(  float _Xx) noexcept  {
    return :: coshf(_Xx);
}

[[nodiscard]]   inline float erf(  float _Xx) noexcept  {
    return :: erff(_Xx);
}

[[nodiscard]]   inline float erfc(  float _Xx) noexcept  {
    return :: erfcf(_Xx);
}

[[nodiscard]]   inline float exp(  float _Xx) noexcept  {
    return :: expf(_Xx);
}

[[nodiscard]]   inline float exp2(  float _Xx) noexcept  {
    return :: exp2f(_Xx);
}

[[nodiscard]]   inline float expm1(  float _Xx) noexcept  {
    return :: expm1f(_Xx);
}

[[nodiscard]]   inline float fabs(  float _Xx) noexcept  {
    return :: fabsf(_Xx);
}

[[nodiscard]]   inline float fdim(  float _Xx,   float _Yx) noexcept  {
    return :: fdimf(_Xx, _Yx);
}

[[nodiscard]]   inline float floor(  float _Xx) noexcept  {

    return __floorf(_Xx);




#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline float fma(  float _Xx,   float _Yx,   float _Zx) noexcept  {
    return :: fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float fmax(  float _Xx,   float _Yx) noexcept  {
    return :: fmaxf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmin(  float _Xx,   float _Yx) noexcept  {
    return :: fminf(_Xx, _Yx);
}

[[nodiscard]]   inline float fmod(  float _Xx,   float _Yx) noexcept  {
    return :: fmodf(_Xx, _Yx);
}

inline float frexp(  float _Xx,   int* _Yx) noexcept  {
    return :: frexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float hypot(  float _Xx,   float _Yx) noexcept  {
    return :: hypotf(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  float _Xx) noexcept  {
    return :: ilogbf(_Xx);
}

[[nodiscard]]   inline float ldexp(  float _Xx,   int _Yx) noexcept  {
    return :: ldexpf(_Xx, _Yx);
}

[[nodiscard]]   inline float lgamma(  float _Xx) noexcept  {
    return :: lgammaf(_Xx);
}

[[nodiscard]]   inline long long llrint(  float _Xx) noexcept  {
    return :: llrintf(_Xx);
}

[[nodiscard]]   inline long long llround(  float _Xx) noexcept  {
    return :: llroundf(_Xx);
}

[[nodiscard]]   inline float log(  float _Xx) noexcept  {
    return :: logf(_Xx);
}

[[nodiscard]]   inline float log10(  float _Xx) noexcept  {
    return :: log10f(_Xx);
}

[[nodiscard]]   inline float log1p(  float _Xx) noexcept  {
    return :: log1pf(_Xx);
}

[[nodiscard]]   inline float log2(  float _Xx) noexcept  {
    return :: log2f(_Xx);
}

[[nodiscard]]   inline float logb(  float _Xx) noexcept  {
    return :: logbf(_Xx);
}

[[nodiscard]]   inline long lrint(  float _Xx) noexcept  {
    return :: lrintf(_Xx);
}

[[nodiscard]]   inline long lround(  float _Xx) noexcept  {
    return :: lroundf(_Xx);
}

inline float modf(  float _Xx,   float* _Yx) noexcept  {
    return :: modff(_Xx, _Yx);
}

[[nodiscard]]   inline float nearbyint(  float _Xx) noexcept  {
    return :: nearbyintf(_Xx);
}

[[nodiscard]]   inline float nextafter(  float _Xx,   float _Yx) noexcept  {
    return :: nextafterf(_Xx, _Yx);
}

[[nodiscard]]   inline float nexttoward(  float _Xx,   long double _Yx) noexcept  {
    return :: nexttowardf(_Xx, _Yx);
}

[[nodiscard]]   inline float pow(  float _Xx,   float _Yx) noexcept  {
    return :: powf(_Xx, _Yx);
}

[[nodiscard]]   inline float remainder(  float _Xx,   float _Yx) noexcept  {
    return :: remainderf(_Xx, _Yx);
}

inline float remquo(  float _Xx,   float _Yx,   int* _Zx) noexcept  {
    return :: remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline float rint(  float _Xx) noexcept  {
    return :: rintf(_Xx);
}

[[nodiscard]]   inline float round(  float _Xx) noexcept  {

    return __roundf(_Xx);




#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline float scalbln(  float _Xx,   long _Yx) noexcept  {
    return :: scalblnf(_Xx, _Yx);
}

[[nodiscard]]   inline float scalbn(  float _Xx,   int _Yx) noexcept  {
    return :: scalbnf(_Xx, _Yx);
}

[[nodiscard]]   inline float sin(  float _Xx) noexcept  {
    return :: sinf(_Xx);
}

[[nodiscard]]   inline float sinh(  float _Xx) noexcept  {
    return :: sinhf(_Xx);
}

[[nodiscard]]   inline float sqrt(  float _Xx) noexcept  {
    return :: sqrtf(_Xx);
}

[[nodiscard]]   inline float tan(  float _Xx) noexcept  {
    return :: tanf(_Xx);
}

[[nodiscard]]   inline float tanh(  float _Xx) noexcept  {
    return :: tanhf(_Xx);
}

[[nodiscard]]   inline float tgamma(  float _Xx) noexcept  {
    return :: tgammaf(_Xx);
}

[[nodiscard]]   inline float trunc(  float _Xx) noexcept  {

    return __truncf(_Xx);




#line 288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline long double acos(  long double _Xx) noexcept  {
    return :: acosl(_Xx);
}

[[nodiscard]]   inline long double acosh(  long double _Xx) noexcept  {
    return :: acoshl(_Xx);
}

[[nodiscard]]   inline long double asin(  long double _Xx) noexcept  {
    return :: asinl(_Xx);
}

[[nodiscard]]   inline long double asinh(  long double _Xx) noexcept  {
    return :: asinhl(_Xx);
}

[[nodiscard]]   inline long double atan(  long double _Xx) noexcept  {
    return :: atanl(_Xx);
}

[[nodiscard]]   inline long double atanh(  long double _Xx) noexcept  {
    return :: atanhl(_Xx);
}

[[nodiscard]]   inline long double atan2(  long double _Yx,   long double _Xx) noexcept
 {
    return :: atan2l(_Yx, _Xx);
}

[[nodiscard]]   inline long double cbrt(  long double _Xx) noexcept  {
    return :: cbrtl(_Xx);
}

[[nodiscard]]   inline long double ceil(  long double _Xx) noexcept  {

    return __ceil(static_cast<double>(_Xx));




#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline long double copysign(  long double _Number,   long double _Sign) noexcept
 {

    return __copysign(static_cast<double>(_Number), static_cast<double>(_Sign));




#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline long double cos(  long double _Xx) noexcept  {
    return :: cosl(_Xx);
}

[[nodiscard]]   inline long double cosh(  long double _Xx) noexcept  {
    return :: coshl(_Xx);
}

[[nodiscard]]   inline long double erf(  long double _Xx) noexcept  {
    return :: erfl(_Xx);
}

[[nodiscard]]   inline long double erfc(  long double _Xx) noexcept  {
    return :: erfcl(_Xx);
}

[[nodiscard]]   inline long double exp(  long double _Xx) noexcept  {
    return :: expl(_Xx);
}

[[nodiscard]]   inline long double exp2(  long double _Xx) noexcept  {
    return :: exp2l(_Xx);
}

[[nodiscard]]   inline long double expm1(  long double _Xx) noexcept  {
    return :: expm1l(_Xx);
}

[[nodiscard]]   inline long double fabs(  long double _Xx) noexcept  {
    return :: fabsl(_Xx);
}

[[nodiscard]]   inline long double fdim(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fdiml(_Xx, _Yx);
}

[[nodiscard]]   inline long double floor(  long double _Xx) noexcept  {

    return __floor(static_cast<double>(_Xx));




#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline long double fma(
      long double _Xx,   long double _Yx,   long double _Zx) noexcept  {
    return :: fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double fmax(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmaxl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmin(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fminl(_Xx, _Yx);
}

[[nodiscard]]   inline long double fmod(  long double _Xx,   long double _Yx) noexcept
 {
    return :: fmodl(_Xx, _Yx);
}

inline long double frexp(  long double _Xx,   int* _Yx) noexcept  {
    return :: frexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double hypot(  long double _Xx,   long double _Yx) noexcept
 {
    return :: hypotl(_Xx, _Yx);
}

[[nodiscard]]   inline int ilogb(  long double _Xx) noexcept  {
    return :: ilogbl(_Xx);
}

[[nodiscard]]   inline long double ldexp(  long double _Xx,   int _Yx) noexcept  {
    return :: ldexpl(_Xx, _Yx);
}

[[nodiscard]]   inline long double lgamma(  long double _Xx) noexcept  {
    return :: lgammal(_Xx);
}

[[nodiscard]]   inline long long llrint(  long double _Xx) noexcept  {
    return :: llrintl(_Xx);
}

[[nodiscard]]   inline long long llround(  long double _Xx) noexcept  {
    return :: llroundl(_Xx);
}

[[nodiscard]]   inline long double log(  long double _Xx) noexcept  {
    return :: logl(_Xx);
}

[[nodiscard]]   inline long double log10(  long double _Xx) noexcept  {
    return :: log10l(_Xx);
}

[[nodiscard]]   inline long double log1p(  long double _Xx) noexcept  {
    return :: log1pl(_Xx);
}

[[nodiscard]]   inline long double log2(  long double _Xx) noexcept  {
    return :: log2l(_Xx);
}

[[nodiscard]]   inline long double logb(  long double _Xx) noexcept  {
    return :: logbl(_Xx);
}

[[nodiscard]]   inline long lrint(  long double _Xx) noexcept  {
    return :: lrintl(_Xx);
}

[[nodiscard]]   inline long lround(  long double _Xx) noexcept  {
    return :: lroundl(_Xx);
}

inline long double modf(  long double _Xx,   long double* _Yx) noexcept  {
    return :: modfl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nearbyint(  long double _Xx) noexcept  {
    return :: nearbyintl(_Xx);
}

[[nodiscard]]   inline long double nextafter(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nextafterl(_Xx, _Yx);
}

[[nodiscard]]   inline long double nexttoward(  long double _Xx,   long double _Yx) noexcept
 {
    return :: nexttowardl(_Xx, _Yx);
}

[[nodiscard]]   inline long double pow(  long double _Xx,   long double _Yx) noexcept
 {
    return :: powl(_Xx, _Yx);
}

[[nodiscard]]   inline long double remainder(  long double _Xx,   long double _Yx) noexcept
 {
    return :: remainderl(_Xx, _Yx);
}

inline long double remquo(  long double _Xx,   long double _Yx,   int* _Zx) noexcept  {
    return :: remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]]   inline long double rint(  long double _Xx) noexcept  {
    return :: rintl(_Xx);
}

[[nodiscard]]   inline long double round(  long double _Xx) noexcept  {

    return __round(static_cast<double>(_Xx));




#line 512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

[[nodiscard]]   inline long double scalbln(  long double _Xx,   long _Yx) noexcept  {
    return :: scalblnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double scalbn(  long double _Xx,   int _Yx) noexcept  {
    return :: scalbnl(_Xx, _Yx);
}

[[nodiscard]]   inline long double sin(  long double _Xx) noexcept  {
    return :: sinl(_Xx);
}

[[nodiscard]]   inline long double sinh(  long double _Xx) noexcept  {
    return :: sinhl(_Xx);
}

[[nodiscard]]   inline long double sqrt(  long double _Xx) noexcept  {
    return :: sqrtl(_Xx);
}

[[nodiscard]]   inline long double tan(  long double _Xx) noexcept  {
    return :: tanl(_Xx);
}

[[nodiscard]]   inline long double tanh(  long double _Xx) noexcept  {
    return :: tanhl(_Xx);
}

[[nodiscard]]   inline long double tgamma(  long double _Xx) noexcept  {
    return :: tgammal(_Xx);
}

[[nodiscard]]   inline long double trunc(  long double _Xx) noexcept  {

    return __trunc(static_cast<double>(_Xx));




#line 554 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}

namespace std {
template <class _Ty1, class _Ty2>
using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>, long double,
    conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float,
        double>>; 
}

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value,   int* const _Exp) noexcept  {
    return :: frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, class _Ty3,
    ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2> && ::std:: is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>> fma(
    _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, ::std:: _Common_float_type_t<_Ty2, _Ty3>>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    } else {
        return :: fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0>
::std:: _Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept  {
    using _Common = ::std:: _Common_float_type_t<_Ty1, _Ty2>;
    if constexpr (::std:: is_same_v<_Common, float>) {
        return :: remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else if constexpr (::std:: is_same_v<_Common, double>) {
        return :: remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    } else {
        return :: remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}
















#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"




























#line 639 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"


template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acos(_Ty _Left) noexcept { return :: acos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asin(_Ty _Left) noexcept { return :: asin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atan(_Ty _Left) noexcept { return :: atan(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept { return :: atan2(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cos(_Ty _Left) noexcept { return :: cos(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sin(_Ty _Left) noexcept { return :: sin(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tan(_Ty _Left) noexcept { return :: tan(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double acosh(_Ty _Left) noexcept { return :: acosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double asinh(_Ty _Left) noexcept { return :: asinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double atanh(_Ty _Left) noexcept { return :: atanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cosh(_Ty _Left) noexcept { return :: cosh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sinh(_Ty _Left) noexcept { return :: sinh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tanh(_Ty _Left) noexcept { return :: tanh(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp(_Ty _Left) noexcept { return :: exp(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double exp2(_Ty _Left) noexcept { return :: exp2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double expm1(_Ty _Left) noexcept { return :: expm1(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] int ilogb(_Ty _Left) noexcept { return :: ilogb(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept { return :: ldexp(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log(_Ty _Left) noexcept { return :: log(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log10(_Ty _Left) noexcept { return :: log10(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log1p(_Ty _Left) noexcept { return :: log1p(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double log2(_Ty _Left) noexcept { return :: log2(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double logb(_Ty _Left) noexcept { return :: logb(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept { return :: scalbn(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept { return :: scalbln(static_cast<double>(_Left), _Arg2); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double cbrt(_Ty _Left) noexcept { return :: cbrt(static_cast<double>(_Left)); }

template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double fabs(_Ty _Left) noexcept { return :: fabs(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept { return :: hypot(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> pow(_Ty1 _Left, _Ty2 _Right) noexcept { return :: pow(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double sqrt(_Ty _Left) noexcept { return :: sqrt(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erf(_Ty _Left) noexcept { return :: erf(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double erfc(_Ty _Left) noexcept { return :: erfc(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double lgamma(_Ty _Left) noexcept { return :: lgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double tgamma(_Ty _Left) noexcept { return :: tgamma(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double ceil(_Ty _Left) noexcept { return __ceil(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double floor(_Ty _Left) noexcept { return __floor(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nearbyint(_Ty _Left) noexcept { return :: nearbyint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double rint(_Ty _Left) noexcept { return :: rint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lrint(_Ty _Left) noexcept { return :: lrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llrint(_Ty _Left) noexcept { return :: llrint(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double round(_Ty _Left) noexcept { return __round(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long lround(_Ty _Left) noexcept { return :: lround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] long long llround(_Ty _Left) noexcept { return :: llround(static_cast<double>(_Left)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double trunc(_Ty _Left) noexcept { return __trunc(static_cast<double>(_Left)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmod(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept { return :: remainder(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept { return __copysign(static_cast<double>(_Left), static_cast<double>(_Right)); }

template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept { return :: nextafter(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty, ::std:: enable_if_t<::std:: is_integral_v<_Ty>, int> = 0> [[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept { return :: nexttoward(static_cast<double>(_Left), _Arg2); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fdim(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmax(static_cast<double>(_Left), static_cast<double>(_Right)); }
template <class _Ty1, class _Ty2, ::std:: enable_if_t<::std:: is_arithmetic_v<_Ty1> && ::std:: is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] ::std:: _Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept { return :: fmin(static_cast<double>(_Left), static_cast<double>(_Right)); }














namespace std {
 using :: abs;
 using :: acos;
 using :: asin;
 using :: atan;
 using :: atan2;
 using :: ceil;
 using :: cos;
 using :: cosh;
 using :: exp;
 using :: fabs;
 using :: floor;
 using :: fmod;
 using :: frexp;
 using :: ldexp;
 using :: log;
 using :: log10;
 using :: modf;
 using :: pow;
 using :: sin;
 using :: sinh;
 using :: sqrt;
 using :: tan;
 using :: tanh;

 using :: acosf;
 using :: asinf;
 using :: atanf;
 using :: atan2f;
 using :: ceilf;
 using :: cosf;
 using :: coshf;
 using :: expf;
 using :: fabsf;
 using :: floorf;
 using :: fmodf;
 using :: frexpf;
 using :: ldexpf;
 using :: logf;
 using :: log10f;
 using :: modff;
 using :: powf;
 using :: sinf;
 using :: sinhf;
 using :: sqrtf;
 using :: tanf;
 using :: tanhf;

 using :: acosl;
 using :: asinl;
 using :: atanl;
 using :: atan2l;
 using :: ceill;
 using :: cosl;
 using :: coshl;
 using :: expl;
 using :: fabsl;
 using :: floorl;
 using :: fmodl;
 using :: frexpl;
 using :: ldexpl;
 using :: logl;
 using :: log10l;
 using :: modfl;
 using :: powl;
 using :: sinl;
 using :: sinhl;
 using :: sqrtl;
 using :: tanl;
 using :: tanhl;

 using :: float_t;
 using :: double_t;

 using :: acosh;
 using :: asinh;
 using :: atanh;
 using :: cbrt;
 using :: erf;
 using :: erfc;
 using :: expm1;
 using :: exp2;

inline namespace _Binary_hypot {
     using :: hypot;
} 

 using :: ilogb;
 using :: lgamma;
 using :: log1p;
 using :: log2;
 using :: logb;
 using :: llrint;
 using :: lrint;
 using :: nearbyint;
 using :: rint;
 using :: llround;
 using :: lround;
 using :: fdim;
 using :: fma;
 using :: fmax;
 using :: fmin;
 using :: round;
 using :: trunc;
 using :: remainder;
 using :: remquo;
 using :: copysign;
 using :: nan;
 using :: nextafter;
 using :: scalbn;
 using :: scalbln;
 using :: nexttoward;
 using :: tgamma;

 using :: acoshf;
 using :: asinhf;
 using :: atanhf;
 using :: cbrtf;
 using :: erff;
 using :: erfcf;
 using :: expm1f;
 using :: exp2f;
 using :: hypotf;
 using :: ilogbf;
 using :: lgammaf;
 using :: log1pf;
 using :: log2f;
 using :: logbf;
 using :: llrintf;
 using :: lrintf;
 using :: nearbyintf;
 using :: rintf;
 using :: llroundf;
 using :: lroundf;
 using :: fdimf;
 using :: fmaf;
 using :: fmaxf;
 using :: fminf;
 using :: roundf;
 using :: truncf;
 using :: remainderf;
 using :: remquof;
 using :: copysignf;
 using :: nanf;
 using :: nextafterf;
 using :: scalbnf;
 using :: scalblnf;
 using :: nexttowardf;
 using :: tgammaf;

 using :: acoshl;
 using :: asinhl;
 using :: atanhl;
 using :: cbrtl;
 using :: erfl;
 using :: erfcl;
 using :: expm1l;
 using :: exp2l;
 using :: hypotl;
 using :: ilogbl;
 using :: lgammal;
 using :: log1pl;
 using :: log2l;
 using :: logbl;
 using :: llrintl;
 using :: lrintl;
 using :: nearbyintl;
 using :: rintl;
 using :: llroundl;
 using :: lroundl;
 using :: fdiml;
 using :: fmal;
 using :: fmaxl;
 using :: fminl;
 using :: roundl;
 using :: truncl;
 using :: remainderl;
 using :: remquol;
 using :: copysignl;
 using :: nanl;
 using :: nextafterl;
 using :: scalbnl;
 using :: scalblnl;
 using :: nexttowardl;
 using :: tgammal;

 using :: fpclassify;
 using :: signbit;
 using :: isfinite;
 using :: isinf;
 using :: isnan;
 using :: isnormal;
 using :: isgreater;
 using :: isgreaterequal;
 using :: isless;
 using :: islessequal;
 using :: islessgreater;
 using :: isunordered;
}


extern "C" {
[[nodiscard]]  double __stdcall __std_smf_assoc_laguerre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_laguerref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_assoc_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_assoc_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_beta(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_betaf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_1(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_1f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_2(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_2f(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_comp_ellint_3(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_comp_ellint_3f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_i(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_if(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_j(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_jf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_bessel_k(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_bessel_kf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_cyl_neumann(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_cyl_neumannf(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_1(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_1f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_2(double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_2f(float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_ellint_3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_ellint_3f(float, float, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_expint(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_expintf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hermite(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hermitef(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_laguerre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_laguerref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_legendre(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_legendref(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_riemann_zeta(double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_riemann_zetaf(float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_bessel(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_besself(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_legendre(unsigned int, unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_legendref(unsigned int, unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_sph_neumann(unsigned int, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_sph_neumannf(unsigned int, float) noexcept;
[[nodiscard]]  double __stdcall __std_smf_hypot3(double, double, double) noexcept;
[[nodiscard]]  float __stdcall __std_smf_hypot3f(float, float, float) noexcept;
}

namespace std {
 [[nodiscard]] inline double assoc_laguerre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept  {
    return __std_smf_assoc_laguerre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_laguerref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept  {
    return __std_smf_assoc_laguerref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_laguerrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept  {
    return __std_smf_assoc_laguerre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double assoc_legendre(
    const unsigned int _Degree, const unsigned int _Order, const double _Value) noexcept  {
    return __std_smf_assoc_legendre(_Degree, _Order, _Value);
}

 [[nodiscard]] inline float assoc_legendref(
    const unsigned int _Degree, const unsigned int _Order, const float _Value) noexcept  {
    return __std_smf_assoc_legendref(_Degree, _Order, _Value);
}

 [[nodiscard]] inline long double assoc_legendrel(
    const unsigned int _Degree, const unsigned int _Order, const long double _Value) noexcept  {
    return __std_smf_assoc_legendre(_Degree, _Order, static_cast<double>(_Value));
}

 [[nodiscard]] inline double beta(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_beta(_Arg1, _Arg2);
}

 [[nodiscard]] inline float betaf(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_betaf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double betal(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double comp_ellint_1(const double _Arg) noexcept  {
    return __std_smf_comp_ellint_1(_Arg);
}

 [[nodiscard]] inline float comp_ellint_1f(const float _Arg) noexcept  {
    return __std_smf_comp_ellint_1f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_1l(const long double _Arg) noexcept  {
    return __std_smf_comp_ellint_1(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_2(const double _Arg) noexcept  {
    return __std_smf_comp_ellint_2(_Arg);
}

 [[nodiscard]] inline float comp_ellint_2f(const float _Arg) noexcept  {
    return __std_smf_comp_ellint_2f(_Arg);
}

 [[nodiscard]] inline long double comp_ellint_2l(const long double _Arg) noexcept  {
    return __std_smf_comp_ellint_2(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double comp_ellint_3(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_comp_ellint_3(_Arg1, _Arg2);
}

 [[nodiscard]] inline float comp_ellint_3f(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_comp_ellint_3f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double comp_ellint_3l(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_i(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_cyl_bessel_i(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_if(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_cyl_bessel_if(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_il(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_j(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_cyl_bessel_j(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_jf(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_cyl_bessel_jf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_jl(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_bessel_k(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_cyl_bessel_k(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_bessel_kf(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_cyl_bessel_kf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_bessel_kl(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double cyl_neumann(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_cyl_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float cyl_neumannf(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_cyl_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double cyl_neumannl(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_1(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_ellint_1(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_1f(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_ellint_1f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_1l(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_2(const double _Arg1, const double _Arg2) noexcept  {
    return __std_smf_ellint_2(_Arg1, _Arg2);
}

 [[nodiscard]] inline float ellint_2f(const float _Arg1, const float _Arg2) noexcept  {
    return __std_smf_ellint_2f(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double ellint_2l(const long double _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double ellint_3(const double _Arg1, const double _Arg2, const double _Arg3) noexcept
 {
    return __std_smf_ellint_3(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline float ellint_3f(const float _Arg1, const float _Arg2, const float _Arg3) noexcept
 {
    return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3);
}

 [[nodiscard]] inline long double ellint_3l(
    const long double _Arg1, const long double _Arg2, const long double _Arg3) noexcept  {
    return __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3));
}

 [[nodiscard]] inline double expint(const double _Arg) noexcept  {
    return __std_smf_expint(_Arg);
}

 [[nodiscard]] inline float expintf(const float _Arg) noexcept  {
    return __std_smf_expintf(_Arg);
}

 [[nodiscard]] inline long double expintl(const long double _Arg) noexcept  {
    return __std_smf_expint(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double hermite(const unsigned int _Arg1, const double _Arg2) noexcept  {
    return __std_smf_hermite(_Arg1, _Arg2);
}

 [[nodiscard]] inline float hermitef(const unsigned int _Arg1, const float _Arg2) noexcept  {
    return __std_smf_hermitef(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double hermitel(const unsigned int _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_hermite(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double laguerre(const unsigned int _Arg1, const double _Arg2) noexcept
 {
    return __std_smf_laguerre(_Arg1, _Arg2);
}

 [[nodiscard]] inline float laguerref(const unsigned int _Arg1, const float _Arg2) noexcept  {
    return __std_smf_laguerref(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double laguerrel(const unsigned int _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_laguerre(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double legendre(const unsigned int _Degree, const double _Value) noexcept
 {
    return __std_smf_legendre(_Degree, _Value);
}

 [[nodiscard]] inline float legendref(const unsigned int _Degree, const float _Value) noexcept
 {
    return __std_smf_legendref(_Degree, _Value);
}

 [[nodiscard]] inline long double legendrel(const unsigned int _Degree, const long double _Value) noexcept
 {
    return __std_smf_legendre(_Degree, static_cast<double>(_Value));
}

 [[nodiscard]] inline double riemann_zeta(const double _Arg) noexcept  {
    return __std_smf_riemann_zeta(_Arg);
}
 [[nodiscard]] inline float riemann_zetaf(const float _Arg) noexcept  {
    return __std_smf_riemann_zetaf(_Arg);
}

 [[nodiscard]] inline long double riemann_zetal(const long double _Arg) noexcept  {
    return __std_smf_riemann_zeta(static_cast<double>(_Arg));
}

 [[nodiscard]] inline double sph_bessel(const unsigned int _Arg1, const double _Arg2) noexcept
 {
    return __std_smf_sph_bessel(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_besself(const unsigned int _Arg1, const float _Arg2) noexcept
 {
    return __std_smf_sph_besself(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_bessell(const unsigned int _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2));
}

 [[nodiscard]] inline double sph_legendre(
    const unsigned int _Arg1, const unsigned int _Arg2, const double _Theta) noexcept
 {
    return __std_smf_sph_legendre(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline float sph_legendref(
    const unsigned int _Arg1, const unsigned int _Arg2, const float _Theta) noexcept
 {
    return __std_smf_sph_legendref(_Arg1, _Arg2, _Theta);
}

 [[nodiscard]] inline long double sph_legendrel(
    const unsigned int _Arg1, const unsigned int _Arg2, const long double _Theta) noexcept  {
    return __std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Theta));
}

 [[nodiscard]] inline double sph_neumann(const unsigned int _Arg1, const double _Arg2) noexcept
 {
    return __std_smf_sph_neumann(_Arg1, _Arg2);
}

 [[nodiscard]] inline float sph_neumannf(const unsigned int _Arg1, const float _Arg2) noexcept
 {
    return __std_smf_sph_neumannf(_Arg1, _Arg2);
}

 [[nodiscard]] inline long double sph_neumannl(const unsigned int _Arg1, const long double _Arg2) noexcept
 {
    return __std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2));
}





























































 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_laguerre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_laguerref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_laguerre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto assoc_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_assoc_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_assoc_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto beta(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_betaf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_beta(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_1(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_1f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_1(static_cast<double>(_Arg))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto comp_ellint_2(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_2f(_Arg); } else { return static_cast<_Common>(__std_smf_comp_ellint_2(static_cast<double>(_Arg))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto comp_ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_comp_ellint_3f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_comp_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_i(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_if(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_i(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_j(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_jf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_j(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_bessel_k(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_bessel_kf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_bessel_k(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto cyl_neumann(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_cyl_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_cyl_neumann(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_1(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_1f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_1(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2>, int> = 0> [[nodiscard]] auto ellint_2(const _Ty1 _Arg1, const _Ty2 _Arg2) noexcept { using _Common = _Common_float_type_t<_Ty1, _Ty2>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_2f(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_ellint_2(static_cast<double>(_Arg1), static_cast<double>(_Arg2))); } }
 template <class _Ty1, class _Ty2, class _Ty3, enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0> [[nodiscard]] auto ellint_3(const _Ty1 _Arg1, const _Ty2 _Arg2, const _Ty3 _Arg3) noexcept { using _Common = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; if constexpr (is_same_v<_Common, float>) { return __std_smf_ellint_3f(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>( __std_smf_ellint_3(static_cast<double>(_Arg1), static_cast<double>(_Arg2), static_cast<double>(_Arg3))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto expint(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_expintf(_Arg); } else { return static_cast<_Common>(__std_smf_expint(static_cast<double>(_Arg))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto hermite(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_hermitef(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_hermite(_Arg1, static_cast<double>(_Arg2))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto laguerre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_laguerref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_laguerre(_Arg1, static_cast<double>(_Arg2))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto legendre(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_legendref(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_legendre(_Arg1, static_cast<double>(_Arg2))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto riemann_zeta(const _Ty _Arg) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_riemann_zetaf(_Arg); } else { return static_cast<_Common>(__std_smf_riemann_zeta(static_cast<double>(_Arg))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_bessel(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_besself(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_bessel(_Arg1, static_cast<double>(_Arg2))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_legendre( const unsigned int _Arg1, const unsigned int _Arg2, const _Ty _Arg3) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_legendref(_Arg1, _Arg2, _Arg3); } else { return static_cast<_Common>(__std_smf_sph_legendre(_Arg1, _Arg2, static_cast<double>(_Arg3))); } }
 template <class _Ty, enable_if_t<is_arithmetic_v<_Ty>, int> = 0> [[nodiscard]] auto sph_neumann(const unsigned int _Arg1, const _Ty _Arg2) noexcept { using _Common = conditional_t<is_integral_v<_Ty>, double, _Ty>; if constexpr (is_same_v<_Common, float>) { return __std_smf_sph_neumannf(_Arg1, _Arg2); } else { return static_cast<_Common>(__std_smf_sph_neumann(_Arg1, static_cast<double>(_Arg2))); } }







 [[nodiscard]] inline double hypot(const double _Dx, const double _Dy, const double _Dz) noexcept
 {
    return __std_smf_hypot3(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline float hypot(const float _Dx, const float _Dy, const float _Dz) noexcept
 {
    return __std_smf_hypot3f(_Dx, _Dy, _Dz);
}

 [[nodiscard]] inline long double hypot(
    const long double _Dx, const long double _Dy, const long double _Dz) noexcept  {
    return __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] auto hypot(const _Ty1 _Dx, const _Ty2 _Dy, const _Ty3 _Dz) noexcept  {
    
    
    
    using _Common      = _Common_float_type_t<_Ty1, _Common_float_type_t<_Ty2, _Ty3>>; 
    const auto _Result = __std_smf_hypot3(static_cast<double>(_Dx), static_cast<double>(_Dy), static_cast<double>(_Dz));
    return static_cast<_Common>(_Result);
}


template <class _Ty>
[[nodiscard]] constexpr _Ty _Linear_for_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    if (::std:: is_constant_evaluated()) {
        auto _Smaller     = _ArgT;
        auto _Larger      = _ArgB - _ArgA;
        auto _Abs_smaller = _Float_abs(_Smaller);
        auto _Abs_larger  = _Float_abs(_Larger);
        if (_Abs_larger < _Abs_smaller) {
            ::std:: swap(_Smaller, _Larger);
            ::std:: swap(_Abs_smaller, _Abs_larger);
        }

        if (_Abs_smaller > 1) {
            
            
            
            return 2 * (_Ty{0.5} * _ArgA + _Smaller * (_Ty{0.5} * _Larger));
        } else {
            return _ArgA + _Smaller * _Larger;
        }
    }

    return ::std:: fma(_ArgT, _ArgB - _ArgA, _ArgA);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty _Common_lerp(const _Ty _ArgA, const _Ty _ArgB, const _Ty _ArgT) noexcept {
    

    const bool _T_is_finite = _Is_finite(_ArgT);
    if (_T_is_finite && _Is_finite(_ArgA) && _Is_finite(_ArgB)) {
        
        if ((_ArgA <= 0 && _ArgB >= 0) || (_ArgA >= 0 && _ArgB <= 0)) {
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        }

        if (_ArgT == 1) {
            
            return _ArgB;
        }

        
        const auto _Candidate = _Linear_for_lerp(_ArgA, _ArgB, _ArgT);
        
        if ((_ArgT > 1) == (_ArgB > _ArgA)) {
            if (_ArgB > _Candidate) {
                return _ArgB;
            }
        } else {
            if (_Candidate > _ArgB) {
                return _ArgB;
            }
        }

        return _Candidate;
    }

    if (::std:: is_constant_evaluated()) {
        if (_Is_nan(_ArgA)) {
            return _ArgA;
        }

        if (_Is_nan(_ArgB)) {
            return _ArgB;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT;
        }
    } else {
        
        if (_Is_nan(_ArgA) || _Is_nan(_ArgB)) {
            return (_ArgA + _ArgB) + _ArgT;
        }

        if (_Is_nan(_ArgT)) {
            return _ArgT + _ArgT;
        }
    }

    if (_T_is_finite) {
        
        if (_ArgT < 0) {
            
            return _ArgA - _ArgB;
        } else if (_ArgT <= 1) {
            
            
            
            return _ArgT * _ArgB + (1 - _ArgT) * _ArgA;
        } else {
            
            return _ArgB - _ArgA;
        }
    } else {
        
        return _ArgT * (_ArgB - _ArgA);
    }
}

 [[nodiscard]] constexpr inline float lerp(const float _ArgA, const float _ArgB, const float _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline double lerp(
    const double _ArgA, const double _ArgB, const double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 [[nodiscard]] constexpr inline long double lerp(
    const long double _ArgA, const long double _ArgB, const long double _ArgT) noexcept {
    return _Common_lerp(_ArgA, _ArgB, _ArgT);
}

 template <class _Ty1, class _Ty2, class _Ty3,
    enable_if_t<is_arithmetic_v<_Ty1> && is_arithmetic_v<_Ty2> && is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] constexpr auto lerp(const _Ty1 _ArgA, const _Ty2 _ArgB, const _Ty3 _ArgT) noexcept {
    using _Tgt = conditional_t<_Is_any_of_v<long double, _Ty1, _Ty2, _Ty3>, long double, double>;
    return _Common_lerp(static_cast<_Tgt>(_ArgA), static_cast<_Tgt>(_ArgB), static_cast<_Tgt>(_ArgT));
}
#line 1484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
}
#line 1486 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"



#pragma warning(pop)
#pragma pack(pop)

#line 1493 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
#line 1494 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cmath"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"















#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {



















#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"


 using streamoff  = long long;
 using streamsize = long long;

 template <class _Statetype>
class fpos { 
public:
     fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

    fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

    [[nodiscard]] _Statetype state() const {
        return _Mystate;
    }

    void state(_Statetype _State) {
        _Mystate = _State;
    }

    operator streamoff() const noexcept  {
        
        
        return _Myoff + _Fpos;
    }


    [[deprecated("warning STL4019: " "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with " "workarounds for old versions of Visual C++. It will be removed in a future release, and in this " "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as " "conversions to and from streamoff, or an integral type, instead. If you are receiving this message " "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use " "standards-conforming mechanisms, as it does for other compilers. You can define " "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to suppress this warning, " "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t seekpos() const noexcept {
        return {};
    }
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

    [[nodiscard]] streamoff operator-(const fpos& _Right) const noexcept  {
        return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
    }

    fpos& operator+=(streamoff _Off) noexcept  { 
        _Myoff += _Off;
        return *this;
    }

    fpos& operator-=(streamoff _Off) noexcept  { 
        _Myoff -= _Off;
        return *this;
    }

    [[nodiscard]] fpos operator+(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] fpos operator-(streamoff _Off) const {
        fpos _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const fpos& _Right) const noexcept  {
        return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
    }

    template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
    [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right) noexcept  {
        return static_cast<streamoff>(_Left) == _Right;
    }




















#line 131 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

private:
    streamoff _Myoff; 
    fpos_t _Fpos; 
    _Statetype _Mystate; 
};

 using streampos  = fpos<_Mbstatet>;
 using wstreampos = streampos;

 using u8streampos = streampos;
#line 143 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"
 using u16streampos = streampos;
 using u32streampos = streampos;

 extern "C++" class locale;
 template <class _Facet>
const _Facet& __cdecl use_facet(const locale&);

 template <class _Elem>
struct char_traits;
template <>
struct char_traits<char>;

template <>
struct char_traits<char8_t>;
#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"
template <>
struct char_traits<char16_t>;
template <>
struct char_traits<char32_t>;
template <>
struct char_traits<wchar_t>;





 template <class _Ty>
class allocator;
 extern "C++" class ios_base;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ios;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class istreambuf_iterator;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class ostreambuf_iterator;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_streambuf;

#pragma vtordisp(push, 2) 
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_istream;
 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ostream;
#pragma vtordisp(pop) 

 extern "C++" template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_iostream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringbuf;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_istringstream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_ostringstream;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_stringstream;

 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_spanbuf;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ispanstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ospanstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_spanstream;
#line 208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_filebuf;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ifstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_ofstream;
 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_fstream;

template <class _Elem, class _Traits = char_traits<_Elem>>
class _Basic_syncbuf_impl;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_syncbuf;
 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_osyncstream;
#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"


 extern "C++" template <class _Elem, class _InIt>
class num_get;
 extern "C++" template <class _Elem, class _OutIt>
class num_put;
 template <class _Elem>
class collate;
#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

 using ios           = basic_ios<char, char_traits<char>>;
 using streambuf     = basic_streambuf<char, char_traits<char>>;
 using istream       = basic_istream<char, char_traits<char>>;
 using ostream       = basic_ostream<char, char_traits<char>>;
 using iostream      = basic_iostream<char, char_traits<char>>;
 using stringbuf     = basic_stringbuf<char, char_traits<char>, allocator<char>>;
 using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
 using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
 using stringstream  = basic_stringstream<char, char_traits<char>, allocator<char>>;
 using filebuf       = basic_filebuf<char, char_traits<char>>;
 using ifstream      = basic_ifstream<char, char_traits<char>>;
 using ofstream      = basic_ofstream<char, char_traits<char>>;
 using fstream       = basic_fstream<char, char_traits<char>>;

 using syncbuf     = basic_syncbuf<char>;
 using osyncstream = basic_osyncstream<char>;
#line 251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

 using spanbuf     = basic_spanbuf<char>;
 using ispanstream = basic_ispanstream<char>;
 using ospanstream = basic_ospanstream<char>;
 using spanstream  = basic_spanstream<char>;
#line 257 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

 using wios           = basic_ios<wchar_t, char_traits<wchar_t>>;
 using wstreambuf     = basic_streambuf<wchar_t, char_traits<wchar_t>>;
 using wistream       = basic_istream<wchar_t, char_traits<wchar_t>>;
 using wostream       = basic_ostream<wchar_t, char_traits<wchar_t>>;
 using wiostream      = basic_iostream<wchar_t, char_traits<wchar_t>>;
 using wstringbuf     = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wstringstream  = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
 using wfilebuf       = basic_filebuf<wchar_t, char_traits<wchar_t>>;
 using wifstream      = basic_ifstream<wchar_t, char_traits<wchar_t>>;
 using wofstream      = basic_ofstream<wchar_t, char_traits<wchar_t>>;
 using wfstream       = basic_fstream<wchar_t, char_traits<wchar_t>>;

 using wsyncbuf     = basic_syncbuf<wchar_t>;
 using wosyncstream = basic_osyncstream<wchar_t>;
#line 275 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

 using wspanbuf     = basic_spanbuf<wchar_t>;
 using wispanstream = basic_ispanstream<wchar_t>;
 using wospanstream = basic_ospanstream<wchar_t>;
 using wspanstream  = basic_spanstream<wchar_t>;
#line 281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"

}



#pragma warning(pop)
#pragma pack(pop)
#line 289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"
#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iosfwd"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 template <class _Container>
class back_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;


    using difference_type = ptrdiff_t;


#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    constexpr explicit back_insert_iterator(_Container& _Cont) noexcept 
        : container(::std:: addressof(_Cont)) {}

    constexpr back_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        container->push_back(_Val);
        return *this;
    }

    constexpr back_insert_iterator& operator=(typename _Container::value_type&& _Val) {
        container->push_back(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] constexpr back_insert_iterator& operator*() noexcept  {
        return *this;
    }

    constexpr back_insert_iterator& operator++() noexcept  {
        return *this;
    }

    constexpr back_insert_iterator operator++(int) noexcept  {
        return *this;
    }

protected:
    _Container* container;
};

 template <class _Container>
[[nodiscard]] constexpr back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept  {
    
    return back_insert_iterator<_Container>(_Cont);
}

 template <class _Container>
class front_insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;


    using difference_type = ptrdiff_t;


#line 87 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    constexpr explicit front_insert_iterator(_Container& _Cont) : container(::std:: addressof(_Cont)) {}

    constexpr front_insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        container->push_front(_Val);
        return *this;
    }

    constexpr front_insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        container->push_front(::std:: move(_Val));
        return *this;
    }

    [[nodiscard]] constexpr front_insert_iterator& operator*() { 
        return *this;
    }

    constexpr front_insert_iterator& operator++() { 
        return *this;
    }

    constexpr front_insert_iterator operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
};

 template <class _Container>
[[nodiscard]] constexpr front_insert_iterator<_Container> front_inserter(_Container& _Cont) {
    return front_insert_iterator<_Container>(_Cont);
}

 template <class _Container>
class insert_iterator { 
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;
    using pointer           = void;
    using reference         = void;

    using container_type = _Container;

    using difference_type = ptrdiff_t;
    using _Wrapped_iter   = ranges::iterator_t<_Container>;



#line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    constexpr insert_iterator(_Container& _Cont, _Wrapped_iter _Where)
        : container(::std:: addressof(_Cont)), iter(::std:: move(_Where)) {}

    constexpr insert_iterator& operator=(const typename _Container::value_type& _Val) {
        
        iter = container->insert(iter, _Val);
        ++iter;
        return *this;
    }

    constexpr insert_iterator& operator=(typename _Container::value_type&& _Val) { 
        iter = container->insert(iter, ::std:: move(_Val));
        ++iter;
        return *this;
    }

    [[nodiscard]] constexpr insert_iterator& operator*() { 
        return *this;
    }

    constexpr insert_iterator& operator++() { 
        return *this;
    }

    constexpr insert_iterator& operator++(int) { 
        return *this;
    }

protected:
    _Container* container;
    _Wrapped_iter iter;
};







 template <class _Container>
[[nodiscard]] constexpr insert_iterator<_Container> inserter(_Container& _Cont, ::std::ranges:: iterator_t<_Container> _Where) {
    return insert_iterator<_Container>(_Cont, _Where);
}

 template <semiregular _Se>
class move_sentinel {
public:
    constexpr move_sentinel() = default;

    constexpr explicit move_sentinel(_Se _Val) noexcept(is_nothrow_move_constructible_v<_Se>) 
        : _Last(::std:: move(_Val)) {}

    template <class _Se2>
        requires convertible_to<const _Se2&, _Se>
    constexpr move_sentinel(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_constructible_v<_Se, const _Se2&>) 
        : _Last(_Val._Get_last()) {}

    template <class _Se2>
        requires assignable_from<_Se&, const _Se2&>
    constexpr move_sentinel& operator=(const move_sentinel<_Se2>& _Val) noexcept(
        is_nothrow_assignable_v<_Se&, const _Se2&>)  {
        _Last = _Val._Get_last();
        return *this;
    }

    [[nodiscard]] constexpr _Se base() const noexcept(is_nothrow_copy_constructible_v<_Se>)  {
        return _Last;
    }

    [[nodiscard]] constexpr const _Se& _Get_last() const noexcept {
        return _Last;
    }

    using _Prevent_inheriting_unwrap = move_sentinel;

    
    [[nodiscard]] constexpr move_sentinel<_Unwrapped_t<const _Se&>> _Unwrapped() const&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()}))
        requires ::std::ranges:: _Weakly_unwrappable_sentinel<_Se> {
        
        return move_sentinel<_Unwrapped_t<const _Se&>>{_Last._Unwrapped()};
    }
    
    [[nodiscard]] constexpr move_sentinel<_Unwrapped_t<_Se>> _Unwrapped() &&
        noexcept(noexcept(move_sentinel<_Unwrapped_t<_Se>>{::std:: move(_Last)._Unwrapped()}))
        requires ::std::ranges:: _Weakly_unwrappable_sentinel<_Se> {
        
        return move_sentinel<_Unwrapped_t<_Se>>{::std:: move(_Last)._Unwrapped()};
    }

private:
    _Se _Last{};
};
#line 234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

 template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>, class _Diff = ptrdiff_t>
class istream_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Ty;
    using difference_type   = _Diff;
    using pointer           = const _Ty*;
    using reference         = const _Ty&;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using istream_type      = basic_istream<_Elem, _Traits>;

    static_assert(conjunction_v<is_default_constructible<_Ty>, is_copy_constructible<_Ty>, is_copy_assignable<_Ty>>,
        "istream_iterator<T> requires T to be default constructible, copy constructible, and copy assignable. "
        "(N4950 [istream.iterator]/2)");

    constexpr istream_iterator() noexcept(is_nothrow_default_constructible_v<_Ty>)  {}


    constexpr istream_iterator(default_sentinel_t) noexcept(
        is_nothrow_default_constructible_v<_Ty>)  {}
#line 257 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    istream_iterator(istream_type& _Istr) : _Myistr(::std:: addressof(_Istr)) {
        _Getval();
    }

    [[nodiscard]] const _Ty& operator*() const noexcept  {
        ;
        return _Myval;
    }

    [[nodiscard]] const _Ty* operator->() const noexcept  {
        ;
        return ::std:: addressof(_Myval);
    }

    istream_iterator& operator++() {
        _Getval();
        return *this;
    }

    istream_iterator operator++(int) {
        istream_iterator _Tmp = *this;
        _Getval();
        return _Tmp;
    }

    [[nodiscard]] bool _Equal(const istream_iterator& _Right) const noexcept {
        return _Myistr == _Right._Myistr;
    }


    [[nodiscard]] friend bool operator==(const istream_iterator& _Left, default_sentinel_t) noexcept  {
        return !_Left._Myistr;
    }
#line 292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

private:
    void _Getval() { 
        ;
        if (!(*_Myistr >> _Myval)) {
            _Myistr = nullptr;
        }
    }

    istream_type* _Myistr{nullptr}; 
    _Ty _Myval{}; 
};

 template <class _Ty, class _Elem, class _Traits, class _Diff>
[[nodiscard]] bool operator==(const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
    const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) noexcept  {
    return _Left._Equal(_Right);
}







#line 318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

 template <class _Ty, class _Elem = char, class _Traits = char_traits<_Elem>>
class ostream_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;

    using difference_type = ptrdiff_t;


#line 329 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
    using pointer      = void;
    using reference    = void;
    using char_type    = _Elem;
    using traits_type  = _Traits;
    using ostream_type = basic_ostream<_Elem, _Traits>;

    ostream_iterator(ostream_type& _Ostr, const _Elem* const _Delim = nullptr) noexcept 
        : _Mydelim(_Delim), _Myostr(::std:: addressof(_Ostr)) {}

    ostream_iterator& operator=(const _Ty& _Val) { 
        *_Myostr << _Val;
        if (_Mydelim) {
            *_Myostr << _Mydelim;
        }

        return *this;
    }

    [[nodiscard]] ostream_iterator& operator*() noexcept  {
        return *this;
    }

    ostream_iterator& operator++() noexcept  {
        return *this;
    }

    ostream_iterator& operator++(int) noexcept  {
        return *this;
    }

private:
    const _Elem* _Mydelim; 
    ostream_type* _Myostr; 
};

 template <class _Elem, class _Traits>
class istreambuf_iterator {
public:
    using iterator_category = input_iterator_tag;
    using value_type        = _Elem;
    using difference_type   = typename _Traits::off_type;
    using pointer           = const _Elem*;
    using reference         = _Elem;
    using char_type         = _Elem;
    using traits_type       = _Traits;
    using int_type          = typename traits_type::int_type;
    using streambuf_type    = basic_streambuf<_Elem, _Traits>;
    using istream_type      = basic_istream<_Elem, _Traits>;

    constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val() {}

    constexpr istreambuf_iterator(default_sentinel_t) noexcept : _Strbuf(nullptr), _Got(true), _Val() {}
#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val() {}

    istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val() {}

private:
    class _Istreambuf_proxy {
    public:
        [[nodiscard]] _Elem operator*() const noexcept(is_nothrow_copy_constructible_v<_Elem>)  {
            return _Keep;
        }

    private:
        friend istreambuf_iterator;
        _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) noexcept(
            is_nothrow_copy_constructible_v<_Elem>) 
            : _Strbuf(_Strbuf_), _Keep(_Keep_) {}

        streambuf_type* _Strbuf;
        _Elem _Keep;
    };

public:
    istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val() {}

    [[nodiscard]] _Elem operator*() const {
        if (!_Got) {
            _Peek();
        }



#line 415 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

        return _Val;
    }

    istreambuf_iterator& operator++() {


#line 423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

        _Inc();
        return *this;
    }

    _Istreambuf_proxy operator++(int) {
        if (!_Got) {
            _Peek();
        }

        _Istreambuf_proxy _Tmp{_Strbuf, _Val};
        ++*this;
        return _Tmp;
    }

    [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const {
        if (!_Got) {
            _Peek();
        }

        if (!_Right._Got) {
            _Right._Peek();
        }

        return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
    }


    [[nodiscard]] friend bool operator==(const istreambuf_iterator& _Left, default_sentinel_t) {
        if (!_Left._Got) {
            _Left._Peek();
        }

        return !_Left._Strbuf;
    }
#line 459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

private:
    void _Inc() { 
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc())) {
            _Strbuf = nullptr;
            _Got    = true;
        } else {
            _Got = false;
        }
    }

    _Elem _Peek() const { 
        int_type _Meta;
        if (!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc())) {
            _Strbuf = nullptr;
        } else {
            _Val = traits_type::to_char_type(_Meta);
        }

        _Got = true;
        return _Val;
    }

    mutable streambuf_type* _Strbuf; 
    mutable bool _Got; 
    mutable _Elem _Val; 
};

 template <class _Elem, class _Traits>
[[nodiscard]] bool operator==(
    const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right) {
    return _Left.equal(_Right);
}







#line 500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

 template <class _Elem, class _Traits>
class ostreambuf_iterator {
public:
    using iterator_category = output_iterator_tag;
    using value_type        = void;

    using difference_type = ptrdiff_t;


#line 511 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
    using pointer        = void;
    using reference      = void;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using streambuf_type = basic_streambuf<_Elem, _Traits>;
    using ostream_type   = basic_ostream<_Elem, _Traits>;

    ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

    ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}

    ostreambuf_iterator& operator=(_Elem _Right) { 
        if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
            _Failed = true;
        }

        return *this;
    }

    [[nodiscard]] ostreambuf_iterator& operator*() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++() noexcept  {
        return *this;
    }

    ostreambuf_iterator& operator++(int) noexcept  {
        return *this;
    }

    [[nodiscard]] bool failed() const noexcept {
        return _Failed;
    }

private:
    bool _Failed = false; 
    streambuf_type* _Strbuf;
};


enum class _Variantish_state : unsigned char { _Nothing, _Holds_first, _Holds_second };

struct _Variantish_empty_tag {
    explicit _Variantish_empty_tag() = default;
};

template <class _Ty1, class _Ty2>
class _Variantish {
public:
    constexpr explicit _Variantish(_Variantish_empty_tag) noexcept : _Contains{_Variantish_state::_Nothing} {}

    constexpr _Variantish() noexcept(is_nothrow_default_constructible_v<_Ty1>)
        requires default_initializable<_Ty1>
        : _First{}, _Contains{_Variantish_state::_Holds_first} {}

    template <class... _Types>
    constexpr explicit _Variantish(in_place_type_t<_Ty1>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty1, _Types...>)
        : _First(::std:: forward<_Types>(_Args)...), _Contains{_Variantish_state::_Holds_first} {}

    template <class... _Types>
        requires _Different_from<_Ty1, _Ty2>
    constexpr explicit _Variantish(in_place_type_t<_Ty2>, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty2, _Types...>)
        : _Second(::std:: forward<_Types>(_Args)...), _Contains{_Variantish_state::_Holds_second} {}

    
    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&> && is_nothrow_constructible_v<_Ty2, const _Uty2&>)
        : _Contains{_That._Contains} {
        
        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    
    constexpr _Variantish(const _Variantish&) requires is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2> = default;
    

    constexpr _Variantish(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>)
        : _Contains{_That._Contains} {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    
    constexpr _Variantish(_Variantish&&) requires is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2> = default;
    

    constexpr _Variantish(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>)
        : _Contains{_That._Contains} {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, ::std:: move(_That._Get_first()));
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, ::std:: move(_That._Get_second()));
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    constexpr ~_Variantish() {
        _Raw_clear();
    }

    
    constexpr ~_Variantish() requires is_trivially_destructible_v<_Ty1> && is_trivially_destructible_v<_Ty2> = default;

    constexpr _Variantish& operator=(const _Variantish&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_copy_constructible_v<_Ty1>
        && is_trivially_copy_constructible_v<_Ty2>
        && is_trivially_copy_assignable_v<_Ty1>
        && is_trivially_copy_assignable_v<_Ty2> = default;
    

    constexpr _Variantish& operator=(const _Variantish& _That) noexcept(
        is_nothrow_copy_constructible_v<_Ty1>&& is_nothrow_copy_constructible_v<_Ty2>&&
            is_nothrow_copy_assignable_v<_Ty1>&& is_nothrow_copy_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = _That._Get_first();
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = _That._Get_second();
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    constexpr _Variantish& operator=(_Variantish&&) requires is_trivially_destructible_v<_Ty1>
        && is_trivially_destructible_v<_Ty2>
        && is_trivially_move_constructible_v<_Ty1>
        && is_trivially_move_constructible_v<_Ty2>
        && is_trivially_move_assignable_v<_Ty1>
        && is_trivially_move_assignable_v<_Ty2> = default;
    

    constexpr _Variantish& operator=(_Variantish&& _That) noexcept(
        is_nothrow_move_constructible_v<_Ty1>&& is_nothrow_move_constructible_v<_Ty2>&&
            is_nothrow_move_assignable_v<_Ty1>&& is_nothrow_move_assignable_v<_Ty2>) {
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = ::std:: move(_That._Get_first());
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = ::std:: move(_That._Get_second());
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, ::std:: move(_That._Get_first()));
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, ::std:: move(_That._Get_second()));
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    template <class _Uty1, class _Uty2>
        requires _Different_from<_Variantish<_Uty1, _Uty2>, _Variantish>
    constexpr _Variantish& operator=(const _Variantish<_Uty1, _Uty2>& _That) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Uty1&> && is_nothrow_constructible_v<_Ty2, const _Uty2&>
            && is_nothrow_assignable_v<_Ty1&, const _Uty1&> && is_nothrow_assignable_v<_Ty2&, const _Uty2&>) {
        
        if (_Contains == _That._Contains) {
            switch (_Contains) {
            case _Variantish_state::_Holds_first:
                _Get_first() = _That._Get_first();
                break;
            case _Variantish_state::_Holds_second:
                _Get_second() = _That._Get_second();
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return *this;
        }

        _Clear();

        switch (_That._Contains) {
        case _Variantish_state::_Holds_first:
            ::std:: _Construct_in_place(_First, _That._Get_first());
            break;
        case _Variantish_state::_Holds_second:
            ::std:: _Construct_in_place(_Second, _That._Get_second());
            break;
        case _Variantish_state::_Nothing:
            break;
        }

        _Contains = _That._Contains;

        return *this;
    }

    
    friend constexpr void swap(_Variantish& _Left, _Variantish& _Right) noexcept(
        is_nothrow_move_constructible_v<_Ty1> && is_nothrow_move_constructible_v<_Ty2>
            && is_nothrow_swappable_v<_Ty1> && is_nothrow_swappable_v<_Ty2>)
        requires (!_Is_trivially_swappable_v<_Ty1> || !_Is_trivially_swappable_v<_Ty2>) {
        
        if (_Left._Contains == _Right._Contains) {
            switch (_Left._Contains) {
            case _Variantish_state::_Holds_first:
                ::std::ranges:: swap(_Left._Get_first(), _Right._Get_first());
                break;
            case _Variantish_state::_Holds_second:
                ::std::ranges:: swap(_Left._Get_second(), _Right._Get_second());
                break;
            case _Variantish_state::_Nothing:
                break;
            }

            return;
        }

        auto _Tmp = ::std:: move(_Left);
        _Left     = ::std:: move(_Right);
        _Right    = ::std:: move(_Tmp);
    }

    constexpr void _Raw_clear() noexcept {
        switch (_Contains) {
        case _Variantish_state::_Holds_first:
            _First.~_Ty1();
            break;
        case _Variantish_state::_Holds_second:
            _Second.~_Ty2();
            break;
        case _Variantish_state::_Nothing:
            break;
        }
    }

    [[nodiscard]] constexpr _Ty1& _Get_first() noexcept {
        return _First;
    }
    [[nodiscard]] constexpr const _Ty1& _Get_first() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr _Ty2& _Get_second() noexcept {
        return _Second;
    }
    [[nodiscard]] constexpr const _Ty2& _Get_second() const noexcept {
        return _Second;
    }

    constexpr void _Clear() noexcept {
        _Raw_clear();
        _Contains = _Variantish_state::_Nothing;
    }

    template <class... _Types>
    constexpr void _Emplace_first(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty1, _Types...>) {
        _Clear();

        ::std:: _Construct_in_place(_First, ::std:: forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_first;
    }

    template <class... _Types>
    constexpr void _Emplace_second(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty2, _Types...>) {
        _Clear();

        ::std:: _Construct_in_place(_Second, ::std:: forward<_Types>(_Args)...);
        _Contains = _Variantish_state::_Holds_second;
    }

    union {
        remove_cv_t<_Ty1> _First;
        remove_cv_t<_Ty2> _Second;
    };

    _Variantish_state _Contains;
};


template <class _Iter>
concept _Use_postfix_proxy = !requires(_Iter& __it) { { *__it++ } -> _Can_reference; }
    && indirectly_readable<_Iter>
    && constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>
    && move_constructible<iter_value_t<_Iter>>;


 template <input_or_output_iterator _Iter, sentinel_for<_Iter> _Se>
    requires (!same_as<_Iter, _Se> && copyable<_Iter>)
class common_iterator {
private:
    struct _Proxy_base {
        iter_value_t<_Iter> _Keep;

        constexpr explicit _Proxy_base(iter_reference_t<_Iter>&& _Right) noexcept(
            is_nothrow_constructible_v<iter_value_t<_Iter>, iter_reference_t<_Iter>>) 
            : _Keep(::std:: forward<iter_reference_t<_Iter>>(_Right)) {}
    };

public:
    
    constexpr common_iterator() requires default_initializable<_Iter> = default;
    

    constexpr common_iterator(_Iter _Right) noexcept(is_nothrow_move_constructible_v<_Iter>) 
        : _Val{in_place_type<_Iter>, ::std:: move(_Right)} {}

    constexpr common_iterator(_Se _Right) noexcept(is_nothrow_move_constructible_v<_Se>) 
        : _Val{in_place_type<_Se>, ::std:: move(_Right)} {}

    constexpr explicit common_iterator(_Variantish_empty_tag _Tag) noexcept : _Val{_Tag} {}

    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter> && convertible_to<const _OSe&, _Se>
    constexpr common_iterator(const common_iterator<_OIter, _OSe>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _OIter&>&& is_nothrow_constructible_v<_Se, const _OSe&>) 
        : _Val{_Right._Get_val()} {}

    
    template <class _OIter, class _OSe>
        requires convertible_to<const _OIter&, _Iter> && convertible_to<const _OSe&, _Se>
            && assignable_from<_Iter&, const _OIter&> && assignable_from<_Se&, const _OSe&>
    constexpr common_iterator& operator=(const common_iterator<_OIter, _OSe>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _OIter&> && is_nothrow_constructible_v<_Se, const _OSe&>
            && is_nothrow_assignable_v<_Iter&, const _OIter&>
            && is_nothrow_assignable_v<_Se&, const _OSe&>)  {
        
        _Val = _Right._Get_val();
        return *this;
    }

    [[nodiscard]] constexpr decltype(auto) operator*() {



#line 912 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return *_Val._Get_first();
    }

    [[nodiscard]] constexpr decltype(auto) operator*() const
        requires _Dereferenceable<const _Iter>
    {



#line 922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return *_Val._Get_first();
    }

    
    [[nodiscard]] constexpr auto operator->() const
        requires indirectly_readable<const _Iter>
            && (_Has_member_arrow<const _Iter&> || is_reference_v<iter_reference_t<_Iter>>
                || constructible_from<iter_value_t<_Iter>, iter_reference_t<_Iter>>) {
        



#line 935 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        if constexpr (_Has_member_arrow<const _Iter&> || is_pointer_v<_Iter>) {
            return _Val._Get_first();
        } else if constexpr (is_reference_v<iter_reference_t<_Iter>>) {
            auto&& _Tmp = *_Val._Get_first();
            return ::std:: addressof(_Tmp);
        } else {
            class _Arrow_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                [[nodiscard]] constexpr const iter_value_t<_Iter>* operator->() const noexcept {
                    return ::std:: addressof(this->_Keep);
                }
            };

            return _Arrow_proxy{*_Val._Get_first()};
        }
    }

    constexpr common_iterator& operator++() {



#line 961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        ++_Val._Get_first();
        return *this;
    }

    constexpr decltype(auto) operator++(int) {



#line 970 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        if constexpr (forward_iterator<_Iter>) {
            common_iterator _Tmp = *this;
            ++_Val._Get_first();
            return _Tmp;
        } else if constexpr (_Use_postfix_proxy<_Iter>) {
            class _Postfix_proxy : private _Proxy_base {
            public:
                friend common_iterator;

                using _Proxy_base::_Proxy_base;

                [[nodiscard]] constexpr const iter_value_t<_Iter>& operator*() const noexcept {
                    return this->_Keep;
                }
            };

            _Postfix_proxy _Tmp{*_Val._Get_first()};
            ++_Val._Get_first();
            return _Tmp;
        } else {
            return _Val._Get_first()++;
        }
    }

    template <class _OIter, sentinel_for<_Iter> _OSe>
        requires sentinel_for<_Se, _OIter>
    [[nodiscard]] friend constexpr bool operator==(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();




#line 1004 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                if constexpr (equality_comparable_with<_Iter, _OIter>) {
                    return _Left._Val._Get_first() == _Right_val._Get_first();
                } else {
                    return true;
                }
            } else {
                return _Left._Val._Get_first() == _Right_val._Get_second();
            }
        } else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_second() == _Right_val._Get_first();
            } else {
                return true;
            }
        }
    }

    template <sized_sentinel_for<_Iter> _OIter, sized_sentinel_for<_Iter> _OSe>
        requires sized_sentinel_for<_Se, _OIter>
    [[nodiscard]] friend constexpr iter_difference_t<_OIter> operator-(
        const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) {
        auto& _Right_val = _Right._Get_val();




#line 1034 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

        if (_Left._Val._Contains == _Variantish_state::_Holds_first) {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_first() - _Right_val._Get_first();
            } else {
                return _Left._Val._Get_first() - _Right_val._Get_second();
            }
        } else {
            if (_Right_val._Contains == _Variantish_state::_Holds_first) {
                return _Left._Val._Get_second() - _Right_val._Get_first();
            } else {
                return 0;
            }
        }
    }

    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const common_iterator& _Right) noexcept(
        noexcept(::std::ranges:: iter_move(_Right._Val._Get_first())))
        requires input_iterator<_Iter>
    {



#line 1058 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return ::std::ranges:: iter_move(_Right._Val._Get_first());
    }

    template <indirectly_swappable<_Iter> _OIter, class _OSe>
    friend constexpr void iter_swap(const common_iterator& _Left, const common_iterator<_OIter, _OSe>& _Right) noexcept(
        noexcept(::std::ranges:: iter_swap(_Left._Val._Get_first(), _Right._Get_val()._Get_first()))) {
        auto& _Right_val = _Right._Get_val();




#line 1070 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return ::std::ranges:: iter_swap(_Left._Val._Get_first(), _Right_val._Get_first());
    }

    [[nodiscard]] constexpr _Variantish<_Iter, _Se>& _Get_val() noexcept {
        return _Val;
    }
    [[nodiscard]] constexpr const _Variantish<_Iter, _Se>& _Get_val() const noexcept {
        return _Val;
    }

private:
    _Variantish<_Iter, _Se> _Val;
};

template <class _Iter, class _Se>
struct incrementable_traits<common_iterator<_Iter, _Se>> {
    using difference_type = iter_difference_t<_Iter>;
};

template <class, class>
struct _Common_iterator_pointer_type {
    using pointer = void;
};

template <class _Iter, class _Se>
    requires _Has_member_arrow<const common_iterator<_Iter, _Se>&>
struct _Common_iterator_pointer_type<_Iter, _Se> {
    using pointer = decltype(::std:: declval<const common_iterator<_Iter, _Se>&>().operator->());
};

template <class _Iter>
concept _Has_forward_category = requires {
    typename _Iter_cat_t<_Iter>;
    requires derived_from<_Iter_cat_t<_Iter>, forward_iterator_tag>;
};

template <input_iterator _Iter, class _Se>
struct iterator_traits<common_iterator<_Iter, _Se>> {
    using iterator_concept  = conditional_t<forward_iterator<_Iter>, forward_iterator_tag, input_iterator_tag>;
    using iterator_category = conditional_t<_Has_forward_category<_Iter>, forward_iterator_tag, input_iterator_tag>;
    using value_type        = iter_value_t<_Iter>;
    using difference_type   = iter_difference_t<_Iter>;
    using pointer           = typename _Common_iterator_pointer_type<_Iter, _Se>::pointer;
    using reference         = iter_reference_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_value_type_base {};

template <indirectly_readable _Iter>
struct _Counted_iterator_value_type_base<_Iter> {
    using value_type = iter_value_t<_Iter>;
};

template <class _Iter>
struct _Counted_iterator_category_base : _Counted_iterator_value_type_base<_Iter> {};

template <_Has_member_iterator_category _Iter>
struct _Counted_iterator_category_base<_Iter> : _Counted_iterator_value_type_base<_Iter> {
    using iterator_category = typename _Iter::iterator_category;
};

template <class _Iter>
struct _Counted_iterator_concept_base : _Counted_iterator_category_base<_Iter> {};

template <_Has_member_iterator_concept _Iter>
struct _Counted_iterator_concept_base<_Iter> : _Counted_iterator_category_base<_Iter> {
    using iterator_concept = typename _Iter::iterator_concept;
};

 template <input_or_output_iterator _Iter>
class counted_iterator : public _Counted_iterator_concept_base<_Iter> {
public:
    using iterator_type   = _Iter;
    using difference_type = iter_difference_t<_Iter>;

    
    
    constexpr counted_iterator() requires default_initializable<_Iter> = default;
    

    constexpr counted_iterator(_Iter _Right, const iter_difference_t<_Iter> _Diff) noexcept(
        is_nothrow_move_constructible_v<_Iter>) 
        : _Current(::std:: move(_Right)), _Length(_Diff) {


#line 1157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
    }

    template <class _Other>
        requires convertible_to<const _Other&, _Iter>
    constexpr counted_iterator(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_constructible_v<_Iter, const _Other&>) 
        : _Current(_Right.base()), _Length(_Right.count()) {}

    template <class _Other>
        requires assignable_from<_Iter&, const _Other&>
    constexpr counted_iterator& operator=(const counted_iterator<_Other>& _Right) noexcept(
        is_nothrow_assignable_v<_Iter&, const _Other&>)  {
        _Current = _Right.base();
        _Length  = _Right.count();
        return *this;
    }

    
    [[nodiscard]] constexpr const _Iter& base() const& noexcept {
        return _Current;
    }

    [[nodiscard]] constexpr _Iter base() && noexcept(is_nothrow_move_constructible_v<_Iter>)  {
        return ::std:: move(_Current);
    }

    [[nodiscard]] constexpr iter_difference_t<_Iter> count() const noexcept {
        return _Length;
    }

    
    [[nodiscard]] constexpr decltype(auto) operator*() noexcept(noexcept(*_Current))  {


#line 1192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return *_Current;
    }

    [[nodiscard]] constexpr decltype(auto) operator*() const noexcept(noexcept(*_Current)) 
        requires _Dereferenceable<const _Iter>
    {


#line 1201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return *_Current;
    }

    [[nodiscard]] constexpr auto operator->() const noexcept
        requires contiguous_iterator<_Iter>
    {
        return ::std:: to_address(_Current);
    }

    [[nodiscard]] constexpr decltype(auto) operator[](const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {


#line 1216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Current[_Diff];
    }

    
    constexpr counted_iterator& operator++() {


#line 1224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        ++_Current;
        --_Length;
        return *this;
    }

    constexpr decltype(auto) operator++(int) {


#line 1233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        --_Length;
        try {
        return _Current++;

        } catch (...) {
        ++_Length;

        throw;
        }
    }

    constexpr counted_iterator operator++(int)
        requires forward_iterator<_Iter>
    {


#line 1250 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        counted_iterator _Tmp = *this;
        ++_Current;
        --_Length;
        return _Tmp;
    }

    constexpr counted_iterator& operator--()
        requires bidirectional_iterator<_Iter>
    {
        --_Current;
        ++_Length;
        return *this;
    }

    constexpr counted_iterator operator--(int)
        requires bidirectional_iterator<_Iter>
    {
        counted_iterator _Tmp = *this;
        --_Current;
        ++_Length;
        return _Tmp;
    }

    [[nodiscard]] constexpr counted_iterator operator+(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Length - _Diff)};
    }

    [[nodiscard]] friend constexpr counted_iterator operator+(
        const iter_difference_t<_Iter> _Diff, const counted_iterator& _Right)
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Right._Current + _Diff, static_cast<iter_difference_t<_Iter>>(_Right._Length - _Diff)};
    }

    constexpr counted_iterator& operator+=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {


#line 1292 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        _Current += _Diff;
        _Length -= _Diff;
        return *this;
    }

    [[nodiscard]] constexpr counted_iterator operator-(const iter_difference_t<_Iter> _Diff) const
        requires random_access_iterator<_Iter>
    {
        return counted_iterator{_Current - _Diff, static_cast<iter_difference_t<_Iter>>(_Length + _Diff)};
    }

    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr iter_difference_t<_Other> operator-(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept  {


#line 1309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Right.count() - _Left._Length;
    }

    [[nodiscard]] friend constexpr iter_difference_t<_Iter> operator-(
        const counted_iterator& _Left, default_sentinel_t) noexcept  {
        return -_Left._Length;
    }

    [[nodiscard]] friend constexpr iter_difference_t<_Iter> operator-(
        default_sentinel_t, const counted_iterator& _Right) noexcept  {
        return _Right._Length;
    }

    constexpr counted_iterator& operator-=(const iter_difference_t<_Iter> _Diff)
        requires random_access_iterator<_Iter>
    {


#line 1328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        _Current -= _Diff;
        _Length += _Diff;
        return *this;
    }

    
    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr bool operator==(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept  {


#line 1340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Left._Length == _Right.count();
    }

    [[nodiscard]] friend constexpr bool operator==(const counted_iterator& _Left, default_sentinel_t) noexcept
     {
        return _Left._Length == 0;
    }

    template <common_with<_Iter> _Other>
    [[nodiscard]] friend constexpr strong_ordering operator<=>(
        const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept  {


#line 1354 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Right.count() <=> _Left._Length;
    }

    
    [[nodiscard]] friend constexpr iter_rvalue_reference_t<_Iter> iter_move(const counted_iterator& _Right) noexcept(
        noexcept(::std::ranges:: iter_move(_Right._Current)))
        requires input_iterator<_Iter>
    {
        return ::std::ranges:: iter_move(_Right._Current);
    }

    template <indirectly_swappable<_Iter> _Other>
    friend constexpr void iter_swap(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) noexcept(
        noexcept(::std::ranges:: iter_swap(_Left._Current, _Right.base()))) {
        ::std::ranges:: iter_swap(_Left._Current, _Right.base());
    }































#line 1402 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    template <common_with<_Iter> _Other>
    friend constexpr void _Verify_range(const counted_iterator& _Left, const counted_iterator<_Other>& _Right) {
        if constexpr (_Range_verifiable_v<_Iter, _Other>) {
            _Verify_range(_Left._Current, _Right.base());
        }


#line 1411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
    }

    constexpr void _Verify_offset(const iter_difference_t<_Iter> _Off) const {


#line 1417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        if constexpr (_Offset_verifiable_v<_Iter>) {
            _Current._Verify_offset(_Off);
        }
    }

    using _Prevent_inheriting_unwrap = counted_iterator;

    [[nodiscard]] constexpr counted_iterator<_Unwrapped_t<const _Iter&>> _Unwrapped() const& noexcept(
        noexcept(counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length}))
        requires _Unwrappable_v<const _Iter&>
    {
        return counted_iterator<_Unwrapped_t<const _Iter&>>{_Current._Unwrapped(), _Length};
    }

    [[nodiscard]] constexpr counted_iterator<_Unwrapped_t<_Iter>> _Unwrapped() && noexcept(
        noexcept(counted_iterator<_Unwrapped_t<_Iter>>{::std:: move(_Current)._Unwrapped(), _Length}))
        requires _Unwrappable_v<_Iter>
    {
        return counted_iterator<_Unwrapped_t<_Iter>>{::std:: move(_Current)._Unwrapped(), _Length};
    }

    static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_Iter>;

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, const _Other&>
    constexpr void _Seek_to(const counted_iterator<_Other>& _It) {
        _Current._Seek_to(_It.base());
        _Length = _It.count();
    }

    template <class _Other>
        requires _Wrapped_seekable_v<_Iter, _Other>
    constexpr void _Seek_to(counted_iterator<_Other>&& _It) {
        _Current._Seek_to(::std:: move(_It).base());
        _Length = _It.count();
    }

private:
    _Iter _Current{};
    iter_difference_t<_Iter> _Length = 0;
};

template <input_iterator _Iter>
    requires (!_Is_from_primary<iterator_traits<_Iter>>)
struct iterator_traits<counted_iterator<_Iter>> : iterator_traits<_Iter> {
    using pointer = conditional_t<contiguous_iterator<_Iter>, add_pointer_t<iter_reference_t<_Iter>>, void>;
};
#line 1465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

}

namespace stdext {
template <class _Ptr>
class [[deprecated( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory " "functions are non-Standard extensions and will be removed in the future. std::span (since C++20) and " "gsl::span can be used instead. You can define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or " "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]] checked_array_iterator { 
private:
    using _Pointee_type = ::std:: remove_pointer_t<_Ptr>;
    static_assert(::std:: is_pointer_v<_Ptr> && ::std:: is_object_v<_Pointee_type>,
        "checked_array_iterator requires pointers to objects");

public:
    using iterator_category = ::std:: random_access_iterator_tag;
    using value_type        = ::std:: remove_cv_t<_Pointee_type>;
    using difference_type   = ::std:: ptrdiff_t;
    using pointer           = _Ptr;
    using reference         = _Pointee_type&;

    using iterator_concept = ::std:: contiguous_iterator_tag;
#line 1485 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    constexpr checked_array_iterator() = default;

    constexpr checked_array_iterator(const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept
        : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index) {
        do { if (_Index <= _Size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    }

    __pragma(warning(push)) __pragma(warning(disable : 4996))
    template <class _Ty = _Pointee_type, ::std:: enable_if_t<!::std:: is_const_v<_Ty>, int> = 0>
    constexpr operator checked_array_iterator<const _Ty*>() const noexcept {
        return checked_array_iterator<const _Ty*>{_Myarray, _Mysize, _Myindex};
    }
    __pragma(warning(pop))

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myarray + _Myindex;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        return _Myarray + _Myindex;
    }

    constexpr checked_array_iterator& operator++() noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex < _Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        ++_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator++(int) noexcept {
        checked_array_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator--() noexcept {
        do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        do { if (_Myindex != 0) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        --_Myindex;
        return *this;
    }

    constexpr checked_array_iterator operator--(int) noexcept {
        checked_array_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr checked_array_iterator& operator+=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1548 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1553 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        }

        _Myindex += _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator+(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr checked_array_iterator operator+(
        const difference_type _Off, const checked_array_iterator<_Ptr>& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr checked_array_iterator& operator-=(const difference_type _Off) noexcept {
        if (_Off != 0) {
            do { if (_Myarray) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off > 0) {
            do { if (_Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        }

        if (_Off < 0) {
            do { if (_Mysize - _Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1582 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        }

        _Myindex -= _Off;
        return *this;
    }

    [[nodiscard]] constexpr checked_array_iterator operator-(const difference_type _Off) const noexcept {
        checked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1597 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return static_cast<difference_type>(_Myindex - _Right._Myindex);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1607 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Myindex == _Right._Myindex;
    }


    [[nodiscard]] constexpr ::std:: strong_ordering operator<=>(const checked_array_iterator& _Right) const noexcept {
        do { if (_Myarray == _Right._Myarray && _Mysize == _Right._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1614 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        return _Myindex <=> _Right._Myindex;
    }






















#line 1639 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    friend constexpr void _Verify_range(
        const checked_array_iterator& _First, const checked_array_iterator& _Last) noexcept {
        do { if (_First._Myarray == _Last._Myarray && _First._Mysize == _Last._Mysize) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1644 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        do { if (_First._Myindex <= _Last._Myindex) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {
        if (_Off < 0) {
            do { if (_Myindex >= size_t{0} - static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1651 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        }

        if (_Off > 0) {
            do { if (_Mysize - _Myindex >= static_cast<size_t>(_Off)) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
#line 1656 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
        }
    }

    using _Prevent_inheriting_unwrap = checked_array_iterator;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myarray + _Myindex;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myindex = static_cast<size_t>(_It - _Myarray);
    }

private:
    _Ptr _Myarray   = nullptr; 
    size_t _Mysize  = 0; 
    size_t _Myindex = 0; 
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ptr>
[[deprecated( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory " "functions are non-Standard extensions and will be removed in the future. std::span (since C++20) and " "gsl::span can be used instead. You can define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or " "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] constexpr checked_array_iterator<_Ptr> make_checked_array_iterator(
    const _Ptr _Array, const size_t _Size, const size_t _Index = 0) noexcept {
    return checked_array_iterator<_Ptr>(_Array, _Size, _Index);
}
__pragma(warning(pop))

template <class _Ptr>
class [[deprecated( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory " "functions are non-Standard extensions and will be removed in the future. std::span (since C++20) and " "gsl::span can be used instead. You can define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or " "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]] unchecked_array_iterator { 
private:
    using _Pointee_type = ::std:: remove_pointer_t<_Ptr>;
    static_assert(::std:: is_pointer_v<_Ptr> && ::std:: is_object_v<_Pointee_type>,
        "unchecked_array_iterator requires pointers to objects");

public:
    using iterator_category = ::std:: random_access_iterator_tag;
    using value_type        = ::std:: remove_cv_t<_Pointee_type>;
    using difference_type   = ::std:: ptrdiff_t;
    using pointer           = _Ptr;
    using reference         = _Pointee_type&;

    using iterator_concept = ::std:: contiguous_iterator_tag;
#line 1699 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    constexpr unchecked_array_iterator() = default;

    constexpr explicit unchecked_array_iterator(const _Ptr _Src) noexcept : _Myptr(_Src) {}

    __pragma(warning(push)) __pragma(warning(disable : 4996))
    template <class _Ty = _Pointee_type, ::std:: enable_if_t<!::std:: is_const_v<_Ty>, int> = 0>
    constexpr operator unchecked_array_iterator<const _Ty*>() const noexcept {
        return unchecked_array_iterator<const _Ty*>{_Myptr};
    }
    __pragma(warning(pop))

    [[nodiscard]] constexpr _Ptr base() const noexcept {
        return _Myptr;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *_Myptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return _Myptr;
    }

    constexpr unchecked_array_iterator& operator++() noexcept {
        ++_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator++(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        ++_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator--() noexcept {
        --_Myptr;
        return *this;
    }

    constexpr unchecked_array_iterator operator--(int) noexcept {
        unchecked_array_iterator _Tmp = *this;
        --_Myptr;
        return _Tmp;
    }

    constexpr unchecked_array_iterator& operator+=(const difference_type _Off) noexcept {
        _Myptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator+(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr unchecked_array_iterator operator+(
        const difference_type _Off, const unchecked_array_iterator& _Next) noexcept {
        return _Next + _Off;
    }

    constexpr unchecked_array_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr unchecked_array_iterator operator-(const difference_type _Off) const noexcept {
        unchecked_array_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr - _Right._Myptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr == _Right._Myptr;
    }


    [[nodiscard]] constexpr ::std:: strong_ordering operator<=>(const unchecked_array_iterator& _Right) const noexcept {
        return _Myptr <=> _Right._Myptr;
    }




















#line 1808 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"






#line 1815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"

    using _Prevent_inheriting_unwrap = unchecked_array_iterator;

    static constexpr bool _Unwrap_when_unverified = true;

    [[nodiscard]] constexpr _Ptr _Unwrapped() const noexcept {
        return _Myptr;
    }

    constexpr void _Seek_to(_Ptr _It) noexcept {
        _Myptr = _It;
    }

private:
    _Ptr _Myptr = nullptr; 
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ptr>
[[deprecated( "warning STL4043: stdext::checked_array_iterator, stdext::unchecked_array_iterator, and related factory " "functions are non-Standard extensions and will be removed in the future. std::span (since C++20) and " "gsl::span can be used instead. You can define _SILENCE_STDEXT_ARR_ITERS_DEPRECATION_WARNING or " "_SILENCE_ALL_MS_EXT_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] unchecked_array_iterator<_Ptr> make_unchecked_array_iterator(
    const _Ptr _It) noexcept {
    return unchecked_array_iterator<_Ptr>(_It);
}
__pragma(warning(pop))
}


namespace std {
__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct pointer_traits<::stdext:: checked_array_iterator<_Ty*>> {
    using pointer         = ::stdext:: checked_array_iterator<_Ty*>;
    using element_type    = _Ty;
    using difference_type = ptrdiff_t;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {
        return _Iter._Unwrapped();
    }
};
__pragma(warning(pop))
}
#line 1857 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"



#pragma warning(pop)
#pragma pack(pop)
#line 1863 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
#line 1864 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iterator"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"









#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\share.h"







#pragma once




#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\share.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_system_error_abi.hpp"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )








#line 24 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_system_error_abi.hpp"

extern "C" {
[[nodiscard]] size_t __stdcall __std_get_string_size_without_trailing_whitespace(
    const char* _Str, size_t _Size) noexcept;

[[nodiscard]] size_t __stdcall __std_system_error_allocate_message(
    unsigned long _Message_id, char** _Ptr_str) noexcept;
void __stdcall __std_system_error_deallocate_message(char* _Str) noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_system_error_abi.hpp"
#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_system_error_abi.hpp"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cerrno"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cerrno"
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cerrno"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {




#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"
 extern "C++" [[nodiscard]]  int __cdecl uncaught_exceptions() noexcept;

}



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    


#line 29 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"













typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;






   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 69 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
    #line 73 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    
    
    

    
        
    

#line 85 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    static_assert((sizeof(unsigned int) <= 16), "sizeof(unsigned int) <= _ALLOCA_S_MARKER_SIZE");


    #pragma warning(push)
    #pragma warning(disable: 6540) 
                                   

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 112 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

















    
    







#line 139 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"




#line 144 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#line 145 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014) 
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                ((void)0);
            }
            #line 167 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 172 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"




    
#line 178 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\malloc.h"
#pragma external_header(pop)
#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_exception.h"







#pragma once

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"







#pragma once



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )




__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )(void);
typedef void (__cdecl* terminate_function)(void);








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 44 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

#line 46 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 50 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_terminate.h"

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"



#pragma warning(push)
#pragma warning(disable:   4514 4820 )

__pragma(pack(push, 8)) extern "C" {






















#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"

struct _EXCEPTION_POINTERS;


    
        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

         _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );
    #line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"

    extern "C++" { 
        class type_info;
    } 

     int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

     bool __cdecl __uncaught_exception();
     int  __cdecl __uncaught_exceptions();
#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"

} __pragma(pack(pop))

#pragma warning(pop) 

#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\eh.h"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_exception.h"







#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

 void __cdecl __std_exception_copy(
         __std_exception_data const* _From,
      __std_exception_data*       _To
    );

 void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class exception
{
public:

    exception() noexcept
        : _Data()
    {
    }

    explicit exception(char const* const _Message) noexcept
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) noexcept
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) noexcept
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) noexcept
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() noexcept
    {
        __std_exception_destroy(&_Data);
    }

    [[nodiscard]] virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() noexcept
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() noexcept
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() noexcept
        : bad_alloc("bad array new length")
    {
    }
};

#pragma warning(pop)

} 

#pragma pack(pop)

#pragma warning(pop) 
#line 153 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_exception.h"
#pragma external_header(pop)
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"

namespace std {

 class exception;
 class bad_exception;

 using ::terminate;


 using ::set_terminate;
 using ::terminate_handler;

 [[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept {
    
    return _get_terminate();
}
#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"













#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"

}










































































































































#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"

extern "C++"  void __cdecl __ExceptionPtrCreate(  void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrDestroy(  void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCopy(  void*,   const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrAssign(  void*,   const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrCompare(
      const void*,   const void*) noexcept;
extern "C++"  bool __cdecl __ExceptionPtrToBool(  const void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrSwap(  void*,   void*) noexcept;
extern "C++"  void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
extern "C++" [[noreturn]]  void __cdecl __ExceptionPtrRethrow(  const void*);
extern "C++"  void __cdecl __ExceptionPtrCopyException(
      void*,   const void*,   const void*) noexcept;

namespace std {

 class exception_ptr {
public:
    exception_ptr() noexcept {
        __ExceptionPtrCreate(this);
    }

    exception_ptr(nullptr_t) noexcept {
        __ExceptionPtrCreate(this);
    }

    ~exception_ptr() noexcept {
        __ExceptionPtrDestroy(this);
    }

    exception_ptr(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrCopy(this, &_Rhs);
    }

    exception_ptr& operator=(const exception_ptr& _Rhs) noexcept {
        __ExceptionPtrAssign(this, &_Rhs);
        return *this;
    }

    exception_ptr& operator=(nullptr_t) noexcept {
        exception_ptr _Ptr;
        __ExceptionPtrAssign(this, &_Ptr);
        return *this;
    }

    explicit operator bool() const noexcept {
        return __ExceptionPtrToBool(this);
    }

    static exception_ptr _Current_exception() noexcept {
        exception_ptr _Retval;
        __ExceptionPtrCurrentException(&_Retval);
        return _Retval;
    }

    static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr) {
        exception_ptr _Retval;
        if (!_Ptr) {
            
            return _Retval;
        }
        __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
        return _Retval;
    }

    friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept {
        __ExceptionPtrSwap(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept {
        return __ExceptionPtrCompare(&_Lhs, &_Rhs);
    }

    [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept {
        return !_Lhs;
    }

















#line 301 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"

private:




    void* _Data1{};
    void* _Data2{};



};

 [[nodiscard]] inline exception_ptr current_exception() noexcept {
    return exception_ptr::_Current_exception();
}

 [[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr) {
    __ExceptionPtrRethrow(&_Ptr);
}

template <class _Ex>
void* __GetExceptionInfo(_Ex);

 template <class _Ex>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] exception_ptr make_exception_ptr(_Ex _Except) noexcept {
    return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
}

[[noreturn]] inline void _Throw_bad_array_new_length() {
    throw bad_array_new_length{};
}

 class nested_exception { 
public:
    nested_exception() noexcept : _Exc(::std:: current_exception()) {}

    nested_exception(const nested_exception&) noexcept            = default;
    nested_exception& operator=(const nested_exception&) noexcept = default;
    virtual ~nested_exception() noexcept {}

    [[noreturn]] void rethrow_nested() const { 
        if (_Exc) {
            ::std:: rethrow_exception(_Exc);
        } else {
            ::std:: terminate(); 
        }
    }

    [[nodiscard]] exception_ptr nested_ptr() const noexcept { 
        return _Exc;
    }

private:
    exception_ptr _Exc;
};

template <class _Ty, class _Uty>
struct _With_nested : _Uty, nested_exception { 
    explicit _With_nested(_Ty&& _Arg)
        : _Uty(::std:: forward<_Ty>(_Arg)), nested_exception() {} 
};

 template <class _Ty>
[[noreturn]] void throw_with_nested(_Ty&& _Arg) {
    
    using _Uty = decay_t<_Ty>;

    if constexpr (is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>) {
        
        using _Glued = _With_nested<_Ty, _Uty>;
        throw _Glued(::std:: forward<_Ty>(_Arg));
    } else {
        
        throw ::std:: forward<_Ty>(_Arg);
    }
}


 template <class _Ty>
void rethrow_if_nested(const _Ty& _Arg) {
    
    constexpr bool _Can_use_dynamic_cast =
        is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>);

    if constexpr (_Can_use_dynamic_cast) {
        const auto _Nested = dynamic_cast<const nested_exception*>(::std:: addressof(_Arg));

        if (_Nested) {
            _Nested->rethrow_nested();
        }
    }
}



#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"

 class bad_variant_access
    : public exception { 
public:
    bad_variant_access() noexcept = default;

    [[nodiscard]] const char*  what() const noexcept override {
        return "bad variant access";
    }






#line 414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"
};

[[noreturn]] inline void _Throw_bad_variant_access() {
    throw bad_variant_access{};
}

}



#pragma warning(pop)
#pragma pack(pop)

#line 428 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"
#line 429 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\exception"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )























#line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"








#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"











#pragma detect_mismatch("annotate_string", "0")
#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"

#pragma detect_mismatch("annotate_vector", "0")
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"













extern "C" {







}







































#line 125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"

#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"



#pragma warning(pop)
#pragma pack(pop)

#line 134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"
#line 135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_sanitizer_annotate_container.hpp"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"












#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"












#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )





























































namespace std {

 class bad_alloc;
 class bad_array_new_length;


#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"


 struct destroying_delete_t {
    explicit destroying_delete_t() = default;
};
 inline constexpr destroying_delete_t destroying_delete{};
#line 91 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"


 template <class _Ty>
[[nodiscard("'std::launder' has a potential effect on the return value (not on the passed argument). " "It is not useful to call 'std::launder' and discard the return value.")]] constexpr _Ty* launder(_Ty* _Ptr) noexcept {
    static_assert(!is_function_v<_Ty> && !is_void_v<_Ty>,
        "N4950 [ptr.launder]/1: Mandates: !is_function_v<T> && !is_void_v<T> is true.");
    return __builtin_launder(_Ptr);
}


 inline constexpr size_t hardware_constructive_interference_size = 64;
 inline constexpr size_t hardware_destructive_interference_size  = 64;


#line 106 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"

#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"

 using new_handler = void(__cdecl*)();

 extern "C++"  new_handler __cdecl set_new_handler(  new_handler) noexcept;
 extern "C++" [[nodiscard]]  new_handler __cdecl get_new_handler() noexcept;
}



#pragma warning(pop)
#pragma pack(pop)

#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"
#line 122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\new"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )

















#line 36 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"












#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"











#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"




#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"

namespace std {


 enum class memory_order : int {
    relaxed,
    consume,
    acquire,
    release,
    acq_rel,
    seq_cst,

    
    memory_order_relaxed = relaxed,
    memory_order_consume = consume,
    memory_order_acquire = acquire,
    memory_order_release = release,
    memory_order_acq_rel = acq_rel,
    memory_order_seq_cst = seq_cst
};
 inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;
 inline constexpr memory_order memory_order_consume = memory_order::consume;
 inline constexpr memory_order memory_order_acquire = memory_order::acquire;
 inline constexpr memory_order memory_order_release = memory_order::release;
 inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;
 inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;









#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"

using _Atomic_counter_t = unsigned long;

template <class _Integral, class _Ty>
[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<volatile _Integral&>(_Source);
}

template <class _Integral, class _Ty>
[[nodiscard]] const volatile _Integral* _Atomic_address_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    return &reinterpret_cast<const volatile _Integral&>(_Source);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"
#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"











#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v0<true, tuple<_Dests...>, _Srcs...> =
    !conjunction_v<is_convertible<_Srcs, _Dests>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_conditional_explicit_v =
    _Tuple_conditional_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_constructible_v =
    _Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_constructible_v =
    _Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_assignable<_Dests&, _Srcs>...>; 


template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_assignable_v0<true, const tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_assignable<const _Dests&, _Srcs>...>;
#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_assignable_v =
    _Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

template <class _Dest, class... _Srcs>
struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>> {};

template <bool _Same, class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0 = false;

template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>; 


template <class... _Dests, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v0<true, const tuple<_Dests...>, _Srcs...> =
    conjunction_v<is_nothrow_assignable<const _Dests&, _Srcs>...>;
#line 92 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

template <class _Dest, class... _Srcs>
inline constexpr bool _Tuple_nothrow_assignable_v =
    _Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;


template <class _Myself, class _OtherTuple, class... _Other>
struct _Tuple_convert_val : true_type {};

template <class _This, class _OtherTuple, class _Uty>
struct _Tuple_convert_val<tuple<_This>, _OtherTuple, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, _OtherTuple>,
          is_convertible<_OtherTuple, _This>>> {};


template <class _Myself, class _This2, class... _Rest2>
struct _Tuple_perfect_val : true_type {};

template <class _Myself, class _This2>
struct _Tuple_perfect_val<_Myself, _This2> : bool_constant<!is_same_v<_Myself, _Remove_cvref_t<_This2>>> {};

template <class _Ty0, class _Ty1, class _Uty0, class _Uty1>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1>, _Uty0, _Uty1>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
          is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

template <class _Ty0, class _Ty1, class _Ty2, class _Uty0, class _Uty1, class _Uty2>
struct _Tuple_perfect_val<tuple<_Ty0, _Ty1, _Ty2>, _Uty0, _Uty1, _Uty2>
    : bool_constant<disjunction_v<negation<is_same<_Remove_cvref_t<_Uty0>, allocator_arg_t>>,
          is_same<_Remove_cvref_t<_Ty0>, allocator_arg_t>>> {};

struct _Ignore { 
    template <class _Ty>
    constexpr const _Ignore& operator=(const _Ty&) const noexcept  {
        
        return *this;
    }
};

 inline constexpr _Ignore ignore{};






template <class _Ty>
struct _Tuple_val { 
    constexpr _Tuple_val() : _Val() {}

    template <class _Other>
    constexpr _Tuple_val(_Other&& _Arg) : _Val(::std:: forward<_Other>(_Arg)) {}

    template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
    constexpr _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: uses_allocator<_Ty, _Alloc>,
                        ::std:: negation<::std:: is_constructible<_Ty, ::std:: allocator_arg_t, const _Alloc&, _Other...>>>,
            int> = 0>
    constexpr _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(::std:: forward<_Other>(_Arg)..., _Al) {}

    _Ty _Val;
};

struct _Exact_args_t {
    explicit _Exact_args_t() = default;
}; 

struct _Unpack_tuple_t {
    explicit _Unpack_tuple_t() = default;
}; 

struct _Alloc_exact_args_t {
    explicit _Alloc_exact_args_t() = default;
}; 

struct _Alloc_unpack_tuple_t {
    explicit _Alloc_unpack_tuple_t() = default;
}; 


template <class _Tuple, class _Other, class _Indices = make_index_sequence<tuple_size_v<_Tuple>>>
inline constexpr bool _Can_construct_values_from_tuple_like_v = false;

template <class... _Types, class _Other, size_t... _Indices>
inline constexpr bool _Can_construct_values_from_tuple_like_v<tuple<_Types...>, _Other, index_sequence<_Indices...>> =
    conjunction_v<is_constructible<_Types, decltype(::std:: get<_Indices>(::std:: declval<_Other>()))>...>;












template <class _TTuple, class _UTuple, class _Indices = make_index_sequence<tuple_size_v<_UTuple>>>
struct _Three_way_comparison_result_with_tuple_like {};

template <class... _TTypes, class _UTuple, size_t... _Indices>
    requires

    (sizeof...(_TTypes) == sizeof...(_Indices)) &&
#line 208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
    (requires { typename _Synth_three_way_result<_TTypes, tuple_element_t<_Indices, _UTuple>>; } && ...)
struct _Three_way_comparison_result_with_tuple_like<tuple<_TTypes...>, _UTuple, index_sequence<_Indices...>> {
    using type = common_comparison_category_t<_Synth_three_way_result<_TTypes, tuple_element_t<_Indices, _UTuple>>...>;
};

template <class _TTuple, _Tuple_like _UTuple>
using _Three_way_comparison_result_with_tuple_like_t =
    _Three_way_comparison_result_with_tuple_like<_TTuple, _UTuple>::type;

template <class _Ty>
concept _Tuple_like_non_tuple = !_Is_specialization_v<_Ty, tuple> && _Tuple_like<_Ty>;
#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

template <>
class tuple<> { 
public:
    constexpr tuple() noexcept = default; 

    constexpr tuple(const tuple&) noexcept  {} 


    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple(_Other&&) noexcept  {}
#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc&) noexcept  {}

    template <class _Alloc>
    constexpr tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept  {}


    template <class _Alloc, _Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple(allocator_arg_t, const _Alloc&, _Other&&) noexcept  {}
#line 245 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Tag, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag) noexcept  {}

    template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc&) noexcept  {}

    constexpr tuple& operator=(const tuple&) = default;

    constexpr const tuple& operator=(const tuple&) const noexcept  {
        return *this;
    }


    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr tuple& operator=(_Other&&) noexcept  {
        return *this;
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (tuple_size_v<remove_cvref_t<_Other>> == 0)
    constexpr const tuple& operator=(_Other&&) const noexcept  {
        return *this;
    }
#line 271 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#line 272 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    constexpr void swap(tuple&) noexcept {}

    constexpr void swap(const tuple&) const noexcept {}
#line 277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    constexpr bool _Equals(const tuple&) const noexcept {
        return true;
    }


    [[nodiscard]] constexpr strong_ordering _Three_way_compare(const tuple&) const noexcept {
        return strong_ordering::equal;
    }




#line 291 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"


    template <_Tuple_like_non_tuple _Other>
    [[nodiscard]] friend constexpr bool operator==(const tuple&, const _Other&) noexcept  {
        static_assert(tuple_size_v<_Other> == 0, "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
        return true;
    }

    template <_Tuple_like_non_tuple _Other>
        requires (tuple_size_v<remove_cvref_t<_Other>> == 0)
    [[nodiscard]] friend constexpr strong_ordering operator<=>(const tuple&, const _Other&) noexcept  {
        return strong_ordering::equal;
    }
#line 305 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
};

template <class _This, class... _Rest>
class tuple<_This, _Rest...> : private tuple<_Rest...> { 
public:
    using _This_type = _This;
    using _Mybase    = tuple<_Rest...>;

    template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, ::std:: _Exact_args_t>, int> = 0>
    constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...), _Myfirst(::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _Tag, class _Alloc, class _This2, class... _Rest2,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_exact_args_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg, ::std:: forward<_This2>(_This_arg)) {}

    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
        enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

    template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> = 0>
    constexpr tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
            make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{}) {}

    template <class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int>           = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>,
            is_nothrow_default_constructible<_Rest>...>) 
        : _Mybase(), _Myfirst() {}

    template <class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>) tuple(
        const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(conjunction_v<is_nothrow_copy_constructible<_This2>,
        is_nothrow_copy_constructible<_Rest>...>) 
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...) {}

    template <class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>) tuple(_This2&& _This_arg,
        _Rest2&&... _Rest_arg) noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>) 
        : tuple(_Exact_args_t{}, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    tuple(const tuple&) = default;
    tuple(tuple&&)      = default;


    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other&...>,
                                               ::std:: _Tuple_convert_val<tuple, tuple<_Other...>&, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other&...>)
        tuple(tuple<_Other...>& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
#line 374 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                                               ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(const tuple<_Other...>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other&...>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                                               ::std:: _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}


    template <class... _Other, enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other...>,
                                               ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>, _Other...>>,
                                   int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other...>)
        tuple(const tuple<_Other...>&& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _Other...>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}

    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First&, _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First&, _Second&>)
        tuple(pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, _First&, _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}
#line 405 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(const pair<_First, _Second>& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>) 
        : tuple(_Unpack_tuple_t{}, _Right) {}

    template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>) tuple(
        pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}


    template <class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First, const _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First, const _Second>)
        tuple(const pair<_First, _Second>&& _Right) noexcept(
            _Tuple_nothrow_constructible_v<tuple, const _First, const _Second>) 
        : tuple(_Unpack_tuple_t{}, ::std:: move(_Right)) {}


    template <class _Other, class _Indices = index_sequence_for<_Rest...>>
    static constexpr bool _Is_tuple_like_constructor_explicit_v = false;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Is_tuple_like_constructor_explicit_v<_Other, index_sequence<_Indices...>> =
        negation_v<conjunction<is_convertible<decltype(::std:: get<0>(::std:: declval<_Other>())), _This>,
            is_convertible<decltype(::std:: get<_Indices + 1>(::std:: declval<_Other>())), _Rest>...>>;




    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
              && _Can_construct_values_from_tuple_like_v<tuple, _Other>
              && (sizeof...(_Rest) != 0 || (!is_convertible_v<_Other, _This> && !is_constructible_v<_This, _Other>) )
#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
    constexpr explicit(_Is_tuple_like_constructor_explicit_v<_Other>) tuple(_Other&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std:: forward<_Other>(_Right)) {
    }
#line 448 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#line 449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Alloc, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: is_default_constructible<_This2>, ::std:: is_default_constructible<_Rest>...>,
            int> = 0>
    constexpr explicit(
        !conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...) {}

    template <class _Alloc, class _This2, class... _Rest2,
        enable_if_t<conjunction_v<::std:: _Tuple_perfect_val<tuple, _This2, _Rest2...>,
                        ::std:: _Tuple_constructible_val<tuple, _This2, _Rest2...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...) {}

    template <class _Alloc, class _This2 = _This,
        enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
    constexpr tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
    constexpr tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}


    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other&...>,
                        ::std:: _Tuple_convert_val<tuple, tuple<_Other...>&, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other&...>,
                        ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>&, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, _Other...>,
                        ::std:: _Tuple_convert_val<tuple, tuple<_Other...>, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}


    template <class _Alloc, class... _Other,
        enable_if_t<conjunction_v<::std:: _Tuple_constructible_val<tuple, const _Other...>,
                        ::std:: _Tuple_convert_val<tuple, const tuple<_Other...>, _Other...>>,
            int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First&, _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First&, _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}
#line 522 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right) {}

    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}


    template <class _Alloc, class _First, class _Second,
        enable_if_t<_Tuple_constructible_v<tuple, const _First, const _Second>, int> = 0>
    constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First, const _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right)) {}





    template <class _Alloc, _Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
              && _Can_construct_values_from_tuple_like_v<tuple, _Other>
              && (sizeof...(_Rest) != 0 || (!is_convertible_v<_Other, _This> && !is_constructible_v<_This, _Other>) )
#line 552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
    constexpr explicit(_Is_tuple_like_constructor_explicit_v<_Other>)
        tuple(allocator_arg_t, const _Alloc& _Al, _Other&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Other>(_Right)) {
    }
#line 557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#line 558 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    tuple& operator=(const volatile tuple&) = delete;

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_copy_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_copy_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    constexpr tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }


    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_copy_assignable_no_precondition_check<const _This2>,
                        ::std:: _Is_copy_assignable_no_precondition_check<const _Rest>...>,
            int> = 0>
    constexpr const tuple& operator=(_Identity_t<const _Myself&> _Right) const
        noexcept(conjunction_v<is_nothrow_copy_assignable<const _This2>,
            is_nothrow_copy_assignable<const _Rest>...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }
#line 585 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_move_assignable_no_precondition_check<_This2>,
                        ::std:: _Is_move_assignable_no_precondition_check<_Rest>...>,
            int> = 0>
    constexpr tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }


    template <class _Myself = tuple, class _This2 = _This,
        enable_if_t<conjunction_v<::std:: _Is_assignable_no_precondition_check<const _This2&, _This2>,
                        ::std:: _Is_assignable_no_precondition_check<const _Rest&, _Rest>...>,
            int> = 0>
    constexpr const tuple& operator=(_Identity_t<_Myself&&> _Right) const
        noexcept(conjunction_v<is_nothrow_assignable<const _This2&, _This2>,
            is_nothrow_assignable<const _Rest&, _Rest>...>)  {
        _Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<_Mybase>(_Right._Get_rest());
        return *this;
    }
#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, const _Other&...>>,
                                   int> = 0>
    constexpr tuple& operator=(const tuple<_Other...>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _Other&...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }


    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<const tuple, const _Other&...>>,
                                   int> = 0>
    constexpr const tuple& operator=(const tuple<_Other...>& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, const _Other&...>)  {
        _Myfirst._Val = _Right._Myfirst._Val;
        _Get_rest()   = _Right._Get_rest();
        return *this;
    }
#line 632 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<tuple, _Other...>>,
                                   int> = 0>
    constexpr tuple& operator=(tuple<_Other...>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _Other...>)  {
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }


    template <class... _Other, enable_if_t<conjunction_v<::std:: negation<::std:: is_same<tuple, ::std:: tuple<_Other...>>>,
                                               ::std:: _Tuple_assignable_val<const tuple, _Other...>>,
                                   int> = 0>
    constexpr const tuple& operator=(tuple<_Other...>&& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, _Other...>)  {
        _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
        _Get_rest()   = ::std:: forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
        return *this;
    }
#line 654 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
    constexpr tuple& operator=(const pair<_First, _Second>& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)  {
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }


    template <class _First, class _Second,
        enable_if_t<_Tuple_assignable_v<const tuple, const _First&, const _Second&>, int> = 0>
    constexpr const tuple& operator=(const pair<_First, _Second>& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, const _First&, const _Second&>)  {
        _Myfirst._Val             = _Right.first;
        _Get_rest()._Myfirst._Val = _Right.second;
        return *this;
    }
#line 674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
    constexpr tuple& operator=(pair<_First, _Second>&& _Right) noexcept(
        _Tuple_nothrow_assignable_v<tuple, _First, _Second>)  {
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }


    template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<const tuple, _First, _Second>, int> = 0>
    constexpr const tuple& operator=(pair<_First, _Second>&& _Right) const
        noexcept(_Tuple_nothrow_assignable_v<const tuple, _First, _Second>)  {
        _Myfirst._Val             = ::std:: forward<_First>(_Right.first);
        _Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
        return *this;
    }


    template <bool _Const_assignment, class _Other, class _Indices = index_sequence_for<_Rest...>>
    static constexpr bool _Can_assign_values_from_tuple_like_v = false;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Can_assign_values_from_tuple_like_v<false, _Other, index_sequence<_Indices...>> =
        conjunction_v<is_assignable<_This&, decltype(::std:: get<0>(::std:: declval<_Other>()))>,
            is_assignable<_Rest&, decltype(::std:: get<_Indices + 1>(::std:: declval<_Other>()))>...>;

    template <_Tuple_like _Other, size_t... _Indices>
    static constexpr bool _Can_assign_values_from_tuple_like_v<true, _Other, index_sequence<_Indices...>> =
        conjunction_v<is_assignable<const _This&, decltype(::std:: get<0>(::std:: declval<_Other>()))>,
            is_assignable<const _Rest&, decltype(::std:: get<_Indices + 1>(::std:: declval<_Other>()))>...>;

    template <_Tuple_like _Other, size_t... _Indices>
    constexpr void _Assign_tuple_like(_Other&& _Right, index_sequence<_Indices...>) {
        ((void) (::std:: get<_Indices>(*this) = ::std:: get<_Indices>(::std:: forward<_Other>(_Right))), ...);
    }

    template <_Tuple_like _Other, size_t... _Indices>
    constexpr void _Assign_tuple_like(_Other&& _Right, index_sequence<_Indices...>) const {
        ((void) (::std:: get<_Indices>(*this) = ::std:: get<_Indices>(::std:: forward<_Other>(_Right))), ...);
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
              && _Can_assign_values_from_tuple_like_v<false, _Other>
    constexpr tuple& operator=(_Other&& _Right) {
        _Assign_tuple_like(::std:: forward<_Other>(_Right), make_index_sequence<1 + sizeof...(_Rest)>{});
        return *this;
    }

    template <_Different_from<tuple> _Other>
        requires _Tuple_like<_Other> && (!_Is_subrange_v<remove_cvref_t<_Other>>)
              && (1 + sizeof...(_Rest) == tuple_size_v<remove_cvref_t<_Other>>)
              && _Can_assign_values_from_tuple_like_v<true, _Other>
    constexpr const tuple& operator=(_Other&& _Right) const {
        _Assign_tuple_like(::std:: forward<_Other>(_Right), make_index_sequence<1 + sizeof...(_Rest)>{});
        return *this;
    }
#line 734 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#line 735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    constexpr void swap(tuple& _Right) noexcept(
        conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>) {
        using ::std:: swap;
        swap(_Myfirst._Val, _Right._Myfirst._Val); 
        _Mybase::swap(_Right._Get_rest());
    }


    template <int = 0> 
    constexpr void swap(const tuple& _Right) const
        noexcept(conjunction_v<is_nothrow_swappable<const _This>, is_nothrow_swappable<const _Rest>...>) {
        using ::std:: swap;
        swap(_Myfirst._Val, _Right._Myfirst._Val); 
        _Mybase::swap(_Right._Get_rest());
    }
#line 752 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    constexpr _Mybase& _Get_rest() noexcept { 
        return *this;
    }

    constexpr const _Mybase& _Get_rest() const noexcept { 
        return *this;
    }

    template <class... _Other>
    constexpr bool _Equals(const tuple<_Other...>& _Right) const {
        return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
    }


    template <class _First, class... _Other>
    [[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_This, _First>,
        _Synth_three_way_result<_Rest, _Other>...>
        _Three_way_compare(const tuple<_First, _Other...>& _Right) const {
        if (auto _Result = _Synth_three_way{}(_Myfirst._Val, _Right._Myfirst._Val); _Result != 0) {
            return _Result;
        }
        return _Mybase::_Three_way_compare(_Right._Get_rest());
    }


    template <class _Other, class _Indices = make_index_sequence<1 + sizeof...(_Rest)>>
    static constexpr bool _Can_equal_compare_with_tuple_like_v = false;

    template <class _Other, size_t... _Indices>
    static constexpr bool _Can_equal_compare_with_tuple_like_v<_Other, index_sequence<_Indices...>> =
        (requires(const tuple& _Left, const _Other& _Right) {
            { ::std:: get<_Indices>(_Left) == ::std:: get<_Indices>(_Right) } -> _Boolean_testable;
        } && ...);

    template <class _Other, size_t... _Indices>
    [[nodiscard]] constexpr bool _Equals_to_tuple_like(const _Other& _Right, index_sequence<_Indices...>) const {
        return ((::std:: get<_Indices>(*this) == ::std:: get<_Indices>(_Right)) && ...);
    }

    template <_Tuple_like_non_tuple _Other>
    [[nodiscard]] friend constexpr bool operator==(const tuple& _Left, const _Other& _Right) {
        static_assert(1 + sizeof...(_Rest) == tuple_size_v<_Other>,
            "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
        static_assert(_Can_equal_compare_with_tuple_like_v<_Other>,
            "For all i, where 0 <= i < sizeof...(TTypes), get<i>(t) == get<i>(u) must be a valid expression (N4950 "
            "[tuple.rel]/2).");
        return _Left._Equals_to_tuple_like(_Right, make_index_sequence<1 + sizeof...(_Rest)>{});
    }

    template <class _Other, size_t... _Indices>
    [[nodiscard]] constexpr auto _Three_way_compare_with_tuple_like(
        const _Other& _Right, index_sequence<_Indices...>) const {
        _Three_way_comparison_result_with_tuple_like_t<tuple, _Other> _Result = strong_ordering::equal;
        (void) (((_Result = _Synth_three_way{}(::std:: get<_Indices>(*this), ::std:: get<_Indices>(_Right))) == 0) && ...);
        return _Result;
    }

    template <_Tuple_like_non_tuple _Other>
    [[nodiscard]] friend constexpr auto operator<=>(const tuple& _Left, const _Other& _Right)
        -> _Three_way_comparison_result_with_tuple_like_t<tuple, _Other> {
        return _Left._Three_way_compare_with_tuple_like(_Right, make_index_sequence<1 + sizeof...(_Rest)>{});
    }
#line 816 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"






#line 823 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

    template <size_t _Index, class... _Types>
    friend constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

    template <class _Ty, class... _Types>
    friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

    _Tuple_val<_This> _Myfirst; 
};


template <class... _Types>
tuple(_Types...) -> tuple<_Types...>;

template <class _Ty1, class _Ty2>
tuple(pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, _Types...) -> tuple<_Types...>;

template <class _Alloc, class _Ty1, class _Ty2>
tuple(allocator_arg_t, _Alloc, pair<_Ty1, _Ty2>) -> tuple<_Ty1, _Ty2>;

template <class _Alloc, class... _Types>
tuple(allocator_arg_t, _Alloc, tuple<_Types...>) -> tuple<_Types...>;
#line 870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

 template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    static_assert(
        sizeof...(_Types1) == sizeof...(_Types2), "Cannot compare tuples of different sizes (N4950 [tuple.rel]/2).");
    return _Left._Equals(_Right);
}


 template <class... _Types1, class... _Types2>
[[nodiscard]] constexpr common_comparison_category_t<_Synth_three_way_result<_Types1, _Types2>...> operator<=>(
    const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right) {
    return _Left._Three_way_compare(_Right);
}




























#line 913 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

 template <class... _Types, enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0>
constexpr void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class... _Types, enable_if_t<conjunction_v<is_swappable<const _Types>...>, int> = 0>
constexpr void swap(const tuple<_Types...>& _Left, const tuple<_Types...>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}
#line 926 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

template <class _Ty, class _Tuple>
struct _Tuple_element {}; 

template <class _This, class... _Rest>
struct _Tuple_element<_This, tuple<_This, _Rest...>> { 
    static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
    using _Ttype = tuple<_This, _Rest...>;
};

template <class _Ty, class _This, class... _Rest>
struct _Tuple_element<_Ty, tuple<_This, _Rest...>> { 
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
};

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <size_t _Index, class... _Types>
[[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

  template <size_t _Index, class... _Types>
[[nodiscard]] constexpr auto&& _Tuple_get(tuple<_Types...>&& _Tuple) noexcept {
    
    using _Ty    = tuple_element_t<_Index, tuple<_Types...>>;
    using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
}

 template <class _Ty, class... _Types>
[[nodiscard]] constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept {
    using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
    return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
}

template <class _This, class... _Rest>
template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, ::std:: _Unpack_tuple_t>, int> >
constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

template <class _This, class... _Rest>
template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices,
    enable_if_t<is_same_v<_Tag, ::std:: _Alloc_unpack_tuple_t>, int> >
constexpr tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...) {}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { 
    using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
    return _Ttype(::std:: forward<_Types>(_Args)...);
}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept { 
    using _Ttype = tuple<_Types&...>;
    return _Ttype(_Args...);
}

 template <class... _Types>
[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept { 
    return tuple<_Types&&...>(::std:: forward<_Types>(_Args)...);
}

template <class _Ty, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Sequences>
struct _Tuple_cat2;

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next> {
    using _Ret    = tuple<tuple_element_t<_Kx, _Remove_cvref_t<tuple_element_t<_Ix, _Ty>>>...>;
    using _Kx_seq = index_sequence<_Kx...>;
    using _Ix_seq = index_sequence<_Ix...>;
};

template <class _Ty, size_t... _Kx, size_t... _Ix, size_t _Ix_next, size_t... _Kx_next, class... _Rest>
struct _Tuple_cat2<_Ty, index_sequence<_Kx...>, index_sequence<_Ix...>, _Ix_next, index_sequence<_Kx_next...>, _Rest...>
    : _Tuple_cat2<_Ty, index_sequence<_Kx..., _Kx_next...>,
          index_sequence<_Ix..., (_Ix_next + 0 * _Kx_next)...>, 
          _Ix_next + 1, _Rest...> {};


template <_Tuple_like... _Tuples>


#line 1048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
using _Tuple_cat1 = _Tuple_cat2<tuple<_Tuples&&...>, index_sequence<>, index_sequence<>, 0,
    make_index_sequence<tuple_size_v<_Remove_cvref_t<_Tuples>>>...>;

template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty _Arg) {
    return _Ret{::std:: get<_Kx>(::std:: get<_Ix>(::std:: move(_Arg)))...};
}


 template <_Tuple_like... _Tuples>


#line 1061 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
[[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::_Ret tuple_cat(_Tuples&&... _Tpls) { 
    using _Cat1   = _Tuple_cat1<_Tuples...>;
    using _Ret    = typename _Cat1::_Ret;
    using _Kx_seq = typename _Cat1::_Kx_seq;
    using _Ix_seq = typename _Cat1::_Ix_seq;
    return _Tuple_cat<_Ret>(_Kx_seq{}, _Ix_seq{}, ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...));
}



template <class _Callable, _Tuple_like _Tuple, size_t... _Indices>


#line 1075 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
constexpr decltype(auto) _Apply_impl(_Callable&& _Obj, _Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    noexcept(::std:: invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...))) {
    return ::std:: invoke(::std:: forward<_Callable>(_Obj), ::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}


 template <class _Callable, _Tuple_like _Tuple>


#line 1085 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
constexpr decltype(auto) apply(_Callable&& _Obj, _Tuple&& _Tpl) noexcept(
    noexcept(_Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{}))) {
    return _Apply_impl(::std:: forward<_Callable>(_Obj), ::std:: forward<_Tuple>(_Tpl),
        make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}


template <class _Ty, _Tuple_like _Tuple, size_t... _Indices>


#line 1097 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
constexpr _Ty _Make_from_tuple_impl(_Tuple&& _Tpl, index_sequence<_Indices...>) noexcept(
    is_nothrow_constructible_v<_Ty, decltype(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl)))...>) {
    
    static_assert(is_constructible_v<_Ty, decltype(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl)))...>,
        "the target type must be constructible from the fields of the argument tuple (N4950 [tuple.apply]/4).");
    return _Ty(::std:: get<_Indices>(::std:: forward<_Tuple>(_Tpl))...);
}


 template <class _Ty, _Tuple_like _Tuple>


#line 1110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
[[nodiscard]] constexpr _Ty make_from_tuple(_Tuple&& _Tpl) noexcept(noexcept(_Make_from_tuple_impl<_Ty>(
    ::std:: forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{})))  {
    
    return _Make_from_tuple_impl<_Ty>(
        ::std:: forward<_Tuple>(_Tpl), make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>{});
}
#line 1117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

template <class... _Types, class _Alloc>
struct uses_allocator<tuple<_Types...>, _Alloc> : true_type {}; 


template <_Tuple_like _TTuple, _Tuple_like _UTuple, template <class> class _TQual, template <class> class _UQual,
    class _Indices = make_index_sequence<tuple_size_v<_TTuple>>>
struct _Tuple_like_common_reference;

template <class _TTuple, class _UTuple, template <class> class _TQual, template <class> class _UQual,
    size_t... _Indices>
    requires requires {
        typename tuple<common_reference_t<_TQual<tuple_element_t<_Indices, _TTuple>>,
            _UQual<tuple_element_t<_Indices, _UTuple>>>...>;
    }
struct _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual, index_sequence<_Indices...>> {
    using type = tuple<
        common_reference_t<_TQual<tuple_element_t<_Indices, _TTuple>>, _UQual<tuple_element_t<_Indices, _UTuple>>>...>;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple, template <class> class _TQual, template <class> class _UQual>
    requires (_Is_specialization_v<_TTuple, tuple> || _Is_specialization_v<_UTuple, tuple>)
          && is_same_v<_TTuple, decay_t<_TTuple>> && is_same_v<_UTuple, decay_t<_UTuple>>
          && (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>) && requires {
                 typename _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type;
             }
struct basic_common_reference<_TTuple, _UTuple, _TQual, _UQual> {
    using type = _Tuple_like_common_reference<_TTuple, _UTuple, _TQual, _UQual>::type;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple, class _Indices = make_index_sequence<tuple_size_v<_TTuple>>>
struct _Tuple_like_common_type;

template <class _TTuple, class _UTuple, size_t... _Indices>
    requires requires {
        typename tuple<common_type_t<tuple_element_t<_Indices, _TTuple>, tuple_element_t<_Indices, _UTuple>>...>;
    }
struct _Tuple_like_common_type<_TTuple, _UTuple, index_sequence<_Indices...>> {
    using type = tuple<common_type_t<tuple_element_t<_Indices, _TTuple>, tuple_element_t<_Indices, _UTuple>>...>;
};

template <_Tuple_like _TTuple, _Tuple_like _UTuple>
    requires (_Is_specialization_v<_TTuple, tuple> || _Is_specialization_v<_UTuple, tuple>)
          && is_same_v<_TTuple, decay_t<_TTuple>> && is_same_v<_UTuple, decay_t<_UTuple>>
          && (tuple_size_v<_TTuple> == tuple_size_v<_UTuple>) && requires {
                 typename _Tuple_like_common_type<_TTuple, _UTuple>::type;
             }
struct common_type<_TTuple, _UTuple> {
    using type = _Tuple_like_common_type<_TTuple, _UTuple>::type;
};
#line 1168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"










#line 1179 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"

}



#pragma warning(pop)
#pragma pack(pop)
#line 1187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#line 1188 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\tuple"
#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
#line 20 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Ptrty>
[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept { 
    return ::std:: addressof(*_Ptr);
}

template <class _Ty>
[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

template <class _Ty>
struct [[nodiscard]] _Tidy_guard { 
    _Ty* _Target;
    constexpr ~_Tidy_guard() {
        if (_Target) {
            _Target->_Tidy();
        }
    }
};

template <class _Ty>
struct [[nodiscard]] _Tidy_deallocate_guard { 
    _Ty* _Target;
    constexpr ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target->_Tidy_deallocate();
        }
    }
};

template <class _Keycmp, class _Lhs, class _Rhs>
inline constexpr bool _Nothrow_compare = noexcept(
    static_cast<bool>(::std:: declval<const _Keycmp&>()(::std:: declval<const _Lhs&>(), ::std:: declval<const _Rhs&>())));

template <size_t _Ty_size>
[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size > 1;

    if constexpr (_Overflow_is_possible) {
        constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
        if (_Count > _Max_possible) {
            _Throw_bad_array_new_length(); 
        }
    }

    return _Count * _Ty_size;
}

template <class _Ty>
inline constexpr size_t _New_alignof = (::std:: max)(alignof(_Ty), 16ull);

struct _Default_allocate_traits {
    __declspec(allocator) static



        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }


    __declspec(allocator) static



        void* _Allocate_aligned(const size_t _Bytes, const size_t _Align) {







        {
            return ::operator new(_Bytes, align_val_t{_Align});
        }
    }
#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 && (_Value & (_Value - 1)) == 0;
}


inline constexpr size_t _Big_allocation_threshold = 4096;
inline constexpr size_t _Big_allocation_alignment = 32;


;


;




inline constexpr size_t _Non_user_size           = sizeof(void*) + _Big_allocation_alignment - 1;
#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


inline constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;


#line 134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Traits>
__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {
    
    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size <= _Bytes) {
        _Throw_bad_array_new_length(); 
    }

    const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
    do { if (_Ptr_container != 0) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false); 
    void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
    static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;




    return _Ptr;
}

inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {
    
    _Bytes += _Non_user_size;

    const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];

    
    
    ;

    
    



    constexpr uintptr_t _Min_back_shift = sizeof(void*);
#line 172 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
    do { if (_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
    _Ptr = reinterpret_cast<void*>(_Ptr_container);
}
#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(_Align > 16ull), int> = 0>
__declspec(allocator) constexpr void* _Allocate(const size_t _Bytes) {
    
    if (_Bytes == 0) {
        return nullptr;
    }


    if (::std:: is_constant_evaluated()) {
        return _Traits::_Allocate(_Bytes);
    } else
#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        size_t _Passed_align = _Align;

        if (_Bytes >= _Big_allocation_threshold) {
            
            _Passed_align = (::std:: max)(_Align, _Big_allocation_alignment);
        }
#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
    }
}

template <size_t _Align, enable_if_t<(_Align > 16ull), int> = 0>
constexpr void _Deallocate(void* _Ptr, const size_t _Bytes) noexcept {
    

    if (::std:: is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#line 212 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        size_t _Passed_align = _Align;

        if (_Bytes >= _Big_allocation_threshold) { 
            _Passed_align = (::std:: max)(_Align, _Big_allocation_alignment);
        }
#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
    }
}




#line 227 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t<(!1 || _Align <= 16ull), int> = 0>
__declspec(allocator) constexpr void* _Allocate(const size_t _Bytes) {
    


    if (!::std:: is_constant_evaluated())
#line 236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        if (_Bytes >= _Big_allocation_threshold) { 
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }
    }
#line 242 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);
    }

    return nullptr;
}

template <size_t _Align, enable_if_t<(!1 || _Align <= 16ull), int> = 0>
constexpr void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {
    

    if (::std:: is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {

        if (_Bytes >= _Big_allocation_threshold) { 
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }
#line 264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        ::operator delete(_Ptr, _Bytes);
    }
}



template <class _Ty, class... _Types>
_Ty* _Global_new(_Types&&... _Args) { 
    struct [[nodiscard]] _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate<_New_alignof<_Ty>>(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(::std:: forward<_Types>(_Args)...);
    return static_cast<_Ty*>(::std:: exchange(_Guard._Result, nullptr));
}

template <class _Ptr, class _Ty>
using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
constexpr _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept {
    return pointer_traits<_Pointer>::pointer_to(*_Ptr);
}

template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0>
constexpr _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
constexpr void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template <class _Ty>
constexpr void _Destroy_in_place(_Ty& _Obj) noexcept {
    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
    } else {
        _Obj.~_Ty();
    }
}


 template <class _Ty>
constexpr void destroy_at(_Ty* const _Location) noexcept  {

    if constexpr (is_array_v<_Ty>) {
        _Destroy_range(::std:: begin(*_Location), ::std:: end(*_Location));
    } else
#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        _Location->~_Ty();
    }
}
#line 324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Ptrty>
auto _Const_cast(_Ptrty _Ptr) noexcept { 
    using _Elem       = typename pointer_traits<_Ptrty>::element_type;
    using _Modifiable = remove_const_t<_Elem>;
    using _Dest       = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

    return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
}

template <class _Ty>
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast<remove_const_t<_Ty>*>(_Ptr);
}

template <class _Ty, class = void>
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>> {
    using type = typename _Ty::pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>> {
    using type = typename _Ty::const_pointer;
};
__pragma(warning(pop))

template <class _Ty, class = void>
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<void>;
};

template <class _Ty>
struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>> {
    using type = typename _Ty::void_pointer;
};

template <class _Ty, class = void>
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::template rebind<const void>;
};

template <class _Ty>
struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>> {
    using type = typename _Ty::const_void_pointer;
};

template <class _Ty, class = void>
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type<_Ty>::type;
    using type   = typename pointer_traits<_Ptrty>::difference_type;
};

template <class _Ty>
struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>> {
    using type = typename _Ty::difference_type;
};

template <class _Ty, class = void>
struct _Get_size_type {
    using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
};

template <class _Ty>
struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>> {
    using type = typename _Ty::size_type;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>> {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>> {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

template <class _Ty, class = void>
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template <class _Ty>
struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>> {
    using type = typename _Ty::propagate_on_container_swap;
};

template <class _Ty, class = void>
struct _Get_is_always_equal {
    using type = bool_constant<is_empty_v<_Ty>>;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty>
struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>> {
    using type = typename _Ty::is_always_equal;
};
__pragma(warning(pop))

template <class _Ty, class _Other, class = void>
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter<_Other, _Ty>::type;
};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Ty, class _Other>
struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>> {
    using type = typename _Ty::template rebind<_Other>::other;
};
__pragma(warning(pop))

 template <class _Ty>
class allocator;

template <class _Alloc, class = void>
struct _Is_default_allocator : false_type {};

template <class _Ty>
struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type {};



template <class _Alloc, class _SizeTy>
concept _Has_member_allocate_at_least = requires(_Alloc& _Al, const _SizeTy& _Count) { _Al.allocate_at_least(_Count); };







#line 484 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
#line 485 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Void, class... _Types>
struct _Has_no_allocator_construct : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr, class... _Args>
struct _Has_no_allocator_construct<
    void_t<decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>, _Alloc, _Ptr,
    _Args...> : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr, class... _Args>
using _Uses_default_construct =
    disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

template <class _Alloc, class _Ptr, class = void>
struct _Has_no_alloc_destroy : true_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Ptr>
struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
    : false_type {};
__pragma(warning(pop))

template <class _Alloc, class _Ptr>
using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
struct _Has_allocate_hint : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc, class _Size_type, class _Const_void_pointer>
struct _Has_allocate_hint<_Alloc, _Size_type, _Const_void_pointer,
    void_t<decltype(::std:: declval<_Alloc&>().allocate(
        ::std:: declval<const _Size_type&>(), ::std:: declval<const _Const_void_pointer&>()))>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_max_size : false_type {};

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Has_max_size<_Alloc, void_t<decltype(::std:: declval<const _Alloc&>().max_size())>> : true_type {};
__pragma(warning(pop))

template <class _Alloc, class = void>
struct _Has_select_on_container_copy_construction : false_type {};

template <class _Alloc>
struct _Has_select_on_container_copy_construction<_Alloc,
    void_t<decltype(::std:: declval<const _Alloc&>().select_on_container_copy_construction())>> : true_type {};


 template <class _Ptr, class _SizeTy = size_t>
struct allocation_result {
    _Ptr ptr;
    _SizeTy count;
};
#line 544 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

 template <class _Alloc>
struct allocator_traits;

__pragma(warning(push)) __pragma(warning(disable : 4996))
template <class _Alloc>
struct _Normal_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type<_Alloc>::type;
    using const_pointer      = typename _Get_const_pointer_type<_Alloc>::type;
    using void_pointer       = typename _Get_void_pointer_type<_Alloc>::type;
    using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

    using size_type       = typename _Get_size_type<_Alloc>::type;
    using difference_type = typename _Get_difference_type<_Alloc>::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap<_Alloc>::type;
    using is_always_equal                        = typename _Get_is_always_equal<_Alloc>::type;

    template <class _Other>
    using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

    template <class _Other>
    using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {
        return _Al.allocate(_Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }


    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr allocation_result<pointer, size_type> allocate_at_least(
        _Alloc& _Al,  const size_type _Count) {
        if constexpr (_Has_member_allocate_at_least<_Alloc, size_type>) {
            return _Al.allocate_at_least(_Count);
        } else {
            return {_Al.allocate(_Count), _Count};
        }
    }
#line 597 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    static constexpr void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template <class _Ty, class... _Types>
    static constexpr void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args) {
        if constexpr (_Uses_default_construct<_Alloc, _Ty*, _Types...>::value) {

            ::std:: construct_at(_Ptr, ::std:: forward<_Types>(_Args)...);


#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        } else {
            _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
        }
    }

    template <class _Ty>
    static constexpr void destroy(_Alloc& _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy<_Alloc, _Ty*>::value) {

            ::std:: destroy_at(_Ptr);


#line 623 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        } else {
            _Al.destroy(_Ptr);
        }
    }

    [[nodiscard]] static constexpr size_type max_size(const _Alloc& _Al) noexcept {
        if constexpr (_Has_max_size<_Alloc>::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits<size_type>::max)() / sizeof(value_type);
        }
    }

    [[nodiscard]] static constexpr _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        if constexpr (_Has_select_on_container_copy_construction<_Alloc>::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
__pragma(warning(pop))

template <class _Alloc>
struct _Default_allocator_traits { 
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template <class _Other>
    using rebind_alloc = allocator<_Other>;

    template <class _Other>
    using rebind_traits = allocator_traits<allocator<_Other>>;

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count) {

        if (::std:: is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#line 677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr __declspec(allocator) pointer
        allocate(_Alloc& _Al,  const size_type _Count, const_void_pointer) {

        if (::std:: is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#line 691 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            (void) _Al;
            return static_cast<pointer>(
                _Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }
    }


    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] static constexpr allocation_result<pointer, size_type> allocate_at_least(
        _Alloc& _Al,  const size_type _Count) {
        return {_Al.allocate(_Count), _Count};
    }
#line 704 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    static constexpr void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {
        

        if (::std:: is_constant_evaluated()) {
            _Al.deallocate(_Ptr, _Count);
        } else
#line 712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            (void) _Al;
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }
    }

    template <class _Objty, class... _Types>
    static constexpr void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

        ::std:: construct_at(_Ptr, ::std:: forward<_Types>(_Args)...);


#line 725 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    }

    template <class _Uty>
    static constexpr void destroy(_Alloc&, _Uty* const _Ptr) {

        ::std:: destroy_at(_Ptr);


#line 734 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    }

    [[nodiscard]] static constexpr size_type max_size(const _Alloc&) noexcept {
        return static_cast<size_t>(-1) / sizeof(value_type);
    }

    [[nodiscard]] static constexpr _Alloc select_on_container_copy_construction(const _Alloc& _Al) {
        return _Al;
    }
};

 template <class _Alloc>
struct allocator_traits : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>,
                              _Normal_allocator_traits<_Alloc>> {};



template <class _Alloc>
inline constexpr bool _Choose_pocca_v = allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value
                                          && !allocator_traits<_Alloc>::is_always_equal::value;

enum class _Pocma_values {
    _Equal_allocators, 
    _Propagate_allocators, 
    _No_propagate_allocators, 
};

template <class _Alloc>
inline constexpr _Pocma_values _Choose_pocma_v =
    allocator_traits<_Alloc>::is_always_equal::value
        ? _Pocma_values::_Equal_allocators
        : (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value
                ? _Pocma_values::_Propagate_allocators
                : _Pocma_values::_No_propagate_allocators);

template <class _Alloc, class _Value_type>
using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;



template <class _Alloc, class _Value_type>
using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&,
        _Rebind_alloc_t<_Alloc, _Value_type>>;

template <class _Alloc> 
inline constexpr bool _Is_simple_alloc_v =
    is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>
    && is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>
    && is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>
    && is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

template <class _Value_type>
struct _Simple_types { 
                       
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};


inline constexpr size_t _Asan_granularity      = 8;
inline constexpr size_t _Asan_granularity_mask = _Asan_granularity - 1;

struct _Asan_aligned_pointers {
    const void* _First;
    const void* _End;

    [[nodiscard]] constexpr const void* _Clamp_to_end(const void* _Mid) const noexcept {
        ;
        if (_Mid > _End) {
            return _End;
        } else {
            return _Mid;
        }
    }
};

















































































[[nodiscard]] inline _Asan_aligned_pointers _Get_asan_aligned_first_end(
    const void* const _First, const void* const _End) noexcept {
    return {
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_First) & ~_Asan_granularity_mask),
        reinterpret_cast<const void*>(reinterpret_cast<uintptr_t>(_End) & ~_Asan_granularity_mask),
    };
}




[[nodiscard]] inline const void* _Get_asan_aligned_after(const void* const _End) noexcept {
    return reinterpret_cast<const void*>(
        (reinterpret_cast<uintptr_t>(_End) + _Asan_granularity_mask) & ~_Asan_granularity_mask);
}

template <class _Container, class = void>
inline constexpr size_t _Container_allocation_minimum_asan_alignment = alignof(typename _Container::value_type);

template <class _Container>
inline constexpr size_t _Container_allocation_minimum_asan_alignment<_Container,
    void_t<decltype(_Container::allocator_type::_Minimum_asan_allocation_alignment)>> =
    (::std:: max)(
        alignof(typename _Container::value_type), _Container::allocator_type::_Minimum_asan_allocation_alignment);

 template <class _Ty>
class allocator {
public:
    static_assert(!is_const_v<_Ty>, "The C++ Standard forbids containers of const elements "
                                    "because allocator<const T> is ill-formed.");
    static_assert(!is_function_v<_Ty>, "The C++ Standard forbids allocators for function elements "
                                       "because of [allocator.requirements].");
    static_assert(!is_reference_v<_Ty>, "The C++ Standard forbids allocators for reference elements "
                                        "because of [allocator.requirements].");

    using _From_primary = allocator;

    using value_type = _Ty;







#line 940 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment           = true_type;
    using is_always_equal [[deprecated("warning STL4033: " "std::allocator::is_always_equal is deprecated in C++20 by LWG-3170. " "Prefer std::allocator_traits<allocator<T>>::is_always_equal. " "You can define _SILENCE_CXX20_IS_ALWAYS_EQUAL_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] = true_type;














#line 961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    constexpr allocator() noexcept {}

    constexpr allocator(const allocator&) noexcept = default;
    template <class _Other>
    constexpr allocator(const allocator<_Other>&) noexcept {}
    constexpr ~allocator()                           = default;
    constexpr allocator& operator=(const allocator&) = default;

    constexpr void deallocate(_Ty* const _Ptr, const size_t _Count) {
        ;
        
        _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
    }

    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] constexpr __declspec(allocator) _Ty* allocate( const size_t _Count) {
        static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
        return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
    }


    [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] constexpr allocation_result<_Ty*> allocate_at_least(
         const size_t _Count) {
        return {allocate(_Count), _Count};
    }
#line 987 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"




















#line 1008 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    static constexpr size_t _Minimum_asan_allocation_alignment = _Asan_granularity;
};
























#line 1036 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

 template <class _Ty, class _Other>
[[nodiscard]] constexpr bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept {
    return true;
}






#line 1048 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"



template <class _Alloc>
using _Guide_size_type_t =
    typename allocator_traits<conditional_t<_Is_allocator<_Alloc>::value, _Alloc, allocator<int>>>::size_type;
#line 1055 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Alloc>
using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

template <class _Alloc>
using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

template <class _Alloc>
constexpr void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

template <class _Alloc>
constexpr void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { 
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
        _Left = ::std:: move(_Right);
    }
}

template <class _Alloc>
constexpr void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {
    if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
        swap(_Left, _Right); 
    } else {
        ;
    }
}

template <class _Alloc>
constexpr void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
        for (; _First != _Last; ++_First) {
            allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
        }
    }
}

template <class _NoThrowFwdIt, class _NoThrowSentinel>
constexpr void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    
    if constexpr (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}

template <class _Size_type, class _Unsigned_type>
[[nodiscard]] constexpr _Size_type _Convert_size(const _Unsigned_type _Len) noexcept(
    sizeof(_Unsigned_type) <= sizeof(_Size_type)) {
    
    ;
    ;

    if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
        if (_Len > (numeric_limits<_Size_type>::max)()) {
            _Xlength_error("size is too long for _Size_type");
        }
    }

    return static_cast<_Size_type>(_Len);
}

template <class _Alloc>
constexpr void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Alloc_traits = allocator_traits<_Alloc>;
    if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
        _Alloc_traits::deallocate(_Al, _Ptr, 1);
    } else {
        using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
}

template <class _Alloc>
constexpr void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {
    
    using _Ty = typename _Alloc::value_type;
    _Ptr->~_Ty();
    _Deallocate_plain(_Al, _Ptr);
}

template <class _Alloc>
struct _Alloc_construct_ptr { 
    using pointer = _Alloc_ptr_t<_Alloc>;
    _Alloc& _Al;
    pointer _Ptr;

    constexpr explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    [[nodiscard]] constexpr pointer _Release() noexcept { 
        return ::std:: exchange(_Ptr, nullptr);
    }

    constexpr void _Allocate() { 
        _Ptr = nullptr; 
        _Ptr = _Al.allocate(1);
    }

    constexpr ~_Alloc_construct_ptr() { 
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&)            = delete;
    _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
};

struct _Fake_allocator {};

struct _Container_base0 {
    constexpr void _Orphan_all() noexcept {}
    constexpr void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}
    constexpr void _Alloc_proxy(const _Fake_allocator&) noexcept {}
    constexpr void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept {}
};

struct _Iterator_base0 {
    constexpr void _Adopt(const void*) noexcept {}
    constexpr const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

struct _Container_base12;
struct _Container_proxy { 
    constexpr _Container_proxy() noexcept = default;
    constexpr _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

    const _Container_base12* _Mycont       = nullptr;
    mutable _Iterator_base12* _Myfirstiter = nullptr;
};

struct _Container_base12 {
public:
    constexpr _Container_base12() noexcept = default;

    _Container_base12(const _Container_base12&)            = delete;
    _Container_base12& operator=(const _Container_base12&) = delete;

    constexpr void _Orphan_all() noexcept;
    constexpr void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

    template <class _Alloc>
    constexpr void _Alloc_proxy(_Alloc&& _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy->_Mycont = this;
    }

    template <class _Alloc>
    constexpr void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
        
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy->_Mycont = this;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Myproxy, _New_proxy));
    }

    _Container_proxy* _Myproxy = nullptr;

private:
    constexpr void _Orphan_all_unlocked_v3() noexcept;
    constexpr void _Swap_proxy_and_iterators_unlocked(_Container_base12&) noexcept;

    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(3);
        _Orphan_all_unlocked_v3();
    }

    void _Swap_proxy_and_iterators_locked(_Container_base12& _Right) noexcept {
        _Lockit _Lock(3);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }
};

struct _Iterator_base12 { 
public:
    constexpr _Iterator_base12() noexcept = default; 

    constexpr _Iterator_base12(const _Iterator_base12& _Right) noexcept {
        *this = _Right;
    }

    constexpr _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {









#line 1259 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        _Myproxy = _Right._Myproxy;
#line 1261 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        return *this;
    }























#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    constexpr void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) { 
            _Myproxy = _Parent->_Myproxy;
        } else { 
            _Myproxy = nullptr;
        }
    }
#line 1295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    constexpr const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy->_Mycont : nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = 0 == 0;

    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;






























































#line 1367 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
};

constexpr void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { 
        return;
    }

    
    for (auto _Pnext = ::std:: exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {
        _Pnext->_Myproxy = nullptr;
    }
}

constexpr void _Container_base12::_Orphan_all() noexcept {









#line 1391 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
}

constexpr void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12& _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;

    if (_Myproxy) {
        _Myproxy->_Mycont = this;
    }

    if (_Right._Myproxy) {
        _Right._Myproxy->_Mycont = &_Right;
    }
}

constexpr void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept {









#line 1418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    _Swap_proxy_and_iterators_unlocked(_Right);
#line 1420 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
}


using _Container_base = _Container_base0;
using _Iterator_base  = _Iterator_base0;



#line 1429 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; 

struct _Fake_proxy_ptr_impl { 
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&)            = delete;
    _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
    constexpr _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept {}
    constexpr _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

    constexpr void _Bind(const _Fake_allocator&, _Container_base0*) noexcept {}
    constexpr void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    
    _Container_proxy* _Ptr = nullptr;

    constexpr void _Release() noexcept { 
        _Ptr = nullptr;
    }

protected:
    constexpr _Basic_container_proxy_ptr12()                       = default;
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&)      = delete;
};

template <class _Alloc>
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    
    _Alloc& _Al;

    constexpr _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

    constexpr _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {
        
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, ::std:: addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }

    constexpr void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept {
        
        
        _Ptr->_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, ::std:: exchange(_Mycont->_Myproxy, ::std:: exchange(_Ptr, nullptr)));
    }

    constexpr ~_Container_proxy_ptr12() {
        if (_Ptr) {
            _Delete_plain_internal(_Al, _Ptr);
        }
    }
};


inline constexpr _Fake_allocator _Fake_alloc{};

template <class _Alloc>
using _Container_proxy_ptr = _Fake_proxy_ptr_impl;




#line 1500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; 

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; 

template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
class _Compressed_pair final : private _Ty1 { 
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; 

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return *this;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return *this;
    }
};

template <class _Ty1, class _Ty2>
class _Compressed_pair<_Ty1, _Ty2, false> final { 
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template <class... _Other2>
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    template <class _Other1, class... _Other2>
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std:: forward<_Other1>(_Val1)), _Myval2(::std:: forward<_Other2>(_Val2)...) {}

    constexpr _Ty1& _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1& _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

template <class _Ty>
pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty)) {
        for (; 0 < _Count; _Count /= 2) {
            const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
            void* _Pbuf;

            if constexpr (alignof(_Ty) > 16ull) {
                _Pbuf = ::operator new(_Size, align_val_t{alignof(_Ty)}, nothrow);
            } else
#line 1575 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast<_Ty*>(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

template <class _Ty>
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {

    if constexpr (alignof(_Ty) > 16ull) {
        ::operator delete(_Pbuf, align_val_t{alignof(_Ty)});
    } else
#line 1595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        ::operator delete(_Pbuf);
    }
}

template <class _NoThrowFwdIt>
struct [[nodiscard]] _Uninitialized_backout {
    
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&)            = delete;
    _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

    constexpr ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template <class... _Types>
    constexpr void _Emplace_back(_Types&&... _Vals) {
        
        _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { 
        _First = _Last;
        return _Last;
    }
};

template <class _InIt, class _NoThrowFwdIt>
constexpr _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_move_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {

        if (!::std:: is_constant_evaluated())
#line 1637 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(::std:: move(*_First));
    }

    return _Backout._Release();
}


namespace ranges {
    template <class _It>
    concept _No_throw_input_iterator =
        input_iterator<_It> && is_lvalue_reference_v<iter_reference_t<_It>>
        && same_as<remove_cvref_t<iter_reference_t<_It>>, remove_reference_t<iter_reference_t<_It>>> 
        && same_as<remove_cvref_t<iter_reference_t<_It>>, iter_value_t<_It>>;

    template <class _Se, class _It>
    concept _No_throw_sentinel_for = sentinel_for<_Se, _It>;

    template <class _It>
    concept _No_throw_forward_iterator =
        _No_throw_input_iterator<_It> && forward_iterator<_It> && _No_throw_sentinel_for<_It, _It>;

    template <class _Rng>
    concept _No_throw_input_range = range<_Rng> && _No_throw_input_iterator<iterator_t<_Rng>>
                                 && _No_throw_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>;

    template <class _Rng>
    concept _No_throw_forward_range = _No_throw_input_range<_Rng> && _No_throw_forward_iterator<iterator_t<_Rng>>;

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_count(_InIt _IFirst, _OutIt _OFirst, const size_t _Count) noexcept {
        const auto _IFirstPtr     = _To_address(_IFirst);
        const auto _OFirstPtr     = _To_address(_OFirst);
        const auto _IFirst_ch     = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch     = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const size_t _Count_bytes = _Count * sizeof(iter_value_t<_InIt>);
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count);
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

    template <class _InIt, class _OutIt, class _DistIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_distance(
        _InIt _IFirst, _OutIt _OFirst, const _DistIt _DFirst, const _DistIt _DLast) noexcept {
        
        const auto _IFirstPtr   = _To_address(_IFirst);
        const auto _OFirstPtr   = _To_address(_OFirst);
        const auto _DFirstPtr   = _To_address(_DFirst);
        const auto _DLastPtr    = _To_address(_DLast);
        const auto _IFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _OFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _DFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_DFirstPtr));
        const auto _DLast_ch    = const_cast<char*>(reinterpret_cast<const volatile char*>(_DLastPtr));
        const auto _Count_bytes = static_cast<size_t>(_DLast_ch - _DFirst_ch);
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += _Count_bytes / sizeof(iter_value_t<_InIt>);
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += _Count_bytes / sizeof(iter_value_t<_OutIt>);
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

    template <class _InIt, class _OutIt>
    in_out_result<_InIt, _OutIt> _Copy_memcpy_common(
        _InIt _IFirst, _InIt _ILast, _OutIt _OFirst, _OutIt _OLast) noexcept {
        const auto _IFirstPtr   = _To_address(_IFirst);
        const auto _ILastPtr    = _To_address(_ILast);
        const auto _OFirstPtr   = _To_address(_OFirst);
        const auto _OLastPtr    = _To_address(_OLast);
        const auto _IFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_IFirstPtr));
        const auto _ILast_ch    = const_cast<const char*>(reinterpret_cast<const volatile char*>(_ILastPtr));
        const auto _OFirst_ch   = const_cast<char*>(reinterpret_cast<const volatile char*>(_OFirstPtr));
        const auto _OLast_ch    = const_cast<const char*>(reinterpret_cast<const volatile char*>(_OLastPtr));
        const auto _Count_bytes = static_cast<size_t>((::std:: min)(_ILast_ch - _IFirst_ch, _OLast_ch - _OFirst_ch));
        :: memcpy(_OFirst_ch, _IFirst_ch, _Count_bytes);
        if constexpr (is_pointer_v<_InIt>) {
            _IFirst = reinterpret_cast<_InIt>(_IFirst_ch + _Count_bytes);
        } else {
            _IFirst += static_cast<iter_difference_t<_InIt>>(_Count_bytes / sizeof(iter_value_t<_InIt>));
        }

        if constexpr (is_pointer_v<_OutIt>) {
            _OFirst = reinterpret_cast<_OutIt>(_OFirst_ch + _Count_bytes);
        } else {
            _OFirst += static_cast<iter_difference_t<_OutIt>>(_Count_bytes / sizeof(iter_value_t<_OutIt>));
        }
        return {::std:: move(_IFirst), ::std:: move(_OFirst)};
    }

     template <class _In, class _Out>
    using uninitialized_move_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
        _No_throw_sentinel_for<_Out> _OSe>
        requires (constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>)
    uninitialized_move_result<_It, _Out> _Uninitialized_move_unchecked(
        _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
        constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
        constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
        if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible && _Sized_or_unreachable_sentinel_for<_Se, _It>
                      && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
            if constexpr (_Is_sized1 && _Is_sized2) {
                return _Copy_memcpy_common(_IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)), _OFirst,
                    ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else if constexpr (_Is_sized1) {
                return _Copy_memcpy_distance(_IFirst, _OFirst, _IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)));
            } else if constexpr (_Is_sized2) {
                return _Copy_memcpy_distance(_IFirst, _OFirst, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else {
                ;
            }
        } else {
            _Uninitialized_backout _Backout{::std:: move(_OFirst)};

            for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                _Backout._Emplace_back(::std::ranges:: iter_move(_IFirst));
            }

            return {::std:: move(_IFirst), _Backout._Release()};
        }
    }
} 
#line 1782 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Alloc>
class [[nodiscard]] _Uninitialized_backout_al {
    
private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    constexpr _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_backout_al(const _Uninitialized_backout_al&)            = delete;
    _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

    constexpr ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }

    template <class... _Types>
    constexpr void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    constexpr pointer _Release() { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _InIt, class _Se, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_copy(
    _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;


    auto _UFirst = ::std::ranges:: _Unwrap_iter<_Se>(::std:: move(_First));
    auto _ULast  = ::std::ranges:: _Unwrap_sent<_InIt>(::std:: move(_Last));





#line 1832 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
                               && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;

    if constexpr (_Can_memmove) {

        if (!::std:: is_constant_evaluated())
#line 1840 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
                _Copy_memmove(_To_address(_UFirst), _To_address(_ULast), _Unfancy(_Dest));
                _Dest += _ULast - _UFirst;
            } else {
                const auto _Count = static_cast<size_t>(_ULast - _UFirst);
                _Copy_memmove_n(_To_address(_UFirst), _Count, _Unfancy(_Dest));
                _Dest += _Count;
            }
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_copy_n(
    _InIt _First, size_t _Count, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval = typename _Alloc::value_type*;

    auto _UFirst = _Get_unwrapped(::std:: move(_First));

    constexpr bool _Can_memmove =
        conjunction_v<bool_constant<_Iter_copy_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
            _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>;

    if constexpr (_Can_memmove) {

        if (!::std:: is_constant_evaluated())
#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            _Copy_memmove_n(_UFirst, _Count, _Unfancy(_Dest));
            _Dest += _Count;
            return _Dest;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _Count != 0; ++_UFirst, (void) --_Count) {
        _Backout._Emplace_back(*_UFirst);
    }

    return _Backout._Release();
}

template <class _InIt, class _NoThrowFwdIt>
constexpr _NoThrowFwdIt _Uninitialized_copy_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    if constexpr (_Iter_copy_cat<_InIt, _NoThrowFwdIt>::_Bitcopy_constructible) {

        if (!::std:: is_constant_evaluated())
#line 1900 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout<_NoThrowFwdIt> _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

 template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

template <class _InIt, class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_move(
    const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {
    
    
    using _Ptrval     = typename _Alloc::value_type*;
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
                      _Uses_default_construct<_Alloc, _Ptrval, decltype(::std:: move(*_UFirst))>>) {

        if (!::std:: is_constant_evaluated())
#line 1937 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(::std:: move(*_UFirst));
    }

    return _Backout._Release();
}

template <class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_fill_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {
    
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {

        if (!::std:: is_constant_evaluated())
#line 1960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {

        if (!::std:: is_constant_evaluated())
#line 1968 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

 template <class _NoThrowFwdIt, class _Tval>
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

template <class _NoThrowFwdIt>
inline constexpr bool _Use_memset_value_construct_v =
    conjunction_v<bool_constant<_Iterator_is_contiguous<_NoThrowFwdIt>>, is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
        negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
        negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

template <class _Ptr>
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { 
    char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));
    char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));
    :: memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
    return _Last;
}

template <class _Alloc>
constexpr _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(
    _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {
    
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {

        if (!::std:: is_constant_evaluated())
#line 2032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
    for (; 0 < _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    
    ;
    if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
        for (; 0 < _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}











#line 2074 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


template <class _Key, class... _Args>
struct _In_place_key_extract_set {
    
    static constexpr bool _Extractable = false;
};

template <class _Key>
struct _In_place_key_extract_set<_Key, _Key> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val) noexcept {
        return _Val;
    }
};


template <class _Key, class... _Args>
struct _In_place_key_extract_map {
    
    static constexpr bool _Extractable = false;
};

template <class _Key, class _Second>
struct _In_place_key_extract_map<_Key, _Key, _Second> {
    
    static constexpr bool _Extractable = true;
    static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept {
        return _Val;
    }
};

template <class _Key, class _First, class _Second>
struct _In_place_key_extract_map<_Key, pair<_First, _Second>> {
    
    static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
    static const _Key& _Extract(const pair<_First, _Second>& _Val) {
        return _Val.first;
    }
};

#pragma warning(push)
#pragma warning(disable : 4624) 
template <class _Ty>
struct _Wrap {
    _Ty _Value; 
};
#pragma warning(pop)

template <class _Alloc>
struct _Alloc_temporary2 {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits<_Alloc>;

    _Alloc& _Al;














    union {
        value_type _Value;
    };

    [[nodiscard]] constexpr value_type& _Get_value() noexcept {
        return _Value;
    }

    [[nodiscard]] constexpr const value_type& _Get_value() const noexcept {
        return _Value;
    }
#line 2156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

    template <class... _Args>
    constexpr explicit _Alloc_temporary2(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, ::std:: addressof(_Get_value()), ::std:: forward<_Args>(_Vals)...);
    }

    _Alloc_temporary2(const _Alloc_temporary2&)            = delete;
    _Alloc_temporary2& operator=(const _Alloc_temporary2&) = delete;

    constexpr ~_Alloc_temporary2() {
        _Traits::destroy(_Al, ::std:: addressof(_Get_value()));
    }
};

template <class _Alloc>
[[nodiscard]] constexpr bool _Allocators_equal(const _Alloc& _Lhs, const _Alloc& _Rhs) noexcept {
    if constexpr (allocator_traits<_Alloc>::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}


template <class _Ty, class = void>
inline constexpr bool _Has_member_from_primary = false;
template <class _Ty>
inline constexpr bool _Has_member_from_primary<_Ty, void_t<typename _Ty::_From_primary>> = true;




template <class _Alloc>
inline constexpr bool _Should_allocate_at_least =
    !_Has_member_from_primary<_Alloc>
    && _Has_member_allocate_at_least<_Alloc, typename allocator_traits<_Alloc>::size_type>;
#line 2195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Alloc>
[[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] constexpr typename allocator_traits<_Alloc>::pointer _Allocate_at_least_helper(
    _Alloc& _Al,  typename allocator_traits<_Alloc>::size_type& _Count) {

    if constexpr (_Should_allocate_at_least<_Alloc>) {
        auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
        _Count                  = _Allocated;
        return _Ptr;
    } else
#line 2206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        return _Al.allocate(_Count);
    }
}

 template <class _FwdIt, class _Ty>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

 template <class _FwdIt, class _Pr>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = ::std:: move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

template <class _Container, class _Uty>
constexpr typename _Container::size_type _Erase_remove(_Container& _Cont, const _Uty& _Val) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
constexpr typename _Container::size_type _Erase_remove_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, ::std:: remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

template <class _Container, class _Pr>
typename _Container::size_type _Erase_nodes_if(_Container& _Cont, _Pr _Pred) {
    
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}

template <class _Ty1, class _Ty2>
void _Deduce_as_pair(const pair<_Ty1, _Ty2>&); 

template <class _Ty, class = void>
inline constexpr bool _Is_deducible_as_pair = false;

template <class _Ty>
inline constexpr bool _Is_deducible_as_pair<_Ty, decltype(::std:: _Deduce_as_pair(::std:: declval<_Ty>()))> = true;

template <class _Ty>
inline constexpr bool _Is_cv_pair = _Is_specialization_v<remove_cv_t<_Ty>, pair>;

template <class _Ty>
const _Ty& _Normally_bind(_Identity_t<const _Ty&>); 

template <class _Ty>
_Ty&& _Normally_bind(_Identity_t<_Ty&&>); 

template <class _Ty, class _Uty>
using _Normally_bound_ref = decltype(::std:: _Normally_bind<_Ty>(::std:: declval<_Uty>()));

template <class _Ty, class _Uty, class = void>
inline constexpr bool _Is_normally_bindable = false;

template <class _Ty, class _Uty>
inline constexpr bool _Is_normally_bindable<_Ty, _Uty, void_t<_Normally_bound_ref<_Ty, _Uty>>> = true;


 template <class _Ty, class _Alloc, class... _Types, enable_if_t<!_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Types&&... _Args) noexcept {
    if constexpr (!uses_allocator_v<remove_cv_t<_Ty>, _Alloc>) {
        static_assert(is_constructible_v<_Ty, _Types...>,
            "If uses_allocator_v<remove_cv_t<T>, Alloc> does not hold, T must be constructible from Types...");
        (void) _Al;
        return ::std:: forward_as_tuple(::std:: forward<_Types>(_Args)...);
    } else if constexpr (is_constructible_v<_Ty, allocator_arg_t, const _Alloc&, _Types...>) {
        using _ReturnType = tuple<allocator_arg_t, const _Alloc&, _Types&&...>;
        return _ReturnType{allocator_arg, _Al, ::std:: forward<_Types>(_Args)...};
    } else if constexpr (is_constructible_v<_Ty, _Types..., const _Alloc&>) {
        return ::std:: forward_as_tuple(::std:: forward<_Types>(_Args)..., _Al);
    } else {
        static_assert(_Always_false<_Ty>,
            "T must be constructible from either (allocator_arg_t, const Alloc&, Types...) "
            "or (Types..., const Alloc&) if uses_allocator_v<remove_cv_t<T>, Alloc> is true");
    }
}

 template <class _Ty, class _Alloc, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept;

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept;


 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>& _Pair) noexcept;
#line 2348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept;

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept;


 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>&& _Pair) noexcept;
#line 2360 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


 template <class _Ty, class _Alloc, class _Uty>
    requires _Is_cv_pair<_Ty> && (_Pair_like<_Uty> || !_Is_deducible_as_pair<_Uty&>)



#line 2368 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept;

 template <class _Ty, class _Alloc, class _Tuple1, class _Tuple2, enable_if_t<_Is_cv_pair<_Ty>, int> = 0>
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, piecewise_construct_t, _Tuple1&& _Tup1, _Tuple2&& _Tup2) noexcept {
    return ::std:: make_tuple(piecewise_construct,
        ::std:: apply(
            [&_Al](auto&&... _Tuple_args) {
                return ::std:: uses_allocator_construction_args<typename _Ty::first_type>(
                    _Al, ::std:: forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            ::std:: forward<_Tuple1>(_Tup1)),
        ::std:: apply(
            [&_Al](auto&&... _Tuple_args) {
                return ::std:: uses_allocator_construction_args<typename _Ty::second_type>(
                    _Al, ::std:: forward<decltype(_Tuple_args)>(_Tuple_args)...);
            },
            ::std:: forward<_Tuple2>(_Tup2)));
}

 template <class _Ty, class _Alloc, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al) noexcept {
    
    
    return ::std:: make_tuple(piecewise_construct, ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al));
}

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty1&& _Val1, _Uty2&& _Val2) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: forward<_Uty1>(_Val1)),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, ::std:: forward<_Uty2>(_Val2)));
}


 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, _Pair.first),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, _Pair.second));
}
#line 2417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, _Pair.first),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, _Pair.second));
}

 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, pair<_Uty1, _Uty2>&& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: get<0>(::std:: move(_Pair))),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, ::std:: get<1>(::std:: move(_Pair))));
}


 template <class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t<_Is_cv_pair<_Ty>, int> >
[[nodiscard]] constexpr auto uses_allocator_construction_args(
    const _Alloc& _Al, const pair<_Uty1, _Uty2>&& _Pair) noexcept {
    
    
    
    return ::std:: make_tuple(piecewise_construct,
        ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: get<0>(::std:: move(_Pair))),
        ::std:: uses_allocator_construction_args<typename _Ty::second_type>(_Al, ::std:: get<1>(::std:: move(_Pair))));
}
#line 2451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


 template <class _Ty, class _Alloc, class _Uty>
    requires _Is_cv_pair<_Ty> && (_Pair_like<_Uty> || !_Is_deducible_as_pair<_Uty&>)



#line 2459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
[[nodiscard]] constexpr auto uses_allocator_construction_args(const _Alloc& _Al, _Uty&& _Ux) noexcept {

    if constexpr (_Pair_like<_Uty> && !_Is_subrange_v<remove_cvref_t<_Uty>>) {
        
        
        
        
        return ::std:: make_tuple(piecewise_construct,
            ::std:: uses_allocator_construction_args<typename _Ty::first_type>(_Al, ::std:: get<0>(::std:: forward<_Uty>(_Ux))),
            ::std:: uses_allocator_construction_args<typename _Ty::second_type>(
                _Al, ::std:: get<1>(::std:: forward<_Uty>(_Ux))));
    } else
#line 2472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
    {
        struct _Pair_remaker {
            const _Alloc& _Al;
            _Uty& _Ux;

            constexpr operator remove_cv_t<_Ty>() const {
                using _Pair_t = remove_cv_t<_Ty>;
                static_assert(_Is_normally_bindable<_Pair_t, _Uty>,
                    "The argument must be bindable to a reference to the std::pair type.");

                using _Pair_first_t   = _Pair_t::first_type;
                using _Pair_second_t  = _Pair_t::second_type;
                using _Pair_ref_t     = _Normally_bound_ref<_Pair_t, _Uty>;
                _Pair_ref_t _Pair_ref = ::std:: forward<_Uty>(_Ux);
                if constexpr (is_same_v<_Pair_ref_t, const _Pair_t&>) {
                    
                    
                    return _Pair_t{piecewise_construct,
                        ::std:: uses_allocator_construction_args<_Pair_first_t>(_Al, _Pair_ref.first),
                        ::std:: uses_allocator_construction_args<_Pair_second_t>(_Al, _Pair_ref.second)};
                } else {
                    
                    
                    return _Pair_t{piecewise_construct,
                        ::std:: uses_allocator_construction_args<_Pair_first_t>(_Al, ::std:: get<0>(::std:: move(_Pair_ref))),
                        ::std:: uses_allocator_construction_args<_Pair_second_t>(_Al, ::std:: get<1>(::std:: move(_Pair_ref)))};
                }
            }
        };

        
        
        return tuple<_Pair_remaker>({_Al, _Ux});
    }
}

 template <class _Ty, class _Alloc, class... _Types>
[[nodiscard]] constexpr _Ty make_obj_using_allocator(const _Alloc& _Al, _Types&&... _Args) {
    return ::std:: make_from_tuple<_Ty>(::std:: uses_allocator_construction_args<_Ty>(_Al, ::std:: forward<_Types>(_Args)...));
}

 template <class _Ty, class _Alloc, class... _Types>
constexpr _Ty* uninitialized_construct_using_allocator(_Ty* _Ptr, const _Alloc& _Al, _Types&&... _Args) {
    return ::std:: apply(
        [&](auto&&... _Construct_args) {
            return ::std:: construct_at(_Ptr, ::std:: forward<decltype(_Construct_args)>(_Construct_args)...);
        },
        ::std:: uses_allocator_construction_args<_Ty>(_Al, ::std:: forward<_Types>(_Args)...));
}
#line 2522 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"


 struct from_range_t {
    explicit from_range_t() = default;
};
 inline constexpr from_range_t from_range;

template <class _Rng, class _Elem>
concept _Container_compatible_range =
    (::std::ranges:: input_range<_Rng>) &&convertible_to<::std::ranges:: range_reference_t<_Rng>, _Elem>;

template <::std::ranges:: input_range _Rng>
using _Range_key_type = remove_const_t<typename ::std::ranges:: range_value_t<_Rng>::first_type>;

template <::std::ranges:: input_range _Rng>
using _Range_mapped_type = typename ::std::ranges:: range_value_t<_Rng>::second_type; 

template <::std::ranges:: input_range _Rng>
using _Range_to_alloc_type =
    pair<const typename ::std::ranges:: range_value_t<_Rng>::first_type, typename ::std::ranges:: range_value_t<_Rng>::second_type>;
#line 2543 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"

template <class _Ty,
    bool = is_empty_v<_Ty> && !is_final_v<_Ty>>
class _Ebco_base : private _Ty { 
private:
    using _Mybase = _Ty; 

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return *this;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return *this;
    }
};

template <class _Ty>
class _Ebco_base<_Ty, false> { 
private:
    _Ty _Myval;

protected:
    template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
    constexpr explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std:: forward<_Other>(_Val)) {}

    constexpr _Ty& _Get_val() noexcept {
        return _Myval;
    }

    constexpr const _Ty& _Get_val() const noexcept {
        return _Myval;
    }
};

 inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept  {
    
    size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
    if (_Off != 0) {
        _Off = _Bound - _Off; 
    }

    if (_Space < _Off || _Space - _Off < _Size) {
        return nullptr;
    }

    
    _Ptr = static_cast<char*>(_Ptr) + _Off;
    _Space -= _Off;
    return _Ptr;
}

template <class _Ty, class = void>
inline constexpr bool _Is_transparent_v = false;

template <class _Ty>
inline constexpr bool _Is_transparent_v<_Ty, void_t<typename _Ty::is_transparent>> = true;

template <class _Ty>
struct _Is_transparent : bool_constant<_Is_transparent_v<_Ty>> {};


template <class _Ty>
concept _Transparent = _Is_transparent_v<_Ty>;
#line 2613 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
}



#pragma warning(pop)
#pragma pack(pop)
#line 2620 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
#line 2621 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xmemory"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {






































































































#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"


namespace pmr {
     class __declspec(novtable) memory_resource {
    public:
        virtual ~memory_resource() noexcept = default;

        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) void* allocate( const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) { 
            ;
            void* _Ptr = do_allocate(_Bytes, _Align);
            return ::operator new(_Bytes, _Ptr);
        }

        void deallocate(void* const _Ptr, const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
            
            ;
            return do_deallocate(_Ptr, _Bytes, _Align);
        }

        [[nodiscard]] bool is_equal(const memory_resource& _That) const noexcept {
            
            return do_is_equal(_That);
        }

    private:
        virtual void* do_allocate(size_t _Bytes, size_t _Align)               = 0;
        virtual void do_deallocate(void* _Ptr, size_t _Bytes, size_t _Align)  = 0;
        virtual bool do_is_equal(const memory_resource& _That) const noexcept = 0;
    };

     [[nodiscard]] inline bool operator==(
        const memory_resource& _Left, const memory_resource& _Right) noexcept {
        return &_Left == &_Right || _Left.is_equal(_Right);
    }





#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"

    extern "C"  memory_resource* __cdecl _Aligned_get_default_resource() noexcept;
    extern "C"  memory_resource* __cdecl _Unaligned_get_default_resource() noexcept;

     [[nodiscard]] inline memory_resource* get_default_resource() noexcept {

        return ::std:: pmr::_Aligned_get_default_resource();


#line 177 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
    }


    template <class _Uty>
    struct [[nodiscard]] _Deallocate_bytes_guard {
        ~_Deallocate_bytes_guard() noexcept {
            if (_Mem_res) {
                _Mem_res->deallocate(_Pobj, sizeof(_Uty), alignof(_Uty));
            }
        }

        _Deallocate_bytes_guard& operator=(const _Deallocate_bytes_guard&) = delete;
        _Deallocate_bytes_guard& operator=(_Deallocate_bytes_guard&&)      = delete;

        memory_resource* _Mem_res;
        void* _Pobj;
    };
#line 195 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"


     template <class _Ty = byte>


#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
    class polymorphic_allocator {
    public:
        template <class>
        friend class polymorphic_allocator;

        using value_type = _Ty;

        polymorphic_allocator() noexcept = default;

         polymorphic_allocator(memory_resource* const _Resource_) noexcept 
            : _Resource{_Resource_} { 
            ;
#line 214 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
        }

        polymorphic_allocator(const polymorphic_allocator&) = default;

        template <class _Uty>
        polymorphic_allocator(const polymorphic_allocator<_Uty>& _That) noexcept
            : _Resource{_That._Resource} {} 

        polymorphic_allocator& operator=(const polymorphic_allocator&) = delete;

        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Ty* allocate( const size_t _Count) {
            
            void* const _Vp = _Resource->allocate(_Get_size_of_n<sizeof(_Ty)>(_Count), alignof(_Ty));
            return static_cast<_Ty*>(_Vp);
        }

        void deallocate(_Ty* const _Ptr, const size_t _Count) noexcept  {
            
            
            _Resource->deallocate(_Ptr, _Count * sizeof(_Ty), alignof(_Ty));
        }


        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) void* allocate_bytes(
            const size_t _Bytes, const size_t _Align = alignof(max_align_t)) {
            return _Resource->allocate(_Bytes, _Align);
        }

        void deallocate_bytes(void* const _Ptr, const size_t _Bytes,
            const size_t _Align = alignof(max_align_t)) noexcept  {
            _Resource->deallocate(_Ptr, _Bytes, _Align);
        }

        template <class _Uty>
        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Uty* allocate_object(
             const size_t _Count = 1) {
            void* const _Vp = allocate_bytes(_Get_size_of_n<sizeof(_Uty)>(_Count), alignof(_Uty));
            return static_cast<_Uty*>(_Vp);
        }

        template <class _Uty>
        void deallocate_object(_Uty* const _Ptr, const size_t _Count = 1) noexcept  {
            deallocate_bytes(_Ptr, _Count * sizeof(_Uty), alignof(_Uty));
        }

        template <class _Uty, class... _Types>
        [[nodiscard("This function allocates memory and returns a raw pointer. " "Discarding the return value will cause a memory leak.")]] __declspec(allocator) _Uty* new_object(_Types&&... _Args) {
            _Uty* const _Ptr = allocate_object<_Uty>();

            _Deallocate_bytes_guard<_Uty> _Guard{_Resource, _Ptr};
            construct(_Ptr, ::std:: forward<_Types>(_Args)...);
            _Guard._Mem_res = nullptr;

            return _Ptr;
        }

        template <class _Uty>
        void delete_object(_Uty* const _Ptr) noexcept  {
            ::std:: _Destroy_in_place(*_Ptr);
            deallocate_object(_Ptr);
        }
#line 276 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"

        template <class _Uty, class... _Types>
        void construct(_Uty* const _Ptr, _Types&&... _Args) {
            

            
            ::std:: apply(
                [_Ptr](auto&&... _Construct_args) {
                    return ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr)))
                        _Uty(::std:: forward<decltype(_Construct_args)>(_Construct_args)...);
                },
                ::std:: uses_allocator_construction_args<_Uty>(*this, ::std:: forward<_Types>(_Args)...));







#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
        }

        template <class _Uty>
        [[deprecated("warning STL4032: " "std::pmr::polymorphic_allocator::destroy() is deprecated in C++17 by LWG-3036. " "Prefer std::destroy_at() or std::allocator_traits<polymorphic_allocator>::destroy(). " "You can define _SILENCE_CXX17_POLYMORPHIC_ALLOCATOR_DESTROY_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] void destroy(_Uty* const _Ptr) noexcept  {
            ::std:: _Destroy_in_place(*_Ptr);
        }

        [[nodiscard]] polymorphic_allocator select_on_container_copy_construction() const noexcept  {
            
            return {};
        }

        [[nodiscard]] memory_resource* resource() const noexcept  {
            
            return _Resource;
        }

        [[nodiscard]] friend bool operator==(
            const polymorphic_allocator& _Lhs, const polymorphic_allocator& _Rhs) noexcept {
            return *_Lhs._Resource == *_Rhs._Resource;
        }






#line 324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"

    private:
        memory_resource* _Resource = ::std:: pmr::get_default_resource();
    };

     template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator==(
        const polymorphic_allocator<_Ty1>& _Left, const polymorphic_allocator<_Ty2>& _Right) noexcept {
        
        return *_Left.resource() == *_Right.resource();
    }







#line 343 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"

} 

template <class _Ty, class _Ptr>
struct _Has_no_alloc_destroy<pmr::polymorphic_allocator<_Ty>, _Ptr, void> : true_type {
    
    
};

#line 353 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"

}



#pragma warning(pop)
#pragma pack(pop)
#line 361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
#line 362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xpolymorphic_allocator.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )








#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

namespace std {
template <class _Elem, class _Int_type>
struct _Char_traits { 
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = _Mbstatet;

    using comparison_category = strong_ordering;
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    

    static constexpr _Elem* copy(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        if (::std:: is_constant_evaluated()) {
            
            for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                _First1[_Idx] = _First2[_Idx];
            }

            return _First1;
        }
#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _First1;
    }

      static constexpr _Elem* _Copy_s( 
                                                                                 _Elem* const _First1,
        const size_t _Dest_size,   const _Elem* const _First2, const size_t _Count) noexcept {
        
        do { if (_Count <= _Dest_size) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        return copy(_First1, _First2, _Count);
    }

    static constexpr _Elem* move(  _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        


#line 84 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        if (::std:: is_constant_evaluated()) {
            
            
            
            
            

            
            
            bool _Loop_forward = true;

            for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
                if (_First1 == _Src) {
                    _Loop_forward = false;
                    break;
                }
            }

            if (_Loop_forward) {
                for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
                    _First1[_Idx] = _First2[_Idx];
                }
            } else {
                for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
                    _First1[_Idx - 1] = _First2[_Idx - 1];
                }
            }

            return _First1;
        }
#line 116 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        :: memmove(_First1, _First2, _Count * sizeof(_Elem));
#line 119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _First1;
    }

    
    

    [[nodiscard]] static constexpr int compare(  const _Elem* _First1,
          const _Elem* _First2, size_t _Count) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First1, ++_First2) {
            if (*_First1 != *_First2) {
                return *_First1 < *_First2 ? -1 : +1;
            }
        }

        return 0;
    }

    [[nodiscard]] static constexpr size_t length(  const _Elem* _First) noexcept  {
        
        size_t _Count = 0;
        while (*_First != _Elem()) {
            ++_Count;
            ++_First;
        }

        return _Count;
    }

    [[nodiscard]] static constexpr const _Elem* find(
          const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept  {
        
        for (; 0 < _Count; --_Count, ++_First) {
            if (*_First == _Ch) {
                return _First;
            }
        }

        return nullptr;
    }

    static constexpr _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        

        if (::std:: is_constant_evaluated()) {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                ::std:: construct_at(_Next, _Ch);
            }
        } else
#line 171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        {
            for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {
                *_Next = _Ch;
            }
        }

        return _First;
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            ::std:: construct_at(::std:: addressof(_Left), _Right);
        } else
#line 186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        {
            _Left = _Right;
        }
    }

    [[nodiscard]] static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return static_cast<int_type>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};

template <class _Elem>
struct _WChar_traits : private _Char_traits<_Elem, unsigned short> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, unsigned short>;

public:
    using char_type  = _Elem;
    using int_type   = unsigned short;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;
#line 235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static constexpr int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemcmp(_First1, _First2, _Count);
        } else {
            return _Primary_char_traits::compare(_First1, _First2, _Count);
        }



#line 253 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] static constexpr size_t length(  const _Elem* _First) noexcept  {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wcslen(_First);
        } else {
            return _Primary_char_traits::length(_First);
        }


#line 266 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] static constexpr const _Elem* find(
          const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept  {
        

        if constexpr (is_same_v<_Elem, wchar_t>) {
            return __builtin_wmemchr(_First, _Ch, _Count);
        } else {
            return _Primary_char_traits::find(_First, _Count, _Ch);
        }


#line 280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    static constexpr _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#line 290 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return reinterpret_cast<_Elem*>(:: wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#line 300 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left < _Right;
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return _Meta;
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return _Ch;
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return ((wint_t)(0xFFFF));
    }
};

 template <class _Elem>
struct char_traits : _Char_traits<_Elem, long> {}; 

template <>
struct char_traits<char16_t> : _WChar_traits<char16_t> {};

template <>
struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int> {};

template <>
struct char_traits<wchar_t> : _WChar_traits<wchar_t> {};










#line 354 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

template <class _Elem, class _Int_type>
struct _Narrow_char_traits : private _Char_traits<_Elem, _Int_type> {
    
private:
    using _Primary_char_traits = _Char_traits<_Elem, _Int_type>;

public:
    using char_type  = _Elem;
    using int_type   = _Int_type;
    using pos_type   = streampos;
    using off_type   = streamoff;
    using state_type = mbstate_t;

    using comparison_category = strong_ordering;
#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    using _Primary_char_traits::_Copy_s;
    using _Primary_char_traits::copy;
    using _Primary_char_traits::move;

    [[nodiscard]] static constexpr int compare(  const _Elem* const _First1,
          const _Elem* const _First2, const size_t _Count) noexcept  {
        

        return __builtin_memcmp(_First1, _First2, _Count);


#line 383 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] static constexpr size_t length(  const _Elem* const _First) noexcept  {
        


        if constexpr (is_same_v<_Elem, char8_t>) {

            return __builtin_u8strlen(_First);


#line 395 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        } else
#line 397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        {
            return __builtin_strlen(_First);
        }


#line 403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] static constexpr const _Elem* find(  const _Elem* const _First, const size_t _Count,
        const _Elem& _Ch) noexcept  {
        


        if constexpr (is_same_v<_Elem, char8_t>) {

            return __builtin_u8memchr(_First, _Ch, _Count);


#line 416 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        } else
#line 418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        {
            return __builtin_char_memchr(_First, _Ch, _Count);
        }


#line 424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    static constexpr _Elem* assign(
          _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept  {
        

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_First, _Count, _Ch);
        }
#line 434 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return static_cast<_Elem*>(:: memset(_First, _Ch, _Count));
    }

    static constexpr void assign(_Elem& _Left, const _Elem& _Right) noexcept {

        if (::std:: is_constant_evaluated()) {
            return _Primary_char_traits::assign(_Left, _Right);
        }
#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Left = _Right;
    }

    [[nodiscard]] static constexpr bool eq(const _Elem _Left, const _Elem _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr bool lt(const _Elem _Left, const _Elem _Right) noexcept {
        return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
    }

    [[nodiscard]] static constexpr _Elem to_char_type(const int_type _Meta) noexcept {
        return static_cast<_Elem>(_Meta);
    }

    [[nodiscard]] static constexpr int_type to_int_type(const _Elem _Ch) noexcept {
        return static_cast<unsigned char>(_Ch);
    }

    [[nodiscard]] static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {
        return _Left == _Right;
    }

    [[nodiscard]] static constexpr int_type not_eof(const int_type _Meta) noexcept {
        return _Meta != eof() ? _Meta : !eof();
    }

    [[nodiscard]] static constexpr int_type eof() noexcept {
        return static_cast<int_type>((-1));
    }
};




template <>
struct char_traits<char> : _Narrow_char_traits<char, int> {}; 


template <>
struct char_traits<char8_t> : _Narrow_char_traits<char8_t, unsigned int> {};
#line 486 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

template <class _Elem, class _Traits, class _SizeT>
basic_ostream<_Elem, _Traits>& _Insert_string(
    basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {
    
    using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
    typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

    _SizeT _Pad;
    if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {
        _Pad = 0;
    } else {
        _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
    }

    const typename _Ostr_t::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= _Ostr_t::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        if (_State == _Ostr_t::goodbit
            && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {
            _State |= _Ostr_t::badbit;
        } else {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= _Ostr_t::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(_Ostr_t::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

template <class _Traits>
using _Traits_ch_t = typename _Traits::char_type;

template <class _Traits>
using _Traits_ptr_t = const typename _Traits::char_type*;

template <class _Traits>
constexpr bool _Traits_equal(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
}

template <class _Traits>
constexpr int _Traits_compare(  const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
      const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {
    
    const int _Ans = _Traits::compare(_Left, _Right, (::std:: min)(_Left_size, _Right_size));

    if (_Ans != 0) {
        return _Ans;
    }

    if (_Left_size < _Right_size) {
        return -1;
    }

    if (_Left_size > _Right_size) {
        return 1;
    }

    return 0;
}

template <class _Traits>
constexpr size_t _Traits_find(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {
        
        
        
        
        
        
        
        
        return static_cast<size_t>(-1);
    }

    if (_Needle_size == 0) { 
        return _Start_at;
    }

    const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
    for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
        _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
        if (!_Match_try) { 
            return static_cast<size_t>(-1);
        }

        if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { 
            return static_cast<size_t>(_Match_try - _Haystack);
        }
    }
}

template <class _Traits>
constexpr size_t _Traits_find_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) {
        const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
        if (_Found_at) {
            return static_cast<size_t>(_Found_at - _Haystack);
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size == 0) {
        return (::std:: min)(_Start_at, _Hay_size); 
    }

    if (_Needle_size <= _Hay_size) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
            if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_ch(  const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
    const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Elem, bool = _Is_character<_Elem>::value>
class _String_bitmap { 
public:
    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            _Matches[static_cast<unsigned char>(*_First)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Matches[static_cast<unsigned char>(_Ch)];
    }

private:
    bool _Matches[256] = {};
};

template <class _Elem>
class _String_bitmap<_Elem, false> { 
public:
    static_assert(is_unsigned_v<_Elem>,
        "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N4950 [char.traits]. "
        "Visual C++ accepts other unsigned integral types as an extension.");

    constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {
        
        
        for (; _First != _Last; ++_First) {
            const auto _Ch = *_First;
            if (_Ch >= 256U) {
                return false;
            }

            _Matches[static_cast<unsigned char>(_Ch)] = true;
        }

        return true;
    }

    constexpr bool _Match(const _Elem _Ch) const noexcept { 
        return _Ch < 256U && _Matches[_Ch];
    }

private:
    bool _Matches[256] = {};
};

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size != 0 && _Start_at < _Hay_size) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_first_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Needle_size != 0 && _Hay_size != 0) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_last_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_first_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Start_at < _Hay_size) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_first_not_of<_Traits, false>(
                    _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        } else {
            const auto _End = _Haystack + _Hay_size;
            for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_find_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Start_at < _Hay_size) { 
        const auto _End = _Haystack + _Hay_size;
        for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits, bool _Special = _Is_specialization_v<_Traits, char_traits>>
constexpr size_t _Traits_find_last_not_of(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at,   const _Traits_ptr_t<_Traits> _Needle,
    const size_t _Needle_size) noexcept {
    
    if (_Hay_size != 0) { 
        if constexpr (_Special) {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { 
                                                                    
                return _Traits_find_last_not_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
            }

            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Matches._Match(*_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        } else {
            for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
                if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
                    return static_cast<size_t>(_Match_try - _Haystack); 
                }

                if (_Match_try == _Haystack) {
                    break; 
                }
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Traits>
constexpr size_t _Traits_rfind_not_ch(  const _Traits_ptr_t<_Traits> _Haystack,
    const size_t _Hay_size, const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {
    
    if (_Hay_size != 0) { 
        for (auto _Match_try = _Haystack + (::std:: min)(_Start_at, _Hay_size - 1);; --_Match_try) {
            if (!_Traits::eq(*_Match_try, _Ch)) {
                return static_cast<size_t>(_Match_try - _Haystack); 
            }

            if (_Match_try == _Haystack) {
                break; 
            }
        }
    }

    return static_cast<size_t>(-1); 
}

template <class _Ty>
inline constexpr bool _Is_EcharT = _Is_any_of_v<_Ty, char, wchar_t,

    char8_t,
#line 893 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    char16_t, char32_t>;


 template <class _Elem, class _Traits = char_traits<_Elem>>
class basic_string_view;

template <class _Traits>
class _String_view_iterator {
public:

    using iterator_concept = contiguous_iterator_tag;
#line 905 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Traits::char_type;
    using difference_type   = ptrdiff_t;
    using pointer           = const value_type*;
    using reference         = const value_type&;

    constexpr _String_view_iterator() noexcept = default;

private:
    friend basic_string_view<value_type, _Traits>;




#line 920 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept : _Myptr(_Ptr) {}
#line 922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

public:
    [[nodiscard]] constexpr reference operator*() const noexcept {




#line 930 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return *_Myptr;
#line 932 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {




#line 940 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Myptr;
#line 942 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    constexpr _String_view_iterator& operator++() noexcept {




#line 950 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        ++_Myptr;
#line 952 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return *this;
    }

    constexpr _String_view_iterator operator++(int) noexcept {
        _String_view_iterator _Tmp{*this};
        ++*this;
        return _Tmp;
    }

    constexpr _String_view_iterator& operator--() noexcept {




#line 967 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        --_Myptr;
#line 969 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return *this;
    }

    constexpr _String_view_iterator operator--(int) noexcept {
        _String_view_iterator _Tmp{*this};
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {













#line 993 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        (void) _Off;
#line 995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept {



#line 1002 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Myptr += _Off;
#line 1004 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return *this;
    }

    [[nodiscard]] constexpr _String_view_iterator operator+(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{*this};
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_view_iterator operator+(
        const difference_type _Off, _String_view_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept {















#line 1037 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Myptr -= _Off;
#line 1039 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return *this;
    }

    [[nodiscard]] constexpr _String_view_iterator operator-(const difference_type _Off) const noexcept {
        _String_view_iterator _Tmp{*this};
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _String_view_iterator& _Right) const noexcept {




#line 1055 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Myptr - _Right._Myptr;
#line 1057 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _String_view_iterator& _Right) const noexcept {




#line 1069 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Myptr == _Right._Myptr;
#line 1071 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _String_view_iterator& _Right) const noexcept {




#line 1080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Myptr <=> _Right._Myptr;
#line 1082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }


























#line 1110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"







#line 1118 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_view_iterator;

    [[nodiscard]] constexpr pointer _Unwrapped() const noexcept {


#line 1125 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Myptr;
#line 1127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    static constexpr bool _Unwrap_when_unverified = 0 == 0;

    constexpr void _Seek_to(pointer _It) noexcept {


#line 1135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Myptr = _It;
#line 1137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

private:




#line 1145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    pointer _Myptr = nullptr;
#line 1147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
};


template <class _Traits>
struct pointer_traits<_String_view_iterator<_Traits>> {
    using pointer         = _String_view_iterator<_Traits>;
    using element_type    = const typename pointer::value_type; 
    using difference_type = pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer& _Iter) noexcept {
        return _Iter._Unwrapped();
    }
};
#line 1161 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

#pragma warning(push)


#pragma warning(disable : 6510)

 template <class _Elem, class _Traits>
class basic_string_view { 
public:
    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "Bad char_traits for basic_string_view; N4950 [string.view.template.general]/1 "
        "\"The program is ill-formed if traits::char_type is not the same type as charT.\"");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string_view must be a non-array trivial standard-layout type. See N4950 "
        "[strings.general]/1.");

    using traits_type            = _Traits;
    using value_type             = _Elem;
    using pointer                = _Elem*;
    using const_pointer          = const _Elem*;
    using reference              = _Elem&;
    using const_reference        = const _Elem&;
    using const_iterator         = _String_view_iterator<_Traits>;
    using iterator               = const_iterator;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;
    using reverse_iterator       = const_reverse_iterator;
    using size_type              = size_t;
    using difference_type        = ptrdiff_t;

    static constexpr auto npos{static_cast<size_type>(-1)};

    constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) {}

    constexpr basic_string_view(const basic_string_view&) noexcept            = default;
    constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;

     constexpr basic_string_view(  const const_pointer _Ntcts) noexcept 
        : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}


    basic_string_view(nullptr_t) = delete;
#line 1204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string_view(
          const const_pointer _Cts, const size_type _Count) noexcept 
        : _Mydata(_Cts), _Mysize(_Count) {


#line 1211 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }


    template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
        requires (is_same_v<iter_value_t<_Iter>, _Elem> && !is_convertible_v<_Sent, size_type>)
    constexpr basic_string_view(_Iter _First, _Sent _Last) noexcept(noexcept(_Last - _First)) 
        : _Mydata(::std:: to_address(_First)), _Mysize(static_cast<size_type>(_Last - _First)) {}


    
    template <class _Range>
        requires (!same_as<remove_cvref_t<_Range>, basic_string_view>
            && ::std::ranges:: contiguous_range<_Range>
            && ::std::ranges:: sized_range<_Range>
            && same_as<::std::ranges:: range_value_t<_Range>, _Elem>
            && !is_convertible_v<_Range, const _Elem*>
            && !requires(remove_cvref_t<_Range>& _Rng) {
                _Rng.operator ::std:: basic_string_view<_Elem, _Traits>();
            })
    constexpr explicit basic_string_view(_Range&& _Rng) noexcept(
        noexcept(::std::ranges:: data(_Rng)) && noexcept(::std::ranges:: size(_Rng))) 
        : _Mydata(::std::ranges:: data(_Rng)), _Mysize(static_cast<size_t>(::std::ranges:: size(_Rng))) {}
    
#line 1235 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
#line 1236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr const_iterator begin() const noexcept {


#line 1241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return const_iterator(_Mydata);
#line 1243 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {


#line 1249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return const_iterator(_Mydata + _Mysize);
#line 1251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator{end()};
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator{begin()};
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    constexpr const_pointer _Unchecked_begin() const noexcept {
        return _Mydata;
    }

    constexpr const_pointer _Unchecked_end() const noexcept {
        return _Mydata + _Mysize;
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        return _Mysize;
    }

    [[nodiscard]] constexpr size_type length() const noexcept {
        return _Mysize;
    }

    [[nodiscard]] constexpr bool empty() const noexcept {
        return _Mysize == 0;
    }

    [[nodiscard]] constexpr const_pointer data() const noexcept {
        return _Mydata;
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        
        
        return (::std:: min)(static_cast<size_t>(9223372036854775807i64), static_cast<size_t>(-1) / sizeof(_Elem));
    }

    [[nodiscard]] constexpr const_reference operator[](const size_type _Off) const noexcept  {


#line 1311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Mydata[_Off];
    }

    [[nodiscard]] constexpr const_reference at(const size_type _Off) const {
        
        _Check_offset_exclusive(_Off);
        return _Mydata[_Off];
    }

    [[nodiscard]] constexpr const_reference front() const noexcept  {


#line 1324 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Mydata[0];
    }

    [[nodiscard]] constexpr const_reference back() const noexcept  {


#line 1331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Mydata[_Mysize - 1];
    }

    constexpr void remove_prefix(const size_type _Count) noexcept  {


#line 1338 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Mydata += _Count;
        _Mysize -= _Count;
    }

    constexpr void remove_suffix(const size_type _Count) noexcept  {


#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Mysize -= _Count;
    }

    constexpr void swap(basic_string_view& _Other) noexcept {
        const basic_string_view _Tmp{_Other}; 
        _Other = *this;
        *this  = _Tmp;
    }

    constexpr size_type copy(
          _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mydata + _Off, _Count);
        return _Count;
    }

      constexpr size_type
        _Copy_s(  _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mydata + _Off, _Count);
        return _Count;
    }

    [[nodiscard]] constexpr basic_string_view substr(const size_type _Off = 0, size_type _Count = npos) const {
        
        _Check_offset(_Off);
        _Count = _Clamp_suffix_size(_Off, _Count);
        return basic_string_view(_Mydata + _Off, _Count);
    }

    constexpr bool _Equal(const basic_string_view _Right) const noexcept {
        return _Traits_equal<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr int compare(const basic_string_view _Right) const noexcept {
        return _Traits_compare<_Traits>(_Mydata, _Mysize, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right) const {
        
        return substr(_Off, _Nx).compare(_Right);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string_view _Right,
        const size_type _Roff, const size_type _Count) const {
        
        return substr(_Off, _Nx).compare(_Right.substr(_Roff, _Count));
    }

    [[nodiscard]] constexpr int compare(  const _Elem* const _Ptr) const noexcept  {
        
        return compare(basic_string_view(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) const {
        
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,
          const _Elem* const _Ptr, const size_type _Count) const {
        
        return substr(_Off, _Nx).compare(basic_string_view(_Ptr, _Count));
    }


    [[nodiscard]] constexpr bool starts_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata, _Right._Mydata, _Rightsize) == 0;
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(front(), _Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem* const _Right) const noexcept  {
        return starts_with(basic_string_view(_Right));
    }

    [[nodiscard]] constexpr bool ends_with(const basic_string_view _Right) const noexcept {
        const auto _Rightsize = _Right._Mysize;
        if (_Mysize < _Rightsize) {
            return false;
        }
        return _Traits::compare(_Mydata + (_Mysize - _Rightsize), _Right._Mydata, _Rightsize) == 0;
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem _Right) const noexcept {
        return !empty() && _Traits::eq(back(), _Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem* const _Right) const noexcept  {
        return ends_with(basic_string_view(_Right));
    }
#line 1449 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


    [[nodiscard]] constexpr bool contains(const basic_string_view _Right) const noexcept {
        return find(_Right) != npos;
    }

    [[nodiscard]] constexpr bool contains(const _Elem _Right) const noexcept {
        return find(_Right) != npos;
    }

    [[nodiscard]] constexpr bool contains(const _Elem* const _Right) const noexcept  {
        return find(_Right) != npos;
    }
#line 1463 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find(const basic_string_view _Right, const size_type _Off = 0) const noexcept {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
     {
        
        return _Traits_find<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type rfind(const basic_string_view _Right, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
     {
        
        return _Traits_rfind<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_first_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_first_of(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept  {
        
        return _Traits_find_first_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_last_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { 
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_last_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return _Traits_find_last_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const basic_string_view _Right,
        const size_type _Off = 0) const noexcept { 
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return _Traits_find_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_first_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_first_not_of(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept  {
        
        return _Traits_find_first_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const basic_string_view _Right,
        const size_type _Off = npos) const noexcept { 
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Right._Mydata, _Right._Mysize);
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return _Traits_rfind_not_ch<_Traits>(_Mydata, _Mysize, _Off, _Ch);
    }

    [[nodiscard]] constexpr size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Count);
    }

    [[nodiscard]] constexpr size_type find_last_not_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return _Traits_find_last_not_of<_Traits>(_Mydata, _Mysize, _Off, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr bool _Starts_with(const basic_string_view _View) const noexcept {
        return _Mysize >= _View._Mysize && _Traits::compare(_Mydata, _View._Mydata, _View._Mysize) == 0;
    }

private:
    constexpr void _Check_offset(const size_type _Off) const { 
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    constexpr void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min)(_Size, _Mysize - _Off);
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string_view position");
    }

    const_pointer _Mydata;
    size_type _Mysize;
};

#pragma warning(pop)


template <contiguous_iterator _Iter, sized_sentinel_for<_Iter> _Sent>
basic_string_view(_Iter, _Sent) -> basic_string_view<iter_value_t<_Iter>>;


template <::std::ranges:: contiguous_range _Range>
basic_string_view(_Range&&) -> basic_string_view<::std::ranges:: range_value_t<_Range>>;
#line 1637 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

namespace ranges {
    template <class _Elem, class _Traits>
    inline constexpr bool enable_view<basic_string_view<_Elem, _Traits>> = true;
    template <class _Elem, class _Traits>
    inline constexpr bool enable_borrowed_range<basic_string_view<_Elem, _Traits>> = true;
} 
#line 1645 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 template <class _Elem, class _Traits>
[[nodiscard]] constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}







#line 1659 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr bool operator==(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return _Lhs._Equal(_Rhs);
}



























































































#line 1757 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


template <class _Traits, class = void>
struct _Get_comparison_category {
    using type = weak_ordering;
};

template <class _Traits>
struct _Get_comparison_category<_Traits, void_t<typename _Traits::comparison_category>> {
    using type = _Traits::comparison_category;

    static_assert(_Is_any_of_v<type, partial_ordering, weak_ordering, strong_ordering>,
        "N4950 [string.view.comparison]/4: Mandates: R denotes a comparison category type.");
};

template <class _Traits>
using _Get_comparison_category_t = _Get_comparison_category<_Traits>::type;

 template <class _Elem, class _Traits>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const basic_string_view<_Elem, _Traits> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}

 template <class _Elem, class _Traits, int = 2> 
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string_view<_Elem, _Traits> _Lhs, const _Identity_t<basic_string_view<_Elem, _Traits>> _Rhs) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Lhs.compare(_Rhs) <=> 0);
}
#line 1787 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 using string_view = basic_string_view<char>;

 using u8string_view = basic_string_view<char8_t>;
#line 1792 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
 using u16string_view = basic_string_view<char16_t>;
 using u32string_view = basic_string_view<char32_t>;
 using wstring_view   = basic_string_view<wchar_t>;

template <class _Elem>
struct hash<basic_string_view<_Elem>> : _Conditionally_enabled_hash<basic_string_view<_Elem>, _Is_EcharT<_Elem>> {
    [[nodiscard]] static size_t _Do_hash(const basic_string_view<_Elem> _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.data(), _Keyval.size());
    }
};

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string_view<_Elem, _Traits> _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_view_literals {
         [[nodiscard]] constexpr string_view operator""sv(const char* _Str, size_t _Len) noexcept {
            return string_view(_Str, _Len);
        }

         [[nodiscard]] constexpr wstring_view operator""sv(const wchar_t* _Str, size_t _Len) noexcept {
            return wstring_view(_Str, _Len);
        }


         [[nodiscard]] constexpr basic_string_view<char8_t> operator""sv(
            const char8_t* _Str, size_t _Len) noexcept {
            return basic_string_view<char8_t>(_Str, _Len);
        }
#line 1825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

         [[nodiscard]] constexpr u16string_view operator""sv(const char16_t* _Str, size_t _Len) noexcept {
            return u16string_view(_Str, _Len);
        }

         [[nodiscard]] constexpr u32string_view operator""sv(const char32_t* _Str, size_t _Len) noexcept {
            return u32string_view(_Str, _Len);
        }
    } 
} 
#line 1836 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

template <class _Mystr>
class _String_const_iterator : public _Iterator_base {
public:

    using iterator_concept = contiguous_iterator_tag;
#line 1843 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::const_pointer;
    using reference         = const value_type&;

    constexpr _String_const_iterator() noexcept : _Ptr() {}

    constexpr _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pstring);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {









#line 1866 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        ;
        return *_Ptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    constexpr _String_const_iterator& operator++() noexcept {






#line 1883 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        ++_Ptr;
        return *this;
    }

    constexpr _String_const_iterator operator++(int) noexcept {
        _String_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr _String_const_iterator& operator--() noexcept {






#line 1902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        --_Ptr;
        return *this;
    }

    constexpr _String_const_iterator operator--(int) noexcept {
        _String_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {





















#line 1936 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        (void) _Off;
#line 1938 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    constexpr _String_const_iterator& operator+=(const difference_type _Off) noexcept {


#line 1944 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr _String_const_iterator operator+(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_const_iterator operator+(
        const difference_type _Off, _String_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _String_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr _String_const_iterator operator-(const difference_type _Off) const noexcept {
        _String_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _String_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Unfancy(_Ptr) <=> _Unfancy(_Right._Ptr);
    }





















#line 2011 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr void _Compat(const _String_const_iterator& _Right) const noexcept {
        



#line 2018 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        (void) _Right;
#line 2020 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }







#line 2029 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    using _Prevent_inheriting_unwrap = _String_const_iterator;

    [[nodiscard]] constexpr const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    constexpr void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
    }

    pointer _Ptr; 
};


template <class _Mystr>
struct pointer_traits<_String_const_iterator<_Mystr>> {
    using pointer         = _String_const_iterator<_Mystr>;
    using element_type    = const typename pointer::value_type; 
    using difference_type = pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {






#line 2058 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        const auto _Rawptr = ::std:: to_address(_Iter._Ptr);







#line 2068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _Rawptr;
    }
};
#line 2073 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

template <class _Mystr>
class _String_iterator : public _String_const_iterator<_Mystr> {
public:
    using _Mybase = _String_const_iterator<_Mystr>;


    using iterator_concept = contiguous_iterator_tag;
#line 2082 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Mystr::value_type;
    using difference_type   = typename _Mystr::difference_type;
    using pointer           = typename _Mystr::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    constexpr _String_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    constexpr _String_iterator operator++(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    constexpr _String_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    constexpr _String_iterator operator--(int) noexcept {
        _String_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    constexpr _String_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] constexpr _String_iterator operator+(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _String_iterator operator+(
        const difference_type _Off, _String_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _String_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] constexpr _String_iterator operator-(const difference_type _Off) const noexcept {
        _String_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _String_iterator;

    [[nodiscard]] constexpr value_type* _Unwrapped() const noexcept {
        return const_cast<value_type*>(_Unfancy(this->_Ptr));
    }
};


template <class _Mystr>
struct pointer_traits<_String_iterator<_Mystr>> {
    using pointer         = _String_iterator<_Mystr>;
    using element_type    = pointer::value_type;
    using difference_type = pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {






#line 2176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        const auto _Rawptr = ::std:: to_address(_Iter._Ptr);







#line 2186 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return const_cast<element_type*>(_Rawptr);
    }
};
#line 2191 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer>
struct _String_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

template <class _Val_types>
class _String_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    constexpr _String_val() noexcept : _Bx() {}

    
    static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
    
    static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
                                           : sizeof(value_type) <= 2 ? 7
                                           : sizeof(value_type) <= 4 ? 3
                                           : sizeof(value_type) <= 8 ? 1
                                                                     : 0;
    
    static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;

    [[nodiscard]] constexpr value_type* _Myptr() noexcept {
        value_type* _Result = _Bx._Buf;
        if (_Large_mode_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    [[nodiscard]] constexpr const value_type* _Myptr() const noexcept {
        const value_type* _Result = _Bx._Buf;
        if (_Large_mode_engaged()) {
            _Result = _Unfancy(_Bx._Ptr);
        }

        return _Result;
    }

    [[nodiscard]] constexpr bool _Large_mode_engaged() const noexcept {
        return _Myres > _Small_string_capacity;
    }

    constexpr void _Activate_SSO_buffer() noexcept {
        

        if (::std:: is_constant_evaluated()) {
            for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
                _Bx._Buf[_Idx] = value_type();
            }
        }
#line 2256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    constexpr void _Check_offset(const size_type _Off) const {
        
        if (_Mysize < _Off) {
            _Xran();
        }
    }

    constexpr void _Check_offset_exclusive(const size_type _Off) const {
        
        if (_Mysize <= _Off) {
            _Xran();
        }
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid string position");
    }

    [[nodiscard]] constexpr size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
        
        return (::std:: min)(_Size, _Mysize - _Off);
    }

    union _Bxty { 
        
        
        constexpr _Bxty() noexcept : _Buf() {} 
        constexpr ~_Bxty() noexcept {} 

        value_type _Buf[_BUF_SIZE];
        pointer _Ptr;
        char _Alias[_BUF_SIZE]; 
    };
    _Bxty _Bx;

    
    
    size_type _Mysize = 0; 
    size_type _Myres  = 0; 
};


template <class _Ty>
inline constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);

struct _String_constructor_concat_tag {
    
    explicit _String_constructor_concat_tag() = default;
};

struct _String_constructor_rvalue_allocator_tag {
    
    explicit _String_constructor_rvalue_allocator_tag() = default;
};

[[noreturn]] inline void _Xlen_string() {
    _Xlength_error("string too long");
}


template <class _Rng, class _Ty>
concept _Contiguous_range_of =
    (::std::ranges:: contiguous_range<_Rng>) &&same_as<remove_cvref_t<::std::ranges:: range_reference_t<_Rng>>, _Ty>;
#line 2322 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
class basic_string { 
private:
    friend _Tidy_deallocate_guard<basic_string>;
    friend basic_stringbuf<_Elem, _Traits, _Alloc>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
    using _Alty_traits = allocator_traits<_Alty>;

    using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer>>>;

    static_assert(!1 || is_same_v<_Elem, typename _Alloc::value_type>,
        "basic_string<T, Traits, Allocator>" " requires that Allocator's value_type match " "T" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");

    static_assert(is_same_v<_Elem, typename _Traits::char_type>,
        "N4950 [string.require]/3 requires that the supplied "
        "char_traits character type match the string's character type.");

    static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
        "The character type of basic_string must be a non-array trivial standard-layout type. See N4950 "
        "[strings.general]/1.");

public:
    using traits_type    = _Traits;
    using allocator_type = _Alloc;

    using value_type      = _Elem;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = _String_iterator<_Scary_val>;
    using const_iterator = _String_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

private:
    static constexpr size_type _BUF_SIZE              = _Scary_val::_BUF_SIZE;
    static constexpr size_type _Alloc_mask            = _Scary_val::_Alloc_mask;
    static constexpr size_type _Small_string_capacity = _Scary_val::_Small_string_capacity;

    
    static constexpr size_type _Least_allocation_size = _Small_string_capacity + 1 + 1;

    
    
    
    
    
    
    
    
    
    
    static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
    
    static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
    static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;

    template <class _Iter>
    
    
    using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;


    template <class _StringViewIsh>
    using _Is_string_view_ish =
        enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
                        negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
            int>;
#line 2400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


















































































#line 2483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

public:
    constexpr
    basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Tidy_init();
    }

    constexpr explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Tidy_init();
    }

    constexpr basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string(const basic_string& _Right, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, npos));
    }

    constexpr basic_string(
        const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Construct<_Construct_strategy::_From_ptr>(
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }


    constexpr basic_string(basic_string&& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Move_construct_from_substr(_Right, _Roff, npos);
    }

    constexpr basic_string(
        basic_string&& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Move_construct_from_substr(_Right, _Roff, _Count);
    }
#line 2533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string(  const _Elem* const _Ptr,  const size_type _Count)
        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

    constexpr basic_string(
          const _Elem* const _Ptr,  const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);
    }

    constexpr basic_string(  const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }


    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2552 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    constexpr basic_string(  const _Elem* const _Ptr, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }


    basic_string(nullptr_t) = delete;
#line 2560 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string( const size_type _Count, const _Elem _Ch)
        : _Mypair(_Zero_then_variadic_args_t{}) { 
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }


    template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
#line 2569 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    constexpr basic_string( const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        _Construct<_Construct_strategy::_From_char>(_Ch, _Count);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast  = _Get_unwrapped(_Last);
        if (_UFirst == _ULast) {
            _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
            _Tidy_init();
        } else {
            if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
                _Construct<_Construct_strategy::_From_ptr>(
                    _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            } else if constexpr (_Is_cpp17_fwd_iter_v<decltype(_UFirst)>) {
                const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
                const auto _Count  = _Convert_size<size_type>(_Length);
                _Construct_from_iter(::std:: move(_UFirst), ::std:: move(_ULast), _Count);
            } else {
                _Construct_from_iter(::std:: move(_UFirst), ::std:: move(_ULast));
            }
        }
    }

private:
    enum class _Allocation_policy { _At_least, _Exactly };

    template <_Allocation_policy _Policy = _Allocation_policy::_At_least>
    [[nodiscard]] static constexpr pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {
        ;
        ++_Capacity; 

        pointer _Fancy_ptr;
        if constexpr (_Policy == _Allocation_policy::_At_least) {
            _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);
        } else {
            ;
            _Fancy_ptr = _Al.allocate(_Capacity);
        }


        
        
        if (::std:: is_constant_evaluated()) {
            _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
            for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
                ::std:: construct_at(_Ptr + _Idx);
            }
        }
#line 2623 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        --_Capacity;
        return _Fancy_ptr;
    }

    static constexpr void _Deallocate_for_capacity(
        _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {
        ;
        _Al.deallocate(_Old_ptr, _Capacity + 1); 
    }

    enum class _Construct_strategy : uint8_t { _From_char, _From_ptr, _From_string };

    template <_Construct_strategy _Strat, class _Char_or_ptr>
    constexpr void _Construct(const _Char_or_ptr _Arg,  const size_type _Count) {
        auto& _My_data = _Mypair._Myval2;
        ;

        if constexpr (_Strat == _Construct_strategy::_From_char) {
            ;
        } else {
            ;
        }

        if (_Count > max_size()) {
            _Xlen_string(); 
        }

        auto& _Al       = _Getal();
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if (_Count <= _Small_string_capacity) {
            _My_data._Mysize = _Count;
            _My_data._Myres  = _Small_string_capacity;

            if constexpr (_Strat == _Construct_strategy::_From_char) {
                _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
                _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
                _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
            } else { 



                _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
#line 2670 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
            }

            _Proxy._Release();
            return;
        }

        _My_data._Myres         = _Small_string_capacity;
        size_type _New_capacity = _Calculate_growth(_Count);
        const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); 
        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

        _My_data._Mysize = _Count;
        _My_data._Myres  = _New_capacity;
        if constexpr (_Strat == _Construct_strategy::_From_char) {
            _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
            _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
        } else { 
            _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
        }

        ;
        _Proxy._Release();
    }

    template <class _Iter, class _Sent, class _Size = nullptr_t>
    constexpr void _Construct_from_iter(_Iter _First, const _Sent _Last, _Size _Count = {}) {
        
        
        
        

        auto& _My_data  = _Mypair._Myval2;
        auto& _Al       = _Getal();
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        _My_data._Mysize = 0;
        _My_data._Myres  = _Small_string_capacity;

        if constexpr (is_same_v<_Size, size_type>) {
            if (_Count > max_size()) {
                _Xlen_string(); 
            }

            if (_Count > _Small_string_capacity) {
                size_type _New_capacity = _Calculate_growth(_Count);
                const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); 
                _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                _My_data._Myres = _New_capacity;
            }
        }

        _Tidy_deallocate_guard<basic_string> _Guard{this};
        for (; _First != _Last; ++_First) {
            if constexpr (!is_same_v<_Size, size_type>) {
                if (_My_data._Mysize == _My_data._Myres) { 
                    if (_My_data._Mysize == max_size()) {
                        _Xlen_string(); 
                    }

                    _Elem* const _Old_ptr   = _My_data._Myptr();
                    size_type _New_capacity = _Calculate_growth(_My_data._Mysize);
                    const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); 

                    _Traits::copy(_Unfancy(_New_ptr), _Old_ptr, _My_data._Mysize);
                    if (_My_data._Large_mode_engaged()) { 
                        _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
                        _My_data._Bx._Ptr = _New_ptr;
                    } else {
                        _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
                    }
                    _My_data._Myres = _New_capacity;
                }
            }

            _Elem* const _Ptr = _My_data._Myptr();
            _Traits::assign(_Ptr[_My_data._Mysize], *_First);
            ++_My_data._Mysize;
        }

        _Elem* const _Ptr = _My_data._Myptr();
        _Traits::assign(_Ptr[_My_data._Mysize], _Elem());
        ;
        _Guard._Target = nullptr;
        _Proxy._Release();
    }

public:

    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string(from_range_t, _Rng&& _Range, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (::std::ranges:: sized_range<_Rng> || ::std::ranges:: forward_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            if constexpr (_Contiguous_range_of<_Rng, _Elem>) {
                _Construct<_Construct_strategy::_From_ptr>(::std::ranges:: data(_Range), _Count);
            } else {
                _Construct_from_iter(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range), _Count);
            }
        } else {
            _Construct_from_iter(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
    }
#line 2778 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Take_contents(_Right);
    }

    constexpr basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                _Construct<_Construct_strategy::_From_string>(
                    _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return;
            }
        }

        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Take_contents(_Right);
    }

    constexpr basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al,
        const _Elem* const _Left_ptr, const size_type _Left_size, const _Elem* const _Right_ptr,
        const size_type _Right_size)
        : _Mypair(
            _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {
        ;
        ;
        ;
        const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);
        size_type _New_capacity = _Small_string_capacity;
        auto& _My_data          = _Mypair._Myval2;
        _Elem* _Ptr             = _My_data._Bx._Buf;
        auto&& _Alproxy         = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 

        if (_New_capacity < _New_size) {
            _New_capacity           = _Calculate_growth(_New_size, _Small_string_capacity, max_size());
            const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); 
            _Ptr                    = _Unfancy(_Fancyptr);
            _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        }

        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        _Traits::copy(_Ptr, _Left_ptr, _Left_size);
        _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);
        _Traits::assign(_Ptr[_New_size], _Elem());
        ;
        _Proxy._Release();
    }

    constexpr basic_string(_String_constructor_concat_tag, basic_string& _Left, basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Left._Getal()) {
        auto& _My_data    = _Mypair._Myval2;
        auto& _Left_data  = _Left._Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Left_data._Orphan_all();
        _Right_data._Orphan_all();
        const auto _Left_size  = _Left_data._Mysize;
        const auto _Right_size = _Right_data._Mysize;

        const auto _Left_capacity  = _Left_data._Myres;
        const auto _Right_capacity = _Right_data._Myres;
        
        const auto _New_size     = static_cast<size_type>(_Left_size + _Right_size);
        const bool _Fits_in_left = _Right_size <= _Left_capacity - _Left_size;
        if (_Fits_in_left && _Right_capacity <= _Left_capacity) {
            
            _My_data._Alloc_proxy(_Fake_alloc); 
            _Take_contents(_Left);
            const auto _Ptr = _My_data._Myptr();
            ;
            _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
            _My_data._Mysize = _New_size;
            return;
        }

        const bool _Fits_in_right = _Left_size <= _Right_capacity - _Right_size;
        if (_Allocators_equal(_Getal(), _Right._Getal()) && _Fits_in_right) {
            
            
            
            
            
            
            
            
            
            ;
            _My_data._Alloc_proxy(_Fake_alloc); 
            _Take_contents(_Right);
            const auto _Ptr = _Unfancy(_My_data._Bx._Ptr);
            ;
            _Traits::move(_Ptr + _Left_size, _Ptr, _Right_size + 1);
            _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
            _My_data._Mysize = _New_size;
            return;
        }

        
        const auto _Max = max_size();
        if (_Max - _Left_size < _Right_size) { 
            _Xlen_string();
        }

        size_type _New_capacity = _Calculate_growth(_New_size, _Small_string_capacity, _Max);
        auto&& _Alproxy         = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); 
        const pointer _Fancyptr = _Allocate_for_capacity(_Getal(), _New_capacity); 
        
        _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);
        _My_data._Mysize = _New_size;
        _My_data._Myres  = _New_capacity;
        const auto _Ptr  = _Unfancy(_Fancyptr);
        _Traits::copy(_Ptr, _Left_data._Myptr(), _Left_size);
        _Traits::copy(_Ptr + _Left_size, _Right_data._Myptr(), _Right_size + 1);
        ;
        _Proxy._Release();
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr explicit basic_string(const _StringViewIsh& _Right, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _Ty, enable_if_t<is_convertible_v<const _Ty&, basic_string_view<_Elem, _Traits>>, int> = 0>
    constexpr basic_string(
        const _Ty& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) { 
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        const auto _As_sub_view                          = _As_view.substr(_Roff, _Count);
        _Construct<_Construct_strategy::_From_ptr>(_As_sub_view.data(), _Convert_size<size_type>(_As_sub_view.size()));
    }
#line 2917 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


    basic_string(_String_constructor_rvalue_allocator_tag, _Alloc&& _Al)
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Al)) {
        
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Tidy_init();
    }

    [[nodiscard]] bool _Move_assign_from_buffer(
        _Elem* const _Right, const size_type _Size, const size_type _Actual_allocation_size) {
        
        auto& _My_data = _Mypair._Myval2;
        ;
        ; 
        _Traits::assign(_Right[_Size], _Elem());

        const bool _Is_large = _Actual_allocation_size >= _Least_allocation_size;
        if (_Is_large) {
            ;
            _Construct_in_place(_My_data._Bx._Ptr, _Refancy<pointer>(_Right));
            _My_data._Mysize = _Size;
            _My_data._Myres  = _Actual_allocation_size - 1;
            ;
        } else {
            _Traits::copy(_My_data._Bx._Buf, _Right, _Actual_allocation_size);
            _My_data._Mysize = _Size;
            _My_data._Myres  = _Small_string_capacity;
        }

        return _Is_large;
    }

    
    struct _Released_buffer {
        pointer _Ptr;
        size_type _Size;
        size_type _Actual_allocation_size;
    };

    [[nodiscard]] _Released_buffer _Release_to_buffer(_Alloc& _Al) {
        
        _Released_buffer _Result;
        auto& _My_data = _Mypair._Myval2;
        _Result._Size  = _My_data._Mysize;
        ;
        if (_My_data._Large_mode_engaged()) {
            _Result._Ptr                    = _My_data._Bx._Ptr;
            _Result._Actual_allocation_size = _My_data._Myres + 1;
        } else {
            
            size_type _Allocated = _Least_allocation_size;
            _Result._Ptr         = _Allocate_at_least_helper(_Al, _Allocated);
            _Traits::copy(_Unfancy(_Result._Ptr), _My_data._Bx._Buf, _BUF_SIZE);
            _Result._Actual_allocation_size = _Allocated;
        }
        _My_data._Orphan_all();
        _Tidy_init();
        return _Result;
    }
#line 2978 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& operator=(basic_string&& _Right) noexcept(
        _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al                 = _Getal();
        auto& _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                
                _Mypair._Myval2._Orphan_all();
                _Mypair._Myval2._Reload_proxy(_Fake_alloc, _Fake_alloc);
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                return *this;
            }
        }

        _Tidy_deallocate();
        _Pocma(_Al, _Right_al);
        _Take_contents(_Right);
        return *this;
    }

    constexpr basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std:: move(_Right))) {
        *this = ::std:: move(_Right);
        return *this;
    }

private:
    void _Memcpy_val_from(const basic_string& _Right) noexcept {
        ;
        const auto _My_data_mem =
            reinterpret_cast<unsigned char*>(::std:: addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
        const auto _Right_data_mem =
            reinterpret_cast<const unsigned char*>(::std:: addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
        :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
    }

    constexpr void _Take_contents(basic_string& _Right) noexcept {
        
        
        
        
        
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;


        if constexpr (_Can_memcpy_val) {

            if (!::std:: is_constant_evaluated())
#line 3036 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
            {







#line 3045 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

                _Memcpy_val_from(_Right);
                _Right._Tidy_init();
                return;
            }
        }
#line 3052 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        if (_Right_data._Large_mode_engaged()) { 
            _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
            _Right_data._Bx._Ptr = nullptr;
            _Swap_proxy_and_iterators(_Right);
        } else { 
            _My_data._Activate_SSO_buffer();
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Right_data._Orphan_all();
        }

        _My_data._Myres  = _Right_data._Myres;
        _My_data._Mysize = _Right_data._Mysize;

        _Right._Tidy_init();
    }


    constexpr void _Move_construct_from_substr(basic_string& _Right, const size_type _Roff, const size_type _Size_max) {
        auto& _Right_data = _Right._Mypair._Myval2;
        _Right_data._Check_offset(_Roff);

        const auto _Result_size = _Right_data._Clamp_suffix_size(_Roff, _Size_max);
        const auto _Right_ptr   = _Right_data._Myptr();
        auto& _Al               = _Getal();
        if (_Allocators_equal(_Al, _Right._Getal()) && _Result_size > _Small_string_capacity) {
            if (_Roff != 0) {
                _Traits::move(_Right_ptr, _Right_ptr + _Roff, _Result_size);
            }
            _Right._Eos(_Result_size);

            _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
            _Take_contents(_Right);
        } else {
            _Construct<_Construct_strategy::_From_ptr>(_Right_ptr + _Roff, _Result_size);
        }
    }
#line 3090 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

public:
    constexpr basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&& _Alproxy = _Fake_alloc;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
        _Tidy_init();
        assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        _Proxy._Release();
    }

    constexpr basic_string& operator=(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& operator+=(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& assign(initializer_list<_Elem> _Ilist) {
        return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr basic_string& append(initializer_list<_Elem> _Ilist) {
        return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist) {


#line 3121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist) {
        
        _Adl_verify_range(_First, _Last);


#line 3133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
    }

    constexpr ~basic_string() noexcept {
        _Tidy_deallocate();





#line 3146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    }

    static constexpr auto npos{static_cast<size_type>(-1)};

    constexpr basic_string& operator=(const basic_string& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al             = _Getal();
        const auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                auto&& _Alproxy       = _Fake_alloc;
                auto&& _Right_alproxy = _Fake_alloc;
                _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); 

                const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
                const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
                if (_Right_size > _Small_string_capacity) {
                    size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
                    auto _Right_al_non_const = _Right_al;
                    const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); 

                    _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
                    _Tidy_deallocate();
                    _Mypair._Myval2._Bx._Ptr = _New_ptr;
                    _Mypair._Myval2._Mysize  = _Right_size;
                    _Mypair._Myval2._Myres   = _New_capacity;
                } else {
                    _Tidy_deallocate();
                    _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
                    _Mypair._Myval2._Mysize = _Right_size;
                    _Mypair._Myval2._Myres  = _Small_string_capacity;
                }

                _Pocca(_Al, _Right_al);
                _New_proxy._Bind(_Alproxy, ::std:: addressof(_Mypair._Myval2));
                return *this;
            }
        }

        _Pocca(_Al, _Right_al);
        assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        return *this;
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& operator=(const _StringViewIsh& _Right) {
        return assign(_Right);
    }
#line 3199 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& operator=(  const _Elem* const _Ptr) {
        return assign(_Ptr);
    }


    basic_string& operator=(nullptr_t) = delete;
#line 3207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& operator=(const _Elem _Ch) { 
        ;
        _Mypair._Myval2._Mysize = 1;
        _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
        _Traits::assign(_Ptr[0], _Ch);
        _Traits::assign(_Ptr[1], _Elem());
        return *this;
    }

    constexpr basic_string& operator+=(const basic_string& _Right) {
        return append(_Right);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& operator+=(const _StringViewIsh& _Right) {
        return append(_Right);
    }
#line 3227 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& operator+=(  const _Elem* const _Ptr) { 
        return append(_Ptr);
    }

    constexpr basic_string& operator+=(_Elem _Ch) {
        push_back(_Ch);
        return *this;
    }

    constexpr basic_string& append(const basic_string& _Right) {
        return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& append(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& append(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return append(_As_view.substr(_Roff, _Count));
    }
#line 3263 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& append(
          const _Elem* const _Ptr,  const size_type _Count) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
                const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
    }

    constexpr basic_string& append(  const _Elem* const _Ptr) { 
        return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& append( const size_type _Count, const _Elem _Ch) {
        
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
                const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& append(const _Iter _First, const _Iter _Last) {
        
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }


    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& append_range(_Rng&& _Range) {
        if constexpr (::std::ranges:: sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(::std::ranges:: size(_Range)));
            return append(::std::ranges:: data(_Range), _Count);
        } else {
            const basic_string _Right(from_range, _Range, get_allocator());
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
#line 3341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& assign(const basic_string& _Right) {
        *this = _Right;
        return *this;
    }

    constexpr basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& assign(const _StringViewIsh& _Right) {
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& assign(
        const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return assign(_As_view.substr(_Roff, _Count));
    }
#line 3369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& assign(
          const _Elem* const _Ptr,  const size_type _Count) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            ;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::move(_Old_ptr, _Ptr, _Count);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            ;
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
    }

    constexpr basic_string& assign(  const _Elem* const _Ptr) {
        return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& assign( const size_type _Count, const _Elem _Ch) {
        
        if (_Count <= _Mypair._Myval2._Myres) {
            ;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Mypair._Myval2._Mysize = _Count;
            _Traits::assign(_Old_ptr, _Count, _Ch);
            _Traits::assign(_Old_ptr[_Count], _Elem());
            return *this;
        }

        return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& assign(const _Iter _First, const _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            basic_string _Right(_UFirst, _ULast, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }


    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& assign_range(_Rng&& _Range) {
        if constexpr (::std::ranges:: sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(::std::ranges:: size(_Range)));
            return assign(::std::ranges:: data(_Range), _Count);
        } else {
            basic_string _Right(from_range, _Range, get_allocator());
            if (_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres) {
                _Mypair._Myval2._Orphan_all();
                _Swap_data(_Right);
                return *this;
            } else {
                return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }
    }
#line 3453 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& insert(const size_type _Off, const basic_string& _Right) {
        
        return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& insert(
        const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& insert(const size_type _Off, const _StringViewIsh& _Right) {
        
        const basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& insert(
        const size_type _Off, const _StringViewIsh& _Right, const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return insert(_Off, _As_view.substr(_Roff, _Count));
    }
#line 3483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& insert(
        const size_type _Off,   const _Elem* const _Ptr,  const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;

        
        

        const bool _Check_overlap = _Count <= _Mypair._Myval2._Myres - _Old_size && !::std:: is_constant_evaluated();


#line 3497 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        if (_Check_overlap) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            
            
            size_type _Ptr_shifted_after;
            if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                
                _Ptr_shifted_after = _Count; 
            } else if (_Insert_at <= _Ptr) { 
                _Ptr_shifted_after = 0;
            } else { 
                _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
            }

            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
            _Traits::copy(
                _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
    }

    constexpr basic_string& insert(const size_type _Off,   const _Elem* const _Ptr) {
        
        return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& insert(
        const size_type _Off,  const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count <= _Mypair._Myval2._Myres - _Old_size) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + _Count;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); 
            _Traits::assign(_Insert_at, _Count, _Ch); 
            return *this;
        }

        return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
    }

    constexpr iterator insert(const const_iterator _Where, const _Elem _Ch) { 


#line 3568 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, 1, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr iterator insert(
        const const_iterator _Where,  const size_type _Count, const _Elem _Ch) {
        


#line 3579 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        insert(_Off, _Count, _Ch);
        return begin() + static_cast<difference_type>(_Off);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last) {
        


#line 3590 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_elem_cptr<decltype(_UFirst)>::value) {
            insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
        } else {
            const basic_string _Right(_UFirst, _ULast, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }


    template <_Container_compatible_range<_Elem> _Rng>
    constexpr iterator insert_range(const const_iterator _Where, _Rng&& _Range) {


#line 3610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());

        if constexpr (::std::ranges:: sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(::std::ranges:: size(_Range)));
            insert(_Off, ::std::ranges:: data(_Range), _Count);
        } else {
            const basic_string _Right(from_range, _Range, get_allocator());
            insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        return begin() + static_cast<difference_type>(_Off);
    }
#line 3623 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& erase(const size_type _Off = 0) { 
        _Mypair._Myval2._Check_offset(_Off);
        _Eos(_Off);
        return *this;
    }

private:
    constexpr basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {
        _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();
        _Elem* const _Erase_at    = _My_ptr + _Off;
        const size_type _New_size = _Old_size - _Count;
        _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); 
        ;
        _Mypair._Myval2._Mysize = _New_size;
        return *this;
    }

public:
    constexpr basic_string& erase(const size_type _Off, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Erase_noexcept(_Off, _Count);
    }

    constexpr iterator erase(const const_iterator _Where) noexcept  {


#line 3654 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, 1);
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
     {
        _Adl_verify_range(_First, _Last);


#line 3665 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        _Erase_noexcept(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
        return begin() + static_cast<difference_type>(_Off);
    }

    constexpr void clear() noexcept { 
        _Eos(0);
    }

    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const basic_string& _Right) {
        
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr basic_string& replace(const size_type _Off, size_type _Nx, const basic_string& _Right,
        const size_type _Roff, size_type _Count = npos) {
        
        _Right._Mypair._Myval2._Check_offset(_Roff);
        _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
        return replace(_Off, _Nx, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.data(), _Convert_size<size_type>(_As_view.size()));
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return replace(_Off, _Nx, _As_view.substr(_Roff, _Count));
    }
#line 3703 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& replace(
        const size_type _Off, size_type _Nx,   const _Elem* const _Ptr, const size_type _Count) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Nx == _Count) { 
            _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
            return *this;
        }

        const size_type _Old_size    = _Mypair._Myval2._Mysize;
        const size_type _Suffix_size = _Old_size - _Nx - _Off + 1;
        if (_Count < _Nx) { 
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at, _Ptr, _Count);
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Suffix_size);

            const auto _New_size = _Old_size - (_Nx - _Count);
            ;
            _Mypair._Myval2._Mysize = _New_size;
            return *this;
        }

        const size_type _Growth = static_cast<size_type>(_Count - _Nx);

        
        

        if (!::std:: is_constant_evaluated())
#line 3735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        {
            if (_Growth <= _Mypair._Myval2._Myres - _Old_size) { 
                ;
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _Nx;

                size_type _Ptr_shifted_after; 
                if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size) {
                    _Ptr_shifted_after = _Count;
                } else if (_Suffix_at <= _Ptr) {
                    _Ptr_shifted_after = 0;
                } else {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);
                
                
                
                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);
                
                
                _Traits::copy(
                    _Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }
        }

        return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Ptr, _Count);
    }

    constexpr basic_string& replace(const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) {
        
        return replace(_Off, _Nx, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
    }

    constexpr basic_string& replace(const size_type _Off, size_type _Nx, const size_type _Count, const _Elem _Ch) {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Nx = _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx);
        if (_Count == _Nx) {
            _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
            return *this;
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Count < _Nx || _Count - _Nx <= _Mypair._Myval2._Myres - _Old_size) {
            
            
            const auto _New_size = _Old_size + _Count - _Nx;
            ;
            _Mypair._Myval2._Mysize = _New_size;
            _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
            _Elem* const _Insert_at = _Old_ptr + _Off;
            _Traits::move(_Insert_at + _Count, _Insert_at + _Nx, _Old_size - _Nx - _Off + 1);
            _Traits::assign(_Insert_at, _Count, _Ch);
            ;
            return *this;
        }

        return _Reallocate_grow_by(
            _Count - _Nx,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
                const size_type _Nx, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _Nx, _Old_size - _Nx - _Off + 1);
            },
            _Off, _Nx, _Count, _Ch);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const basic_string& _Right) {
        
        _Adl_verify_range(_First, _Last);


#line 3823 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _StringViewIsh& _Right) {
        
        _Adl_verify_range(_First, _Last);


#line 3836 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
    }
#line 3840 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr basic_string& replace(const const_iterator _First, const const_iterator _Last,
          const _Elem* const _Ptr, const size_type _Count) {
        
        _Adl_verify_range(_First, _Last);


#line 3848 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last,   const _Elem* const _Ptr) {
        
        _Adl_verify_range(_First, _Last);


#line 3859 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
    }

    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch) {
        
        _Adl_verify_range(_First, _Last);


#line 3870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
            static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr basic_string& replace(
        const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2) {
        
        _Adl_verify_range(_First, _Last);


#line 3882 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2  = _Get_unwrapped(_Last2);
        if constexpr (_Is_elem_cptr<decltype(_UFirst2)>::value) {
            return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
        } else {
            const basic_string _Right(_UFirst2, _ULast2, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }


    template <_Container_compatible_range<_Elem> _Rng>
    constexpr basic_string& replace_with_range(const const_iterator _First, const const_iterator _Last, _Rng&& _Range) {
        _Adl_verify_range(_First, _Last);


#line 3902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        const auto _Off    = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
        const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);

        if constexpr (::std::ranges:: sized_range<_Rng> && _Contiguous_range_of<_Rng, _Elem>) {
            const auto _Count = _Convert_size<size_type>(_To_unsigned_like(::std::ranges:: size(_Range)));
            return replace(_Off, _Length, ::std::ranges:: data(_Range), _Count);
        } else {
            const basic_string _Right(from_range, _Range, get_allocator());
            return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }
    }
#line 3914 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr iterator begin() noexcept {
        return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr const_iterator begin() const noexcept {
        return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr iterator end() noexcept {
        return iterator(
            _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {
        return const_iterator(
            _Refancy<const_pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
            ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr _Elem* _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr const _Elem* _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr _Elem* _Unchecked_end() noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr const _Elem* _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] constexpr reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    constexpr void shrink_to_fit() { 
        auto& _My_data = _Mypair._Myval2;

        if (!_My_data._Large_mode_engaged()) { 
            return;
        }

        if (_My_data._Mysize <= _Small_string_capacity) {
            _Become_small();
            return;
        }

        size_type _Target_capacity = (::std:: min)(_My_data._Mysize | _Alloc_mask, max_size());
        if (_Target_capacity < _My_data._Myres) { 
            auto& _Al = _Getal();
            const pointer _New_ptr =
                _Allocate_for_capacity<_Allocation_policy::_Exactly>(_Al, _Target_capacity); 
            ;

            _My_data._Orphan_all();
            _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
            _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);
            _My_data._Bx._Ptr = _New_ptr;
            _My_data._Myres   = _Target_capacity;
            ;
        }
    }

    [[nodiscard]] constexpr reference at(const size_type _Off) {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr const_reference at(const size_type _Off) const {
        _Mypair._Myval2._Check_offset_exclusive(_Off);
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr reference operator[](const size_type _Off) noexcept  {


#line 4025 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }

    [[nodiscard]] constexpr const_reference operator[](const size_type _Off) const noexcept
     {


#line 4033 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        return _Mypair._Myval2._Myptr()[_Off];
    }


     constexpr operator basic_string_view<_Elem, _Traits>() const noexcept {
        
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};
    }
#line 4042 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr void push_back(const _Elem _Ch) { 
        const size_type _Old_size = _Mypair._Myval2._Mysize;
        if (_Old_size < _Mypair._Myval2._Myres) {
            ;
            _Mypair._Myval2._Mysize = _Old_size + 1;
            _Elem* const _Ptr       = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[_Old_size], _Ch);
            _Traits::assign(_Ptr[_Old_size + 1], _Elem());
            return;
        }

        _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
    }

    constexpr void pop_back() noexcept  {
        const size_type _Old_size = _Mypair._Myval2._Mysize;


#line 4069 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Eos(_Old_size - 1);
    }

    [[nodiscard]] constexpr reference front() noexcept  {


#line 4076 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] constexpr const_reference front() const noexcept  {


#line 4084 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _Mypair._Myval2._Myptr()[0];
    }

    [[nodiscard]] constexpr reference back() noexcept  {


#line 4092 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] constexpr const_reference back() const noexcept  {


#line 4100 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
    }

    [[nodiscard]] constexpr   const _Elem* c_str() const noexcept {
        return _Mypair._Myval2._Myptr();
    }

    [[nodiscard]] constexpr   const _Elem* data() const noexcept {
        return _Mypair._Myval2._Myptr();
    }


    [[nodiscard]] constexpr   _Elem* data() noexcept {
        return _Mypair._Myval2._Myptr();
    }
#line 4117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type length() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        return _Mypair._Myval2._Mysize;
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
        const size_type _Storage_max = 
            (::std:: max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
        return (::std:: min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),
            _Storage_max - 1 
        );
    }

    constexpr void resize( const size_type _New_size, const _Elem _Ch = _Elem()) {
        
        const size_type _Old_size = size();
        if (_New_size <= _Old_size) {
            _Eos(_New_size);
        } else {
            append(_New_size - _Old_size, _Ch);
        }
    }

    template <class _Operation>
    constexpr void

        resize_and_overwrite


#line 4152 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        ( const size_type _New_size, _Operation _Op) {
        if (_Mypair._Myval2._Myres < _New_size) {
            _Reallocate_grow_by(_New_size - _Mypair._Myval2._Mysize,
                [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                    _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                });
        } else {
            ;
            _Mypair._Myval2._Mysize = _New_size;
        }

        auto _Arg_ptr                   = _Mypair._Myval2._Myptr();
        auto _Arg_size                  = _New_size;
        const auto _Result_size         = ::std:: move(_Op)(_Arg_ptr, _Arg_size);
        const auto _Result_as_size_type = static_cast<size_type>(_Result_size);



#line 4171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
        _Eos(_Result_as_size_type);
    }


    template <class _Operation>
    constexpr void _Resize_and_overwrite( const size_type _New_size, _Operation _Op) {
        resize_and_overwrite(_New_size, _Op);
    }
#line 4180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type capacity() const noexcept {
        return _Mypair._Myval2._Myres;
    }


    constexpr void reserve( const size_type _Newcap) {
        
        if (_Mypair._Myval2._Myres >= _Newcap) { 
            return; 
        }

        const size_type _Old_size = _Mypair._Myval2._Mysize;
        _Reallocate_grow_by(
            _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
            });

        _Mypair._Myval2._Mysize = _Old_size;
    }

    [[deprecated("warning STL4024: " "std::string::reserve() without an argument is deprecated in C++20. " "To shrink the string's capacity, use std::string::shrink_to_fit() instead. Otherwise, provide an " "argument to std::string::reserve(). " "You can define _SILENCE_CXX20_STRING_RESERVE_WITHOUT_ARGUMENT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void reserve() {
        if (_Mypair._Myval2._Mysize == 0 && _Mypair._Myval2._Large_mode_engaged()) {
            _Become_small();
        }
    }





























#line 4236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] constexpr bool empty() const noexcept {
        return _Mypair._Myval2._Mysize == 0;
    }

    constexpr size_type copy(
          _Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    constexpr   size_type
        _Copy_s(  _Elem* const _Dest, const size_type _Dest_size, size_type _Count,
            const size_type _Off = 0) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
        _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
        return _Count;
    }

    static constexpr void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small) noexcept {
        
        const pointer _Ptr = _Starts_large._Bx._Ptr;
        _Destroy_in_place(_Starts_large._Bx._Ptr);

        _Starts_large._Activate_SSO_buffer();
        _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);

        _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
    }

    constexpr void _Swap_data(basic_string& _Right) noexcept {
        using ::std:: swap;

        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        const bool _My_large    = _My_data._Large_mode_engaged();
        const bool _Right_large = _Right_data._Large_mode_engaged();


        if constexpr (_Can_memcpy_val) {

            if (!::std:: is_constant_evaluated())
#line 4285 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
            {
                const auto _My_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_My_data)) + _Memcpy_val_offset;
                const auto _Right_data_mem =
                    reinterpret_cast<unsigned char*>(::std:: addressof(_Right_data)) + _Memcpy_val_offset;
                unsigned char _Temp_mem[_Memcpy_val_size];
                :: memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
                :: memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
                :: memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

                return;
            }
        }
#line 4299 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

        if (_My_large && _Right_large) { 
            swap(_My_data._Bx._Ptr, _Right_data._Bx._Ptr); 
        } else if (_My_large) { 
            _Swap_bx_large_with_small(_My_data, _Right_data);
        } else if (_Right_large) { 
            _Swap_bx_large_with_small(_Right_data, _My_data);
        } else {
            _Elem _Temp_buf[_BUF_SIZE];
            _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _My_data._Mysize + 1);
            _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
            _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _My_data._Mysize + 1);
        }

        ::std:: swap(_My_data._Mysize, _Right_data._Mysize);
        ::std:: swap(_My_data._Myres, _Right_data._Myres);
    }

    constexpr void swap(basic_string& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());














#line 4335 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

            _Swap_data(_Right);
        }
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find(  const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(_Traits_find<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type rfind(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4387 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type rfind(  const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
     {
        
        return static_cast<size_type>(_Traits_rfind<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_first_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find_first_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_first_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_first_of(
          const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_last_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4463 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_last_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_last_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_first_not_of(const _StringViewIsh& _Right, const size_type _Off = 0) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4500 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find_first_not_of(
        const basic_string& _Right, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(  const _Elem* const _Ptr,
        const size_type _Off, const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(
          const _Elem* const _Ptr, size_type _Off = 0) const noexcept
     {
        
        return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept {
        
        return static_cast<size_type>(
            _Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr size_type find_last_not_of(const _StringViewIsh& _Right, const size_type _Off = npos) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _As_view.data(), _As_view.size()));
    }
#line 4539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr size_type find_last_not_of(
        const basic_string& _Right, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(),
            _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(  const _Elem* const _Ptr, const size_type _Off,
        const size_type _Count) const noexcept  {
        
        return static_cast<size_type>(
            _Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(
          const _Elem* const _Ptr, const size_type _Off = npos) const noexcept  {
        
        return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
    }

    [[nodiscard]] constexpr size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept {
        
        return static_cast<size_type>(
            _Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
    }


    [[nodiscard]] bool _Starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        
        return basic_string_view<_Elem, _Traits>(*this)._Starts_with(_Right);
    }
#line 4573 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr basic_string substr(const size_type _Off = 0, const size_type _Count = npos)

        const&


#line 4580 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    {
        
        return basic_string{*this, _Off, _Count};
    }


    [[nodiscard]] constexpr basic_string substr(const size_type _Off = 0, const size_type _Count = npos) && {
        
        return basic_string{::std:: move(*this), _Off, _Count};
    }
#line 4591 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    constexpr bool _Equal(const basic_string& _Right) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    constexpr bool _Equal(  const _Elem* const _Ptr) const noexcept {
        
        return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }


    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const _StringViewIsh& _Right) const
        noexcept(_Is_nothrow_convertible_v<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>) {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right) const {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _As_view.data(), _As_view.size());
    }

    template <class _StringViewIsh, _Is_string_view_ish<_StringViewIsh> = 0>
    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const _StringViewIsh& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        basic_string_view<_Elem, _Traits> _As_view = _Right;
        _Mypair._Myval2._Check_offset(_Off);
        const auto _With_substr = _As_view.substr(_Roff, _Count);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _With_substr.data(), _With_substr.size());
    }
#line 4633 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr int compare(const basic_string& _Right) const noexcept {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] constexpr int compare(size_type _Off, size_type _Nx, const basic_string& _Right) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx, const basic_string& _Right,
        const size_type _Roff, const size_type _Count = npos) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        _Right._Mypair._Myval2._Check_offset(_Roff);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
    }

    [[nodiscard]] constexpr int compare(  const _Elem* const _Ptr) const noexcept  {
        
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr int compare(
        const size_type _Off, const size_type _Nx,   const _Elem* const _Ptr) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx),
            _Ptr, _Traits::length(_Ptr));
    }

    [[nodiscard]] constexpr int compare(const size_type _Off, const size_type _Nx,
          const _Elem* const _Ptr, const size_type _Count) const {
        
        _Mypair._Myval2._Check_offset(_Off);
        return _Traits_compare<_Traits>(
            _Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _Nx), _Ptr, _Count);
    }


    [[nodiscard]] constexpr bool starts_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool starts_with(const _Elem* const _Right) const noexcept  {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.starts_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }

    [[nodiscard]] constexpr bool ends_with(const _Elem* const _Right) const noexcept  {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.ends_with(_Right);
    }
#line 4702 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


    [[nodiscard]] constexpr bool contains(const basic_string_view<_Elem, _Traits> _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }

    [[nodiscard]] constexpr bool contains(const _Elem _Right) const noexcept {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }

    [[nodiscard]] constexpr bool contains(const _Elem* const _Right) const noexcept  {
        return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize}.contains(_Right);
    }
#line 4716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    [[nodiscard]] static constexpr size_type _Calculate_growth(
        const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {
        const size_type _Masked = _Requested | _Alloc_mask;
        if (_Masked > _Max) { 
            return _Max;
        }

        if (_Old > _Max - _Old / 2) { 
            return _Max;
        }

        return (::std:: max)(_Masked, _Old + _Old / 2);
    }

    [[nodiscard]] constexpr size_type _Calculate_growth(const size_type _Requested) const noexcept {
        return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
    }

    template <class _Fty, class... _ArgTys>
    constexpr basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {
        
        
        if (_New_size > max_size()) {
            _Xlen_string(); 
        }

        const size_type _Old_capacity = _Mypair._Myval2._Myres;
        size_type _New_capacity       = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); 

        _Mypair._Myval2._Orphan_all();
        ;
        _Mypair._Myval2._Mysize = _New_size;
        _Mypair._Myval2._Myres  = _New_capacity;
        _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
        if (_Old_capacity > _Small_string_capacity) {
            _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);
            _Mypair._Myval2._Bx._Ptr = _New_ptr;
        } else {
            _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
        }

        ;
        return *this;
    }

    template <class _Fty, class... _ArgTys>
    constexpr basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {
        
        
        auto& _My_data            = _Mypair._Myval2;
        const size_type _Old_size = _My_data._Mysize;
        if (max_size() - _Old_size < _Size_increase) {
            _Xlen_string(); 
        }

        const size_type _New_size     = _Old_size + _Size_increase;
        const size_type _Old_capacity = _My_data._Myres;
        size_type _New_capacity       = _Calculate_growth(_New_size);
        auto& _Al                     = _Getal();
        const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); 

        _My_data._Orphan_all();
        ;
        _My_data._Mysize      = _New_size;
        _My_data._Myres       = _New_capacity;
        _Elem* const _Raw_new = _Unfancy(_New_ptr);
        if (_Old_capacity > _Small_string_capacity) {
            const pointer _Old_ptr = _My_data._Bx._Ptr;
            _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
            _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);
            _My_data._Bx._Ptr = _New_ptr;
        } else {
            _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
            _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
        }

        ;
        return *this;
    }

    constexpr void _Become_small() {
        
        auto& _My_data = _Mypair._Myval2;
        ;
        ;

        _My_data._Orphan_all();
        ;
        const pointer _Ptr = _My_data._Bx._Ptr;
        auto& _Al          = _Getal();
        _Destroy_in_place(_My_data._Bx._Ptr);
        _My_data._Activate_SSO_buffer();
        _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);
        _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);
        _My_data._Myres = _Small_string_capacity;
    }

    constexpr void _Eos(const size_type _New_size) noexcept { 
        ;
        _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _New_size], _Elem());
    }

    constexpr void _Tidy_init() noexcept {
        
        auto& _My_data   = _Mypair._Myval2;
        _My_data._Mysize = 0;
        _My_data._Myres  = _Small_string_capacity;
        _My_data._Activate_SSO_buffer();

        
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

    constexpr void _Tidy_deallocate() noexcept { 
        auto& _My_data = _Mypair._Myval2;
        _My_data._Orphan_all();
        if (_My_data._Large_mode_engaged()) {
            ;
            const pointer _Ptr = _My_data._Bx._Ptr;
            auto& _Al          = _Getal();
            _Destroy_in_place(_My_data._Bx._Ptr);
            _My_data._Activate_SSO_buffer();
            _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);
        }

        _My_data._Mysize = 0;
        _My_data._Myres  = _Small_string_capacity;
        
        _Traits::assign(_My_data._Bx._Buf[0], _Elem());
    }

public:
    constexpr void _Orphan_all() noexcept { 
        _Mypair._Myval2._Orphan_all();
    }

private:
    constexpr void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    constexpr _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    constexpr const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};


template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
basic_string(_Iter, _Iter, _Alloc = _Alloc())
    -> basic_string<_Iter_value_t<_Iter>, char_traits<_Iter_value_t<_Iter>>, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
explicit basic_string(basic_string_view<_Elem, _Traits>, const _Alloc& = _Alloc())
    -> basic_string<_Elem, _Traits, _Alloc>;

template <class _Elem, class _Traits, class _Alloc = allocator<_Elem>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(basic_string_view<_Elem, _Traits>, _Guide_size_type_t<_Alloc>, _Guide_size_type_t<_Alloc>,
    const _Alloc& = _Alloc()) -> basic_string<_Elem, _Traits, _Alloc>;


template <::std::ranges:: input_range _Rng, class _Alloc = allocator<::std::ranges:: range_value_t<_Rng>>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
basic_string(from_range_t, _Rng&&, _Alloc = _Alloc())
    -> basic_string<::std::ranges:: range_value_t<_Rng>, char_traits<::std::ranges:: range_value_t<_Rng>>, _Alloc>;
#line 4898 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
#line 4899 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 template <class _Elem, class _Traits, class _Alloc>
constexpr void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
    basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Right.size();
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
    const auto _Right_size = _Right.size();
    if (_Right.max_size() - _Right_size < _Left_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    const auto _Right_size = _Right.size();
    if (_Right_size == _Right.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Right, ::std:: addressof(_Left), 1, _Right.c_str(), _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
    const auto _Left_size  = _Left.size();
    const auto _Right_size = _Convert_size<_Size_type>(_Traits::length(_Right));
    if (_Left.max_size() - _Left_size < _Right_size) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right) {
    const auto _Left_size = _Left.size();
    if (_Left_size == _Left.max_size()) {
        _Xlen_string();
    }

    return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, ::std:: addressof(_Right), 1};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {
    return ::std:: move(_Left.append(_Right));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {






#line 4988 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
    return {_String_constructor_concat_tag{}, _Left, _Right};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
      const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {
    return ::std:: move(_Right.insert(0, 1, _Left));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left,   const _Elem* const _Right) {
    return ::std:: move(_Left.append(_Right));
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr basic_string<_Elem, _Traits, _Alloc> operator+(
    basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right) {
    _Left.push_back(_Right);
    return ::std:: move(_Left);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return _Left._Equal(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr bool operator==(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return _Left._Equal(_Right);
}


 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] constexpr _Get_comparison_category_t<_Traits> operator<=>(
    const basic_string<_Elem, _Traits, _Alloc>& _Left,   const _Elem* const _Right) {
    return static_cast<_Get_comparison_category_t<_Traits>>(_Left.compare(_Right) <=> 0);
}





















































































#line 5126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

 using string  = basic_string<char, char_traits<char>, allocator<char>>;
 using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;

 using u8string = basic_string<char8_t, char_traits<char8_t>, allocator<char8_t>>;
#line 5132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
 using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
 using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

template <class _Elem, class _Alloc>
struct hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>>
    : _Conditionally_enabled_hash<basic_string<_Elem, char_traits<_Elem>, _Alloc>, _Is_EcharT<_Elem>> {
    [[nodiscard]] static size_t _Do_hash(const basic_string<_Elem, char_traits<_Elem>, _Alloc>& _Keyval) noexcept {
        return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
    }
};

 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    using _Myis   = basic_istream<_Elem, _Traits>;
    using _Ctype  = typename _Myis::_Ctype;
    using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysizt = typename _Mystr::size_type;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());
        _Str.erase();

        try {
        _Mysizt _Size;
        if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {
            _Size = static_cast<_Mysizt>(_Istr.width());
        } else {
            _Size = _Str.max_size();
        }

        typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

        for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                break; 
            } else { 
                _Str.push_back(_Traits::to_char_type(_Meta));
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    _Istr.width(0);
    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return _Istr;
}

 template <class _Elem, class _Traits, class _Alloc>
basic_ostream<_Elem, _Traits>& operator<<(
    basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {
    return _Insert_string(_Ostr, _Str.data(), _Str.size());
}

inline namespace literals {
    inline namespace string_literals {
         [[nodiscard]] constexpr string operator""s(const char* _Str, size_t _Len) {
            return string{_Str, _Len};
        }

         [[nodiscard]] constexpr wstring operator""s(const wchar_t* _Str, size_t _Len) {
            return wstring{_Str, _Len};
        }


         [[nodiscard]] constexpr basic_string<char8_t> operator""s(const char8_t* _Str, size_t _Len) {
            return basic_string<char8_t>{_Str, _Len};
        }
#line 5213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"

         [[nodiscard]] constexpr u16string operator""s(const char16_t* _Str, size_t _Len) {
            return u16string{_Str, _Len};
        }

         [[nodiscard]] constexpr u32string operator""s(const char32_t* _Str, size_t _Len) {
            return u32string{_Str, _Len};
        }
    } 
} 


 template <class _Elem, class _Traits, class _Alloc, class _Uty>
constexpr basic_string<_Elem, _Traits, _Alloc>::size_type erase(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, const _Uty& _Val) {
    return _Erase_remove(_Cont, _Val);
}

 template <class _Elem, class _Traits, class _Alloc, class _Pr>
constexpr basic_string<_Elem, _Traits, _Alloc>::size_type erase_if(
    basic_string<_Elem, _Traits, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_remove_if(_Cont, _Pass_fn(_Pred));
}
#line 5237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"


namespace pmr {
     template <class _Elem, class _Traits = char_traits<_Elem>>
    using basic_string = ::std:: basic_string<_Elem, _Traits, polymorphic_allocator<_Elem>>;

     using string = basic_string<char>;

     using u8string = basic_string<char8_t>;
#line 5247 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
     using u16string = basic_string<char16_t>;
     using u32string = basic_string<char32_t>;
     using wstring   = basic_string<wchar_t>;
} 
#line 5252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
}








#pragma warning(pop)
#pragma pack(pop)
#line 5264 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
#line 5265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xstring"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {
 class logic_error : public exception { 
public:
    using _Mybase = exception;

    explicit logic_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit logic_error(const char* _Message) : _Mybase(_Message) {}






#line 34 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class domain_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit domain_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit domain_error(const char* _Message) : _Mybase(_Message) {}






#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class invalid_argument : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit invalid_argument(const char* _Message) : _Mybase(_Message) {}






#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class length_error : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit length_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit length_error(const char* _Message) : _Mybase(_Message) {}






#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class out_of_range : public logic_error { 
public:
    using _Mybase = logic_error;

    explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit out_of_range(const char* _Message) : _Mybase(_Message) {}






#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class runtime_error : public exception { 
public:
    using _Mybase = exception;

    explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit runtime_error(const char* _Message) : _Mybase(_Message) {}






#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class overflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit overflow_error(const char* _Message) : _Mybase(_Message) {}






#line 130 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class underflow_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit underflow_error(const char* _Message) : _Mybase(_Message) {}






#line 146 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

 class range_error : public runtime_error { 
public:
    using _Mybase = runtime_error;

    explicit range_error(const string& _Message) : _Mybase(_Message.c_str()) {}

    explicit range_error(const char* _Message) : _Mybase(_Message) {}






#line 162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
};

[[noreturn]] inline void _Throw_range_error(const char* const _Message) {
    throw range_error{_Message};
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 173 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
#line 174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\stdexcept"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcall_once.h"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 struct once_flag { 
    constexpr once_flag() noexcept : _Opaque(nullptr) {}

    once_flag(const once_flag&)            = delete;
    once_flag& operator=(const once_flag&) = delete;

    void* _Opaque;
};










template <class _Ty>
union _Immortalizer_impl { 
    constexpr _Immortalizer_impl() noexcept : _Storage{} {}
    _Immortalizer_impl(const _Immortalizer_impl&)            = delete;
    _Immortalizer_impl& operator=(const _Immortalizer_impl&) = delete;
    ~_Immortalizer_impl() {
        
    }

    _Ty _Storage;
};




#line 57 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcall_once.h"


#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcall_once.h"










extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_begin_initialize(
    void** _LpInitOnce, unsigned long _DwFlags, int* _FPending, void** _LpContext) noexcept;









extern "C" [[nodiscard]] int __declspec(dllimport) __stdcall __std_init_once_complete(
    void** _LpInitOnce, unsigned long _DwFlags, void* _LpContext) noexcept;

extern "C" [[noreturn]] void __stdcall __std_init_once_link_alternate_names_and_abort() noexcept;



inline constexpr unsigned long _Init_once_init_failed = 0x4UL;

struct _Init_once_completer {
    once_flag& _Once;
    unsigned long _DwFlags;
    ~_Init_once_completer() {
        if (!__std_init_once_complete(&_Once._Opaque, _DwFlags, nullptr)) {
            __std_init_once_link_alternate_names_and_abort();
        }
    }
};

 template <class _Fn, class... _Args>
void(call_once)(once_flag& _Once, _Fn&& _Fx, _Args&&... _Ax) noexcept(
    noexcept(::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...)))  {
    
    
    int _Pending;
    if (!__std_init_once_begin_initialize(&_Once._Opaque, 0, &_Pending, nullptr)) {
        :: abort();
    }

    if (_Pending != 0) {
        _Init_once_completer _Op{_Once, _Init_once_init_failed};
        ::std:: invoke(::std:: forward<_Fn>(_Fx), ::std:: forward<_Args>(_Ax)...);
        _Op._DwFlags = 0;
    }
}



}



#pragma warning(pop)
#pragma pack(pop)
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcall_once.h"
#line 127 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcall_once.h"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xerrc.h"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 enum class errc { 
    address_family_not_supported                       = 102, 
    address_in_use                                     = 100, 
    address_not_available                              = 101, 
    already_connected                                  = 113, 
    argument_list_too_long                             = 7, 
    argument_out_of_domain                             = 33, 
    bad_address                                        = 14, 
    bad_file_descriptor                                = 9, 
    bad_message                                        = 104, 
    broken_pipe                                        = 32, 
    connection_aborted                                 = 106, 
    connection_already_in_progress                     = 103, 
    connection_refused                                 = 107, 
    connection_reset                                   = 108, 
    cross_device_link                                  = 18, 
    destination_address_required                       = 109, 
    device_or_resource_busy                            = 16, 
    directory_not_empty                                = 41, 
    executable_format_error                            = 8, 
    file_exists                                        = 17, 
    file_too_large                                     = 27, 
    filename_too_long                                  = 38, 
    function_not_supported                             = 40, 
    host_unreachable                                   = 110, 
    identifier_removed                                 = 111, 
    illegal_byte_sequence                              = 42, 
    inappropriate_io_control_operation                 = 25, 
    interrupted                                        = 4, 
    invalid_argument                                   = 22, 
    invalid_seek                                       = 29, 
    io_error                                           = 5, 
    is_a_directory                                     = 21, 
    message_size                                       = 115, 
    network_down                                       = 116, 
    network_reset                                      = 117, 
    network_unreachable                                = 118, 
    no_buffer_space                                    = 119, 
    no_child_process                                   = 10, 
    no_link                                            = 121, 
    no_lock_available                                  = 39, 
    no_message_available [[deprecated( "warning STL4041: " "std::errc enumerators std::errc::no_message_available, std::errc::no_stream_resources, " "std::errc::not_a_stream, and std::errc::stream_timeout and their corresponding errno macros ENODATA, ENOSR, " "ENOSTR, and ETIME are deprecated in C++23 by LWG-3869. These errno macros are deprecated in POSIX 2008 and " "removed in POSIX 202x. You can define _SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]] = 120, 
    no_message                                         = 122, 
    no_protocol_option                                 = 123, 
    no_space_on_device                                 = 28, 
    no_stream_resources [[deprecated( "warning STL4041: " "std::errc enumerators std::errc::no_message_available, std::errc::no_stream_resources, " "std::errc::not_a_stream, and std::errc::stream_timeout and their corresponding errno macros ENODATA, ENOSR, " "ENOSTR, and ETIME are deprecated in C++23 by LWG-3869. These errno macros are deprecated in POSIX 2008 and " "removed in POSIX 202x. You can define _SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]  = 124, 
    no_such_device_or_address                          = 6, 
    no_such_device                                     = 19, 
    no_such_file_or_directory                          = 2, 
    no_such_process                                    = 3, 
    not_a_directory                                    = 20, 
    not_a_socket                                       = 128, 
    not_a_stream [[deprecated( "warning STL4041: " "std::errc enumerators std::errc::no_message_available, std::errc::no_stream_resources, " "std::errc::not_a_stream, and std::errc::stream_timeout and their corresponding errno macros ENODATA, ENOSR, " "ENOSTR, and ETIME are deprecated in C++23 by LWG-3869. These errno macros are deprecated in POSIX 2008 and " "removed in POSIX 202x. You can define _SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]         = 125, 
    not_connected                                      = 126, 
    not_enough_memory                                  = 12, 
    not_supported                                      = 129, 
    operation_canceled                                 = 105, 
    operation_in_progress                              = 112, 
    operation_not_permitted                            = 1, 
    operation_not_supported                            = 130, 
    operation_would_block                              = 140, 
    owner_dead                                         = 133, 
    permission_denied                                  = 13, 
    protocol_error                                     = 134, 
    protocol_not_supported                             = 135, 
    read_only_file_system                              = 30, 
    resource_deadlock_would_occur                      = 36, 
    resource_unavailable_try_again                     = 11, 
    result_out_of_range                                = 34, 
    state_not_recoverable                              = 127, 
    stream_timeout [[deprecated( "warning STL4041: " "std::errc enumerators std::errc::no_message_available, std::errc::no_stream_resources, " "std::errc::not_a_stream, and std::errc::stream_timeout and their corresponding errno macros ENODATA, ENOSR, " "ENOSTR, and ETIME are deprecated in C++23 by LWG-3869. These errno macros are deprecated in POSIX 2008 and " "removed in POSIX 202x. You can define _SILENCE_CXX23_UNIX_STREAMS_DEPRECATION_WARNING or " "_SILENCE_ALL_CXX23_DEPRECATION_WARNINGS to suppress this warning.")]]       = 137, 
    text_file_busy                                     = 139, 
    timed_out                                          = 138, 
    too_many_files_open_in_system                      = 23, 
    too_many_files_open                                = 24, 
    too_many_links                                     = 31, 
    too_many_symbolic_link_levels                      = 114, 
    value_too_large                                    = 132, 
    wrong_protocol_type                                = 136 
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 108 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xerrc.h"
#line 109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xerrc.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"



















#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic_wait.h"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




inline constexpr unsigned long long _Atomic_wait_no_deadline = 0xFFFF'FFFF'FFFF'FFFF;
inline constexpr unsigned long _Atomic_wait_no_timeout       = 0xFFFF'FFFF; 

extern "C" {
enum class __std_atomic_api_level : unsigned long {
    __not_set,
    __detecting,
    __has_srwlock,
    __has_wait_on_address,
};





__std_atomic_api_level __stdcall __std_atomic_set_api_level(__std_atomic_api_level _Requested_api_level) noexcept;





int __stdcall __std_atomic_wait_direct(
    const void* _Storage, void* _Comparand, size_t _Size, unsigned long _Remaining_timeout) noexcept;
void __stdcall __std_atomic_notify_one_direct(const void* _Storage) noexcept;
void __stdcall __std_atomic_notify_all_direct(const void* _Storage) noexcept;




using _Atomic_wait_indirect_equal_callback_t = bool(__stdcall*)(
    const void* _Storage, void* _Comparand, size_t _Size, void* _Param) noexcept;

int __stdcall __std_atomic_wait_indirect(const void* _Storage, void* _Comparand, size_t _Size, void* _Param,
    _Atomic_wait_indirect_equal_callback_t _Are_equal, unsigned long _Remaining_timeout) noexcept;
void __stdcall __std_atomic_notify_one_indirect(const void* _Storage) noexcept;
void __stdcall __std_atomic_notify_all_indirect(const void* _Storage) noexcept;




unsigned long long __stdcall __std_atomic_wait_get_deadline(unsigned long long _Timeout) noexcept;
unsigned long __stdcall __std_atomic_wait_get_remaining_timeout(unsigned long long _Deadline) noexcept;

}



#pragma warning(pop)
#pragma pack(pop)
#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic_wait.h"
#line 72 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xatomic_wait.h"
#pragma external_header(pop)
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtimec.h"










#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 49 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
















  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



  
__declspec(dllimport) errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
__declspec(dllimport) errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
__declspec(dllimport) errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
__declspec(dllimport) errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 134 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 140 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
__declspec(dllimport) clock_t __cdecl clock(void);

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 163 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 183 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

 
__declspec(dllimport) double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
__declspec(dllimport) double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

__declspec(dllimport) size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl _strdate( char *_Buffer);
#line 298 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"


__declspec(dllimport) errno_t __cdecl _strtime_s(
       char*  _Buffer,
                                                                              size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);
#line 314 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

__declspec(dllimport) __time32_t __cdecl _time32(
      __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
__declspec(dllimport) int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
__declspec(dllimport) int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 361 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"










    


































































































          __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            return _ctime64(_Time);
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            return _gmtime64(_Time);
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            return _localtime64(_Time);
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base);
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 563 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

    #line 565 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

#line 567 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 582 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"

#line 584 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 591 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\time.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 using :: clock_t;
 using :: size_t;
 using :: time_t;
 using :: tm;
 using :: asctime;
 using :: clock;
 using :: strftime;

 using :: timespec;
#line 31 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"
















































 using :: ctime;
 using :: difftime;
 using :: gmtime;
 using :: localtime;
 using :: mktime;
 using :: time;

 using :: timespec_get;
#line 88 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"

#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"
}



#pragma warning(pop)
#pragma pack(pop)

#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"
#line 99 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ctime"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtimec.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {





 long long __cdecl _Xtime_get_ticks();






 long long __cdecl _Query_perf_counter();
 long long __cdecl _Query_perf_frequency();

}



#pragma warning(pop)
#pragma pack(pop)
#line 43 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtimec.h"
#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtimec.h"
















#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {
using _Thrd_id_t = unsigned int;
struct _Thrd_t { 
    void* _Hnd; 
    _Thrd_id_t _Id;
};

using _Smtx_t = void*;

struct _Stl_critical_section {
    void* _Unused       = nullptr; 
    _Smtx_t _M_srw_lock = nullptr;
};

struct _Mtx_internal_imp_t {








    static constexpr size_t _Critical_section_size = 64;


#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"

    static constexpr size_t _Critical_section_align = alignof(void*);

    int _Type{};
    union {
        _Stl_critical_section _Critical_section{};
        ::std:: _Aligned_storage_t<_Critical_section_size, _Critical_section_align> _Cs_storage;
    };
    long _Thread_id{};
    int _Count{};
};




#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"
inline constexpr size_t _Cnd_internal_imp_size = 72;


#line 69 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"

inline constexpr size_t _Cnd_internal_imp_alignment = alignof(void*);

using _Mtx_t = _Mtx_internal_imp_t*;




struct _Cnd_internal_imp_t;
using _Cnd_t = _Cnd_internal_imp_t*;
#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"

enum class _Thrd_result : int { _Success, _Nomem, _Timedout, _Busy, _Error };


 _Thrd_result __cdecl _Thrd_detach(_Thrd_t);
 _Thrd_result __cdecl _Thrd_join(_Thrd_t, int*);
 void __cdecl _Thrd_sleep(const _timespec64*);
 void __cdecl _Thrd_yield();
 unsigned int __cdecl _Thrd_hardware_concurrency();
 _Thrd_id_t __cdecl _Thrd_id();


enum { 
    _Mtx_plain     = 0x01,
    _Mtx_try       = 0x02,
    _Mtx_timed     = 0x04,
    _Mtx_recursive = 0x100
};





 void __cdecl _Mtx_init_in_situ(_Mtx_t, int);
 void __cdecl _Mtx_destroy_in_situ(_Mtx_t);
 int __cdecl _Mtx_current_owns(_Mtx_t);
 _Thrd_result __cdecl _Mtx_lock(_Mtx_t);
 _Thrd_result __cdecl _Mtx_trylock(_Mtx_t);
 _Thrd_result __cdecl _Mtx_unlock(_Mtx_t); 








void __cdecl _Smtx_lock_exclusive(_Smtx_t*);
void __cdecl _Smtx_lock_shared(_Smtx_t*);
int __cdecl _Smtx_try_lock_exclusive(_Smtx_t*);
int __cdecl _Smtx_try_lock_shared(_Smtx_t*);
void __cdecl _Smtx_unlock_exclusive(_Smtx_t*);
void __cdecl _Smtx_unlock_shared(_Smtx_t*);






 void __cdecl _Cnd_init_in_situ(_Cnd_t);
 void __cdecl _Cnd_destroy_in_situ(_Cnd_t);
 _Thrd_result __cdecl _Cnd_wait(_Cnd_t, _Mtx_t); 
 _Thrd_result __cdecl _Cnd_timedwait(_Cnd_t, _Mtx_t, const _timespec64*);
 _Thrd_result __cdecl _Cnd_broadcast(_Cnd_t); 
 _Thrd_result __cdecl _Cnd_signal(_Cnd_t); 
 void __cdecl _Cnd_register_at_thread_exit(_Cnd_t, _Mtx_t, int*);
 void __cdecl _Cnd_unregister_at_thread_exit(_Mtx_t);
 void __cdecl _Cnd_do_broadcast_at_thread_exit();
}

namespace std {
enum { 
    _DEVICE_OR_RESOURCE_BUSY,
    _INVALID_ARGUMENT,
    _NO_SUCH_PROCESS,
    _NOT_ENOUGH_MEMORY,
    _OPERATION_NOT_PERMITTED,
    _RESOURCE_DEADLOCK_WOULD_OCCUR,
    _RESOURCE_UNAVAILABLE_TRY_AGAIN
};

extern "C++" [[noreturn]]  void __cdecl _Throw_Cpp_error(int _Code);
}


#pragma warning(pop)
#pragma pack(pop)
#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"
#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xthreads.h"
















#pragma external_header(pop)
#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )







#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"





extern "C" [[nodiscard]] unsigned char __stdcall __std_atomic_compare_exchange_128(
      long long* _Destination,   long long _ExchangeHigh,   long long _ExchangeLow,
      long long* _ComparandResult) noexcept;
extern "C" [[nodiscard]] char __stdcall __std_atomic_has_cmpxchg16b() noexcept;

#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"




#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"









#line 64 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 67 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"





#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"













enum {
    _Atomic_memory_order_relaxed,
    _Atomic_memory_order_consume,
    _Atomic_memory_order_acquire,
    _Atomic_memory_order_release,
    _Atomic_memory_order_acq_rel,
    _Atomic_memory_order_seq_cst,
};






#line 101 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 102 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

extern "C" inline void _Check_memory_order(const unsigned int _Order) noexcept {
    if (_Order > _Atomic_memory_order_seq_cst) {
        ;
    }
}






























#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

























#line 165 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
























#line 190 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"





#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


























#line 223 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

#line 225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"














#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"



#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"






#line 251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


#line 254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

#pragma warning(push)
#pragma warning(disable : 6001) 
#pragma warning(disable : 28113) 
                                 
extern "C" inline void _Atomic_thread_fence(const unsigned int _Order) noexcept {
    if (_Order == _Atomic_memory_order_relaxed) {
        return;
    }


    __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    if (_Order == _Atomic_memory_order_seq_cst) {
        volatile long _Guard; 

        
        
        
        (void) _InterlockedIncrement(&_Guard);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }




#line 280 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
}
#pragma warning(pop)



extern "C" {
_Smtx_t* __stdcall __std_atomic_get_mutex(const void* _Key) noexcept;
}







#line 296 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

namespace std {

struct _Form_mask_t {};
inline constexpr _Form_mask_t _Form_mask{};
#line 302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty>
struct _Storage_for {
    
    alignas(_Ty) unsigned char _Storage[sizeof(_Ty)];

    _Storage_for()                               = default;
    _Storage_for(const _Storage_for&)            = delete;
    _Storage_for& operator=(const _Storage_for&) = delete;


    explicit _Storage_for(_Form_mask_t) noexcept {
        :: memset(_Storage, 0xff, sizeof(_Ty));
        __builtin_zero_non_value_bits(_Ptr());
    }
#line 318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    [[nodiscard]] _Ty& _Ref() noexcept {
        return reinterpret_cast<_Ty&>(_Storage);
    }

    [[nodiscard]] _Ty* _Ptr() noexcept {
        return reinterpret_cast<_Ty*>(&_Storage);
    }
};


template <class _Ty>
inline constexpr bool _Might_have_non_value_bits =
    !has_unique_object_representations_v<_Ty> && !is_floating_point_v<_Ty>;
#line 333 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

 extern "C" inline void atomic_thread_fence(const memory_order _Order) noexcept {
    ::_Atomic_thread_fence(static_cast<unsigned int>(_Order));
}

 extern "C" inline void atomic_signal_fence(const memory_order _Order) noexcept {
    if (_Order != memory_order_relaxed) {
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
    }
}

 template <class _Ty>
_Ty kill_dependency(_Ty _Arg) noexcept { 
    return _Arg;
}

inline void _Check_store_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_release:
    case memory_order_seq_cst:
        
        break;
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_acq_rel:
    default:
        ;
        break;
    }
}

inline void _Check_load_memory_order(const memory_order _Order) noexcept {
    switch (_Order) {
    case memory_order_relaxed:
    case memory_order_consume:
    case memory_order_acquire:
    case memory_order_seq_cst:
        
        break;
    case memory_order_release:
    case memory_order_acq_rel:
    default:
        ;
        break;
    }
}

[[nodiscard]] inline memory_order _Combine_cas_memory_orders(
    const memory_order _Success, const memory_order _Failure) noexcept {
    
    
    
    
    
    

    
    
    
    
    static constexpr memory_order _Combined_memory_orders[6][6] = {
        {memory_order_relaxed, memory_order_consume, memory_order_acquire, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_consume, memory_order_consume, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acquire, memory_order_acquire, memory_order_acquire, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_release, memory_order_acq_rel, memory_order_acq_rel, memory_order_release, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel, memory_order_acq_rel,
            memory_order_seq_cst},
        {memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst, memory_order_seq_cst,
            memory_order_seq_cst}};

    _Check_memory_order(static_cast<unsigned int>(_Success));
    _Check_load_memory_order(_Failure);
    return _Combined_memory_orders[static_cast<int>(_Success)][static_cast<int>(_Failure)];
}

template <class _Integral, class _Ty>
[[nodiscard]] _Integral _Atomic_reinterpret_as(const _Ty& _Source) noexcept {
    
    static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
    if constexpr (is_integral_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return static_cast<_Integral>(_Source);
    } else if constexpr (is_pointer_v<_Ty> && sizeof(_Integral) == sizeof(_Ty)) {
        return reinterpret_cast<_Integral>(_Source);
    } else {
        _Integral _Result{}; 
        :: memcpy(&_Result, ::std:: addressof(_Source), sizeof(_Source));
        return _Result;
    }
}


template <class _Ty>
struct _Atomic_padded {
    alignas(sizeof(_Ty)) mutable _Ty _Value; 
};







































#line 473 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty>
struct _Atomic_storage_types {
    using _TStorage = _Atomic_padded<_Ty>;
    using _Spinlock = long;
};

template <class _Ty>
struct _Atomic_storage_types<_Ty&> {
    using _TStorage = _Ty&;
    using _Spinlock = _Smtx_t*; 
};


template <class _Ty, size_t = sizeof(remove_reference_t<_Ty>)>


#line 491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
struct _Atomic_storage;


template <class _Ty, class _Value_type>
void _Atomic_wait_direct(
    const _Atomic_storage<_Ty>* const _This, _Value_type _Expected_bytes, const memory_order _Order) noexcept {
    const auto _Storage_ptr = ::std:: addressof(_This->_Storage);
    for (;;) {
        const _Value_type _Observed_bytes = _Atomic_reinterpret_as<_Value_type>(_This->load(_Order));
        if (_Expected_bytes != _Observed_bytes) {

            using _TVal = remove_reference_t<_Ty>;
            if constexpr (_Might_have_non_value_bits<_TVal>) {
                _Storage_for<_TVal> _Mask{_Form_mask};
                const _Value_type _Mask_val = _Atomic_reinterpret_as<_Value_type>(_Mask._Ref());

                if (((_Expected_bytes ^ _Observed_bytes) & _Mask_val) == 0) {
                    _Expected_bytes = _Observed_bytes;
                    continue;
                }
            }
#line 513 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

            return;
        }

        __std_atomic_wait_direct(_Storage_ptr, &_Expected_bytes, sizeof(_Value_type), _Atomic_wait_no_timeout);
    }
}
#line 521 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


inline void _Atomic_lock_acquire(long& _Spinlock) noexcept {

    
    
    
    int _Current_backoff       = 1;
    constexpr int _Max_backoff = 64;
    while (_InterlockedExchange(&_Spinlock, 1) != 0) {
        while (__iso_volatile_load32(&reinterpret_cast<int&>(_Spinlock)) != 0) {
            for (int _Count_down = _Current_backoff; _Count_down != 0; --_Count_down) {
                _mm_pause();
            }
            _Current_backoff = _Current_backoff < _Max_backoff ? _Current_backoff << 1 : _Max_backoff;
        }
    }








#line 547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
}

inline void _Atomic_lock_release(long& _Spinlock) noexcept {

    _InterlockedExchange(&_Spinlock, 0); 






#line 559 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
}

inline void _Atomic_lock_acquire(_Smtx_t* _Spinlock) noexcept {
    _Smtx_lock_exclusive(_Spinlock);
}

inline void _Atomic_lock_release(_Smtx_t* _Spinlock) noexcept {
    _Smtx_unlock_exclusive(_Spinlock);
}

template <class _Spinlock_t>
class [[nodiscard]] _Atomic_lock_guard {
public:
    explicit _Atomic_lock_guard(_Spinlock_t& _Spinlock_) noexcept : _Spinlock(_Spinlock_) {
        _Atomic_lock_acquire(_Spinlock);
    }

    ~_Atomic_lock_guard() {
        _Atomic_lock_release(_Spinlock);
    }

    _Atomic_lock_guard(const _Atomic_lock_guard&)            = delete;
    _Atomic_lock_guard& operator=(const _Atomic_lock_guard&) = delete;

private:
    _Spinlock_t& _Spinlock;
};


template <class _Spinlock_t>
bool __stdcall _Atomic_wait_compare_non_lock_free(
    const void* _Storage, void* _Comparand, size_t _Size, void* _Spinlock_raw) noexcept {
    _Spinlock_t& _Spinlock = *static_cast<_Spinlock_t*>(_Spinlock_raw);
    _Atomic_lock_acquire(_Spinlock);
    const auto _Cmp_result = :: memcmp(_Storage, _Comparand, _Size);
    _Atomic_lock_release(_Spinlock);
    return _Cmp_result == 0;
}


inline bool __stdcall _Atomic_wait_compare_16_bytes(const void* _Storage, void* _Comparand, size_t, void*) noexcept {
    const auto _Dest              = static_cast<long long*>(const_cast<void*>(_Storage));
    const auto _Cmp               = static_cast<const long long*>(_Comparand);
    alignas(16) long long _Tmp[2] = {_Cmp[0], _Cmp[1]};

    return __std_atomic_compare_exchange_128(_Dest, _Tmp[1], _Tmp[0], _Tmp) != 0;


#line 608 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
}
#line 610 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 611 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 612 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty, size_t >
struct _Atomic_storage {
    
    

    using _TVal  = remove_reference_t<_Ty>;
    using _Guard = _Atomic_lock_guard<typename _Atomic_storage_types<_Ty>::_Spinlock>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage(_Value) {
        
    }

    void store(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_store_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _Storage = _Value;
    }

    [[nodiscard]] _TVal load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        
        _Check_load_memory_order(_Order);
        _Guard _Lock{_Spinlock};
        _TVal _Local(_Storage);
        return _Local;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        _Check_memory_order(static_cast<unsigned int>(_Order));
        _Guard _Lock{_Spinlock};
        _TVal _Result(_Storage);
        _Storage = _Value;
        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Check_memory_order(static_cast<unsigned int>(_Order));
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        bool _Result;

        __builtin_zero_non_value_bits(_Expected_ptr);
#line 661 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Guard _Lock{_Spinlock};

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Local;
            const auto _Local_ptr = _Local._Ptr();
            :: memcpy(_Local_ptr, _Storage_ptr, sizeof(_TVal));
            __builtin_zero_non_value_bits(_Local_ptr);
            _Result = :: memcmp(_Local_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
        } else {
            _Result = :: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) == 0;
        }


#line 675 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Result) {
            :: memcpy(_Storage_ptr, ::std:: addressof(_Desired), sizeof(_TVal));
        } else {
            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
        }

        return _Result;
    }


    void wait(_TVal _Expected, memory_order = memory_order_seq_cst) const noexcept {
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        for (;;) {
            {
                _Guard _Lock{_Spinlock};
                if (:: memcmp(_Storage_ptr, _Expected_ptr, sizeof(_TVal)) != 0) {
                    

                    if constexpr (_Might_have_non_value_bits<_TVal>) {
                        _Storage_for<_TVal> _Local;
                        const auto _Local_ptr = _Local._Ptr();
                        :: memcpy(_Local_ptr, _Storage_ptr, sizeof(_TVal));
                        __builtin_zero_non_value_bits(_Local_ptr);
                        __builtin_zero_non_value_bits(_Expected_ptr);
                        if (:: memcmp(_Local_ptr, _Expected_ptr, sizeof(_TVal)) == 0) {
                            
                            
                            :: memcpy(_Expected_ptr, _Storage_ptr, sizeof(_TVal));
                        } else {
                            
                            return;
                        }
                    } else
#line 710 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                    {
                        return;
                    }
                }
            } 

            __std_atomic_wait_indirect(_Storage_ptr, _Expected_ptr, sizeof(_TVal), &_Spinlock,
                &_Atomic_wait_compare_non_lock_free<decltype(_Spinlock)>, _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_indirect(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_indirect(::std:: addressof(_Storage));
    }
#line 729 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


protected:
    void _Init_spinlock_for_ref() noexcept {
        _Spinlock = __std_atomic_get_mutex(::std:: addressof(_Storage));
    }

private:
    
    mutable typename _Atomic_storage_types<_Ty>::_Spinlock _Spinlock{};

public:
    _Ty _Storage{};




#line 747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
};

template <class _Ty>
struct _Atomic_storage<_Ty, 1> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        (void) _InterlockedExchange8(((_Mem)), ((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem      = _Atomic_address_as<char>(_Storage);
        const char _As_bytes = _Atomic_reinterpret_as<char>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store8((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store8((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel: ; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes  = __iso_volatile_load8(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<char>(_Storage);
        char _As_bytes;


#line 791 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _As_bytes = __iso_volatile_load8(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default: ; break; }
#line 794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        char _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Value));
#line 802 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        char _Expected_bytes = _Atomic_reinterpret_as<char>(_Expected); 
        char _Prev_bytes;


        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const char _Mask_val = _Atomic_reinterpret_as<char>(_Mask._Ref());

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes);
#line 818 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    reinterpret_cast<char&>(_Expected) = _Prev_bytes;
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 830 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange8(_Atomic_address_as<char>(_Storage), _Atomic_reinterpret_as<char>(_Desired), _Expected_bytes);
#line 832 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        reinterpret_cast<char&>(_Expected) = _Prev_bytes;
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<char>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 853 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 2> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        (void) _InterlockedExchange16(((_Mem)), ((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem       = _Atomic_address_as<short>(_Storage);
        const short _As_bytes = _Atomic_reinterpret_as<short>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store16((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store16((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel: ; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes = __iso_volatile_load16(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<short>(_Storage);
        short _As_bytes;


#line 899 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _As_bytes = __iso_volatile_load16(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default: ; break; }
#line 902 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        short _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Value));
#line 910 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        short _Expected_bytes = _Atomic_reinterpret_as<short>(_Expected); 
        short _Prev_bytes;

        if constexpr (_Might_have_non_value_bits<_Ty>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const short _Mask_val = _Atomic_reinterpret_as<short>(_Mask._Ref());

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes);
#line 925 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 937 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange16(_Atomic_address_as<short>(_Storage), _Atomic_reinterpret_as<short>(_Desired), _Expected_bytes);
#line 939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_Ty));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<short>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 4> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        (void) _InterlockedExchange(reinterpret_cast<volatile long*>((_Mem)), static_cast<long>((_As_bytes)));
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem     = _Atomic_address_as<int>(_Storage);
        const int _As_bytes = _Atomic_reinterpret_as<int>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store32((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store32((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel: ; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        int _As_bytes   = __iso_volatile_load32(_Mem);
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<int>(_Storage);
        int _As_bytes;


#line 1006 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _As_bytes = __iso_volatile_load32(_Mem);
        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default: ; break; }
#line 1009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Value));
#line 1017 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long _Expected_bytes = _Atomic_reinterpret_as<long>(_Expected); 
        long _Prev_bytes;

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const long _Mask_val = _Atomic_reinterpret_as<long>(_Mask);

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes);
#line 1032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 1044 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange(_Atomic_address_as<long>(_Storage), _Atomic_reinterpret_as<long>(_Desired), _Expected_bytes);
#line 1046 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<long>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 1067 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};

template <class _Ty>
struct _Atomic_storage<_Ty, 8> { 

    using _TVal = remove_reference_t<_Ty>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty>, _Ty, const _TVal> _Value) noexcept
        : _Storage{_Value} {
        
    }

    void store(const _TVal _Value) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        (void) _InterlockedExchange64(((_Mem)), ((_As_bytes)));;
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        const auto _Mem           = _Atomic_address_as<long long>(_Storage);
        const long long _As_bytes = _Atomic_reinterpret_as<long long>(_Value);
        switch (static_cast<unsigned int>(_Order)) {
            case _Atomic_memory_order_relaxed: __iso_volatile_store64((_Mem), (_As_bytes)); return; case _Atomic_memory_order_release: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); __iso_volatile_store64((_Mem), (_As_bytes)); return; default: case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_acq_rel: ; [[fallthrough]];
        case _Atomic_memory_order_seq_cst:
            store(_Value);
            return;
        }
    }

    [[nodiscard]] _TVal load() const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);



        long long _As_bytes = __iso_volatile_load64(_Mem);
#line 1107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop));
        return reinterpret_cast<_TVal&>(_As_bytes);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 
        const auto _Mem = _Atomic_address_as<long long>(_Storage);
        long long _As_bytes;


#line 1117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"




        _As_bytes = __iso_volatile_load64(_Mem);
#line 1123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

        switch (static_cast<unsigned int>(_Order)) { case _Atomic_memory_order_relaxed: break; case _Atomic_memory_order_consume: case _Atomic_memory_order_acquire: case _Atomic_memory_order_seq_cst: __pragma(warning(push)) __pragma(warning(disable : 4996)) _ReadWriteBarrier() __pragma(warning(pop)); break; case _Atomic_memory_order_release: case _Atomic_memory_order_acq_rel: default: ; break; }
#line 1126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }











    _TVal exchange(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        
        long long _As_bytes;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _As_bytes = _InterlockedExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Value));
#line 1144 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_TVal&>(_As_bytes);
    }
#line 1147 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        long long _Expected_bytes = _Atomic_reinterpret_as<long long>(_Expected); 
        long long _Prev_bytes;


        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Storage_for<_TVal> _Mask{_Form_mask};
            const long long _Mask_val = _Atomic_reinterpret_as<long long>(_Mask);

            for (;;) {
                _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes);
#line 1162 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                if (_Prev_bytes == _Expected_bytes) {
                    return true;
                }

                if ((_Prev_bytes ^ _Expected_bytes) & _Mask_val) {
                    :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
                    return false;
                }
                _Expected_bytes = (_Expected_bytes & _Mask_val) | (_Prev_bytes & ~_Mask_val);
            }
        }
#line 1174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Prev_bytes = _InterlockedCompareExchange64(_Atomic_address_as<long long>(_Storage), _Atomic_reinterpret_as<long long>(_Desired), _Expected_bytes);
#line 1176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Prev_bytes == _Expected_bytes) {
            return true;
        }

        :: memcpy(::std:: addressof(_Expected), &_Prev_bytes, sizeof(_TVal));
        return false;
    }


    void wait(const _TVal _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Atomic_wait_direct(this, _Atomic_reinterpret_as<long long>(_Expected), _Order);
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_direct(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_direct(::std:: addressof(_Storage));
    }
#line 1197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    typename _Atomic_storage_types<_Ty>::_TStorage _Storage;
};


template <class _Ty>
struct _Atomic_storage<_Ty&, 16> { 
    
    using _TVal = remove_reference_t<_Ty&>;

    _Atomic_storage() = default;

     constexpr _Atomic_storage(conditional_t<is_reference_v<_Ty&>, _Ty&, const _TVal> _Value) noexcept
        : _Storage{_Value} {} 

    void store(const _TVal _Value) noexcept { 
        (void) exchange(_Value);
    }

    void store(const _TVal _Value, const memory_order _Order) noexcept { 
        _Check_store_memory_order(_Order);
        (void) exchange(_Value, _Order);
    }

    [[nodiscard]] _TVal load() const noexcept { 
        long long* const _Storage_ptr = const_cast<long long*>(_Atomic_address_as<const long long>(_Storage));
        _Int128 _Result{}; 
        (void) __std_atomic_compare_exchange_128(_Storage_ptr, 0, 0, &_Result._Low);
        return reinterpret_cast<_TVal&>(_Result);
    }

    [[nodiscard]] _TVal load(const memory_order _Order) const noexcept { 






















#line 1252 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_load_memory_order(_Order);
        return load();
#line 1255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
    }

    _TVal exchange(const _TVal _Value) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value)) { 
        }

        return _Result;
    }

    _TVal exchange(const _TVal _Value, const memory_order _Order) noexcept { 
        _TVal _Result{_Value};
        while (!compare_exchange_strong(_Result, _Value, _Order)) { 
        }

        return _Result;
    }

    bool compare_exchange_strong(_TVal& _Expected, const _TVal _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept { 
        _Int128 _Desired_bytes{};
        :: memcpy(&_Desired_bytes, ::std:: addressof(_Desired), sizeof(_TVal));
        _Int128 _Expected_temp{};
        :: memcpy(&_Expected_temp, ::std:: addressof(_Expected), sizeof(_TVal));
        unsigned char _Result;

        if constexpr (_Might_have_non_value_bits<_TVal>) {
            _Int128 _Expected_originally{};
            :: memcpy(&_Expected_originally, ::std:: addressof(_Expected), sizeof(_TVal));

            _Storage_for<_TVal> _Mask{_Form_mask};
            _Int128 _Mask_val{};
            :: memcpy(&_Mask_val, _Mask._Ptr(), sizeof(_TVal));
            for (;;) {




#line 1294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                (void) _Order;
                _Result = __std_atomic_compare_exchange_128(&reinterpret_cast<long long&>(_Storage), _Desired_bytes._High,
                    _Desired_bytes._Low, &_Expected_temp._Low);
#line 1298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
                if (_Result) {
                    return true;
                }

                if (((_Expected_temp._Low ^ _Expected_originally._Low) & _Mask_val._Low) != 0
                    || ((_Expected_temp._High ^ _Expected_originally._High) & _Mask_val._High) != 0) {
                    :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
                    return false;
                }

                _Expected_temp._Low =
                    (_Expected_originally._Low & _Mask_val._Low) | (_Expected_temp._Low & ~_Mask_val._Low);
                _Expected_temp._High =
                    (_Expected_originally._High & _Mask_val._High) | (_Expected_temp._High & ~_Mask_val._High);
            }
        }
#line 1315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"



#line 1319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        (void) _Order;
        _Result = __std_atomic_compare_exchange_128(
            &reinterpret_cast<long long&>(_Storage), _Desired_bytes._High, _Desired_bytes._Low, &_Expected_temp._Low);
#line 1323 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if (_Result == 0) {
            :: memcpy(::std:: addressof(_Expected), &_Expected_temp, sizeof(_TVal));
        }

        return _Result != 0;
    }


    void wait(_TVal _Expected, memory_order _Order = memory_order_seq_cst) const noexcept {
        const auto _Storage_ptr  = ::std:: addressof(_Storage);
        const auto _Expected_ptr = ::std:: addressof(_Expected);
        _Int128 _Expected_bytes  = reinterpret_cast<const _Int128&>(_Expected);

        for (;;) {
            const _TVal _Observed   = load(_Order);
            _Int128 _Observed_bytes = reinterpret_cast<const _Int128&>(_Observed);
            if (_Observed_bytes._Low != _Expected_bytes._Low || _Observed_bytes._High != _Expected_bytes._High) {

                if constexpr (_Might_have_non_value_bits<_TVal>) {
                    _Storage_for<_TVal> _Mask{_Form_mask};
                    const _Int128 _Mask_val = reinterpret_cast<const _Int128&>(_Mask._Ref());

                    if (((_Expected_bytes._Low ^ _Observed_bytes._Low) & _Mask_val._Low) == 0
                        && ((_Expected_bytes._High ^ _Observed_bytes._High) & _Mask_val._High) == 0) {
                        _Expected_bytes = _Observed_bytes;
                        continue;
                    }
                }
#line 1352 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

                return;
            }

            __std_atomic_wait_indirect(_Storage_ptr, _Expected_ptr, sizeof(_TVal), nullptr,
                &_Atomic_wait_compare_16_bytes, _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        __std_atomic_notify_one_indirect(::std:: addressof(_Storage));
    }

    void notify_all() noexcept {
        __std_atomic_notify_all_indirect(::std:: addressof(_Storage));
    }
#line 1369 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    struct _Int128 {
        alignas(16) long long _Low;
        long long _High;
    };

    typename _Atomic_storage_types<_Ty&>::_TStorage _Storage;
};
#line 1378 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty, size_t = sizeof(_Ty)>
struct _Atomic_integral; 

template <class _Ty>
struct _Atomic_integral<_Ty, 1> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1393 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        char _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor8(_Atomic_address_as<char>(this->_Storage), static_cast<char>(_Operand));
#line 1414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
    }

    _TVal operator++() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), 1));
        ++_Before;
        return static_cast<_TVal>(_Before);
    }

    _TVal operator--(int) noexcept {
        return static_cast<_TVal>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
    }

    _TVal operator--() noexcept {
        unsigned char _Before =
            static_cast<unsigned char>(_InterlockedExchangeAdd8(_Atomic_address_as<char>(this->_Storage), -1));
        --_Before;
        return static_cast<_TVal>(_Before);
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 2> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1465 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        short _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor16(_Atomic_address_as<short>(this->_Storage), static_cast<short>(_Operand));
#line 1472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement16(_Atomic_address_as<short>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned short _After =
            static_cast<unsigned short>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement16(_Atomic_address_as<short>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 4> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;

    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1509 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1516 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1523 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor(_Atomic_address_as<long>(this->_Storage), static_cast<long>(_Operand));
#line 1530 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement(_Atomic_address_as<long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long _After =
            static_cast<unsigned long>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement(_Atomic_address_as<long>(this->_Storage)));
    }
};

template <class _Ty>
struct _Atomic_integral<_Ty, 8> : _Atomic_storage<_Ty> { 
    using _Base = _Atomic_storage<_Ty>;
    using typename _Base::_TVal;

    using _Base::_Base;























































    _TVal fetch_add(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1621 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_and(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedAnd64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1628 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_or(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedOr64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1635 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal fetch_xor(const _TVal _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        long long _Result;
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedXor64(_Atomic_address_as<long long>(this->_Storage), static_cast<long long>(_Operand));
#line 1642 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return static_cast<_TVal>(_Result);
    }

    _TVal operator++(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
        --_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator++() noexcept {
        return static_cast<_TVal>(_InterlockedIncrement64(_Atomic_address_as<long long>(this->_Storage)));
    }

    _TVal operator--(int) noexcept {
        unsigned long long _After =
            static_cast<unsigned long long>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
        ++_After;
        return static_cast<_TVal>(_After);
    }

    _TVal operator--() noexcept {
        return static_cast<_TVal>(_InterlockedDecrement64(_Atomic_address_as<long long>(this->_Storage)));
    }
#line 1667 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
};


template <size_t _TypeSize>
inline constexpr bool _Is_always_lock_free = _TypeSize <= 8 && (_TypeSize & (_TypeSize - 1)) == 0;








#line 1681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty, bool _Is_lock_free = _Is_always_lock_free<sizeof(_Ty)>>
inline constexpr bool _Deprecate_non_lock_free_volatile = true;

template <class _Ty>
[[deprecated("warning STL4030: " "Some operations on volatile-qualified types in the STL are deprecated in C++20. " "You can define _SILENCE_CXX20_VOLATILE_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] inline constexpr bool _Deprecate_non_lock_free_volatile<_Ty, false> = true;

template <class _Ty>
struct _Atomic_integral_facade : _Atomic_integral<_Ty> {
    
    using _Base           = _Atomic_integral<_Ty>;
    using difference_type = _Ty;

    using _Base::_Base;

    

    
    
    
    using _Base::fetch_add;
    _Ty fetch_add(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_sub(const _Ty _Operand) noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand) volatile noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    using _Base::fetch_and;
    _Ty fetch_and(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    using _Base::fetch_or;
    _Ty fetch_or(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    using _Base::fetch_xor;
    _Ty fetch_xor(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    using _Base::operator++;
    _Ty operator++(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    using _Base::operator--;
    _Ty operator--(int) volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() volatile noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->fetch_sub(_Operand) - _Operand);
    }

    _Ty operator&=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator&=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator|=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) noexcept {
        return static_cast<_Ty>(this->_Base::fetch_xor(_Operand) ^ _Operand);
    }

    _Ty operator^=(const _Ty _Operand) volatile noexcept {
        return static_cast<_Ty>(const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand) ^ _Operand);
    }
};

template <class _Ty>
struct _Atomic_integral_facade<_Ty&> : _Atomic_integral<_Ty&> {
    
    using _Base           = _Atomic_integral<_Ty&>;
    using difference_type = _Ty;

    using _Base::_Base;

    [[nodiscard]] static _Ty _Negate(const _Ty _Value) noexcept { 
        return static_cast<_Ty>(0U - static_cast<make_unsigned_t<_Ty>>(_Value));
    }

    _Ty fetch_add(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand);
    }

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand) const noexcept {
        return fetch_add(_Negate(_Operand));
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order) const noexcept {
        return fetch_add(_Negate(_Operand), _Order);
    }

    _Ty operator++(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++(0);
    }

    _Ty operator++() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator++();
    }

    _Ty operator--(int) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--(0);
    }

    _Ty operator--() const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::operator--();
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_add(_Operand) + _Operand);
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_sub(_Operand) - _Operand);
    }

    _Ty fetch_and(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand);
    }

    _Ty fetch_and(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_and(_Operand, _Order);
    }

    _Ty fetch_or(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand);
    }

    _Ty fetch_or(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_or(_Operand, _Order);
    }

    _Ty fetch_xor(const _Ty _Operand) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand);
    }

    _Ty fetch_xor(const _Ty _Operand, const memory_order _Order) const noexcept {
        return const_cast<_Atomic_integral_facade*>(this)->_Base::fetch_xor(_Operand, _Order);
    }

    _Ty operator&=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_and(_Operand) & _Operand);
    }

    _Ty operator|=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_or(_Operand) | _Operand);
    }

    _Ty operator^=(const _Ty _Operand) const noexcept {
        return static_cast<_Ty>(fetch_xor(_Operand) ^ _Operand);
    }
};


template <class _Ty>
struct _Atomic_floating : _Atomic_storage<_Ty> {
    
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = _Ty;

    using _Base::_Base;

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!this->compare_exchange_strong(_Temp, _Temp + _Operand, _Order)) { 
        }

        return _Temp;
    }

    

    
    
    
    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_add(_Operand, _Order);
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!this->compare_exchange_strong(_Temp, _Temp - _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_sub(_Operand, _Order);
    }

    _Ty operator+=(const _Ty _Operand) noexcept {
        return fetch_add(_Operand) + _Operand;
    }

    _Ty operator+=(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_add(_Operand) + _Operand;
    }

    _Ty operator-=(const _Ty _Operand) noexcept {
        return fetch_sub(_Operand) - _Operand;
    }

    _Ty operator-=(const _Ty _Operand) volatile noexcept {
        return const_cast<_Atomic_floating*>(this)->fetch_sub(_Operand) - _Operand;
    }
};

template <class _Ty>
struct _Atomic_floating<_Ty&> : _Atomic_storage<_Ty&> {
    
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = _Ty;

    using _Base::_Base;

    _Ty fetch_add(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!const_cast<_Atomic_floating*>(this)->_Base::compare_exchange_strong(
            _Temp, _Temp + _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty fetch_sub(const _Ty _Operand, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Ty _Temp{this->load(memory_order_relaxed)};
        while (!const_cast<_Atomic_floating*>(this)->_Base::compare_exchange_strong(
            _Temp, _Temp - _Operand, _Order)) { 
        }

        return _Temp;
    }

    _Ty operator+=(const _Ty _Operand) const noexcept {
        return fetch_add(_Operand) + _Operand;
    }

    _Ty operator-=(const _Ty _Operand) const noexcept {
        return fetch_sub(_Operand) - _Operand;
    }
};
#line 1995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

template <class _Ty>
struct _Atomic_pointer : _Atomic_storage<_Ty> {
    using _Base           = _Atomic_storage<_Ty>;
    using difference_type = ptrdiff_t;

    using _Base::_Base;

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2011 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 2013 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 2014 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    

    _Ty fetch_add(const ptrdiff_t _Diff) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff);
    }

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return const_cast<_Atomic_pointer*>(this)->fetch_add(_Diff, _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) volatile noexcept {
        return fetch_add(1);
    }

    _Ty operator++(int) noexcept {
        return fetch_add(1);
    }

    _Ty operator++() volatile noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator++() noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) volatile noexcept {
        return fetch_add(-1);
    }

    _Ty operator--(int) noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() volatile noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator--() noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator+=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) volatile noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};

template <class _Ty>
struct _Atomic_pointer<_Ty&> : _Atomic_storage<_Ty&> {
    using _Base           = _Atomic_storage<_Ty&>;
    using difference_type = ptrdiff_t;

    using _Base::_Base;

    _Ty fetch_add(const ptrdiff_t _Diff, const memory_order _Order = memory_order_seq_cst) const noexcept {
        const ptrdiff_t _Shift_bytes =
            static_cast<ptrdiff_t>(static_cast<size_t>(_Diff) * sizeof(remove_pointer_t<_Ty>));
        ptrdiff_t _Result;



#line 2107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        _Check_memory_order(static_cast<unsigned int>(_Order)); _Result = _InterlockedExchangeAdd64(_Atomic_address_as<long long>(this->_Storage), _Shift_bytes);
#line 2109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 2110 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        return reinterpret_cast<_Ty>(_Result);
    }

    _Ty fetch_sub(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)));
    }

    _Ty fetch_sub(const ptrdiff_t _Diff, const memory_order _Order) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff)), _Order);
    }

    _Ty operator++(int) const noexcept {
        return fetch_add(1);
    }

    _Ty operator++() const noexcept {
        return fetch_add(1) + 1;
    }

    _Ty operator--(int) const noexcept {
        return fetch_add(-1);
    }

    _Ty operator--() const noexcept {
        return fetch_add(-1) - 1;
    }

    _Ty operator+=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(_Diff) + _Diff;
    }

    _Ty operator-=(const ptrdiff_t _Diff) const noexcept {
        return fetch_add(static_cast<ptrdiff_t>(0 - static_cast<size_t>(_Diff))) - _Diff;
    }
};




template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base2_t =
    typename _Select<is_integral_v<_TVal> && !is_same_v<bool, _TVal>>::template _Apply<_Atomic_integral_facade<_Ty>,
        typename _Select<is_pointer_v<_TVal> && is_object_v<remove_pointer_t<_TVal>>>::template _Apply<
            _Atomic_pointer<_Ty>, _Atomic_storage<_Ty>>>;


template <class _TVal, class _Ty = _TVal>
using _Choose_atomic_base_t =
    _Select<is_floating_point_v<_TVal>>::template _Apply<_Atomic_floating<_Ty>, _Choose_atomic_base2_t<_TVal, _Ty>>;



#line 2163 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

 template <class _Ty>
struct atomic : _Choose_atomic_base_t<_Ty> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty>;

public:
    static_assert(is_trivially_copyable_v<_Ty> && is_copy_constructible_v<_Ty> && is_move_constructible_v<_Ty>
                      && is_copy_assignable_v<_Ty> && is_move_assignable_v<_Ty>,
        "atomic<T> requires T to be trivially copyable, copy constructible, move constructible, copy assignable, "
        "and move assignable.");

    using value_type = _Ty;

    using _Base::_Base;

    constexpr atomic() noexcept(is_nothrow_default_constructible_v<_Ty>) : _Base() {}

    atomic(const atomic&)            = delete;
    atomic& operator=(const atomic&) = delete;


    static constexpr bool is_always_lock_free = _Is_always_lock_free<sizeof(_Ty)>;
#line 2187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


    [[nodiscard]] bool is_lock_free() const volatile noexcept {
        constexpr bool _Result = sizeof(_Ty) <= 8 && (sizeof(_Ty) & sizeof(_Ty) - 1) == 0;
        return _Result;
    }










#line 2204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    [[nodiscard]] bool is_lock_free() const noexcept {
        return static_cast<const volatile atomic*>(this)->is_lock_free();
    }

    _Ty operator=(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        this->store(_Value);
        return _Value;
    }

    _Ty operator=(const _Ty _Value) noexcept {
        this->store(_Value);
        return _Value;
    }

    
    
    
    
    
    using _Base::store;
    void store(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        const_cast<atomic*>(this)->_Base::store(_Value, _Order);
    }

    using _Base::load;
    [[nodiscard]] _Ty load() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load();
    }

    [[nodiscard]] _Ty load(const memory_order _Order) const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<const atomic*>(this)->_Base::load(_Order);
    }

    using _Base::exchange;
    _Ty exchange(const _Ty _Value) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::exchange(_Value, _Order);
    }

    using _Base::compare_exchange_strong;
    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return const_cast<atomic*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) volatile noexcept {
        
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Success,
        const memory_order _Failure) volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
        return this->compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }


    using _Base::wait;
    void wait(const _Ty _Expected, const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        const_cast<const atomic*>(this)->_Base::wait(_Expected, _Order);
    }

    using _Base::notify_one;
    void notify_one() volatile noexcept {
        const_cast<atomic*>(this)->_Base::notify_one();
    }

    using _Base::notify_all;
    void notify_all() volatile noexcept {
        const_cast<atomic*>(this)->_Base::notify_all();
    }
#line 2326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    operator _Ty() const volatile noexcept {
        static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
        return this->load();
    }

    operator _Ty() const noexcept {
        return this->load();
    }
};


template <class _Ty>
atomic(_Ty) -> atomic<_Ty>;
#line 2341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


 template <class _Ty>
struct atomic_ref : _Choose_atomic_base_t<_Ty, _Ty&> { 
private:
    using _Base = _Choose_atomic_base_t<_Ty, _Ty&>;

public:
    static_assert(is_trivially_copyable_v<_Ty>, "atomic_ref<T> requires T to be trivially copyable.");

    using value_type = _Ty;

    explicit atomic_ref(_Ty& _Value) noexcept  : _Base(_Value) {
        if constexpr (_Is_potentially_lock_free) {
            _Check_alignment(_Value);
        } else {
            this->_Init_spinlock_for_ref();
        }
    }

    atomic_ref(const atomic_ref&) noexcept = default;

    atomic_ref& operator=(const atomic_ref&) = delete;

    static constexpr bool is_always_lock_free = _Is_always_lock_free<sizeof(_Ty)>;

    static constexpr bool _Is_potentially_lock_free =
        sizeof(_Ty) <= 2 * sizeof(void*) && (sizeof(_Ty) & (sizeof(_Ty) - 1)) == 0;

    static constexpr size_t required_alignment = _Is_potentially_lock_free ? sizeof(_Ty) : alignof(_Ty);

    [[nodiscard]] bool is_lock_free() const noexcept {


#line 2376 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
        if constexpr (is_always_lock_free) {
            return true;
        } else {
            return __std_atomic_has_cmpxchg16b() != 0;
        }
#line 2382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
    }

    void store(const _Ty _Value) const noexcept {
        const_cast<atomic_ref*>(this)->_Base::store(_Value);
    }

    void store(const _Ty _Value, const memory_order _Order) const noexcept {
        const_cast<atomic_ref*>(this)->_Base::store(_Value, _Order);
    }

    _Ty operator=(const _Ty _Value) const noexcept {
        store(_Value);
        return _Value;
    }

    _Ty exchange(const _Ty _Value) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::exchange(_Value);
    }

    _Ty exchange(const _Ty _Value, const memory_order _Order) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::exchange(_Value, _Order);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_strong(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) const noexcept {
        return const_cast<atomic_ref*>(this)->_Base::compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_strong(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired) const noexcept {
        return compare_exchange_strong(_Expected, _Desired);
    }

    bool compare_exchange_weak(_Ty& _Expected, const _Ty _Desired, const memory_order _Order) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Order);
    }

    bool compare_exchange_weak(
        _Ty& _Expected, const _Ty _Desired, const memory_order _Success, const memory_order _Failure) const noexcept {
        return compare_exchange_strong(_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
    }

    operator _Ty() const noexcept {
        return this->load();
    }

    void notify_one() const noexcept {
        const_cast<atomic_ref*>(this)->_Base::notify_one();
    }

    void notify_all() const noexcept {
        const_cast<atomic_ref*>(this)->_Base::notify_all();
    }

private:
    static void _Check_alignment([[maybe_unused]] const _Ty& _Value) {
        ;
#line 2448 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
    }
};
#line 2451 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

 template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const volatile atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

 template <class _Ty>
[[nodiscard]] bool atomic_is_lock_free(const atomic<_Ty>* _Mem) noexcept {
    return _Mem->is_lock_free();
}

 template <class _Ty>
void atomic_store(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value);
}

 template <class _Ty>
void atomic_store(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    _Mem->store(_Value);
}

 template <class _Ty>
void atomic_store_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    _Mem->store(_Value, _Order);
}

 template <class _Ty>
void atomic_store_explicit(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    _Mem->store(_Value, _Order);
}

 template <class _Ty>
[[deprecated("warning STL4028: " "std::atomic_init() overloads are deprecated in C++20. " "The constructors of std::atomic provide equivalent functionality. " "You can define _SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_init(
    volatile atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

 template <class _Ty>
[[deprecated("warning STL4028: " "std::atomic_init() overloads are deprecated in C++20. " "The constructors of std::atomic provide equivalent functionality. " "You can define _SILENCE_CXX20_ATOMIC_INIT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_init(
    atomic<_Ty>* const _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    ::std:: atomic_store_explicit(_Mem, _Value, memory_order_relaxed);
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load(const volatile atomic<_Ty>* const _Mem) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load();
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load(const atomic<_Ty>* const _Mem) noexcept {
    return _Mem->load();
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const volatile atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->load(_Order);
}

 template <class _Ty>
[[nodiscard]] _Ty atomic_load_explicit(const atomic<_Ty>* const _Mem, const memory_order _Order) noexcept {
    return _Mem->load(_Order);
}

 template <class _Ty>
_Ty atomic_exchange(volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value);
}

 template <class _Ty>
_Ty atomic_exchange(atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value) noexcept {
    return _Mem->exchange(_Value);
}

 template <class _Ty>
_Ty atomic_exchange_explicit(
    volatile atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->exchange(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_exchange_explicit(
    atomic<_Ty>* const _Mem, const _Identity_t<_Ty> _Value, const memory_order _Order) noexcept {
    return _Mem->exchange(_Value, _Order);
}

 template <class _Ty>
bool atomic_compare_exchange_strong(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_strong(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_strong_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_strong_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_weak(
    volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_weak(
    atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected, const _Identity_t<_Ty> _Desired) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired);
}

 template <class _Ty>
bool atomic_compare_exchange_weak_explicit(volatile atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
bool atomic_compare_exchange_weak_explicit(atomic<_Ty>* const _Mem, _Identity_t<_Ty>* const _Expected,
    const _Identity_t<_Ty> _Desired, const memory_order _Success, const memory_order _Failure) noexcept {
    return _Mem->compare_exchange_strong(*_Expected, _Desired, _Combine_cas_memory_orders(_Success, _Failure));
}

 template <class _Ty>
_Ty atomic_fetch_add(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_add(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_add(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_add_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_add(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_add_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_add(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_sub(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_sub(atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value) noexcept {
    return _Mem->fetch_sub(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_sub_explicit(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value,
    const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_sub(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_sub_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::difference_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_sub(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_and(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_and(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_and(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_and_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_and(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_and_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_and(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_or(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_or(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_or(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_or_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_or(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_or_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_or(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_xor(volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_xor(atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value) noexcept {
    return _Mem->fetch_xor(_Value);
}

 template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    volatile atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    static_assert(_Deprecate_non_lock_free_volatile<_Ty>, "Never fails");
    return _Mem->fetch_xor(_Value, _Order);
}

 template <class _Ty>
_Ty atomic_fetch_xor_explicit(
    atomic<_Ty>* _Mem, const typename atomic<_Ty>::value_type _Value, const memory_order _Order) noexcept {
    return _Mem->fetch_xor(_Value, _Order);
}


 template <class _Ty>
void atomic_wait(const volatile atomic<_Ty>* const _Mem,
    const typename atomic<_Ty>::value_type _Expected) noexcept { 
    _Mem->wait(_Expected);
}

 template <class _Ty>
void atomic_wait(const atomic<_Ty>* const _Mem,
    const typename atomic<_Ty>::value_type _Expected) noexcept { 
    _Mem->wait(_Expected);
}

 template <class _Ty>
void atomic_wait_explicit(const volatile atomic<_Ty>* const _Mem,
    const typename atomic<_Ty>::value_type _Expected, 
    const memory_order _Order) noexcept {
    _Mem->wait(_Expected, _Order);
}

 template <class _Ty>
void atomic_wait_explicit(const atomic<_Ty>* const _Mem,
    const typename atomic<_Ty>::value_type _Expected, 
    const memory_order _Order) noexcept {
    _Mem->wait(_Expected, _Order);
}

 template <class _Ty>
void atomic_notify_one(volatile atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_one();
}

 template <class _Ty>
void atomic_notify_one(atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_one();
}

 template <class _Ty>
void atomic_notify_all(volatile atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_all();
}

 template <class _Ty>
void atomic_notify_all(atomic<_Ty>* const _Mem) noexcept {
    _Mem->notify_all();
}
#line 2763 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

 using atomic_bool = atomic<bool>;

 using atomic_char   = atomic<char>;
 using atomic_schar  = atomic<signed char>;
 using atomic_uchar  = atomic<unsigned char>;
 using atomic_short  = atomic<short>;
 using atomic_ushort = atomic<unsigned short>;
 using atomic_int    = atomic<int>;
 using atomic_uint   = atomic<unsigned int>;
 using atomic_long   = atomic<long>;
 using atomic_ulong  = atomic<unsigned long>;
 using atomic_llong  = atomic<long long>;
 using atomic_ullong = atomic<unsigned long long>;


 using atomic_char8_t = atomic<char8_t>;
#line 2781 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
 using atomic_char16_t = atomic<char16_t>;
 using atomic_char32_t = atomic<char32_t>;
 using atomic_wchar_t  = atomic<wchar_t>;

 using atomic_int8_t   = atomic<int8_t>;
 using atomic_uint8_t  = atomic<uint8_t>;
 using atomic_int16_t  = atomic<int16_t>;
 using atomic_uint16_t = atomic<uint16_t>;
 using atomic_int32_t  = atomic<int32_t>;
 using atomic_uint32_t = atomic<uint32_t>;
 using atomic_int64_t  = atomic<int64_t>;
 using atomic_uint64_t = atomic<uint64_t>;

 using atomic_int_least8_t   = atomic<int_least8_t>;
 using atomic_uint_least8_t  = atomic<uint_least8_t>;
 using atomic_int_least16_t  = atomic<int_least16_t>;
 using atomic_uint_least16_t = atomic<uint_least16_t>;
 using atomic_int_least32_t  = atomic<int_least32_t>;
 using atomic_uint_least32_t = atomic<uint_least32_t>;
 using atomic_int_least64_t  = atomic<int_least64_t>;
 using atomic_uint_least64_t = atomic<uint_least64_t>;

 using atomic_int_fast8_t   = atomic<int_fast8_t>;
 using atomic_uint_fast8_t  = atomic<uint_fast8_t>;
 using atomic_int_fast16_t  = atomic<int_fast16_t>;
 using atomic_uint_fast16_t = atomic<uint_fast16_t>;
 using atomic_int_fast32_t  = atomic<int_fast32_t>;
 using atomic_uint_fast32_t = atomic<uint_fast32_t>;
 using atomic_int_fast64_t  = atomic<int_fast64_t>;
 using atomic_uint_fast64_t = atomic<uint_fast64_t>;

 using atomic_intptr_t  = atomic<intptr_t>;
 using atomic_uintptr_t = atomic<uintptr_t>;
 using atomic_size_t    = atomic<size_t>;
 using atomic_ptrdiff_t = atomic<ptrdiff_t>;
 using atomic_intmax_t  = atomic<intmax_t>;
 using atomic_uintmax_t = atomic<uintmax_t>;




 using atomic_signed_lock_free   = atomic_intptr_t;
 using atomic_unsigned_lock_free = atomic_uintptr_t;
#line 2825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"




 struct atomic_flag { 

    [[nodiscard]] bool test(const memory_order _Order = memory_order_seq_cst) const noexcept {
        return _Storage.load(_Order) != 0;
    }

    [[nodiscard]] bool test(const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        return _Storage.load(_Order) != 0;
    }
#line 2839 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    bool test_and_set(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        return _Storage.exchange(true, _Order) != 0;
    }

    void clear(const memory_order _Order = memory_order_seq_cst) noexcept {
        _Storage.store(false, _Order);
    }

    void clear(const memory_order _Order = memory_order_seq_cst) volatile noexcept {
        _Storage.store(false, _Order);
    }

    constexpr atomic_flag() noexcept = default;


    void wait(const bool _Expected, const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Storage.wait(static_cast<decltype(_Storage)::value_type>(_Expected), _Order);
    }

    void wait(const bool _Expected, const memory_order _Order = memory_order_seq_cst) const volatile noexcept {
        _Storage.wait(static_cast<decltype(_Storage)::value_type>(_Expected), _Order);
    }

    void notify_one() noexcept {
        _Storage.notify_one();
    }

    void notify_one() volatile noexcept {
        _Storage.notify_one();
    }

    void notify_all() noexcept {
        _Storage.notify_all();
    }

    void notify_all() volatile noexcept {
        _Storage.notify_all();
    }
#line 2883 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"


    atomic<long> _Storage;


#line 2889 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
};


 [[nodiscard]] inline bool atomic_flag_test(const volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test();
}

 [[nodiscard]] inline bool atomic_flag_test(const atomic_flag* const _Flag) noexcept {
    return _Flag->test();
}

 [[nodiscard]] inline bool atomic_flag_test_explicit(
    const volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test(_Order);
}

 [[nodiscard]] inline bool atomic_flag_test_explicit(
    const atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test(_Order);
}
#line 2910 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

 inline bool atomic_flag_test_and_set(atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

 inline bool atomic_flag_test_and_set(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->test_and_set();
}

 inline bool atomic_flag_test_and_set_explicit(
    atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

 inline bool atomic_flag_test_and_set_explicit(
    volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    return _Flag->test_and_set(_Order);
}

 inline void atomic_flag_clear(atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

 inline void atomic_flag_clear(volatile atomic_flag* const _Flag) noexcept {
    _Flag->clear();
}

 inline void atomic_flag_clear_explicit(atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}

 inline void atomic_flag_clear_explicit(
    volatile atomic_flag* const _Flag, const memory_order _Order) noexcept {
    _Flag->clear(_Order);
}


 inline void atomic_flag_wait(const volatile atomic_flag* const _Flag, const bool _Expected) noexcept {
    return _Flag->wait(_Expected);
}

 inline void atomic_flag_wait(const atomic_flag* const _Flag, const bool _Expected) noexcept {
    return _Flag->wait(_Expected);
}

 inline void atomic_flag_wait_explicit(
    const volatile atomic_flag* const _Flag, const bool _Expected, const memory_order _Order) noexcept {
    return _Flag->wait(_Expected, _Order);
}

 inline void atomic_flag_wait_explicit(
    const atomic_flag* const _Flag, const bool _Expected, const memory_order _Order) noexcept {
    return _Flag->wait(_Expected, _Order);
}

 inline void atomic_flag_notify_one(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->notify_one();
}

 inline void atomic_flag_notify_one(atomic_flag* const _Flag) noexcept {
    return _Flag->notify_one();
}

 inline void atomic_flag_notify_all(volatile atomic_flag* const _Flag) noexcept {
    return _Flag->notify_all();
}

 inline void atomic_flag_notify_all(atomic_flag* const _Flag) noexcept {
    return _Flag->notify_all();
}

template <class _Ty>
class _Locked_pointer {
public:
    static_assert(alignof(_Ty) >= (1 << 2), "2 low order bits are needed by _Locked_pointer");
    static constexpr uintptr_t _Lock_mask                = 3;
    static constexpr uintptr_t _Not_locked               = 0;
    static constexpr uintptr_t _Locked_notify_not_needed = 1;
    static constexpr uintptr_t _Locked_notify_needed     = 2;
    static constexpr uintptr_t _Ptr_value_mask           = ~_Lock_mask;

    constexpr _Locked_pointer() noexcept : _Storage{} {}
    explicit _Locked_pointer(_Ty* const _Ptr) noexcept : _Storage{reinterpret_cast<uintptr_t>(_Ptr)} {}

    _Locked_pointer(const _Locked_pointer&)            = delete;
    _Locked_pointer& operator=(const _Locked_pointer&) = delete;

    [[nodiscard]] _Ty* _Lock_and_load() noexcept {
        uintptr_t _Rep = _Storage.load(memory_order_relaxed);
        for (;;) {
            switch (_Rep & _Lock_mask) {
            case _Not_locked: 
                if (_Storage.compare_exchange_weak(_Rep, _Rep | _Locked_notify_not_needed)) {
                    return reinterpret_cast<_Ty*>(_Rep);
                }
                _mm_pause();
                break;

            case _Locked_notify_not_needed: 
                if (!_Storage.compare_exchange_weak(_Rep, (_Rep & _Ptr_value_mask) | _Locked_notify_needed)) {
                    
                    _mm_pause();
                    break;
                }
                _Rep = (_Rep & _Ptr_value_mask) | _Locked_notify_needed;
                [[fallthrough]];

            case _Locked_notify_needed: 
                _Storage.wait(_Rep, memory_order_relaxed);
                _Rep = _Storage.load(memory_order_relaxed);
                break;

            default: 
                :: abort();
            }
        }
    }

    void _Store_and_unlock(_Ty* const _Value) noexcept {
        const auto _Rep = _Storage.exchange(reinterpret_cast<uintptr_t>(_Value));
        if ((_Rep & _Lock_mask) == _Locked_notify_needed) {
            
            _Storage.notify_all();
        }
    }

    [[nodiscard]] _Ty* _Unsafe_load_relaxed() const noexcept {
        return reinterpret_cast<_Ty*>(_Storage.load(memory_order_relaxed));
    }

private:
    atomic<uintptr_t> _Storage;
};
#line 3044 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"

}

























#pragma warning(pop)
#pragma pack(pop)
#line 3074 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#line 3075 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\atomic"
#pragma external_header(pop)
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"



#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )










namespace std {
 enum class io_errc { 
    stream = 1
};

 template <class _Enum>
struct is_error_code_enum : false_type {};

template <>
struct is_error_code_enum<io_errc> : true_type {};

 template <class _Ty>
inline constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

 template <class _Enum>
struct is_error_condition_enum : false_type {};

template <>
struct is_error_condition_enum<errc> : true_type {};

 template <class _Ty>
inline constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

 class error_code;
 class error_condition;

namespace _Ensure_adl {
    void make_error_code()      = delete;
    void make_error_condition() = delete;
} 

 class error_category;

 [[nodiscard]] const error_category& generic_category() noexcept;
 [[nodiscard]] const error_category& iostream_category() noexcept;
 [[nodiscard]] const error_category& system_category() noexcept;

 class __declspec(novtable) error_category { 
public:





#pragma warning(push)
#pragma warning(disable : 4355) 
    constexpr error_category() noexcept : _Addr(this) {}
#pragma warning(pop)
#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

    constexpr virtual ~error_category() noexcept = default;

    [[nodiscard]] virtual const char* name() const noexcept = 0;

    [[nodiscard]] virtual string message(int _Errval) const = 0;

    [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;

    [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

    [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

    [[nodiscard]] bool operator==(const error_category& _Right) const noexcept {



        return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);
#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
    }





#line 112 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"


    [[nodiscard]] strong_ordering operator<=>(const error_category& _Right) const noexcept {
        return _Bit_cast<uintptr_t>(_Addr) <=> _Bit_cast<uintptr_t>(_Right._Addr);
    }








#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

    error_category(const error_category&)            = delete;
    error_category& operator=(const error_category&) = delete;

protected:



    union _Addr_storage {
    private:
        uintptr_t _Num;
        error_category* _Ptr;

    public:
        constexpr explicit _Addr_storage(const uintptr_t _Addr_num) noexcept : _Num(_Addr_num) {}
        constexpr explicit _Addr_storage(error_category* const _Addr_ptr) noexcept : _Ptr(_Addr_ptr) {}

        
        constexpr _Addr_storage& operator=(const uintptr_t _Addr_num) noexcept {
            _Num = _Addr_num;
            return *this;
        }
    };
    ;
    ;

    _Addr_storage _Addr;
#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

    constexpr explicit error_category(const uintptr_t _Addr_) noexcept : _Addr(_Addr_) {}

    enum : uintptr_t { 
        _Future_addr   = 1,
        _Generic_addr  = 3,
        _Iostream_addr = 5,
        _System_addr   = 7
    };
};


[[nodiscard]] inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;
#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

 class error_code { 
public:
    error_code() noexcept : _Myval(0), _Mycat(&::std:: system_category()) {} 

    error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
    error_code& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_code;
        *this = make_error_code(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: system_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] error_condition default_error_condition() const noexcept;

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_code& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }

    [[nodiscard]] friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept {
        return _System_error_equal(_Left, _Right);
    }


    [[nodiscard]] friend strong_ordering operator<=>(const error_code& _Left, const error_code& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }





#line 238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
















#line 255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};

 class error_condition { 
public:
    error_condition() noexcept : _Myval(0), _Mycat(&::std:: generic_category()) {} 

    error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr) {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); 
    }

    void assign(int _Val, const error_category& _Cat) noexcept {
        _Myval = _Val;
        _Mycat = &_Cat;
    }

    template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
    error_condition& operator=(_Enum _Errcode) noexcept {
        using _Ensure_adl::make_error_condition;
        *this = make_error_condition(_Errcode); 
        return *this;
    }

    void clear() noexcept {
        _Myval = 0;
        _Mycat = &::std:: generic_category();
    }

    [[nodiscard]] int value() const noexcept {
        return _Myval;
    }

    [[nodiscard]] const error_category& category() const noexcept {
        return *_Mycat;
    }

    [[nodiscard]] string message() const {
        return category().message(value());
    }

    explicit operator bool() const noexcept {
        return value() != 0;
    }


    [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {
        return _Left.category() == _Right.category() && _Left.value() == _Right.value();
    }


    [[nodiscard]] friend strong_ordering operator<=>(
        const error_condition& _Left, const error_condition& _Right) noexcept {
        if (const auto _Result = _Left.category() <=> _Right.category(); _Result != 0) {
            return _Result;
        }
        return _Left.value() <=> _Right.value();
    }





#line 326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"




#line 331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

    
    
    
    friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;




#line 341 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#line 342 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

private:
    int _Myval; 
    const error_category* _Mycat; 
};


[[nodiscard]] inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept {
    return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
}





























































#line 414 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

[[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept {
    
    return error_condition(_Errval, *this);
}

[[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {
    return default_error_condition(_Errval) == _Cond;
}

[[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {
    return *this == _Code.category() && _Code.value() == _Errval;
}

[[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept {
    
    return category().default_error_condition(value());
}

 [[nodiscard]] inline error_code make_error_code(errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), ::std:: generic_category());
}

 [[nodiscard]] inline error_code make_error_code(io_errc _Ec) noexcept {
    return error_code(static_cast<int>(_Ec), ::std:: iostream_category());
}

 [[nodiscard]] inline error_condition make_error_condition(errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), ::std:: generic_category());
}

 [[nodiscard]] inline error_condition make_error_condition(io_errc _Ec) noexcept {
    return error_condition(static_cast<int>(_Ec), ::std:: iostream_category());
}

template <>
struct hash<error_code> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = error_code;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const error_code& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

template <>
struct hash<error_condition> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = error_condition;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const error_condition& _Keyval) const noexcept {
        return hash<int>{}(_Keyval.value());
    }
};

class _System_error : public runtime_error { 
private:
    static string _Makestr(error_code _Errcode, string _Message) { 
        if (!_Message.empty()) {
            _Message.append(": ");
        }

        _Message.append(_Errcode.message());
        return _Message;
    }

protected:
    _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

    _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

    error_code _Mycode; 
};

 class system_error : public _System_error { 
private:
    using _Mybase = _System_error;

public:
    system_error(error_code _Errcode) : _Mybase(_Errcode) {}

    system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

    system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

    system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat)) {}

    system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message) {}

    [[nodiscard]] const error_code& code() const noexcept {
        return _Mycode;
    }






#line 518 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
};

[[noreturn]] inline void _Throw_system_error(const errc _Ec) {
    throw system_error{::std:: make_error_code(_Ec)};
}

extern "C++"  const char* __cdecl _Syserror_map(int);
extern "C++"  int __cdecl _Winerror_map(int);

struct _System_error_message {
    char* _Str;
    size_t _Length;

    explicit _System_error_message(const unsigned long _Ec) noexcept
        : _Str(nullptr), _Length(:: __std_system_error_allocate_message(_Ec, &_Str)) {}

    _System_error_message(const _System_error_message&)            = delete;
    _System_error_message& operator=(const _System_error_message&) = delete;

    ~_System_error_message() {
        :: __std_system_error_deallocate_message(_Str);
    }
};

class _Generic_error_category : public error_category { 
public:
    constexpr _Generic_error_category() noexcept : error_category(_Generic_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "generic";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        return _Syserror_map(_Errcode);
    }
};

class _Iostream_error_category2 : public error_category { 
public:
    constexpr _Iostream_error_category2() noexcept : error_category(_Iostream_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "iostream";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        if (_Errcode == static_cast<int>(io_errc::stream)) {
            static constexpr char _Iostream_error[] = "iostream stream error";
            constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; 
            return string{_Iostream_error, _Iostream_error_length};
        } else {
            return _Syserror_map(_Errcode);
        }
    }
};

class _System_error_category : public error_category { 
public:
    constexpr _System_error_category() noexcept : error_category(_System_addr) {}

    [[nodiscard]] const char* name() const noexcept override {
        return "system";
    }

    [[nodiscard]] string message(int _Errcode) const override {
        const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));
        if (_Msg._Length == 0) {
            static constexpr char _Unknown_error[] = "unknown error";
            constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; 
            return string{_Unknown_error, _Unknown_error_length};
        } else {
            ;
            return string{_Msg._Str, _Msg._Length}; 
        }
    }

    [[nodiscard]] error_condition default_error_condition(int _Errval) const noexcept override {
        if (_Errval == 0) {
            return error_condition(0, ::std:: generic_category());
        }

        
        const int _Posv = _Winerror_map(_Errval);
        if (_Posv == 0) {
            return error_condition(_Errval, ::std:: system_category());
        } else {
            return error_condition(_Posv, ::std:: generic_category());
        }
    }
};





































#line 646 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
template <class _Ty>
[[nodiscard]] const _Ty& _Immortalize_memcpy_image() noexcept {
    static constexpr _Ty _Static;
    return _Static;
}















































#line 699 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"

 [[nodiscard]] inline const error_category& generic_category() noexcept {
    return _Immortalize_memcpy_image<_Generic_error_category>();
}

 [[nodiscard]] inline const error_category& iostream_category() noexcept {
    return _Immortalize_memcpy_image<_Iostream_error_category2>();
}

 [[nodiscard]] inline const error_category& system_category() noexcept {
    return _Immortalize_memcpy_image<_System_error_category>();
}
}


extern "C" {
enum class __std_win_error : unsigned long;
}

namespace std {







[[nodiscard]] inline error_code _Make_ec(__std_win_error _Errno) noexcept { 
    return {static_cast<int>(_Errno), ::std:: system_category()};
}

[[noreturn]] inline void _Throw_system_error_from_std_win_error(const __std_win_error _Errno) {
    throw system_error{_Make_ec(_Errno)};
}
}
#line 735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"







#pragma warning(pop)
#pragma pack(pop)
#line 745 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#line 746 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\system_error"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"












#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\typeinfo"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




#pragma warning(disable : 4275) 

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"







#pragma once






#pragma warning(push)
#pragma warning(disable:   4514 4820 )

#pragma pack(push, 8)

extern "C++" { 





#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 29 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 35 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"

} 


__pragma(pack(push, 8)) extern "C" {

struct __std_type_info_data
{
    const char * _UndecoratedName;
    const char   _DecoratedName[1];
    __std_type_info_data() = delete;
    __std_type_info_data(const __std_type_info_data&) = delete;
    __std_type_info_data(__std_type_info_data&&) = delete;

    __std_type_info_data& operator=(const __std_type_info_data&) = delete;
    __std_type_info_data& operator=(__std_type_info_data&&) = delete;
};

 int __cdecl __std_type_info_compare(
      const __std_type_info_data* _Lhs,
      const __std_type_info_data* _Rhs
    );

 size_t __cdecl __std_type_info_hash(
      const __std_type_info_data* _Data
    );

 const char* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))


#pragma warning(push)
#pragma warning(disable: 4577) 
extern "C++" { 
class type_info
{
public:

    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    [[nodiscard]] size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    [[nodiscard]]

    constexpr
#line 89 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"
    bool operator==(const type_info& _Other) const noexcept
    {

        if (__builtin_is_constant_evaluated())
        {
            return &_Data == &_Other._Data;
        }
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"

        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }






#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"

    [[nodiscard]] bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    [[nodiscard]] const char* name() const noexcept
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 120 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"
    }

    [[nodiscard]] const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:

    mutable __std_type_info_data _Data;
};
} 
#pragma warning(pop)

namespace std {
    using ::type_info;
}



namespace std {

#pragma warning(push)
#pragma warning(disable: 4577) 
class bad_cast
    : public exception
{
public:

    bad_cast() noexcept
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() noexcept
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(const char* const _Message, int) noexcept
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(const char* const _Message, int) noexcept
        : bad_typeid(_Message, 1)
    {
    }
};

#pragma warning(pop)
} 

#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#pragma warning(pop) 
#line 219 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vcruntime_typeinfo.h"
#pragma external_header(pop)
#line 22 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\typeinfo"

 extern "C++" class type_info; 

namespace std {


inline constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);

 using ::type_info;


 class bad_cast;
 class bad_typeid;





























#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\typeinfo"

[[noreturn]] inline void _Throw_bad_cast() {
    throw bad_cast{};
}

}



#pragma pack(pop)
#pragma warning(pop)
#line 77 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\typeinfo"
#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\typeinfo"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"




#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )








namespace std {






 template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_copy(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    return ::std:: uninitialized_copy(_First, _Last, _Dest);
}
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_copy_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        uninitialized_copy_result<_It, _Out> operator()(_It _First1, _Se _Last1, _Out _First2, _OSe _Last2) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Uninitialized_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First1)),
                _Unwrap_sent<_It>(::std:: move(_Last1)), _Unwrap_iter<_OSe>(::std:: move(_First2)),
                _Unwrap_sent<_Out>(::std:: move(_Last2)));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_First2, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_reference_t<_Rng1>>
        uninitialized_copy_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _UResult = _Uninitialized_copy_unchecked(
                _Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            return {::std:: move(_First1), _Rewrap_iterator(_Range2, ::std:: move(_UResult.out))};
        }

    private:
        template <class _It, class _Se, class _Out, class _OSe>
        [[nodiscard]] static uninitialized_copy_result<_It, _Out> _Uninitialized_copy_unchecked(
            _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
            ;
            ;
            ;
            ;
            ;

            constexpr bool _Is_sized1 = sized_sentinel_for<_Se, _It>;
            constexpr bool _Is_sized2 = sized_sentinel_for<_OSe, _Out>;
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_Se, _It>
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (_Is_sized1 && _Is_sized2) {
                    return _Copy_memcpy_common(_IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)), _OFirst,
                        ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                } else if constexpr (_Is_sized1) {
                    return _Copy_memcpy_distance(_IFirst, _OFirst, _IFirst, ::std::ranges:: next(_IFirst, ::std:: move(_ILast)));
                } else if constexpr (_Is_sized2) {
                    return _Copy_memcpy_distance(_IFirst, _OFirst, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                } else {
                    ;
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _IFirst != _ILast && _Backout._Last != _OLast; ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                return {::std:: move(_IFirst), _Backout._Release()};
            }
        }
    };

     inline constexpr _Uninitialized_copy_fn uninitialized_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 126 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _InIt, class _Diff, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _Dest;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(*_UFirst);
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_copy_n(_ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_copy_n(_First, _Count, _Dest);
}
#line 167 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_copy_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_copy_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_reference_t<_It>>
        uninitialized_copy_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) const {
            if (_Count <= 0) {
                return {::std:: move(_First1), ::std:: move(_First2)};
            }

            _Adl_verify_range(_First2, _Last2);
            auto _IFirst = _Get_unwrapped_n(::std:: move(_First1), _Count);
            auto _OFirst = _Unwrap_iter<_OSe>(::std:: move(_First2));
            auto _OLast  = _Unwrap_sent<_Out>(::std:: move(_Last2));
            if constexpr (_Iter_copy_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                    _IFirst = ::std:: move(_UResult.in);
                    _OFirst = ::std:: move(_UResult.out);
                } else {
                    auto _UResult = _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst       = ::std:: move(_UResult.in);
                    _OFirst       = ::std:: move(_UResult.out);
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(*_IFirst);
                }

                _OFirst = _Backout._Release();
            }

            _Seek_wrapped(_First1, ::std:: move(_IFirst));
            _Seek_wrapped(_First2, ::std:: move(_OFirst));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }
    };

     inline constexpr _Uninitialized_copy_n_fn uninitialized_copy_n{_Not_quite_object::_Construct_tag{}};
} 
#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


 template <class _InIt, class _NoThrowFwdIt>
_NoThrowFwdIt uninitialized_move(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    _Seek_wrapped(_Dest, ::std:: _Uninitialized_move_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

 template <class _ExPo, class _FwdIt, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_move(_ExPo&&, const _FwdIt _First, const _FwdIt _Last, _NoThrowFwdIt _Dest) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    return ::std:: uninitialized_move(_First, _Last, _Dest);
}


namespace ranges {
    class _Uninitialized_move_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, _No_throw_forward_iterator _Out,
            _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        uninitialized_move_result<_It, _Out> operator()(_It _First1, _Se _Last1, _Out _First2, _OSe _Last2) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = ::std::ranges:: _Uninitialized_move_unchecked(_Unwrap_iter<_Se>(::std:: move(_First1)),
                _Unwrap_sent<_It>(::std:: move(_Last1)), _Unwrap_iter<_OSe>(::std:: move(_First2)),
                _Unwrap_sent<_Out>(::std:: move(_Last2)));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_First2, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, _No_throw_forward_range _Rng2>
            requires constructible_from<range_value_t<_Rng2>, range_rvalue_reference_t<_Rng1>>
        uninitialized_move_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _UResult = ::std::ranges:: _Uninitialized_move_unchecked(
                _Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            return {::std:: move(_First1), _Rewrap_iterator(_Range2, ::std:: move(_UResult.out))};
        }
    };

     inline constexpr _Uninitialized_move_fn uninitialized_move{_Not_quite_object::_Construct_tag{}};
} 
#line 281 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _InIt, class _Diff, class _NoThrowFwdIt>
pair<_InIt, _NoThrowFwdIt> uninitialized_move_n(_InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return {_First, _Dest};
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    auto _UDest  = _Get_unwrapped_n(_Dest, _Count);
    if constexpr (_Iter_move_cat<decltype(_UFirst), decltype(_UDest)>::_Bitcopy_constructible) {
        _UDest = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), _UDest);
        _UFirst += _Count;
    } else {
        _Uninitialized_backout<decltype(_UDest)> _Backout{_UDest};

        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Backout._Emplace_back(::std:: move(*_UFirst));
        }

        _UDest = _Backout._Release();
    }

    _Seek_wrapped(_Dest, _UDest);
    _Seek_wrapped(_First, _UFirst);
    return {_First, _Dest};
}

 template <class _ExPo, class _FwdIt, class _Diff, class _NoThrowFwdIt,
    _Enable_if_execution_policy_t<_ExPo> = 0>
pair<_FwdIt, _NoThrowFwdIt> uninitialized_move_n(
    _ExPo&&, const _FwdIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_move_n(_First, _Count, _Dest);
}

 template <class _ExPo, class _NoThrowFwdIt, class _Tval, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_fill(_ExPo&&, const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    ::std:: uninitialized_fill(_First, _Last, _Val);
}
#line 333 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


namespace ranges {
     template <class _In, class _Out>
    using uninitialized_move_n_result = in_out_result<_In, _Out>;

    class _Uninitialized_move_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, _No_throw_forward_iterator _Out, _No_throw_sentinel_for<_Out> _OSe>
            requires constructible_from<iter_value_t<_Out>, iter_rvalue_reference_t<_It>>
        uninitialized_move_n_result<_It, _Out> operator()(
            _It _First1, iter_difference_t<_It> _Count, _Out _First2, _OSe _Last2) const {
            if (_Count <= 0) {
                return {::std:: move(_First1), ::std:: move(_First2)};
            }

            _Adl_verify_range(_First2, _Last2);
            auto _IFirst      = _Get_unwrapped_n(::std:: move(_First1), _Count);
            auto _OFirst      = _Unwrap_iter<_OSe>(::std:: move(_First2));
            const auto _OLast = _Unwrap_sent<_Out>(::std:: move(_Last2));
            if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_constructible
                          && _Sized_or_unreachable_sentinel_for<_OSe, _Out>) {
                if constexpr (sized_sentinel_for<_OSe, _Out>) {
                    auto _UResult = _Copy_memcpy_common(
                        _IFirst, _IFirst + _Count, _OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
                    _IFirst = ::std:: move(_UResult.in);
                    _OFirst = ::std:: move(_UResult.out);
                } else {
                    auto _UResult = _Copy_memcpy_count(_IFirst, _OFirst, static_cast<size_t>(_Count));
                    _IFirst       = ::std:: move(_UResult.in);
                    _OFirst       = ::std:: move(_UResult.out);
                }
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Count > 0 && _Backout._Last != _OLast; --_Count, (void) ++_IFirst) {
                    _Backout._Emplace_back(::std::ranges:: iter_move(_IFirst));
                }

                _OFirst = _Backout._Release();
            }

            _Seek_wrapped(_First1, ::std:: move(_IFirst));
            _Seek_wrapped(_First2, ::std:: move(_OFirst));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }
    };

     inline constexpr _Uninitialized_move_n_fn uninitialized_move_n{_Not_quite_object::_Construct_tag{}};

    class _Uninitialized_fill_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _It operator()(_It _First, _Se _Last, const _Ty& _Val) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_fill_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val);

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng, class _Ty>
            requires constructible_from<range_value_t<_Rng>, const _Ty&>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Val) const {
            return _Rewrap_iterator(_Range, _Uninitialized_fill_unchecked(_Ubegin(_Range), _Uend(_Range), _Val));
        }

    private:
        template <class _It, class _Se, class _Ty>
        [[nodiscard]] static _It _Uninitialized_fill_unchecked(_It _OFirst, _Se _OLast, const _Ty& _Val) {
            ;
            ;
            ;

            if constexpr (_Fill_memset_is_safe<_It, _Ty>) {
                const auto _OFinal = ::std::ranges:: next(_OFirst, ::std:: move(_OLast));
                _Fill_memset(_OFirst, _Val, static_cast<size_t>(_OFinal - _OFirst));
                return _OFinal;
            } else {
                if constexpr (_Fill_zero_memset_is_safe<_It, _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        const auto _OFinal = ::std::ranges:: next(_OFirst, ::std:: move(_OLast));
                        _Fill_zero_memset(_OFirst, static_cast<size_t>(_OFinal - _OFirst));
                        return _OFinal;
                    }
                }

                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back(_Val);
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_fill_fn uninitialized_fill{_Not_quite_object::_Construct_tag{}};
} 
#line 440 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff, class _Tval>
_NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Tval>) {
        _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
        _UFirst += _Count;
    } else {
        if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Tval>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
                return _First;
            }
        }

        _Uninitialized_backout<decltype(_UFirst)> _Backout{_UFirst};

        for (; _Count > 0; --_Count) {
            _Backout._Emplace_back(_Val);
        }

        _UFirst = _Backout._Release();
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


 template <class _ExPo, class _NoThrowFwdIt, class _Diff, class _Tval,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_fill_n(
    _ExPo&&, const _NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_NoThrowFwdIt> && is_lvalue_reference_v<_Iter_ref_t<_NoThrowFwdIt>>, "Parallel specialized <memory> algorithms require the iterator type to be forward iterator and dereference " "to lvalues.");

    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    return ::std:: uninitialized_fill_n(_First, _Count, _Val);
}
#line 489 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


namespace ranges {
    class _Uninitialized_fill_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, class _Ty>
            requires constructible_from<iter_value_t<_It>, const _Ty&>
        _It operator()(_It _First, iter_difference_t<_It> _Count, const _Ty& _Val) const {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                _Fill_memset(_UFirst, _Val, static_cast<size_t>(_Count));
                _Seek_wrapped(_First, _UFirst + _Count);
            } else {
                if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                    if (_Is_all_bits_zero(_Val)) {
                        _Fill_zero_memset(_UFirst, static_cast<size_t>(_Count));
                        _Seek_wrapped(_First, _UFirst + _Count);
                        return _First;
                    }
                }

                _Uninitialized_backout _Backout{::std:: move(_UFirst)};

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back(_Val);
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_fill_n_fn uninitialized_fill_n{_Not_quite_object::_Construct_tag{}};

    class _Construct_at_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        
        template <class _Ty, class... _Types>
            requires requires(_Ty* _Ptr, _Types&&... _Args) {
                ::new (static_cast<void*>(_Ptr)) _Ty(static_cast<_Types&&>(_Args)...); 
            }
        constexpr _Ty* operator()(_Ty* _Location, _Types&&... _Args) const
            noexcept(noexcept(::new (static_cast<void*>(_Location))
                    _Ty(::std:: forward<_Types>(_Args)...)))  {
            
            [[msvc::constexpr]] return ::new (static_cast<void*>(_Location)) _Ty(::std:: forward<_Types>(_Args)...);
        }
    };

     inline constexpr _Construct_at_fn construct_at{_Not_quite_object::_Construct_tag{}};

    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    [[nodiscard]] constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept;

    class _Destroy_at_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <destructible _Ty>
        constexpr void operator()(_Ty* const _Location) const noexcept {
            if constexpr (is_array_v<_Ty>) {
                (void) ::std::ranges:: _Destroy_unchecked(::std::ranges:: begin(*_Location), ::std::ranges:: end(*_Location));
            } else {
                _Location->~_Ty();
            }
        }
    };

     inline constexpr _Destroy_at_fn destroy_at{_Not_quite_object::_Construct_tag{}};
} 
#line 570 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


 template <class _NoThrowFwdIt>
constexpr void destroy(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    _Adl_verify_range(_First, _Last);
    _Destroy_range(_Get_unwrapped(_First), _Get_unwrapped(_Last));
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void destroy(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
        requires destructible<iter_value_t<_It>>
    [[nodiscard]] constexpr _It _Destroy_unchecked(_It _First, _Se _Last) noexcept {
        if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
            ::std::ranges:: advance(_First, ::std:: move(_Last));
        } else {
            for (; _First != _Last; ++_First) {
                ::std::ranges:: destroy_at(::std:: addressof(*_First));
            }
        }

        return _First;
    }

    class _Destroy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_input_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires destructible<iter_value_t<_It>>
        constexpr _It operator()(_It _First, _Se _Last) const noexcept {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First,
                ::std::ranges:: _Destroy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last))));
            return _First;
        }

        template <_No_throw_input_range _Rng>
            requires destructible<range_value_t<_Rng>>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const noexcept {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(
                _First, ::std::ranges:: _Destroy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range)));
            return _First;
        }
    };

     inline constexpr _Destroy_fn destroy{_Not_quite_object::_Construct_tag{}};
} 
#line 624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
constexpr _NoThrowFwdIt destroy_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    auto _UFirst = _Get_unwrapped_n(_First, _Count);
    if constexpr (is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
        ::std:: advance(_UFirst, _Count);
    } else {
        for (; _Count > 0; --_Count, (void) ++_UFirst) {
            _Destroy_in_place(*_UFirst);
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt destroy_n(_ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Destroy_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_input_iterator _It>
            requires destructible<iter_value_t<_It>>
        constexpr _It operator()(_It _First, const iter_difference_t<_It> _Count_raw) const noexcept {
            _Algorithm_int_t<iter_difference_t<_It>> _Count = _Count_raw;
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (is_trivially_destructible_v<iter_value_t<_It>>) {
                ::std::ranges:: advance(_UFirst, _Count);
            } else {
                do {
                    ::std::ranges:: destroy_at(::std:: addressof(*_UFirst));
                    ++_UFirst;
                    --_Count;
                } while (_Count > 0);
            }

            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }
    };

     inline constexpr _Destroy_n_fn destroy_n{_Not_quite_object::_Construct_tag{}};
} 
#line 682 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt>
void uninitialized_default_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    using _Ty = remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>;
    _Adl_verify_range(_First, _Last);
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        _Uninitialized_backout _Backout{_Get_unwrapped(_First)};

        for (const auto _ULast = _Get_unwrapped(_Last); _Backout._Last != _ULast; ++_Backout._Last) {
            _Default_construct_in_place(*_Backout._Last);
        }

        _Backout._Release();
    }
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_default_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    class _Uninitialized_default_construct_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, _Se _Last) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_default_construct_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
            auto _UResult = _Uninitialized_default_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static _It _Uninitialized_default_construct_unchecked(_It _OFirst, const _Se _OLast) {
            ;
            ;
            ;

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                ::std::ranges:: advance(_OFirst, _OLast);
                return _OFirst;
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                for (; _Backout._Last != _OLast; ++_Backout._Last) {
                    _Default_construct_in_place(*_Backout._Last);
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_default_construct_fn uninitialized_default_construct{
        _Not_quite_object::_Construct_tag{}};
} 
#line 754 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_default_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    using _Ty                      = _Iter_value_t<_NoThrowFwdIt>;
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if constexpr (is_trivially_default_constructible_v<_Ty>) {
        ::std:: advance(_First, _Count);
    } else {
        _Uninitialized_backout _Backout{_Get_unwrapped_n(_First, _Count)};

        for (; _Count > 0; ++_Backout._Last, (void) --_Count) {
            _Default_construct_in_place(*_Backout._Last);
        }

        _Seek_wrapped(_First, _Backout._Release());
    }
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_default_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Uninitialized_default_construct_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, iter_difference_t<_It> _Count) const {
            if (_Count <= 0) {
                return _First;
            }

            using _Ty = remove_reference_t<iter_reference_t<_It>>;
            if constexpr (is_trivially_default_constructible_v<_Ty>) {
                ::std::ranges:: advance(_First, _Count);
            } else {
                _Uninitialized_backout _Backout{_Get_unwrapped_n(::std:: move(_First), _Count)};

                for (; _Count > 0; --_Count, (void) ++_Backout._Last) {
                    _Default_construct_in_place(*_Backout._Last);
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_default_construct_n_fn uninitialized_default_construct_n{
        _Not_quite_object::_Construct_tag{}};
} 
#line 815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt>
void uninitialized_value_construct(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Use_memset_value_construct_v<_Unwrapped_t<const _NoThrowFwdIt&>>) {
        _Zero_range(_UFirst, _ULast);
    } else {
        _Uninitialized_backout _Backout{_UFirst};

        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back();
        }

        _Backout._Release();
    }
}

 template <class _ExPo, class _NoThrowFwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void uninitialized_value_construct(_ExPo&& _Exec, _NoThrowFwdIt _First, _NoThrowFwdIt _Last) noexcept; 


namespace ranges {
    class _Uninitialized_value_construct_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It, _No_throw_sentinel_for<_It> _Se>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, _Se _Last) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Uninitialized_value_construct_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <_No_throw_forward_range _Rng>
            requires default_initializable<range_value_t<_Rng>>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
            auto _UResult = _Uninitialized_value_construct_unchecked(_Ubegin(_Range), _Uend(_Range));

            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static _It _Uninitialized_value_construct_unchecked(_It _OFirst, _Se _OLast) {
            ;
            ;
            ;

            if constexpr (_Use_memset_value_construct_v<_It>) {
                return _Zero_range(_OFirst, ::std::ranges:: next(_OFirst, ::std:: move(_OLast)));
            } else {
                _Uninitialized_backout _Backout{::std:: move(_OFirst)};

                while (_Backout._Last != _OLast) {
                    _Backout._Emplace_back();
                }

                return _Backout._Release();
            }
        }
    };

     inline constexpr _Uninitialized_value_construct_fn uninitialized_value_construct{
        _Not_quite_object::_Construct_tag{}};
} 
#line 888 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _NoThrowFwdIt, class _Diff>
_NoThrowFwdIt uninitialized_value_construct_n(_NoThrowFwdIt _First, const _Diff _Count_raw) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    _Seek_wrapped(_First, _Uninitialized_value_construct_n_unchecked1(_Get_unwrapped_n(_First, _Count), _Count));
    return _First;
}

 template <class _ExPo, class _NoThrowFwdIt, class _Diff, _Enable_if_execution_policy_t<_ExPo> = 0>
_NoThrowFwdIt uninitialized_value_construct_n(
    _ExPo&& _Exec, _NoThrowFwdIt _First, _Diff _Count_raw) noexcept; 


namespace ranges {
    class _Uninitialized_value_construct_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <_No_throw_forward_iterator _It>
            requires default_initializable<iter_value_t<_It>>
        _It operator()(_It _First, iter_difference_t<_It> _Count) const {
            if (_Count <= 0) {
                return _First;
            }

            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (_Use_memset_value_construct_v<_It>) {
                _Seek_wrapped(_First, _Zero_range(_UFirst, _UFirst + _Count));
            } else {
                _Uninitialized_backout _Backout{::std:: move(_UFirst)};

                for (; _Count > 0; --_Count) {
                    _Backout._Emplace_back();
                }

                _Seek_wrapped(_First, _Backout._Release());
            }
            return _First;
        }
    };

     inline constexpr _Uninitialized_value_construct_n_fn uninitialized_value_construct_n{
        _Not_quite_object::_Construct_tag{}};
} 
#line 938 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
#line 939 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


template <class _PtrTy>
[[nodiscard]] void* _Voidify_unfancy(_PtrTy _Ptr) noexcept {
    if constexpr (is_pointer_v<_PtrTy>) {
        return _Ptr;
    } else {
        return ::std:: addressof(*_Ptr);
    }
}
#line 950 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

















































#line 1000 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"












































































































#line 1109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 class bad_weak_ptr : public exception { 
public:
    bad_weak_ptr() noexcept {}

    [[nodiscard]] const char*  what() const noexcept override {
        
        return "bad_weak_ptr";
    }
};

[[noreturn]] inline void _Throw_bad_weak_ptr() {
    throw bad_weak_ptr{};
}

class __declspec(novtable) _Ref_count_base { 
private:










    virtual void _Destroy() noexcept     = 0; 
    virtual void _Delete_this() noexcept = 0; 
#line 1139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    _Atomic_counter_t _Uses  = 1;
    _Atomic_counter_t _Weaks = 1;

protected:
    constexpr _Ref_count_base() noexcept = default; 

public:
    _Ref_count_base(const _Ref_count_base&)            = delete;
    _Ref_count_base& operator=(const _Ref_count_base&) = delete;

    virtual ~_Ref_count_base() noexcept {} 

    bool _Incref_nz() noexcept { 
        auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);



        long _Count = __iso_volatile_load32(reinterpret_cast<volatile int*>(&_Volatile_uses));
#line 1159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
        while (_Count != 0) {
            const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + 1, _Count);
            if (_Old_value == _Count) {
                return true;
            }

            _Count = _Old_value;
        }

        return false;
    }

    void _Incref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
    }

    void _Incwref() noexcept { 
        _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
    }

    void _Decref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0) {
            _Destroy();
            _Decwref();
        }
    }

    void _Decwref() noexcept { 
        if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0) {
            _Delete_this();
        }
    }

    long _Use_count() const noexcept {
        return static_cast<long>(_Uses);
    }

    virtual void* _Get_deleter(const type_info&) const noexcept {
        return nullptr;
    }
};

template <class _Ty>
class _Ref_count : public _Ref_count_base { 
public:
    explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px) {}

private:
    void _Destroy() noexcept override { 
        delete _Ptr;
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Ty* _Ptr;
};

template <class _Resource, class _Dx>
class _Ref_count_resource : public _Ref_count_base { 
public:
    _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Px) {}

    ~_Ref_count_resource() noexcept override = default; 

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1234 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

        return nullptr;
    }

private:
    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }

    _Compressed_pair<_Dx, _Resource> _Mypair;
};

template <class _Resource, class _Dx, class _Alloc>
class _Ref_count_resource_alloc : public _Ref_count_base {
    
public:
    _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(),
          _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _One_then_variadic_args_t{}, _Ax, _Px) {}

    ~_Ref_count_resource_alloc() noexcept override = default; 

    void* _Get_deleter(const type_info& _Typeid) const noexcept override {

        if (_Typeid == typeid(_Dx)) {
            return const_cast<_Dx*>(::std:: addressof(_Mypair._Get_first()));
        }


#line 1268 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

        return nullptr;
    }

private:
    using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

    void _Destroy() noexcept override { 
        _Mypair._Get_first()(_Mypair._Myval2._Myval2);
    }

    void _Delete_this() noexcept override { 
        _Myalty _Al = _Mypair._Myval2._Get_first();
        this->~_Ref_count_resource_alloc();
        _Deallocate_plain(_Al, this);
    }

    _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
};

 template <class _Ty>
struct default_delete;

 template <class _Ty, class _Dx = default_delete<_Ty>>
class unique_ptr;

 template <class _Ty>
class shared_ptr;

 template <class _Ty>
class weak_ptr;

template <class _Yty, class = void>
struct _Can_enable_shared : false_type {}; 

template <class _Yty>
struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type {
    
};

struct _Exception_ptr_access;

template <class _Ty>
class _Ptr_base { 
public:
    using element_type = remove_extent_t<_Ty>;

    [[nodiscard]] long use_count() const noexcept {
        return _Rep ? _Rep->_Use_count() : 0;
    }

    template <class _Ty2>
    [[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept { 
        return _Rep < _Right._Rep;
    }

    _Ptr_base(const _Ptr_base&)            = delete;
    _Ptr_base& operator=(const _Ptr_base&) = delete;

protected:
    [[nodiscard]] element_type* get() const noexcept {
        return _Ptr;
    }

    constexpr _Ptr_base() noexcept = default;

    ~_Ptr_base() = default;

    template <class _Ty2>
    void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
        
        _Ptr = _Right._Ptr;
        _Rep = _Right._Rep;

        _Right._Ptr = nullptr;
        _Right._Rep = nullptr;
    }

    template <class _Ty2>
    void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
        
        _Other._Incref();

        _Ptr = _Other._Ptr;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
        
        _Other._Incref();

        _Ptr = _Px;
        _Rep = _Other._Rep;
    }

    template <class _Ty2>
    void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
        
        _Ptr = _Px;
        _Rep = _Other._Rep;

        _Other._Ptr = nullptr;
        _Other._Rep = nullptr;
    }

    template <class _Ty0>
    friend class weak_ptr; 

    template <class _Ty2>
    bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep && _Other._Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            return true;
        }

        return false;
    }

    void _Incref() const noexcept {
        if (_Rep) {
            _Rep->_Incref();
        }
    }

    void _Decref() noexcept { 
        if (_Rep) {
            _Rep->_Decref();
        }
    }

    void _Swap(_Ptr_base& _Right) noexcept { 
        ::std:: swap(_Ptr, _Right._Ptr);
        ::std:: swap(_Rep, _Right._Rep);
    }

    template <class _Ty2>
    void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { 
        if (_Other._Rep) {
            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
            _Rep->_Incwref();
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
        
        if (_Other._Rep) {
            _Rep = _Other._Rep; 
            _Rep->_Incwref();

            if (_Rep->_Incref_nz()) {
                _Ptr = _Other._Ptr; 
                _Rep->_Decref();
            } else {
                ;
            }
        } else {
            ;
        }
    }

    template <class _Ty2>
    void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
        
        _Rep        = _Other._Rep; 
        _Other._Rep = nullptr;

        if (_Rep && _Rep->_Incref_nz()) {
            _Ptr = _Other._Ptr; 
            _Rep->_Decref();
        } else {
            ;
        }

        _Other._Ptr = nullptr;
    }

    void _Incwref() const noexcept {
        if (_Rep) {
            _Rep->_Incwref();
        }
    }

    void _Decwref() noexcept { 
        if (_Rep) {
            _Rep->_Decwref();
        }
    }

private:
    element_type* _Ptr{nullptr};
    _Ref_count_base* _Rep{nullptr};

    template <class _Ty0>
    friend class _Ptr_base;

    friend shared_ptr<_Ty>;

    template <class _Ty0>
    friend struct atomic;

    friend _Exception_ptr_access;


    template <class _Dx, class _Ty0>
    friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
#line 1482 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
};

template <class _Yty, class = void>
struct _Can_scalar_delete : false_type {};
template <class _Yty>
struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std:: declval<_Yty*>())>> : bool_constant<!is_void_v<_Yty>> {};

template <class _Yty, class = void>
struct _Can_array_delete : false_type {};
template <class _Yty>
struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std:: declval<_Yty*>())>> : true_type{};

template <class _Fx, class _Arg, class = void>
struct _Can_call_function_object : false_type {};
template <class _Fx, class _Arg>
struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std:: declval<_Fx>()(::std:: declval<_Arg>()))>> : true_type {};

template <class _Yty, class _Ty>
struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type {};
template <class _Yty, class _Uty>
struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type {};
template <class _Yty, class _Uty, size_t _Ext>
struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type {};

template <class _Yty, class _Ty>
struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type {
    
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type {
    
};
template <class _Uty, size_t _Ext>
struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type {
    
};

template <class _Ux>
struct _Temporary_owner {
    _Ux* _Ptr;

    explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_) {}
    _Temporary_owner(const _Temporary_owner&)            = delete;
    _Temporary_owner& operator=(const _Temporary_owner&) = delete;
    ~_Temporary_owner() {
        delete _Ptr;
    }
};

template <class _UxptrOrNullptr, class _Dx>
struct _Temporary_owner_del {
    _UxptrOrNullptr _Ptr;
    _Dx& _Dt;
    bool _Call_deleter = true;

    explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_) {}
    _Temporary_owner_del(const _Temporary_owner_del&)            = delete;
    _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
    ~_Temporary_owner_del() {
        if (_Call_deleter) {
            _Dt(_Ptr);
        }
    }
};

 template <class _Ty>
class shared_ptr : public _Ptr_base<_Ty> { 
private:
    using _Mybase = _Ptr_base<_Ty>;

public:
    using typename _Mybase::element_type;


    using weak_type = weak_ptr<_Ty>;
#line 1567 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    constexpr shared_ptr() noexcept = default;

    constexpr shared_ptr(nullptr_t) noexcept {} 

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    explicit shared_ptr(_Ux* _Px) { 
        if constexpr (is_array_v<_Ty>) {
            _Setpd(_Px, default_delete<_Ux[]>{});
        } else {
            _Temporary_owner<_Ux> _Owner(_Px);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
            _Owner._Ptr = nullptr;
        }
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt) { 
        _Setpd(_Px, ::std:: move(_Dt));
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(_Px, ::std:: move(_Dt), _Ax);
    }

    template <class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt) { 
        _Setpd(nullptr, ::std:: move(_Dt));
    }

    template <class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
    shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax) { 
        _Setpda(nullptr, ::std:: move(_Dt), _Ax);
    }

    template <class _Ty2>
    shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept {
        
        this->_Alias_construct_from(_Right, _Px);
    }

    template <class _Ty2>
    shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept {
        
        this->_Alias_move_construct_from(::std:: move(_Right), _Px);
    }

    shared_ptr(const shared_ptr& _Other) noexcept { 
        this->_Copy_construct_from(_Other);
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        
        this->_Copy_construct_from(_Other);
    }

    shared_ptr(shared_ptr&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept { 
        this->_Move_construct_from(::std:: move(_Right));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    explicit shared_ptr(const weak_ptr<_Ty2>& _Other) { 
        if (!this->_Construct_from_weak(_Other)) {
            _Throw_bad_weak_ptr();
        }
    }








#line 1660 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr(unique_ptr<_Ux, _Dx>&& _Other) {
        using _Fancy_t   = typename unique_ptr<_Ux, _Dx>::pointer;
        using _Raw_t     = typename unique_ptr<_Ux, _Dx>::element_type*;
        using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std:: ref(_Other.get_deleter())), _Dx>;

        const _Fancy_t _Fancy = _Other.get();

        if (_Fancy) {
            const _Raw_t _Raw = _Fancy;
            const auto _Rx =
                new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, ::std:: forward<_Dx>(_Other.get_deleter()));
            _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
            _Other.release();
        }
    }

    ~shared_ptr() noexcept { 
        this->_Decref();
    }

    shared_ptr& operator=(const shared_ptr& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        shared_ptr(_Right).swap(*this);
        return *this;
    }

    shared_ptr& operator=(shared_ptr&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }







#line 1714 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>,
                        is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>,
            int> = 0>
    shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right) { 
        shared_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    void swap(shared_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    void reset() noexcept { 
        shared_ptr().swap(*this);
    }

    template <class _Ux,
        enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px) { 
        shared_ptr(_Px).swap(*this);
    }

    template <class _Ux, class _Dx,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px, _Dx _Dt) { 
        shared_ptr(_Px, _Dt).swap(*this);
    }

    template <class _Ux, class _Dx, class _Alloc,
        enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>,
                        _SP_convertible<_Ux, _Ty>>,
            int> = 0>
    void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax) { 
        shared_ptr(_Px, _Dt, _Ax).swap(*this);
    }

    using _Mybase::get;

    template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
    [[nodiscard]] _Ty2& operator*() const noexcept {
        return *get();
    }

    template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Ty2* operator->() const noexcept {
        return get();
    }

    template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
    [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const noexcept  {
        return get()[_Idx];
    }






#line 1779 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    explicit operator bool() const noexcept {
        return get() != nullptr;
    }

private:
    template <class _UxptrOrNullptr, class _Dx>
    void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt) { 
        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Set_ptr_rep_and_enable_shared(
            _Owner._Ptr, new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std:: move(_Dt)));
        _Owner._Call_deleter = false;
    }

    template <class _UxptrOrNullptr, class _Dx, class _Alloc>
    void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax) { 
        using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

        _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
        _Alref_alloc _Alref(_Ax);
        _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std:: move(_Dt), _Ax);
        _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
        _Constructor._Ptr    = nullptr;
        _Owner._Call_deleter = false;
    }


    template <class _Ty0, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(_Types&&... _Args);

    template <class _Ty0, class _Alloc, class... _Types>
    friend enable_if_t<!is_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(const _Alloc& _Al_arg);

    template <class _Ty0>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared(const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0, class _Alloc>
    friend enable_if_t<is_bounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared(
        const _Alloc& _Al_arg, const remove_extent_t<_Ty0>& _Val);

    template <class _Ty0>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> make_shared_for_overwrite();

    template <class _Ty0, class _Alloc>
    friend enable_if_t<!is_unbounded_array_v<_Ty0>, shared_ptr<_Ty0>> allocate_shared_for_overwrite(
        const _Alloc& _Al_arg);

    template <class _Ty0, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Make_shared_unbounded_array(size_t _Count, const _ArgTypes&... _Args);

    template <class _Ty0, class _Alloc, class... _ArgTypes>
    friend shared_ptr<_Ty0> _Allocate_shared_unbounded_array(
        const _Alloc& _Al, size_t _Count, const _ArgTypes&... _Args);






#line 1847 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    template <class _Ux>
    void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = _Px;
        this->_Rep = _Rx;
        if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
            if (_Px && _Px->_Wptr.expired()) {
                _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
            }
        }
    }

    void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept { 
        this->_Ptr = nullptr;
        this->_Rep = _Rx;
    }
};


template <class _Ty>
shared_ptr(weak_ptr<_Ty>) -> shared_ptr<_Ty>;

template <class _Ty, class _Dx>
shared_ptr(unique_ptr<_Ty, _Dx>) -> shared_ptr<_Ty>;
#line 1872 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty1, class _Ty2>
[[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() == _Right.get();
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] strong_ordering operator<=>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {
    return _Left.get() <=> _Right.get();
}

























#line 1909 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty>
[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() == nullptr;
}


 template <class _Ty>
[[nodiscard]] strong_ordering operator<=>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept {
    return _Left.get() <=> static_cast<shared_ptr<_Ty>::element_type*>(nullptr);
}























































#line 1976 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Elem, class _Traits, class _Ty>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px) {
    
    return _Out << _Px.get();
}

 template <class _Ty>
void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(_Other, _Ptr);
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
    return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
}


 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    return {};
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept {
    
    const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

    if (_Ptr) {
        return shared_ptr<_Ty1>(::std:: move(_Other), _Ptr);
    }

    return {};
}





#line 2060 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


 template <class _Dx, class _Ty>
[[nodiscard]] _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept {
    
    if (_Sx._Rep) {
        return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
    }

    return nullptr;
}



#line 2075 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


struct _For_overwrite_tag {
    explicit _For_overwrite_tag() = default;
};
#line 2081 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

template <class _Ty>
class _Ref_count_obj2 : public _Ref_count_base { 
public:
    template <class... _Types>
    explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

        if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
            ::std:: _Default_construct_in_place(_Storage._Value);
            ((void) _Args, ...);
        } else
#line 2093 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
        {
            ::std:: _Construct_in_place(_Storage._Value, ::std:: forward<_Types>(_Args)...);
        }
    }

    ~_Ref_count_obj2() noexcept override { 
        

        
        
        
    }

    union {
        _Wrap<remove_cv_t<_Ty>> _Storage;
    };

private:
    void _Destroy() noexcept override { 
        _Destroy_in_place(_Storage._Value);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }
};


template <size_t _Align>
struct _Alignas_storage_unit {
    alignas(_Align) char _Space[_Align];
};

enum class _Check_overflow : bool { _Nope, _Yes };

template <class _Refc, _Check_overflow _Check>
[[nodiscard]] size_t _Calculate_bytes_for_flexible_array(const size_t _Count) noexcept(_Check == _Check_overflow::_Nope) {
    constexpr size_t _Align = alignof(_Refc);

    size_t _Bytes = sizeof(_Refc); 

    if (_Count > 1) {
        constexpr size_t _Element_size = sizeof(typename _Refc::_Element_type);

        size_t _Extra_bytes;

        if constexpr (_Check == _Check_overflow::_Yes) {
            _Extra_bytes = _Get_size_of_n<_Element_size>(_Count - 1); 

            if (_Extra_bytes > static_cast<size_t>(-1) - _Bytes - (_Align - 1)) { 
                _Throw_bad_array_new_length(); 
            }
        } else {
            _Extra_bytes = _Element_size * (_Count - 1);
        }

        _Bytes += _Extra_bytes;

        _Bytes = (_Bytes + _Align - 1) & ~(_Align - 1);
    }






    return _Bytes;
}

template <class _Refc>
[[nodiscard]] _Refc* _Allocate_flexible_array(const size_t _Count) {
    const size_t _Bytes = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);

    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > 16ull) {
        return static_cast<_Refc*>(::operator new(_Bytes, align_val_t{_Align}));
    } else
#line 2171 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
    {
        return static_cast<_Refc*>(::operator new(_Bytes));
    }
}

template <class _Refc>
void _Deallocate_flexible_array(_Refc* const _Ptr) noexcept {

    constexpr size_t _Align = alignof(_Refc);
    if constexpr (_Align > 16ull) {
        ::operator delete(static_cast<void*>(_Ptr), align_val_t{_Align});
    } else
#line 2184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
    {
        ::operator delete(static_cast<void*>(_Ptr));
    }
}

template <class _NoThrowIt>
struct [[nodiscard]] _Uninitialized_rev_destroying_backout {
    
    _NoThrowIt _First;
    _NoThrowIt _Last;

    explicit _Uninitialized_rev_destroying_backout(_NoThrowIt _Dest) noexcept : _First(_Dest), _Last(_Dest) {}

    _Uninitialized_rev_destroying_backout(const _Uninitialized_rev_destroying_backout&)            = delete;
    _Uninitialized_rev_destroying_backout& operator=(const _Uninitialized_rev_destroying_backout&) = delete;

    ~_Uninitialized_rev_destroying_backout() {
        while (_Last != _First) {
            --_Last;
            ::std:: destroy_at(::std:: addressof(*_Last));
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        ::std:: _Construct_in_place(*_Last, ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    void _Emplace_back_for_overwrite() {
        ::std:: _Default_construct_in_place(*_Last);
        ++_Last;
    }

    _NoThrowIt _Release() noexcept { 
        _First = _Last;
        return _Last;
    }
};

template <class _Ty>
void _Reverse_destroy_multidimensional_n(_Ty* const _Arr, size_t _Size) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n(_Arr[_Size], extent_v<_Ty>);
        } else {
            _Destroy_in_place(_Arr[_Size]);
        }
    }
}

template <class _Ty>
struct [[nodiscard]] _Reverse_destroy_multidimensional_n_guard {
    _Ty* _Target;
    size_t _Index;

    ~_Reverse_destroy_multidimensional_n_guard() {
        if (_Target) {
            _Reverse_destroy_multidimensional_n(_Target, _Index);
        }
    }
};

template <class _Ty, size_t _Size>
void _Uninitialized_copy_multidimensional(const _Ty (&_In)[_Size], _Ty (&_Out)[_Size]) {
    if constexpr (is_trivial_v<_Ty>) {
        _Copy_memmove_n(_In, _Size, _Out);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional(_In[_Idx], _Out[_Idx]);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_value_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*>) {
        _Zero_range(_Out, _Out + _Size);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_value_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty>
void _Uninitialized_default_construct_multidimensional_n(_Ty* const _Out, const size_t _Size) {
    if constexpr (!is_trivially_default_constructible_v<_Ty>) {
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
            for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
                _Uninitialized_default_construct_multidimensional_n(_Out[_Idx], extent_v<_Ty>);
            }
            _Guard._Target = nullptr;
        } else {
            _Uninitialized_rev_destroying_backout _Backout{_Out};
            for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
                _Backout._Emplace_back_for_overwrite();
            }
            _Backout._Release();
        }
    }
}

template <class _Ty>
void _Uninitialized_fill_multidimensional_n(_Ty* const _Out, const size_t _Size, const _Ty& _Val) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_guard<_Ty> _Guard{_Out, 0};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional(_Val, _Out[_Idx]); 
        }
        _Guard._Target = nullptr;
    } else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty>) {
        _Fill_memset(_Out, _Val, _Size);
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout _Backout{_Out};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, bool = is_trivially_destructible_v<remove_extent_t<_Ty>>>
class _Ref_count_unbounded_array : public _Ref_count_base {
    
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base() {
        _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Count);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base() {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Count);
        } else {
            _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Count, _Val);
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    union {
        _Wrap<remove_cv_t<_Element_type>> _Storage; 
    };

    ~_Ref_count_unbounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        
    }

    void _Delete_this() noexcept override { 
        this->~_Ref_count_unbounded_array();
        _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_unbounded_array<_Ty, false> : public _Ref_count_base {
    
public:
    static_assert(is_unbounded_array_v<_Ty>);

    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array(const size_t _Count) : _Ref_count_base(), _Size(_Count) {
        _Uninitialized_value_construct_multidimensional_n(_Get_ptr(), _Size);
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array(const size_t _Count, const _Arg& _Val) : _Ref_count_base(), _Size(_Count) {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size);
        } else {
            _Uninitialized_fill_multidimensional_n(_Get_ptr(), _Size, _Val);
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<remove_cv_t<_Element_type>> _Storage; 
    };

    ~_Ref_count_unbounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        _Reverse_destroy_multidimensional_n(_Get_ptr(), _Size);
    }

    void _Delete_this() noexcept override { 
        this->~_Ref_count_unbounded_array();
        _Deallocate_flexible_array(this);
    }
};

template <class _Ty>
class _Ref_count_bounded_array : public _Ref_count_base {
    
public:
    static_assert(is_bounded_array_v<_Ty>);

    _Ref_count_bounded_array() : _Ref_count_base(), _Storage() {} 

    template <class _Arg>
    explicit _Ref_count_bounded_array(const _Arg& _Val) : _Ref_count_base() { 
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Storage._Value, extent_v<_Ty>);
        } else {
            _Uninitialized_fill_multidimensional_n(_Storage._Value, extent_v<_Ty>, _Val);
        }
    }

    union {
        _Wrap<remove_cv_t<_Ty>> _Storage;
    };

private:
    ~_Ref_count_bounded_array() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        
        
        _Destroy_in_place(_Storage);
    }

    void _Delete_this() noexcept override { 
        delete this;
    }
};
#line 2464 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

template <class _Ty, class _Alloc>
class _Ref_count_obj_alloc3 : public _Ebco_base<_Rebind_alloc_t<_Alloc, _Ty>>, public _Ref_count_base {
    
private:
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Rebound = _Rebind_alloc_t<_Alloc, _Ty>;

public:
    template <class... _Types>
    explicit _Ref_count_obj_alloc3(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() {

        if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
            _Default_construct_in_place(_Storage._Value);
            ((void) _Args, ...);
        } else
#line 2483 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
        {
            allocator_traits<_Rebound>::construct(
                this->_Get_val(), ::std:: addressof(_Storage._Value), ::std:: forward<_Types>(_Args)...);
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_obj_alloc3() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        allocator_traits<_Rebound>::destroy(this->_Get_val(), ::std:: addressof(_Storage._Value));
    }

    void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc3> _Al(this->_Get_val());
        this->~_Ref_count_obj_alloc3();
        _Deallocate_plain(_Al, this);
    }
};


template <class _Alloc>
class [[nodiscard]] _Uninitialized_rev_destroying_backout_al {
    

private:
    using pointer = _Alloc_ptr_t<_Alloc>;

public:
    _Uninitialized_rev_destroying_backout_al(pointer _Dest, _Alloc& _Al_) noexcept
        : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

    _Uninitialized_rev_destroying_backout_al(const _Uninitialized_rev_destroying_backout_al&)            = delete;
    _Uninitialized_rev_destroying_backout_al& operator=(const _Uninitialized_rev_destroying_backout_al&) = delete;

    ~_Uninitialized_rev_destroying_backout_al() {
        while (_Last != _First) {
            --_Last;
            allocator_traits<_Alloc>::destroy(_Al, _Last);
        }
    }

    template <class... _Types>
    void _Emplace_back(_Types&&... _Vals) { 
        allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std:: forward<_Types>(_Vals)...);
        ++_Last;
    }

    pointer _Release() noexcept { 
        _First = _Last;
        return _Last;
    }

private:
    pointer _First;
    pointer _Last;
    _Alloc& _Al;
};

template <class _Ty, class _Alloc>
void _Reverse_destroy_multidimensional_n_al(_Ty* const _Arr, size_t _Size, _Alloc& _Al) noexcept {
    while (_Size > 0) {
        --_Size;
        if constexpr (is_array_v<_Ty>) {
            _Reverse_destroy_multidimensional_n_al(_Arr[_Size], extent_v<_Ty>, _Al);
        } else {
            allocator_traits<_Alloc>::destroy(_Al, _Arr + _Size);
        }
    }
}

template <class _Ty, class _Alloc>
struct [[nodiscard]] _Reverse_destroy_multidimensional_n_al_guard {
    _Ty* _Target;
    size_t _Index;
    _Alloc& _Al;

    ~_Reverse_destroy_multidimensional_n_al_guard() {
        if (_Target) {
            _Reverse_destroy_multidimensional_n_al(_Target, _Index, _Al);
        }
    }
};

template <class _Ty, size_t _Size, class _Alloc>
void _Uninitialized_copy_multidimensional_al(const _Ty (&_In)[_Size], _Ty (&_Out)[_Size], _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (conjunction_v<is_trivial<_Ty>, _Uses_default_construct<_Alloc, _Item*, const _Item&>>) {
        _Copy_memmove_n(_In, _Size, _Out);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional_al(_In[_Idx], _Out[_Idx], _Al);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_In[_Idx]);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_value_construct_multidimensional_n_al(_Ty* const _Out, const size_t _Size, _Alloc& _Al) {
    using _Item = remove_all_extents_t<_Ty>;
    if constexpr (_Use_memset_value_construct_v<_Item*> && _Uses_default_construct<_Alloc, _Item*>::value) {
        _Zero_range(_Out, _Out + _Size);
    } else if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_value_construct_multidimensional_n_al(_Out[_Idx], extent_v<_Ty>, _Al);
        }
        _Guard._Target = nullptr;
    } else {
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back();
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
void _Uninitialized_fill_multidimensional_n_al(_Ty* const _Out, const size_t _Size, const _Ty& _Val, _Alloc& _Al) {
    if constexpr (is_array_v<_Ty>) {
        _Reverse_destroy_multidimensional_n_al_guard<_Ty, _Alloc> _Guard{_Out, 0, _Al};
        for (size_t& _Idx = _Guard._Index; _Idx < _Size; ++_Idx) {
            _Uninitialized_copy_multidimensional_al(_Val, _Out[_Idx], _Al); 
        }
        _Guard._Target = nullptr;
    } else if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
        _Fill_memset(_Out, _Val, _Size);
    } else {
        if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty>
                      && _Uses_default_construct<_Alloc, _Ty*, const _Ty&>::value) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Out, _Size);
                return;
            }
        }
        _Uninitialized_rev_destroying_backout_al _Backout{_Out, _Al};
        for (size_t _Idx = 0; _Idx < _Size; ++_Idx) {
            _Backout._Emplace_back(_Val);
        }
        _Backout._Release();
    }
}

template <class _Ty, class _Alloc>
class _Ref_count_unbounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
                                         public _Ref_count_base {
    
private:
    static_assert(is_unbounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item    = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    using _Element_type = remove_extent_t<_Ty>;

    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        _Uninitialized_value_construct_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_unbounded_array_alloc(const _Alloc& _Al_arg, const size_t _Count, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base(), _Size(_Count) {
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(_Get_ptr(), _Size); 
        } else {
            _Uninitialized_fill_multidimensional_n_al(_Get_ptr(), _Size, _Val, this->_Get_val());
        }
    }

    [[nodiscard]] auto _Get_ptr() noexcept {
        return ::std:: addressof(_Storage._Value);
    }

private:
    size_t _Size;

    union {
        _Wrap<_Element_type> _Storage; 
    };

    ~_Ref_count_unbounded_array_alloc() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _Reverse_destroy_multidimensional_n_al(_Get_ptr(), _Size, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { 
        constexpr size_t _Align = alignof(_Ref_count_unbounded_array_alloc);
        using _Storage          = _Alignas_storage_unit<_Align>;

        _Rebind_alloc_t<_Alloc, _Storage> _Al(this->_Get_val());
        const size_t _Bytes =
            _Calculate_bytes_for_flexible_array<_Ref_count_unbounded_array_alloc, _Check_overflow::_Nope>(_Size);
        const size_t _Storage_units = _Bytes / sizeof(_Storage);

        this->~_Ref_count_unbounded_array_alloc();

        _Al.deallocate(reinterpret_cast<_Storage*>(this), _Storage_units);
    }
};

template <class _Ty, class _Alloc>
class _Ref_count_bounded_array_alloc : public _Ebco_base<_Rebind_alloc_t<_Alloc, remove_all_extents_t<_Ty>>>,
                                       public _Ref_count_base {
    
private:
    static_assert(is_bounded_array_v<_Ty>);
    static_assert(is_same_v<_Ty, remove_cv_t<_Ty>>, "allocate_shared should remove_cv_t");

    using _Item    = remove_all_extents_t<_Ty>;
    using _Rebound = _Rebind_alloc_t<_Alloc, _Item>;

public:
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { 
        _Uninitialized_value_construct_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
    }

    template <class _Arg>
    explicit _Ref_count_bounded_array_alloc(const _Alloc& _Al_arg, const _Arg& _Val)
        : _Ebco_base<_Rebound>(_Al_arg), _Ref_count_base() { 
        if constexpr (is_same_v<_For_overwrite_tag, _Arg>) {
            _Uninitialized_default_construct_multidimensional_n(
                _Storage._Value, extent_v<_Ty>); 
        } else {
            _Uninitialized_fill_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, _Val, this->_Get_val());
        }
    }

    union {
        _Wrap<_Ty> _Storage;
    };

private:
    ~_Ref_count_bounded_array_alloc() noexcept override { 
        

        
    }

    void _Destroy() noexcept override { 
        if constexpr (!conjunction_v<is_trivially_destructible<_Item>, _Uses_default_destroy<_Rebound, _Item*>>) {
            _Reverse_destroy_multidimensional_n_al(_Storage._Value, extent_v<_Ty>, this->_Get_val());
        }
    }

    void _Delete_this() noexcept override { 
        _Rebind_alloc_t<_Alloc, _Ref_count_bounded_array_alloc> _Al(this->_Get_val());
        this->~_Ref_count_bounded_array_alloc();
        _Deallocate_plain(_Al, this);
    }
};
#line 2760 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty, class... _Types>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]]

    enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>


#line 2768 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
    make_shared(_Types&&... _Args) { 
    const auto _Rx = new _Ref_count_obj2<_Ty>(::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    return _Ret;
}


template <class _Refc>
struct [[nodiscard]] _Global_delete_guard {
    _Refc* _Target;

    ~_Global_delete_guard() {
        
        
        
        if (_Target) {
            _Deallocate_flexible_array(_Target);
        }
    }
};

  template <class _Ty, class... _ArgTypes>
[[nodiscard]] shared_ptr<_Ty> _Make_shared_unbounded_array(const size_t _Count, const _ArgTypes&... _Args) {
    
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc    = _Ref_count_unbounded_array<_Ty>;
    const auto _Rx = _Allocate_flexible_array<_Refc>(_Count);
    _Global_delete_guard<_Refc> _Guard{_Rx};
    ::new (static_cast<void*>(_Rx)) _Refc(_Count, _Args...);
    _Guard._Target = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(const size_t _Count) {
    return _Make_shared_unbounded_array<_Ty>(_Count);
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _Make_shared_unbounded_array<_Ty>(_Count, _Val);
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared() {
    
    const auto _Rx = new _Ref_count_bounded_array<_Ty>();
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared(
    const remove_extent_t<_Ty>& _Val) {
    
    const auto _Rx = new _Ref_count_bounded_array<_Ty>(_Val);
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite() {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        
        const auto _Rx = new _Ref_count_bounded_array<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Storage._Value, _Rx);
    } else {
        
        const auto _Rx = new _Ref_count_obj2<_Ty>(_For_overwrite_tag{});
        _Ret._Set_ptr_rep_and_enable_shared(::std:: addressof(_Rx->_Storage._Value), _Rx);
    }
    return _Ret;
}

 template <class _Ty>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> make_shared_for_overwrite(
    const size_t _Count) {
    return _Make_shared_unbounded_array<_Ty>(_Count, _For_overwrite_tag{});
}
#line 2855 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty, class _Alloc, class... _Types>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]]

    enable_if_t<!is_array_v<_Ty>, shared_ptr<_Ty>>


#line 2863 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
    allocate_shared(const _Alloc& _Al, _Types&&... _Args) { 
    
    
    using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
    _Constructor._Allocate();
    _Construct_in_place(*_Constructor._Ptr, _Al, ::std:: forward<_Types>(_Args)...);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
    return _Ret;
}


template <class _Alloc>
struct _Allocate_n_ptr {
    _Alloc& _Al;
    _Alloc_ptr_t<_Alloc> _Ptr;
    size_t _Nx;

    _Allocate_n_ptr(_Alloc& _Al_, const size_t _Nx_) : _Al(_Al_), _Ptr(_Al_.allocate(_Nx_)), _Nx(_Nx_) {}

    ~_Allocate_n_ptr() {
        if (_Ptr) {
            _Al.deallocate(_Ptr, _Nx);
        }
    }

    _Allocate_n_ptr(const _Allocate_n_ptr&)            = delete;
    _Allocate_n_ptr& operator=(const _Allocate_n_ptr&) = delete;
};

  template <class _Ty, class _Alloc, class... _ArgTypes>
[[nodiscard]] shared_ptr<_Ty> _Allocate_shared_unbounded_array(
    const _Alloc& _Al, const size_t _Count, const _ArgTypes&... _Args) {
    
    static_assert(is_unbounded_array_v<_Ty>);
    using _Refc             = _Ref_count_unbounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    constexpr size_t _Align = alignof(_Refc);
    using _Storage          = _Alignas_storage_unit<_Align>;
    _Rebind_alloc_t<_Alloc, _Storage> _Rebound(_Al);
    const size_t _Bytes         = _Calculate_bytes_for_flexible_array<_Refc, _Check_overflow::_Yes>(_Count);
    const size_t _Storage_units = _Bytes / sizeof(_Storage);
    _Allocate_n_ptr _Guard{_Rebound, _Storage_units};
    const auto _Rx = reinterpret_cast<_Refc*>(_Unfancy(_Guard._Ptr));
    ::new (static_cast<void*>(_Rx)) _Refc(_Al, _Count, _Args...);
    _Guard._Ptr = nullptr;
    shared_ptr<_Ty> _Ret;
    _Ret._Set_ptr_rep_and_enable_shared(_Rx->_Get_ptr(), _Rx);
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count);
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const size_t _Count, const remove_extent_t<_Ty>& _Val) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count, _Val);
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(const _Alloc& _Al) {
    
    using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{_Rebound};
    _Constructor._Allocate();
    ::new (::std:: _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, ::std:: _Unfancy(_Constructor._Release()));
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_bounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared(
    const _Alloc& _Al, const remove_extent_t<_Ty>& _Val) {
    
    using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
    using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
    _Alblock _Rebound(_Al);
    _Alloc_construct_ptr _Constructor{_Rebound};
    _Constructor._Allocate();
    ::new (::std:: _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al, _Val);
    shared_ptr<_Ty> _Ret;
    const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
    _Ret._Set_ptr_rep_and_enable_shared(_Ptr, ::std:: _Unfancy(_Constructor._Release()));
    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<!is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al) {
    shared_ptr<_Ty> _Ret;
    if constexpr (is_array_v<_Ty>) {
        
        using _Refc    = _Ref_count_bounded_array_alloc<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refc>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr _Constructor{_Rebound};
        _Constructor._Allocate();
        ::new (::std:: _Voidify_unfancy(_Constructor._Ptr)) _Refc(_Al, _For_overwrite_tag{});
        const auto _Ptr = static_cast<remove_extent_t<_Ty>*>(_Constructor._Ptr->_Storage._Value);
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, ::std:: _Unfancy(_Constructor._Release()));
    } else {
        
        using _Refoa   = _Ref_count_obj_alloc3<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr<_Alblock> _Constructor{_Rebound};
        _Constructor._Allocate();
        ::std:: _Construct_in_place(*_Constructor._Ptr, _Al, _For_overwrite_tag{});
        const auto _Ptr = reinterpret_cast<_Ty*>(::std:: addressof(_Constructor._Ptr->_Storage._Value));
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, ::std:: _Unfancy(_Constructor._Release()));
    }

    return _Ret;
}

 template <class _Ty, class _Alloc>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] enable_if_t<is_unbounded_array_v<_Ty>, shared_ptr<_Ty>> allocate_shared_for_overwrite(
    const _Alloc& _Al, const size_t _Count) {
    return _Allocate_shared_unbounded_array<_Ty>(_Al, _Count, _For_overwrite_tag{});
}
#line 2995 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty>
class weak_ptr : public _Ptr_base<_Ty> { 
public:

    
    

    
    template <class _Ty2, class = const _Ty2*>
    static constexpr bool _Must_avoid_expired_conversions_from = true;

    
    template <class _Ty2>
    static constexpr bool
        _Must_avoid_expired_conversions_from<_Ty2, decltype(static_cast<const _Ty2*>(static_cast<_Ty*>(nullptr)))> =
            false;
#line 3013 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    constexpr weak_ptr() noexcept {}

    weak_ptr(const weak_ptr& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept {
        this->_Weakly_construct_from(_Other); 
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#line 3032 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_lvalue_avoiding_expired_conversions(_Other);
        } else {
            this->_Weakly_construct_from(_Other);
        }
    }

    weak_ptr(weak_ptr&& _Other) noexcept {
        this->_Move_construct_from(::std:: move(_Other));
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept {



        constexpr bool _Avoid_expired_conversions = _Must_avoid_expired_conversions_from<_Ty2>;
#line 3051 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

        if constexpr (_Avoid_expired_conversions) {
            this->_Weakly_convert_rvalue_avoiding_expired_conversions(::std:: move(_Other));
        } else {
            this->_Move_construct_from(::std:: move(_Other));
        }
    }

    ~weak_ptr() noexcept {
        this->_Decwref();
    }

    weak_ptr& operator=(const weak_ptr& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    weak_ptr& operator=(weak_ptr&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept {
        weak_ptr(::std:: move(_Right)).swap(*this);
        return *this;
    }

    template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
    weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept {
        weak_ptr(_Right).swap(*this);
        return *this;
    }

    void reset() noexcept { 
        weak_ptr{}.swap(*this);
    }

    void swap(weak_ptr& _Other) noexcept {
        this->_Swap(_Other);
    }

    [[nodiscard]] bool expired() const noexcept {
        return this->use_count() == 0;
    }

    [[nodiscard]] shared_ptr<_Ty> lock() const noexcept { 
        shared_ptr<_Ty> _Ret;
        (void) _Ret._Construct_from_weak(*this);
        return _Ret;
    }
};


template <class _Ty>
weak_ptr(shared_ptr<_Ty>) -> weak_ptr<_Ty>;
#line 3114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty>
void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty>
class enable_shared_from_this { 
public:
    using _Esft_type = enable_shared_from_this;

    [[nodiscard]] shared_ptr<_Ty> shared_from_this() {
        return shared_ptr<_Ty>(_Wptr);
    }

    [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const {
        return shared_ptr<const _Ty>(_Wptr);
    }

    [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept {
        return _Wptr;
    }

    [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept {
        return _Wptr;
    }

protected:
    constexpr enable_shared_from_this() noexcept : _Wptr() {}

    enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr() {
        
    }

    enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept { 
        return *this;
    }

    ~enable_shared_from_this() = default;

private:
    template <class _Yty>
    friend class shared_ptr;

    mutable weak_ptr<_Ty> _Wptr;
};

 template <class _Ty>
struct default_delete { 
    constexpr default_delete() noexcept = default;

    template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
    constexpr default_delete(const default_delete<_Ty2>&) noexcept {}

    constexpr void operator()(_Ty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
        delete _Ptr;
    }
};

template <class _Ty>
struct default_delete<_Ty[]> { 
    constexpr default_delete() noexcept = default;

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    constexpr default_delete(const default_delete<_Uty[]>&) noexcept {}

    template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
    constexpr void operator()(_Uty* _Ptr) const noexcept  { 
        static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
        delete[] _Ptr;
    }
};

template <class _Ty, class _Dx_noref, class = void>
struct _Get_deleter_pointer_type { 
    using type = _Ty*;
};

template <class _Ty, class _Dx_noref>
struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>> { 
    using type = typename _Dx_noref::pointer;
};

template <class _Dx2>
using _Unique_ptr_enable_default_t =
    enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

 template <class _Ty, class _Dx >
class unique_ptr { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    constexpr unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    
    
    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
    constexpr unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Dx2                                                                            = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
    constexpr unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Dx2                                                                                      = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    constexpr unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Ty2, class _Dx2,
        enable_if_t<
            conjunction_v<negation<is_array<_Ty2>>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
            int> = 0>
    constexpr unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx2>(_Right.get_deleter()), _Right.release()) {}





#line 3254 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

    template <class _Ty2, class _Dx2,
        enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>,
                        is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>,
            int> = 0>
    constexpr unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx2>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    constexpr unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Dx>(_Right._Mypair._Get_first());
        return *this;
    }

    constexpr void swap(unique_ptr& _Right) noexcept {
        using ::std:: swap;
        swap(_Mypair._Myval2, _Right._Mypair._Myval2); 
        swap(_Mypair._Get_first(), _Right._Mypair._Get_first()); 
    }

    constexpr ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] constexpr _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr add_lvalue_reference_t<_Ty> operator*() const noexcept(noexcept(*::std:: declval<pointer>())) {
        return *_Mypair._Myval2;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return _Mypair._Myval2;
    }

    [[nodiscard]] constexpr pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    constexpr explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    constexpr pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    constexpr void reset(pointer _Ptr = nullptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&)            = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

template <class _Ty, class _Dx>
class unique_ptr<_Ty[], _Dx> { 
public:
    using pointer      = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
    using element_type = _Ty;
    using deleter_type = _Dx;

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
    using _Enable_ctor_reset =
        enable_if_t<is_same_v<_Uty, pointer> || _Is_nullptr::value
                        || (is_same_v<pointer, element_type*> && is_pointer_v<_Uty>
                            && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>),
            int>;

    template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, _Enable_ctor_reset<_Uty> = 0>
    constexpr explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0,
        _Enable_ctor_reset<_Uty> = 0>
    constexpr unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t{}, _Dt, _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0,
        _Enable_ctor_reset<_Uty>                                                                    = 0>
    constexpr unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Dt), _Ptr) {}

    template <class _Uty, class _Dx2 = _Dx,
        enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
    unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

    template <class _Dx2 = _Dx, enable_if_t<is_move_constructible_v<_Dx2>, int> = 0>
    constexpr unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Dx>(_Right.get_deleter()), _Right.release()) {}

    template <class _Dx2 = _Dx, enable_if_t<is_move_assignable_v<_Dx2>, int> = 0>
    constexpr unique_ptr& operator=(unique_ptr&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            reset(_Right.release());
            _Mypair._Get_first() = ::std:: move(_Right._Mypair._Get_first());
        }

        return *this;
    }

    template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
        class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
    using _Enable_conversion = enable_if_t<
        conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>,
            is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>,
        int>;

    template <class _Uty, class _Ex,
        _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>> =
            0>
    constexpr unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: forward<_Ex>(_Right.get_deleter()), _Right.release()) {}

    template <class _Uty, class _Ex, _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>> = 0>
    constexpr unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept {
        reset(_Right.release());
        _Mypair._Get_first() = ::std:: forward<_Ex>(_Right._Mypair._Get_first());
        return *this;
    }

    template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
    constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t{}) {}

    constexpr unique_ptr& operator=(nullptr_t) noexcept {
        reset();
        return *this;
    }

    constexpr void reset(nullptr_t = nullptr) noexcept {
        reset(pointer());
    }

    constexpr void swap(unique_ptr& _Right) noexcept {
        using ::std:: swap;
        swap(_Mypair._Myval2, _Right._Mypair._Myval2); 
        swap(_Mypair._Get_first(), _Right._Mypair._Get_first()); 
    }

    constexpr ~unique_ptr() noexcept {
        if (_Mypair._Myval2) {
            _Mypair._Get_first()(_Mypair._Myval2);
        }
    }

    [[nodiscard]] constexpr _Dx& get_deleter() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr const _Dx& get_deleter() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr _Ty& operator[](size_t _Idx) const noexcept  {
        return _Mypair._Myval2[_Idx];
    }

    [[nodiscard]] constexpr pointer get() const noexcept {
        return _Mypair._Myval2;
    }

    constexpr explicit operator bool() const noexcept {
        return static_cast<bool>(_Mypair._Myval2);
    }

    constexpr pointer release() noexcept {
        return ::std:: exchange(_Mypair._Myval2, nullptr);
    }

    template <class _Uty, _Enable_ctor_reset<_Uty, false_type> = 0>
    constexpr void reset(_Uty _Ptr) noexcept {
        pointer _Old = ::std:: exchange(_Mypair._Myval2, _Ptr);
        if (_Old) {
            _Mypair._Get_first()(_Old);
        }
    }

    unique_ptr(const unique_ptr&)            = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

private:
    template <class, class>
    friend class unique_ptr;

    _Compressed_pair<_Dx, pointer> _Mypair;
};

 template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] constexpr unique_ptr<_Ty> make_unique(_Types&&... _Args) { 
    return unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...));
}

 template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] constexpr unique_ptr<_Ty> make_unique(const size_t _Size) { 
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]());
}

 template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
void make_unique(_Types&&...) = delete;


 template <class _Ty, enable_if_t<!is_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] constexpr unique_ptr<_Ty> make_unique_for_overwrite() {
    
    return unique_ptr<_Ty>(new _Ty);
}

 template <class _Ty, enable_if_t<is_unbounded_array_v<_Ty>, int> = 0>
[[nodiscard("This function constructs an object wrapped by a smart pointer and has no other effects; " "it is not useful to call this function and discard the return value.")]] constexpr unique_ptr<_Ty> make_unique_for_overwrite(const size_t _Size) {
    
    using _Elem = remove_extent_t<_Ty>;
    return unique_ptr<_Ty>(new _Elem[_Size]);
}

 template <class _Ty, class... _Types, enable_if_t<is_bounded_array_v<_Ty>, int> = 0>
void make_unique_for_overwrite(_Types&&...) = delete;
#line 3494 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
constexpr void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept {
    _Left.swap(_Right);
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] constexpr bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Left.get() == _Right.get();
}






#line 3511 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    using _Ptr1   = typename unique_ptr<_Ty1, _Dx1>::pointer;
    using _Ptr2   = typename unique_ptr<_Ty2, _Dx2>::pointer;
    using _Common = common_type_t<_Ptr1, _Ptr2>;
    return less<_Common>{}(_Left.get(), _Right.get());
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Left < _Right);
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return _Right < _Left;
}

 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
[[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    return !(_Right < _Left);
}



 template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    requires three_way_comparable_with<typename unique_ptr<_Ty1, _Dx1>::pointer,
        typename unique_ptr<_Ty2, _Dx2>::pointer>
[[nodiscard]] compare_three_way_result_t<typename unique_ptr<_Ty1, _Dx1>::pointer,
        typename unique_ptr<_Ty2, _Dx2>::pointer>
    operator<=>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right) {
    
    return _Left.get() <=> _Right.get();
}
#line 3547 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept {
    return !_Left;
}
















#line 3569 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left.get(), _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
    return less<_Ptr>{}(_Left, _Right.get());
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Left < _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Left < _Right);
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return _Right < _Left;
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return _Right < _Left;
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) {
    return !(_Right < _Left);
}

 template <class _Ty, class _Dx>
[[nodiscard]] constexpr bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) {
    return !(_Right < _Left);
}


 template <class _Ty, class _Dx>
    requires three_way_comparable<typename unique_ptr<_Ty, _Dx>::pointer>
[[nodiscard]] constexpr compare_three_way_result_t<typename unique_ptr<_Ty, _Dx>::pointer> operator<=>(
    const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) {
    return _Left.get() <=> static_cast<typename unique_ptr<_Ty, _Dx>::pointer>(nullptr);
}
#line 3620 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

template <class _OutTy, class _PxTy, class = void>
struct _Can_stream_unique_ptr : false_type {};
template <class _OutTy, class _PxTy>
struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std:: declval<_OutTy>() << ::std:: declval<_PxTy>().get())>>
    : true_type {};

 template <class _Elem, class _Traits, class _Yty, class _Dx,
    enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px) {
    
    _Out << _Px.get();
    return _Out;
}


















#line 3653 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

 template <class _Ty = void>
struct owner_less; 

template <class _Ty>
struct owner_less<shared_ptr<_Ty>> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = shared_ptr<_Ty>;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = shared_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <class _Ty>
struct owner_less<weak_ptr<_Ty>> {
    using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = weak_ptr<_Ty>;
    using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = weak_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }
};

template <>
struct owner_less<void> {
    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    template <class _Ty, class _Uty>
    [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept {
        return _Left.owner_before(_Right);
    }

    using is_transparent = int;
};

template <class _Ty, class _Dx>
struct hash<unique_ptr<_Ty, _Dx>> : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>,
                                        is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>> {
    static size_t _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(
        _Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value) {
        return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
    }
};

template <class _Ty>
struct hash<shared_ptr<_Ty>> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = shared_ptr<_Ty>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept {
        return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
    }
};


 template <size_t _Nx, class _Ty>
[[nodiscard("'std::assume_aligned' has a potential effect on the return value (not on the passed argument). " "It is not useful to call 'std::assume_aligned' and discard the return value.")]] constexpr _Ty* assume_aligned(_Ty* const _Ptr) noexcept  {
    if (::std:: is_constant_evaluated()) {
        return _Ptr;
    } else {
        
        return static_cast<_Ty*>(__builtin_assume_aligned(_Ptr, _Nx));
    }
}
#line 3750 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

extern "C" {
 void __cdecl _Lock_shared_ptr_spin_lock();
 void __cdecl _Unlock_shared_ptr_spin_lock();
}

struct _Shared_ptr_spin_lock { 
    _Shared_ptr_spin_lock() { 
        _Lock_shared_ptr_spin_lock();
    }

    ~_Shared_ptr_spin_lock() noexcept { 
        _Unlock_shared_ptr_spin_lock();
    }
};

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] bool atomic_is_lock_free(const shared_ptr<_Ty>*) {
    
    return false;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] shared_ptr<_Ty> atomic_load_explicit(
    const shared_ptr<_Ty>* _Ptr, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    shared_ptr<_Ty> _Result = *_Ptr;
    return _Result;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] [[nodiscard]] shared_ptr<_Ty> atomic_load(
    const shared_ptr<_Ty>* _Ptr) { 
    return ::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_store_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] void atomic_store(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) { 
    ::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] shared_ptr<_Ty> atomic_exchange_explicit(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order) {
    
    _Shared_ptr_spin_lock _Lock;
    _Ptr->swap(_Other);
    return _Other;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] shared_ptr<_Ty> atomic_exchange(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other) {
    
    return ::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    shared_ptr<_Ty> _Old_exp; 
    _Shared_ptr_spin_lock _Lock;
    bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
    if (_Success) {
        _Ptr->swap(_Value);
    } else { 
        _Exp->swap(_Old_exp);
        *_Exp = *_Ptr;
    }
    return _Success;
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_weak(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr,
    shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order) { 
    return ::std:: atomic_compare_exchange_weak_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}

 template <class _Ty>
[[deprecated("warning STL4029: " "std::atomic_*() overloads for shared_ptr are deprecated in C++20. " "The shared_ptr specialization of std::atomic provides superior functionality. " "You can define _SILENCE_CXX20_OLD_SHARED_PTR_ATOMIC_SUPPORT_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]] bool atomic_compare_exchange_strong(
    shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value) {
    
    return ::std:: atomic_compare_exchange_strong_explicit(
        _Ptr, _Exp, ::std:: move(_Value), memory_order_seq_cst, memory_order_seq_cst);
}


template <class _Ty>
class alignas(2 * sizeof(void*)) _Atomic_ptr_base {
    
protected:
    constexpr _Atomic_ptr_base() noexcept = default;

    _Atomic_ptr_base(remove_extent_t<_Ty>* const _Px, _Ref_count_base* const _Ref) noexcept
        : _Ptr(_Px), _Repptr(_Ref) {}

    void _Wait(remove_extent_t<_Ty>* _Old, memory_order) const noexcept {
        for (;;) {
            auto _Rep   = _Repptr._Lock_and_load();
            bool _Equal = _Ptr.load(memory_order_relaxed) == _Old;
            _Repptr._Store_and_unlock(_Rep);
            if (!_Equal) {
                break;
            }
            __std_atomic_wait_direct(&_Ptr, &_Old, sizeof(_Old), _Atomic_wait_no_timeout);
        }
    }

    void notify_one() noexcept {
        _Ptr.notify_one();
    }

    void notify_all() noexcept {
        _Ptr.notify_all();
    }

    atomic<remove_extent_t<_Ty>*> _Ptr{nullptr};
    mutable _Locked_pointer<_Ref_count_base> _Repptr;
};

template <class _Ty>
struct atomic<shared_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = shared_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    [[nodiscard]] bool is_lock_free() const noexcept {
        return false;
    }

    void store(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep                  = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr                      = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    [[nodiscard]] shared_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        shared_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr    = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep    = _Rep;
        _Result._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator shared_ptr<_Ty>() const noexcept {
        return load();
    }

    shared_ptr<_Ty> exchange(shared_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        shared_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; 
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Order);
    }

    bool compare_exchange_strong(shared_ptr<_Ty>& _Expected, shared_ptr<_Ty> _Desired,
        const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr                    = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            ::std:: swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        _Ref_count_base* _Expected_rep = _Expected._Rep;
        _Expected._Ptr                 = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep                 = _Rep;
        _Expected._Incref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decref();
        }
        return false;
    }

    void wait(shared_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    constexpr atomic(nullptr_t) noexcept : atomic() {}

    atomic(const shared_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incref();
    }

    atomic(const atomic&)         = delete;
    void operator=(const atomic&) = delete;

    void operator=(shared_ptr<_Ty> _Value) noexcept {
        store(::std:: move(_Value));
    }

    void operator=(nullptr_t) noexcept {
        store(nullptr);
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decref();
        }
    }
};

template <class _Ty>
struct atomic<weak_ptr<_Ty>> : private _Atomic_ptr_base<_Ty> {
private:
    using _Base = _Atomic_ptr_base<_Ty>;

public:
    using value_type = weak_ptr<_Ty>;

    static constexpr bool is_always_lock_free = false;

    [[nodiscard]] bool is_lock_free() const noexcept {
        return false;
    }

    void store(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_store_memory_order(_Order);
        const auto _Rep                  = this->_Repptr._Lock_and_load();
        remove_extent_t<_Ty>* const _Tmp = _Value._Ptr;
        _Value._Ptr                      = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Tmp, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Rep = _Rep;
    }

    [[nodiscard]] weak_ptr<_Ty> load(const memory_order _Order = memory_order_seq_cst) const noexcept {
        _Check_load_memory_order(_Order);
        weak_ptr<_Ty> _Result;
        const auto _Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr    = this->_Ptr.load(memory_order_relaxed);
        _Result._Rep    = _Rep;
        _Result._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        return _Result;
    }

    operator weak_ptr<_Ty>() const noexcept {
        return load();
    }

    weak_ptr<_Ty> exchange(weak_ptr<_Ty> _Value, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        weak_ptr<_Ty> _Result;
        _Result._Rep = this->_Repptr._Lock_and_load();
        _Result._Ptr = this->_Ptr.load(memory_order_relaxed);
        this->_Ptr.store(_Value._Ptr, memory_order_relaxed);
        this->_Repptr._Store_and_unlock(_Value._Rep);
        _Value._Ptr = nullptr; 
        _Value._Rep = nullptr;
        return _Result;
    }

    bool compare_exchange_weak(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_strong(weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Success,
        const memory_order _Failure) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Combine_cas_memory_orders(_Success, _Failure));
    }

    bool compare_exchange_weak(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        return compare_exchange_strong(_Expected, ::std:: move(_Desired), _Order);
    }

    bool compare_exchange_strong(
        weak_ptr<_Ty>& _Expected, weak_ptr<_Ty> _Desired, const memory_order _Order = memory_order_seq_cst) noexcept {
        _Check_memory_order(static_cast<unsigned int>(_Order));
        auto _Rep = this->_Repptr._Lock_and_load();
        if (this->_Ptr.load(memory_order_relaxed) == _Expected._Ptr && _Rep == _Expected._Rep) {
            remove_extent_t<_Ty>* const _Tmp = _Desired._Ptr;
            _Desired._Ptr                    = this->_Ptr.load(memory_order_relaxed);
            this->_Ptr.store(_Tmp, memory_order_relaxed);
            ::std:: swap(_Rep, _Desired._Rep);
            this->_Repptr._Store_and_unlock(_Rep);
            return true;
        }
        const auto _Expected_rep = _Expected._Rep;
        _Expected._Ptr           = this->_Ptr.load(memory_order_relaxed);
        _Expected._Rep           = _Rep;
        _Expected._Incwref();
        this->_Repptr._Store_and_unlock(_Rep);
        if (_Expected_rep) {
            _Expected_rep->_Decwref();
        }
        return false;
    }

    void wait(weak_ptr<_Ty> _Old, memory_order _Order = memory_order_seq_cst) const noexcept {
        this->_Wait(_Old._Ptr, _Order);
    }

    using _Base::notify_all;
    using _Base::notify_one;

    constexpr atomic() noexcept = default;

    atomic(const weak_ptr<_Ty> _Value) noexcept : _Base(_Value._Ptr, _Value._Rep) {
        _Value._Incwref();
    }

    atomic(const atomic&)         = delete;
    void operator=(const atomic&) = delete;

    void operator=(weak_ptr<_Ty> _Value) noexcept {
        store(::std:: move(_Value));
    }

    ~atomic() {
        const auto _Rep = this->_Repptr._Unsafe_load_relaxed();
        if (_Rep) {
            _Rep->_Decwref();
        }
    }
};
#line 4129 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"


template <class _Ty>
struct _Pointer_of_helper {};

template <_Has_member_pointer _Ty>
struct _Pointer_of_helper<_Ty> {
    using type = _Ty::pointer;
};

template <_Has_member_element_type _Ty>
    requires (!_Has_member_pointer<_Ty>)
struct _Pointer_of_helper<_Ty> {
    using type = _Ty::element_type*;
};


template <class _Ty>
    requires (!_Has_member_element_type<_Ty> && !_Has_member_pointer<_Ty>
        && _Has_member_element_type<pointer_traits<_Ty>>)
struct _Pointer_of_helper<_Ty> {
    using type = pointer_traits<_Ty>::element_type*;
};


template <class _Ty>
using _Pointer_of = _Pointer_of_helper<_Ty>::type;

template <class _Ty, class _Uty>
struct _Pointer_of_or_helper {
    using type = _Uty;
};

template <class _Ty, class _Uty>
    requires requires { typename _Pointer_of<_Ty>; }
struct _Pointer_of_or_helper<_Ty, _Uty> {
    using type = _Pointer_of<_Ty>;
};

template <class _Ty, class _Uty>
using _Pointer_of_or = _Pointer_of_or_helper<_Ty, _Uty>::type;


template <class _SmartPtr, class _Sp, class _Pointer, class... _ArgsT>
concept _Resettable_pointer = requires(_SmartPtr& _Smart_ptr, _Pointer _Ptr, _ArgsT&&... _Args) {
    _Smart_ptr.reset(static_cast<_Sp>(_Ptr), ::std:: forward<_ArgsT>(_Args)...);
};

 template <class _SmartPtr, class _Pointer, class... _ArgsT>
class out_ptr_t {
    static_assert(!_Is_specialization_v<_SmartPtr, shared_ptr> || sizeof...(_ArgsT) != 0,
        "out_ptr_t with shared_ptr requires a deleter (N4950 [out.ptr.t]/3)");

public:
    explicit out_ptr_t(_SmartPtr& _Smart_ptr_, _ArgsT... _Args_) noexcept(
        is_nothrow_constructible_v<tuple<_ArgsT...>, _ArgsT...>) 
        : _Smart_ptr(_Smart_ptr_),
          _Mypair(_One_then_variadic_args_t{}, tuple<_ArgsT...>{::std:: forward<_ArgsT>(_Args_)...}) {
        constexpr bool _Is_resettable = requires { _Smart_ptr.reset(); }; 
        if constexpr (_Is_resettable) {
            _Smart_ptr.reset();
        } else {
            static_assert(is_constructible_v<_SmartPtr>, "the adapted pointer type must be default constructible.");
            _Smart_ptr = _SmartPtr();
        }
    }

    out_ptr_t(const out_ptr_t&) = delete;

    ~out_ptr_t() {
        if (!_Get_ptr()) {
            return;
        }

        ::std:: apply(
            [this](auto&&... _Args_) {
                using _Sp = _Pointer_of_or<_SmartPtr, _Pointer>;
                if constexpr (_Resettable_pointer<_SmartPtr, _Sp, _Pointer, _ArgsT...>) {
                    _Smart_ptr.reset(static_cast<_Sp>(_Get_ptr()), ::std:: forward<_ArgsT>(_Args_)...);
                } else {
                    static_assert(is_constructible_v<_SmartPtr, _Sp, _ArgsT...>, "(N4950 [out.ptr.t]/9.3)");
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), ::std:: forward<_ArgsT>(_Args_)...);
                }
            },
            ::std:: move(_Get_args()));
    }

    operator _Pointer*() const noexcept {
        return ::std:: addressof(_Get_ptr());
    }

    operator void**() const noexcept
        requires (!is_same_v<_Pointer, void*>)
    {
        static_assert(is_pointer_v<_Pointer>, "conversion of out_ptr_t<Smart, Pointer, Args...> to void** requires "
                                              "Pointer to be a raw pointer (N4950 [out.ptr.t]/13)");
        return reinterpret_cast<void**>(::std:: addressof(_Get_ptr()));
    }

private:
    [[nodiscard]] _Pointer& _Get_ptr() const noexcept {
        return const_cast<_Pointer&>(_Mypair._Myval2);
    }

    [[nodiscard]] tuple<_ArgsT...>& _Get_args() noexcept {
        return _Mypair._Get_first();
    }

    _SmartPtr& _Smart_ptr;
    _Compressed_pair<tuple<_ArgsT...>, _Pointer> _Mypair;
};

 template <class _Pointer = void, class _SmartPtr, class... _ArgsT>
[[nodiscard]] auto out_ptr(_SmartPtr& _Smart_ptr, _ArgsT&&... _Args) {
    if constexpr (is_void_v<_Pointer>) {
        return out_ptr_t<_SmartPtr, _Pointer_of<_SmartPtr>, _ArgsT&&...>(_Smart_ptr, ::std:: forward<_ArgsT>(_Args)...);
    } else {
        return out_ptr_t<_SmartPtr, _Pointer, _ArgsT&&...>(_Smart_ptr, ::std:: forward<_ArgsT>(_Args)...);
    }
}

 template <class _SmartPtr, class _Pointer, class... _ArgsT>
class inout_ptr_t {
    static_assert(!_Is_specialization_v<_SmartPtr, shared_ptr>,
        "inout_ptr_t doesn't work with shared_ptr (N4950 [inout.ptr.t]/3)");

private:
    [[nodiscard]] static auto _Get_ptr_from_smart(_SmartPtr& _Smart_ptr) noexcept
        requires is_pointer_v<_SmartPtr>
    {
        return _Smart_ptr;
    }

    [[nodiscard]] static auto _Get_ptr_from_smart(_SmartPtr& _Smart_ptr) noexcept(noexcept(_Smart_ptr.get())) {
        return _Smart_ptr.get();
    }

public:
    explicit inout_ptr_t(_SmartPtr& _Smart_ptr_, _ArgsT... _Args_) noexcept(
        is_nothrow_constructible_v<tuple<_ArgsT...>, _ArgsT...>&& noexcept(
            _Get_ptr_from_smart(_Smart_ptr_))) 
        : _Smart_ptr(_Smart_ptr_),
          _Mypair(_One_then_variadic_args_t{}, tuple<_ArgsT...>{::std:: forward<_ArgsT>(_Args_)...},
              _Get_ptr_from_smart(_Smart_ptr_)) {}

    inout_ptr_t(const inout_ptr_t&) = delete;

    ~inout_ptr_t() {
        if constexpr (!is_pointer_v<_SmartPtr>) {
            _Smart_ptr.release();
        }

        if (!_Get_ptr()) {
            return;
        }

        ::std:: apply(
            [this](auto&&... _Args_) {
                using _Sp = _Pointer_of_or<_SmartPtr, _Pointer>;
                if constexpr (is_pointer_v<_SmartPtr>) {
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), ::std:: forward<_ArgsT>(_Args_)...);
                } else if constexpr (_Resettable_pointer<_SmartPtr, _Sp, _Pointer, _ArgsT...>) {
                    _Smart_ptr.reset(static_cast<_Sp>(_Get_ptr()), ::std:: forward<_ArgsT>(_Args_)...);
                } else {
                    static_assert(is_constructible_v<_SmartPtr, _Sp, _ArgsT...>, "(N4950 [inout.ptr.t]/11.4)");
                    _Smart_ptr = _SmartPtr(static_cast<_Sp>(_Get_ptr()), ::std:: forward<_ArgsT>(_Args_)...);
                }
            },
            ::std:: move(_Get_args()));
    }

    operator _Pointer*() const noexcept {
        return ::std:: addressof(_Get_ptr());
    }

    operator void**() const noexcept
        requires (!is_same_v<_Pointer, void*>)
    {
        static_assert(is_pointer_v<_Pointer>, "conversion of inout_ptr_t<Smart, Pointer, Args...> to void** requires "
                                              "Pointer to be a raw pointer (N4950 [inout.ptr.t]/15)");
        return reinterpret_cast<void**>(::std:: addressof(_Get_ptr()));
    }

private:
    [[nodiscard]] _Pointer& _Get_ptr() const noexcept {
        return const_cast<_Pointer&>(_Mypair._Myval2);
    }

    [[nodiscard]] tuple<_ArgsT...>& _Get_args() noexcept {
        return _Mypair._Get_first();
    }

    _SmartPtr& _Smart_ptr;
    _Compressed_pair<tuple<_ArgsT...>, _Pointer> _Mypair;
};

 template <class _Pointer = void, class _SmartPtr, class... _ArgsT>
[[nodiscard]] auto inout_ptr(_SmartPtr& _Smart_ptr, _ArgsT&&... _Args) {
    if constexpr (is_void_v<_Pointer>) {
        return inout_ptr_t<_SmartPtr, _Pointer_of<_SmartPtr>, _ArgsT&&...>(_Smart_ptr, ::std:: forward<_ArgsT>(_Args)...);
    } else {
        return inout_ptr_t<_SmartPtr, _Pointer, _ArgsT&&...>(_Smart_ptr, ::std:: forward<_ArgsT>(_Args)...);
    }
}
#line 4334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"















#line 4350 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"

}






#pragma warning(pop)
#pragma pack(pop)
#line 4361 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
#line 4362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\memory"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfacet"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
extern "C++" class __declspec(dllimport) _Facet_base { 
public:
    virtual  ~_Facet_base() noexcept {} 

    
    virtual void  _Incref() noexcept = 0;

    
    virtual _Facet_base*  _Decref() noexcept = 0;
};



#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfacet"
extern "C++" void __cdecl _Facet_Register(_Facet_base*);
#line 39 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfacet"
}


#pragma warning(pop)
#pragma pack(pop)
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfacet"
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfacet"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_xlocinfo_types.hpp"










#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {

struct _Collvec { 
    unsigned int _Page; 
    wchar_t* _LocaleName;
};

struct _Ctypevec { 
    unsigned int _Page; 
    const short* _Table;
    int _Delfl;
    wchar_t* _LocaleName;
};

struct _Cvtvec { 
    unsigned int _Page; 
    unsigned int _Mbcurmax;
    int _Isclocale; 
    unsigned char _Isleadbyte[32]; 
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_xlocinfo_types.hpp"
#line 47 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_xlocinfo_types.hpp"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cctype"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {









  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);








__inline int __cdecl __acrt_locale_get_ctype_array_value(
      unsigned short const * const _Locale_pctype_array,
              int                    const _Char_value,
                             int                    const _Mask
    )
{
    
    
    
    
    if (_Char_value >= -1 && _Char_value <= 255)
    {
        return _Locale_pctype_array[_Char_value] & _Mask;
    }

    return 0;
}



    
    
    




















    
    
    




        
    #line 137 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    
    

    







        __forceinline int __cdecl __ascii_tolower(int const _C)
        {
            if (_C >= 'A' && _C <= 'Z')
            {
                return _C - ('A' - 'a');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_toupper(int const _C)
        {
            if (_C >= 'a' && _C <= 'z')
            {
                return _C - ('a' - 'A');
            }
            return _C;
        }

        __forceinline int __cdecl __ascii_iswalpha(int const _C)
        {
            return (_C >= 'A' && _C <= 'Z') || (_C >= 'a' && _C <= 'z');
        }

        __forceinline int __cdecl __ascii_iswdigit(int const _C)
        {
            return _C >= '0' && _C <= '9';
        }

        __forceinline int __cdecl __ascii_towlower(int const _C)
        {
            return __ascii_tolower(_C);
        }

        __forceinline int __cdecl __ascii_towupper(int const _C)
        {
            return __ascii_toupper(_C);
        }
    #line 189 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    












#line 206 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    



    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        


        if (_Locale)
        {
            return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        }

        return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask)));
        #line 233 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale) {
            if (_C >= -1 && _C <= 255)
            {
                return __acrt_get_locale_data_prefix(_Locale)->_locale_pctype[_C] & _Mask;
            }

            if (__acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
            {
                return _isctype_l(_C, _Mask, _Locale);
            }

            return 0; 
        }

        return _chvalidchk_l(_C, _Mask, 0);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 293 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



    
    
    
    
#line 301 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"



#line 305 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
} __pragma(pack(pop))

#pragma warning(pop) 
#line 309 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\ctype.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cctype"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 using :: isalnum;
 using :: isalpha;
 using :: iscntrl;
 using :: isdigit;
 using :: isgraph;
 using :: islower;
 using :: isprint;
 using :: ispunct;
 using :: isspace;
 using :: isupper;
 using :: isxdigit;
 using :: tolower;
 using :: toupper;

 using :: isblank;
}



#pragma warning(pop)
#pragma pack(pop)

#line 44 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cctype"
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\cctype"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\clocale"










#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"







#pragma once





#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};

struct tm;























    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    
    __declspec(dllimport) int __cdecl _configthreadlocale(
          int _Flag
        );

        
    __declspec(dllimport) char* __cdecl setlocale(
                int         _Category,
          char const* _Locale
        );

    
    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    
    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    
    __declspec(dllimport) _locale_t __cdecl _create_locale(
            int         _Category,
          char const* _Locale
        );

    __declspec(dllimport) void __cdecl _free_locale(
          _locale_t _Locale
        );

    
        
    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(
                int            _Category,
          wchar_t const* _Locale
        );

    
    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(
            int            _Category,
          wchar_t const* _Locale
        );



    __declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);




    
     
     
    __declspec(dllimport) char*    __cdecl _Getdays(void);

     
     
    __declspec(dllimport) char*    __cdecl _Getmonths(void);

    __declspec(dllimport) void*    __cdecl _Gettnames(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

     
     
    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void*    __cdecl _W_Gettnames(void);

     
    __declspec(dllimport) size_t __cdecl _Strftime(
          char*           _Buffer,
                              size_t           _Max_size,
                            char const*      _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg);

     
    __declspec(dllimport) size_t __cdecl _Wcsftime(
          wchar_t*        _Buffer,
                              size_t           _Max_size,
                            wchar_t const*   _Format,
                              struct tm const* _Timeptr,
                          void*            _Lc_time_arg
        );

#line 179 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"


} __pragma(pack(pop))

#pragma warning(pop) 
#line 185 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\locale.h"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\clocale"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 using :: lconv;
 using :: localeconv;
 using :: setlocale;
}



#pragma warning(pop)
#pragma pack(pop)

#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\clocale"
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\clocale"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {




















 _Collvec __cdecl _Getcoll();
 _Ctypevec __cdecl _Getctype();
 _Cvtvec __cdecl _Getcvt();
 int __cdecl _Getdateorder();







   int __cdecl _Mbrtowc(
     wchar_t*, const char*, size_t _Max_multibyte, mbstate_t*, const _Cvtvec*);
#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"

 int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
 size_t __cdecl _Strxfrm( 
                                                            char* _String1,
      char* _End1, const char*, const char*, const _Collvec*);
 int __cdecl _Tolower(int, const _Ctypevec*);
 int __cdecl _Toupper(int, const _Ctypevec*);
   int __cdecl
    _Wcrtomb(  char*, wchar_t, mbstate_t*, const _Cvtvec*);
 int __cdecl _Wcscoll(
    const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
 size_t __cdecl _Wcsxfrm(   
                                                          wchar_t* _String1,
      wchar_t* _End1, const wchar_t*, const wchar_t*, const _Collvec*);

 short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
 const wchar_t* __cdecl _Getwctypes(
    const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
 wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
 wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);

}

extern "C" {
    __declspec(dllimport) char* __cdecl _Getdays();

    __declspec(dllimport) char* __cdecl _Getmonths();

__declspec(dllimport) void* __cdecl _Gettnames();

  __declspec(dllimport) size_t __cdecl _Strftime(
      char*,   size_t _Maxsize,   const char*,   const tm*,   void*);

    __declspec(dllimport) wchar_t* __cdecl _W_Getdays();

    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths();

__declspec(dllimport) void* __cdecl _W_Gettnames();

  __declspec(dllimport) size_t __cdecl _Wcsftime(
      wchar_t*,   size_t _Maxsize,   const wchar_t*,   const tm*,   void*);
}

namespace std {
extern "C++" class __declspec(dllimport) _Timevec { 
public:
    explicit  _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr) {}

     _Timevec(const _Timevec& _Right) : _Timeptr(nullptr) {
        *this = _Right;
    }

     ~_Timevec() noexcept {
        :: free(_Timeptr);
    }

    _Timevec&  operator=(const _Timevec& _Right) { 
        if (this != &_Right) {
            :: free(_Timeptr);
            _Timeptr                               = _Right._Timeptr;
            const_cast<_Timevec&>(_Right)._Timeptr = nullptr; 
        }

        return *this;
    }

    void*  _Getptr() const {
        return _Timeptr;
    }

private:
    void* _Timeptr; 
};

extern "C++" template <class _Elem>
class __declspec(dllimport) _Yarn { 
public:
     _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

     _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

     _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
        *this = _Right;
    }

    _Yarn&  operator=(const _Yarn& _Right) noexcept {
        return *this = _Right._Myptr;
    }

    _Yarn&  operator=(const _Elem* _Right) noexcept {
        if (_Myptr != _Right) { 
            _Tidy();

            if (_Right) { 
                const _Elem* _Ptr = _Right;
                while (*_Ptr != _Elem{}) {
                    ++_Ptr;
                }

                const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);




                _Myptr = static_cast<_Elem*>(:: malloc(_Count));
#line 168 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"

                if (_Myptr) {
                    :: memcpy(_Myptr, _Right, _Count);
                }
            }
        }

        return *this;
    }

     ~_Yarn() noexcept {
        _Tidy();
    }

    [[nodiscard]] bool  empty() const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem*  c_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

    [[nodiscard]] bool  _Empty() const noexcept {
        return _Myptr == nullptr;
    }

      const _Elem*  _C_str() const noexcept {
        return _Myptr ? _Myptr : &_Nul;
    }

private:
    void  _Tidy() noexcept {
        if (_Myptr) {



            :: free(_Myptr);
#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
        }

        _Myptr = nullptr;
    }

    _Elem* _Myptr; 
    _Elem _Nul; 
};

extern "C++" class __declspec(dllimport) _Locinfo { 
public:
    using _Collvec  = ::_Collvec;
    using _Ctypevec = ::_Ctypevec;
    using _Cvtvec   = ::_Cvtvec;
    using _Timevec  = ::std:: _Timevec;

    static void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
    static void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
    static void __cdecl _Locinfo_dtor(_Locinfo*);
    static _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

     _Locinfo(const char* _Pch = "C")

        : _Lock(0)
#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     _Locinfo(int _Cat, const char* _Pch)

        : _Lock(0)
#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
    {
        if (_Pch) {
            _Locinfo_ctor(this, _Cat, _Pch);
            return;
        }

        _Xruntime_error("bad locale name");
    }

     ~_Locinfo() noexcept {
        _Locinfo_dtor(this);
    }

    _Locinfo&  _Addcats(int _Cat, const char* _Pch) { 
        if (_Pch) {
            return _Locinfo_Addcats(this, _Cat, _Pch);
        }

        _Xruntime_error("bad locale name");
    }

    const char*  _Getname() const {
        return _Newlocname._C_str();
    }

    _Collvec  _Getcoll() const {
        return ::_Getcoll();
    }

    _Ctypevec  _Getctype() const {
        return ::_Getctype();
    }

    _Cvtvec  _Getcvt() const {
        return ::_Getcvt();
    }

    const lconv*  _Getlconv() const {
        return localeconv();
    }

    _Timevec  _Gettnames() const {
        return _Timevec(::_Gettnames());
    }

    const char*  _Getdays() const {
        const char* _Ptr = ::_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Days = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Days._Empty() ? _Days._C_str()
                               : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                 ":Thu:Thursday:Fri:Friday:Sat:Saturday";
    }

    const char*  _Getmonths() const {
        const char* _Ptr = ::_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_Months = _Ptr;
            :: free(const_cast<char*>(_Ptr));
        }

        return !_Months._Empty() ? _Months._C_str()
                                 : ":Jan:January:Feb:February:Mar:March"
                                   ":Apr:April:May:May:Jun:June"
                                   ":Jul:July:Aug:August:Sep:September"
                                   ":Oct:October:Nov:November:Dec:December";
    }

    const char*  _Getfalse() const {
        return "false";
    }

    const char*  _Gettrue() const {
        return "true";
    }

    int  _Getdateorder() const {
        return ::_Getdateorder();
    }

    _Timevec  _W_Gettnames() const {
        return _Timevec(::_W_Gettnames());
    }

    const unsigned short*  _W_Getdays() const {
        const wchar_t* _Ptr = ::_W_Getdays();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Days._Empty()) {
            _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
        } else {
            _Ret = _W_Days._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    const unsigned short*  _W_Getmonths() const {
        const wchar_t* _Ptr = ::_W_Getmonths();
        if (_Ptr) { 
            const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
            :: free(const_cast<wchar_t*>(_Ptr));
        }

        const wchar_t* _Ret;

        if (_W_Months._Empty()) {
            _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                   L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
        } else {
            _Ret = _W_Months._C_str();
        }

        return reinterpret_cast<const unsigned short*>(_Ret);
    }

    _Locinfo(const _Locinfo&)            = delete;
    _Locinfo& operator=(const _Locinfo&) = delete;

private:



    _Lockit _Lock; 
#line 377 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"

    _Yarn<char> _Days; 
    _Yarn<char> _Months; 
    _Yarn<wchar_t> _W_Days; 
    _Yarn<wchar_t> _W_Months; 
    _Yarn<char> _Oldlocname; 
    _Yarn<char> _Newlocname; 
};

template <class _Elem>
int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2) {
        if (*_First1 < *_First2) {
            return -1; 
        } else if (*_First2 < *_First1) {
            return +1; 
        }
    }

    return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
}

template <>
inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline int __cdecl _LStrcoll(const wchar_t* _First1, const wchar_t* _Last1, const wchar_t* _First2,
    const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
}

template <class _Elem>
size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2,
    const _Locinfo::_Collvec*) { 
    const ptrdiff_t _Count = _Last2 - _First2;
    if (_Count <= _Last1 - _First1) {
        :: memcpy(_First1, _First2, _Count * sizeof(_Elem));
    }

    return _Count;
}

template <>
inline size_t __cdecl _LStrxfrm(    char* _First1,
      char* _Last1, const char* _First2, const char* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}

template <>
inline size_t __cdecl _LStrxfrm(    wchar_t* _First1,
      wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2,
    const _Locinfo::_Collvec* _Vector) { 
    return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 443 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
#line 444 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocinfo"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Dummy>
class _Locbase { 
public:
     static const int collate  = ((1 << (1)) >> 1);
     static const int ctype    = ((1 << (2)) >> 1);
     static const int monetary = ((1 << (3)) >> 1);
     static const int numeric  = ((1 << (4)) >> 1);
     static const int time     = ((1 << (5)) >> 1);
     static const int messages = ((1 << (6)) >> 1);
     static const int all      = (((1 << ((6 + 1))) >> 1) - 1);
     static const int none     = 0;
};

template <class _Dummy>
const int _Locbase<_Dummy>::collate;
template <class _Dummy>
const int _Locbase<_Dummy>::ctype;
template <class _Dummy>
const int _Locbase<_Dummy>::monetary;
template <class _Dummy>
const int _Locbase<_Dummy>::numeric;
template <class _Dummy>
const int _Locbase<_Dummy>::time;
template <class _Dummy>
const int _Locbase<_Dummy>::messages;
template <class _Dummy>
const int _Locbase<_Dummy>::all;
template <class _Dummy>
const int _Locbase<_Dummy>::none;

 template <class _Elem>
class collate;

extern "C++" struct __declspec(dllimport) _Crt_new_delete { 




























};

 extern "C++" class locale : public _Locbase<int>, public _Crt_new_delete {
public:
    using category = int;

    class __declspec(dllimport) id { 
    public:
         id(size_t _Val = 0) : _Id(_Val) {}

        id(const id&)            = delete;
        id& operator=(const id&) = delete;

         operator size_t() { 
            if (_Id == 0) { 
                { ::std:: _Lockit _Lock(0);
                if (_Id == 0) {
                    _Id = static_cast<size_t>(++_Id_cnt);
                }
                }
            }
            return _Id;
        }

    private:
        size_t _Id; 

         static int _Id_cnt;
    };

    struct _Facet_guard;

    class __declspec(dllimport) facet : public _Facet_base, public _Crt_new_delete {
        
    private:
        friend _Facet_guard;

    public:
        static size_t __cdecl _Getcat(const facet** = nullptr, const locale* = nullptr) {
            
            return static_cast<size_t>(-1);
        }

        void  _Incref() noexcept override { 
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs));
        }

        _Facet_base*  _Decref() noexcept override { 
            if (_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0) {
                return this;
            }

            return nullptr;
        }

    private:
        _Atomic_counter_t _Myrefs; 

    protected:
        explicit  facet(size_t _Initrefs = 0) noexcept 
            : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) 
        {}

         ~facet() noexcept override {}

    public:
         facet(const facet&)            = delete;
        facet&  operator=(const facet&) = delete;
    };

    struct [[nodiscard]] _Facet_guard {
        facet* _Target;
        ~_Facet_guard() {
            if (_Target) {
                delete _Target->_Decref();
            }
        }
    };

    class __declspec(dllimport) _Locimp : public facet { 
    protected:
         ~_Locimp() noexcept {
            _Locimp_dtor(this);
        }

    private:
        static _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
        static _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);

        static void __cdecl _Locimp_dtor(_Locimp*);
        static void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t); 
        static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);

        friend locale;

         _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*") {
        }

         _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str()) {
            _Locimp_ctor(this, _Right);
        }

        void  _Addfac(facet* _Pfacet, size_t _Id) { 
            _Locimp_Addfac(this, _Pfacet, _Id);
        }

        static _Locimp* __cdecl _Makeloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        static void __cdecl _Makewloc(
            const _Locinfo&, category, _Locimp*, const locale*); 


        static void __cdecl _Makeushloc(
            const _Locinfo&, category, _Locimp*, const locale*); 
#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

        static void __cdecl _Makexloc(
            const _Locinfo&, category, _Locimp*, const locale*); 

        facet** _Facetvec; 
        size_t _Facetcount; 
        category _Catmask; 
        bool _Xparent; 
        _Yarn<char> _Name; 

         static _Locimp* _Clocptr;

    public:
        _Locimp&  operator=(const _Locimp&) = delete;
    };

    template <class _Elem, class _Traits, class _Alloc>
    bool operator()(
        const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const {
        
        const auto& _Coll_fac = ::std:: use_facet<::std:: collate<_Elem>>(*this);

        const _Elem* const _Left_data  = _Left.data();
        const _Elem* const _Right_data = _Right.data();
        return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
    }

    template <class _Facet>
    locale combine(const locale& _Loc) const { 
        _Facet* _Facptr;

        try {
        _Facptr = const_cast<_Facet*>(::std:: addressof(::std:: use_facet<_Facet>(_Loc)));
        } catch (...) {
        _Xruntime_error("locale::combine facet missing");
        }

        _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
        _Newimp->_Addfac(_Facptr, _Facet::id);
        _Newimp->_Catmask = none;
        _Newimp->_Name    = "*";
        return locale{_Newimp};
    }

    template <class _Facet>
    locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        if (_Facptr) { 
            _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
            _Ptr->_Catmask = none;
            _Ptr->_Name    = "*";
        }
    }

#pragma warning(push)
#pragma warning(disable : 26495) 
                                 

    
    
    
    
    
    
    locale(_Uninitialized) {} 
#pragma warning(pop)

    locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {
        _Ptr->_Incref();
    }

    locale() noexcept : _Ptr(_Init(true)) {}


    locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        if (_Cat != none) { 
            ;
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj;
            _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
            _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
            _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
            _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
            _Ptr->_Name    = _Lobj._Getname();
            }
            _Guard._Target = nullptr;
        }
    }

private:
    void _Construct(const string& _Str, category _Cat) {
        ;
        
        bool _Bad = false;
        _Init();
        if (_Cat != none) { 
            _Facet_guard _Guard{_Ptr};
            { _Locinfo _Lobj(_Cat, _Str.c_str());
            if (_Badname(_Lobj)) {
                _Bad = true;
            } else { 
                _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                _Ptr->_Catmask = _Cat;
                _Ptr->_Name    = _Str.c_str();
            }
            }
            _Guard._Target = nullptr;
        }

        if (_Bad) { 
            delete _Ptr->_Decref();
            _Xruntime_error("bad locale name");
        }
    }

public:
    explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        
        
        if (_Locname) {
            _Construct(_Locname, _Cat);
            return;
        }

        _Xruntime_error("bad locale name");
    }

    explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp()) {
        
        _Construct(_Str, _Cat);
    }

    locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr)) {
        
        _Construct(_Str, _Cat);
    }
#line 356 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

    ~locale() noexcept {
        if (_Ptr) {
            delete _Ptr->_Decref();
        }
    }

    const locale& operator=(const locale& _Right) noexcept {
        if (_Ptr != _Right._Ptr) { 
            delete _Ptr->_Decref();
            _Ptr = _Right._Ptr;
            _Ptr->_Incref();
        }
        return *this;
    }

    string name() const {
        return _Ptr ? _Ptr->_Name.c_str() : string{};
    }

      const char* _C_str() const noexcept {
        return _Ptr ? _Ptr->_Name.c_str() : "";
    }

    const facet* _Getfacet(size_t _Id) const { 
        const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; 
        if (_Facptr || !_Ptr->_Xparent) {
            return _Facptr; 
        }

        
        locale::_Locimp* _Ptr0 = _Getgloballocale();
        if (_Id < _Ptr0->_Facetcount) {
            return _Ptr0->_Facetvec[_Id]; 
        }

        return nullptr; 
    }

    [[nodiscard]] bool operator==(const locale& _Loc) const noexcept  { 
        return _Ptr == _Loc._Ptr || (:: strcmp(_C_str(), "*") != 0 && :: strcmp(_C_str(), _Loc._C_str()) == 0);
    }





#line 404 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

    static  const locale& __cdecl classic(); 

    static  locale __cdecl global(const locale&); 

    static  locale __cdecl empty(); 

private:
    locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp) {}

    static  _Locimp* __cdecl _Init(bool _Do_incref = false); 
    static  _Locimp* __cdecl _Getgloballocale();
    static  void __cdecl _Setgloballocale(void*);

    bool _Badname(const _Locinfo& _Lobj) { 
        return :: strcmp(_Lobj._Getname(), "*") == 0;
    }

    _Locimp* _Ptr; 
};

template <class _Facet>
struct _Facetptr { 
     static const locale::facet* _Psave;
};

template <class _Facet>
 const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

 template <class _Facet>
const _Facet& __cdecl use_facet(const locale& _Loc) { 
    { ::std:: _Lockit _Lock(0); 
    const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; 

    const size_t _Id         = _Facet::id;
    const locale::facet* _Pf = _Loc._Getfacet(_Id);

    if (!_Pf) {
        if (_Psave) {
            _Pf = _Psave; 
        } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

            _Throw_bad_cast(); 


#line 450 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
        } else { 
            auto _Pfmod = const_cast<locale::facet*>(_Psave);
            unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));



#line 457 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
            _Facet_Register(_Pfmod);
#line 459 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

            _Pfmod->_Incref();
            _Facetptr<_Facet>::_Psave = _Psave;
            _Pf                       = _Psave;

            (void) _Psave_guard.release();
        }
    }

    return static_cast<const _Facet&>(*_Pf); 
    }
} 

template <class _Elem>
char __cdecl _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&) {
    
    return static_cast<char>(static_cast<unsigned char>(_Char));
}

template <>
inline char __cdecl _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
    return _Byte;
}


template <>
inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt) {
    
    char _Byte       = '\0';
    mbstate_t _Mbst1 = {};
    _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
    return _Byte;
}
#line 497 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

template <class _Elem>
_Elem __cdecl _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {
    
    return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
}

template <>
inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    wchar_t _Wc      = L'\0';
    mbstate_t _Mbst1 = {};
    _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}


template <>
inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    unsigned short _Wc = 0;
    mbstate_t _Mbst1   = {};
    _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
    return _Wc;
}
#line 523 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

template <class _Elem>
_Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {
    
    size_t _Count = :: strlen(_Ptr) + 1;

    _Elem* _Ptrdest = static_cast<_Elem*>(calloc(_Count, sizeof(_Elem)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {
        *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
    }

    return _Ptrdest;
}

template <>
inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    wchar_t _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};

    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';

    return _Ptrdest;
}


template <>
inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt) {
    
    size_t _Count;
    size_t _Count1;
    size_t _Wchars;
    const char* _Ptr1;
    int _Bytes;
    unsigned short _Wc;
    mbstate_t _Mbst1 = {};

    _Count1 = :: strlen(_Ptr) + 1;
    for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {
        if ((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {
            break;
        }
    }

    ++_Wchars; 

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    wchar_t* _Ptrnext = _Ptrdest;
    mbstate_t _Mbst2  = {};
    for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {
        if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {
            break;
        }
    }

    *_Ptrnext = L'\0';
    return reinterpret_cast<unsigned short*>(_Ptrdest);
}
#line 621 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

 extern "C++" class __declspec(dllimport) codecvt_base 
    : public locale::facet 
{
public:
    enum { 
        ok,
        partial,
        error,
        noconv
    };
    using result = int;

     codecvt_base(size_t _Refs = 0) noexcept 
        : locale::facet(_Refs) {}

    bool  always_noconv() const noexcept {
        
        return do_always_noconv();
    }

    int  max_length() const noexcept {
        
        return do_max_length();
    }

    int  encoding() const noexcept {
        return do_encoding();
    }

     ~codecvt_base() noexcept {}

protected:
    virtual bool  do_always_noconv() const noexcept {
        
        return false;
    }

    virtual int  do_max_length() const noexcept {
        
        return 1;
    }

    virtual int  do_encoding() const noexcept {
        return 1; 
    }
};

template <class _Ty>
inline constexpr bool _Is_one_byte_char_like_v = _Is_any_of_v<remove_cv_t<_Ty>, signed char, unsigned char,

    byte,
#line 674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

    char8_t,
#line 677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
    char>;

template <class _Elem, class _Byte>
inline constexpr bool _Is_codecvt_do_always_noconv_v =
    is_same_v<_Byte, _Elem> || (_Is_one_byte_char_like_v<_Byte> && _Is_one_byte_char_like_v<_Elem>);

 extern "C++" template <class _Elem, class _Byte, class _Statype>
class codecvt : public codecvt_base { 
public:
    
    
    
    
    
    
    

    static_assert(!0 || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
        "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using intern_type = _Elem;
    using extern_type = _Byte;
    using state_type  = _Statype;

    result  in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id; 

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Locinfo());
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    bool  do_always_noconv() const noexcept override {
        
        return _Is_codecvt_do_always_noconv_v<_Elem, _Byte>;
    }

    virtual result  do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1,
        _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Elem>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1,
        _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const { 
        _Mid1 = _First1;
        _Mid2 = _First2;
        if constexpr (_Is_codecvt_do_always_noconv_v<_Elem, _Byte>) {
            return noconv; 
        } else {
            
            for (; _Mid1 != _Last1; ++_Mid1, ++_Mid2) {
                if (_Mid2 == _Last2) {
                    return partial;
                }
                *_Mid2 = static_cast<_Byte>(*_Mid1);
            }

            return ok;
        }
    }

    virtual result  do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        _Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const {
        
        
        
        const auto _Dist = static_cast<size_t>((::std:: min)(_Last1 - _First1, ptrdiff_t{2147483647}));
        return static_cast<int>((::std:: min)(_Count, _Dist));
    }
};






template <class _Elem, class _Byte, class _Statype>
 locale::id codecvt<_Elem, _Byte, _Statype>::id;





  template <class _CvtTy, class _Byte, class _Statype>
[[nodiscard]] int _Codecvt_do_length(
    const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) {
    
    

    __pragma(warning(push)) __pragma(warning(disable : 4996))
    using _Elem = typename _CvtTy::intern_type;
    __pragma(warning(pop))

    _Adl_verify_range(_First1, _Last1);
    const auto _Old_first1 = _First1;

    while (_Count > 0 && _First1 != _Last1) { 
        const _Byte* _Mid1;
        _Elem* _Mid2;
        _Elem _Ch;

        

        __pragma(warning(push)) __pragma(warning(disable : 4996))
        const auto _Result = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
        __pragma(warning(pop))

        if (_Result != codecvt_base::ok) {
            if (_Result == codecvt_base::noconv) {
                _First1 += (::std:: min)(static_cast<size_t>(_Last1 - _First1), _Count);
            }

            break; 
        }

        if (_Mid2 == &_Ch + 1) {
            --_Count; 
        }

        _First1 = _Mid1;
    }

    return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
}

enum _Codecvt_mode { _Consume_header = 4, _Generate_header = 2 };

extern "C++" template <>
class __declspec(dllimport) [[deprecated("warning STL4020: " "std::codecvt<char16_t, char, mbstate_t>, std::codecvt<char32_t, char, mbstate_t>, " "std::codecvt_byname<char16_t, char, mbstate_t>, and std::codecvt_byname<char32_t, char, mbstate_t> " "are deprecated in C++20 and replaced by specializations with a second argument of type char8_t. " "You can define _SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
    codecvt<char16_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char16_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            __pragma(warning(pop))
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;
            int _Nskip;

            if (*_Pstate > 1) {
                if (_By < 0x80 || 0xc0 <= _By) {
                    return codecvt::error; 
                }

                
                ++_Mid1;
                *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                *_Pstate = 1;
                continue;
            }

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            _Nskip  = _Nextra < 3 ? 0 : 1; 
            _First1 = _Mid1; 

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip) {
                break; 
            } else {
                for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (0 < _Nskip) {
                _Ch <<= 6; 
            }

            if ((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch) {
                return codecvt::error; 
            }

            if (0xffffu < _Ch) { 
                unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                *_Mid2++ = static_cast<char16_t>(_Ch0);
                *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                continue;
            }

            if (_Nskip != 0) {
                if (_Mid1 == _Last1) { 
                    _Mid1 = _First1;
                    break;
                }

                if ((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By) {
                    return codecvt::error; 
                }

                _Ch |= _By & 0x3f; 
            }

            if (*_Pstate == 0u) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }

                    return _Ans;
                }
            }

            *_Mid2++ = static_cast<char16_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid1                   = _First1;
        _Mid2                   = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned long _Ch;
            const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
            bool _Save                = false;

            if (1 < *_Pstate) { 
                if (_Ch1 < 0xdc00u || 0xe000u <= _Ch1) {
                    return codecvt::error; 
                }

                _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
            } else if (0xd800u <= _Ch1 && _Ch1 < 0xdc00u) { 
                _Ch   = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                _Save = true; 
            } else {
                _Ch = _Ch1; 
            }

            char _By;
            int _Nextra;

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x10000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            }

            int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

            if (_Last2 - _Mid2 < _Nput) {
                break; 
            }

            if (*_Pstate == 0u && (_Mode & _Generate_header) != 0) {
                if (_Last2 - _Mid2 < 3 + _Nput) {
                    break; 
                }

                
                *_Mid2++ = '\xef';
                *_Mid2++ = '\xbb';
                *_Mid2++ = '\xbf';
            }

            ++_Mid1;
            if (_Save || _Nextra < 3) { 
                *_Mid2++ = _By;
                --_Nput;
            }

            for (; 0 < _Nput; --_Nput) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }

            *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const {
        
        unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
        _Mid2                   = _First2;

        return 1u < *_Pstate ? codecvt::error : codecvt::ok; 
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        

        if ((_Mode & _Consume_header) != 0) {
            return 9; 
        }

        if ((_Mode & _Generate_header) != 0) {
            return 7; 
        }

        return 6; 
    }

    int do_encoding() const noexcept override {
        return 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};

extern "C++" template <>
class __declspec(dllimport) [[deprecated("warning STL4020: " "std::codecvt<char16_t, char, mbstate_t>, std::codecvt<char32_t, char, mbstate_t>, " "std::codecvt_byname<char16_t, char, mbstate_t>, and std::codecvt_byname<char32_t, char, mbstate_t> " "are deprecated in C++20 and replaced by specializations with a second argument of type char8_t. " "You can define _SILENCE_CXX20_CODECVT_FACETS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX20_DEPRECATION_WARNINGS to suppress this warning.")]]
    codecvt<char32_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char32_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header) {
        _Init(_Lobj);
    }

     codecvt(
        const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            __pragma(warning(push)) __pragma(warning(disable : 4996))
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
            __pragma(warning(pop))
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo&) {} 

    virtual result  do_in(mbstate_t& _State, const char* _First1, const char* _Last1,
        const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            unsigned char _By = static_cast<unsigned char>(*_Mid1);
            unsigned long _Ch;
            int _Nextra;

            if (_By < 0x80u) {
                _Ch     = _By;
                _Nextra = 0;
            } else if (_By < 0xc0u) { 
                ++_Mid1;
                return codecvt::error;
            } else if (_By < 0xe0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x1f);
                _Nextra = 1;
            } else if (_By < 0xf0u) {
                _Ch     = static_cast<unsigned long>(_By & 0x0f);
                _Nextra = 2;
            } else if (_By < 0xf8u) {
                _Ch     = static_cast<unsigned long>(_By & 0x07);
                _Nextra = 3;
            } else {
                _Ch     = static_cast<unsigned long>(_By & 0x03);
                _Nextra = _By < 0xfc ? 4 : 5;
            }

            if (_Nextra == 0) {
                ++_Mid1;
            } else if (_Last1 - _Mid1 < _Nextra + 1) {
                break; 
            } else {
                for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1) {
                    if ((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By) {
                        return codecvt::error; 
                    } else {
                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;

                if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu) { 
                    const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                    if (_Ans == codecvt::partial) { 
                        *_Pstate = 0;
                        _Mid1    = _First1;
                    }
                    return _Ans;
                }
            }

            if (_Maxcode < _Ch) {
                return codecvt::error; 
            }

            *_Mid2++ = static_cast<char32_t>(_Ch);
        }

        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        char* _Pstate = reinterpret_cast<char*>(&_State);
        _Mid1         = _First1;
        _Mid2         = _First2;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) { 
            char _By;
            int _Nextra;
            unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

            if (_Maxcode < _Ch) {
                return codecvt::error;
            }

            if (_Ch < 0x0080u) {
                _By     = static_cast<char>(_Ch);
                _Nextra = 0;
            } else if (_Ch < 0x0800u) {
                _By     = static_cast<char>(0xc0 | _Ch >> 6);
                _Nextra = 1;
            } else if (_Ch < 0x00010000u) {
                _By     = static_cast<char>(0xe0 | _Ch >> 12);
                _Nextra = 2;
            } else if (_Ch < 0x00200000u) {
                _By     = static_cast<char>(0xf0 | _Ch >> 18);
                _Nextra = 3;
            } else if (_Ch < 0x04000000u) {
                _By     = static_cast<char>(0xf8 | _Ch >> 24);
                _Nextra = 4;
            } else {
                _By     = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
                _Nextra = 5;
            }

            if (*_Pstate == 0) { 
                *_Pstate = 1;
                if ((_Mode & _Generate_header) != 0) {
                    if (_Last2 - _Mid2 < 3 + 1 + _Nextra) {
                        return codecvt::partial; 
                    }

                    
                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }
            }

            if (_Last2 - _Mid2 < 1 + _Nextra) {
                break; 
            }

            ++_Mid1;
            for (*_Mid2++ = _By; 0 < _Nextra;) {
                *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
            }
        }
        return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
    }

    virtual result  do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const {
        
        _Mid2 = _First2;
        return codecvt::noconv;
    }

    friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
    }

    int  do_encoding() const noexcept override {
        
        return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1
                                                                   : 0; 
    }

private:
    unsigned long _Maxcode; 
    _Codecvt_mode _Mode; 
};


template <class _From, class _To>
struct [[nodiscard]] _Codecvt_guard {
    const _From* const& _First1;
    const _From*& _Mid1;
    _To* const& _First2;
    _To*& _Mid2;

    _Codecvt_guard(const _From* const& _First1_, const _From*& _Mid1_, _To* const& _First2_, _To*& _Mid2_)
        : _First1{_First1_}, _Mid1{_Mid1_}, _First2{_First2_}, _Mid2{_Mid2_} {}

    _Codecvt_guard(const _Codecvt_guard&)            = delete;
    _Codecvt_guard& operator=(const _Codecvt_guard&) = delete;

    ~_Codecvt_guard() {
        _Mid1 = _First1;
        _Mid2 = _First2;
    }
};

extern "C++" template <>
class codecvt<char16_t, char8_t, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char16_t;
    using extern_type = char8_t;
    using state_type  = mbstate_t;

    result in(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, const char8_t*& _Mid1,
        char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1, const char16_t*& _Mid1,
        char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result unshift(mbstate_t& _State, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int length(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

    __declspec(dllimport) static locale::id id;

    explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {} 
    explicit codecvt(const _Locinfo&, size_t _Refs = 0) : codecvt_base(_Refs) {} 

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt;
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override = default;

    virtual result  do_in(mbstate_t&, const char8_t* _First1, const char8_t* _Last1,
        const char8_t*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char8_t, char16_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) {
                return partial;
            }

            char8_t _Lead_byte = *_First1;
            if (_Lead_byte < 0b1000'0000u) { 
                *_First2 = static_cast<char16_t>(_Lead_byte);
                continue;
            }

            int _Trailing_count = 1;
            if (_Lead_byte < 0b1110'0000u) {
                if (_Lead_byte < 0b1100'0000u) { 
                    return error;
                }

                
                _Lead_byte &= 0b0001'1111u;
            } else if (_Lead_byte < 0b1111'0000u) { 
                _Lead_byte &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Lead_byte < 0b1111'1000u) { 
                if (_Last2 - _First2 < 2) { 
                    return partial;
                }

                _Lead_byte &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                return partial;
            }

            const char8_t* _Peek = _First1;
            char32_t _Code_point = _Lead_byte;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    return error;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Code_point < 0x10000u) {
                if (_Code_point >= 0xd800u && _Code_point < 0xe000u) { 
                    return error;
                }
                
                *_First2 = static_cast<char16_t>(_Code_point);
            } else if (_Code_point >= 0x110000u) { 
                return error;
            } else {
                
                _Code_point -= 0x10000u;
                
                *_First2 = static_cast<char16_t>(0xd800u | (_Code_point >> 10));
                
                *++_First2 = static_cast<char16_t>(0xdc00u | (_Code_point & 0b11'1111'1111u));
            }

            _First1 = _Peek;
        }

        return ok;
    }

    virtual result  do_out(mbstate_t&, const char16_t* _First1, const char16_t* _Last1,
        const char16_t*& _Mid1, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char16_t, char8_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) { 
                return partial;
            }

            char32_t _Code_point = *_First1;
            if (_Code_point < 0x80u) { 
                *_First2 = static_cast<char8_t>(_Code_point);
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0x800u) { 
                *_First2 = static_cast<char8_t>(0b1100'0000u | (_Code_point >> 6));
            } else if (_Code_point < 0xd800u || _Code_point >= 0xe000u) { 
                *_First2        = static_cast<char8_t>(0b1110'0000u | (_Code_point >> 12));
                _Trailing_count = 2;
            } else if (_Code_point < 0xdc00u) { 
                if (_Last1 - _First1 < 2) { 
                    return partial;
                }

                const char16_t _Low_surrogate = *++_First1;
                if (_Low_surrogate < 0xdc00u || _Low_surrogate >= 0xe000u) { 
                    --_First1;
                    return error;
                }
                _Code_point = 0x10000u + (((_Code_point & 0b11'1111'1111u) << 10) | (_Low_surrogate & 0b11'1111'1111u));

                
                *_First2        = static_cast<char8_t>(0b1111'0000u | (_Code_point >> 18));
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last2 - _First2 < _Trailing_count + 1) { 
                if (_Trailing_count > 2) { 
                    --_First1;
                }
                return partial;
            }

            do {
                --_Trailing_count;
                *++_First2 = static_cast<char8_t>(0b1000'0000u | ((_Code_point >> (6 * _Trailing_count)) & 0b11'1111u));
            } while (_Trailing_count != 0);
        }

        return ok;
    }

    virtual result  do_unshift(mbstate_t&, char8_t* _First2, char8_t*, char8_t*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        mbstate_t&, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);

        const auto _Old_first1 = _First1;

        for (; _First1 != _Last1 && _Count > 0u; ++_First1, --_Count) {
            char32_t _Code_point = *_First1;
            if (_Code_point < 0b1000'0000u) { 
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0b1110'0000u) {
                if (_Code_point < 0b1100'0000u) { 
                    break;
                }

                
                _Code_point &= 0b0001'1111u;
            } else if (_Code_point < 0b1111'0000u) { 
                _Code_point &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Code_point < 0b1111'1000u) { 
                if (_Count < 2u) { 
                    break;
                }

                _Code_point &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                break;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                break;
            }

            const char8_t* _Peek = _First1;
            bool _Done           = false;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    _Done = true;
                    break;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Done) {
                break;
            }

            if (_Code_point < 0x10000u) { 
                if (_Code_point >= 0xd800u && _Code_point < 0xe0000u) { 
                    break;
                }
            } else if (_Code_point < 0x110000u) { 
                --_Count;
            } else { 
                break;
            }

            _First1 = _Peek;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return 4; 
    }

    int  do_encoding() const noexcept override {
        
        return 0; 
    }
};

extern "C++" template <>
class codecvt<char32_t, char8_t, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = char32_t;
    using extern_type = char8_t;
    using state_type  = mbstate_t;

    result in(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, const char8_t*& _Mid1,
        char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1, const char32_t*& _Mid1,
        char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result unshift(mbstate_t& _State, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int length(mbstate_t& _State, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

    __declspec(dllimport) static locale::id id;

    explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {} 
    explicit codecvt(const _Locinfo&, size_t _Refs = 0) : codecvt_base(_Refs) {} 

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt;
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override = default;

    virtual result  do_in(mbstate_t&, const char8_t* _First1, const char8_t* _Last1,
        const char8_t*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char8_t, char32_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) {
                return partial;
            }

            char8_t _Lead_byte = *_First1;
            if (_Lead_byte < 0b1000'0000u) { 
                *_First2 = _Lead_byte;
                continue;
            }

            int _Trailing_count = 1;
            if (_Lead_byte < 0b1110'0000u) {
                if (_Lead_byte < 0b1100'0000u) { 
                    return partial;
                }

                
                _Lead_byte &= 0b0001'1111u;
            } else if (_Lead_byte < 0b1111'0000u) { 
                _Lead_byte &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Lead_byte < 0b1111'1000u) { 
                _Lead_byte &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                return partial;
            }

            const char8_t* _Peek = _First1;
            char32_t _Code_point = _Lead_byte;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    return error;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Code_point >= 0xd800u && (_Code_point < 0xe000u || _Code_point >= 0x110000u)) {
                
                return error;
            }

            _First1  = _Peek;
            *_First2 = _Code_point;
        }

        return ok;
    }

    virtual result  do_out(mbstate_t&, const char32_t* _First1, const char32_t* _Last1,
        const char32_t*& _Mid1, char8_t* _First2, char8_t* _Last2, char8_t*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);

        _Codecvt_guard<char32_t, char8_t> _Guard{_First1, _Mid1, _First2, _Mid2};

        for (; _First1 != _Last1; ++_First1, ++_First2) {
            if (_First2 == _Last2) { 
                return partial;
            }

            const char32_t _Code_point = *_First1;
            if (_Code_point < 0x80u) { 
                *_First2 = static_cast<char8_t>(_Code_point);
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0x800u) { 
                *_First2 = static_cast<char8_t>(0b1100'0000u | (_Code_point >> 6));
            } else if (_Code_point < 0x10000u) { 
                if (_Code_point >= 0xd800u && _Code_point < 0xe000u) { 
                    return error;
                }

                *_First2        = static_cast<char8_t>(0b1110'0000u | (_Code_point >> 12));
                _Trailing_count = 2;
            } else if (_Code_point < 0x110000u) { 
                *_First2        = static_cast<char8_t>(0b1111'0000u | (_Code_point >> 18));
                _Trailing_count = 3;
            } else { 
                return error;
            }

            if (_Last2 - _First2 < _Trailing_count + 1) { 
                return partial;
            }

            do {
                --_Trailing_count;
                *++_First2 = static_cast<char8_t>(0b1000'0000u | ((_Code_point >> (6 * _Trailing_count)) & 0b11'1111u));
            } while (_Trailing_count != 0);
        }

        return ok;
    }

    virtual result  do_unshift(mbstate_t&, char8_t* _First2, char8_t*, char8_t*& _Mid2) const {
        
        _Mid2 = _First2;
        return noconv; 
    }

    virtual int  do_length(
        mbstate_t&, const char8_t* _First1, const char8_t* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);

        const auto _Old_first1 = _First1;

        for (; _First1 != _Last1 && _Count > 0u; ++_First1, --_Count) {
            char32_t _Code_point = *_First1;
            if (_Code_point < 0b1000'0000u) { 
                continue;
            }

            int _Trailing_count = 1;
            if (_Code_point < 0b1110'0000u) {
                if (_Code_point < 0b1100'0000u) { 
                    break;
                }

                
                _Code_point &= 0b0001'1111u;
            } else if (_Code_point < 0b1111'0000u) { 
                _Code_point &= 0b0000'1111u;
                _Trailing_count = 2;
            } else if (_Code_point < 0b1111'1000u) { 
                _Code_point &= 0b0000'0111u;
                _Trailing_count = 3;
            } else { 
                break;
            }

            if (_Last1 - _First1 < _Trailing_count + 1) { 
                break;
            }

            const char8_t* _Peek = _First1;
            bool _Done           = false;
            do {
                const char8_t _By = *++_Peek;
                if ((_By & 0b1100'0000u) != 0b1000'0000u) { 
                    _Done = true;
                    break;
                }

                _Code_point = (_Code_point << 6) | (_By & 0b11'1111u);
            } while (--_Trailing_count != 0);

            if (_Done || (_Code_point >= 0xd800u && (_Code_point < 0xe000u || _Code_point >= 0x110000u))) {
                
                break;
            }

            _First1 = _Peek;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return 4;
    }

    int  do_encoding() const noexcept override {
        
        return 0; 
    }
};
#line 1936 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

extern "C++" template <>
class __declspec(dllimport) codecvt<wchar_t, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = wchar_t;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                [[fallthrough]];

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1,
        const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }
        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};


extern "C++" template <>
class __declspec(dllimport) codecvt<unsigned short, char, mbstate_t> : public codecvt_base {
    
public:
    using intern_type = unsigned short;
    using extern_type = char;
    using state_type  = mbstate_t;

    result  in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  out(mbstate_t& _State, const unsigned short* _First1, const unsigned short* _Last1,
        const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
    }

    result  unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        return do_unshift(_State, _First2, _Last2, _Mid2);
    }

    int  length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        return do_length(_State, _First1, _Last1, _Count);
    }

     static locale::id id;

    explicit  codecvt(size_t _Refs = 0) : codecvt_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    explicit  codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new codecvt(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~codecvt() noexcept override {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();
    }

    virtual result  do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1,
        unsigned short* _First2, unsigned short* _Last2, unsigned short*& _Mid2) const {
        
        mbstate_t _Mystate{};
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        for (;;) {
            if (_Mid1 == _Last1) {
                return ok;
            }

            if (_Mid2 == _Last2) {
                return partial;
            }

            int _Bytes = _Mbrtowc(
                reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
            switch (_Bytes) {
            case -2: 
                return partial;

            case -1: 
                return error;

            case 0: 
                _Bytes = 1;
                [[fallthrough]];

            default: 
                _Mid1 += _Bytes;
                ++_Mid2;
                break;
            }
        }
    }

    virtual result  do_out(mbstate_t& _State, const unsigned short* _First1,
        const unsigned short* _Last1, const unsigned short*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        _Mid1 = _First1;
        _Mid2 = _First2;
        int _Bytes;

        while (_Mid1 != _Last1 && _Mid2 != _Last2) {
            if (5 <= _Last2 - _Mid2) {
                if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else {
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            } else { 
                char _Buf[5];
                mbstate_t _Stsave = _State;

                if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {
                    return error; 
                } else if (_Last2 - _Mid2 < _Bytes) { 
                    _State = _Stsave;
                    break;
                } else { 
                    :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                    ++_Mid1;
                    _Mid2 += _Bytes;
                }
            }
        }

        return _Mid1 == _Last1 ? ok : partial;
    }

    virtual result  do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {
        
        _Adl_verify_range(_First2, _Last2);
        _Mid2       = _First2;
        result _Ans = ok;
        int _Bytes;
        char _Buf[5];
        mbstate_t _Stsave = _State;

        if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {
            _Ans = error; 
        } else if (_Last2 - _Mid2 < --_Bytes) { 
            _State = _Stsave;
            _Ans   = partial;
        } else if (0 < _Bytes) { 
            :: memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
            _Mid2 += _Bytes;
        }

        return _Ans;
    }

    virtual int  do_length(
        mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {
        
        
        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        for (; _Count > 0u && _First1 != _Last1; --_Count) {
            wchar_t _Ch;
            int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
            if (_Bytes < 0) { 
                break;
            }

            if (_Bytes == 0) { 
                _Bytes = 1;
            }

            
            _First1 += _Bytes;
        }

        return static_cast<int>((::std:: min)(_First1 - _Old_first1, ptrdiff_t{2147483647}));
    }

    bool  do_always_noconv() const noexcept override {
        
        return false;
    }

    int  do_max_length() const noexcept override {
        
        return static_cast<int>(_Cvt._Mbcurmax);
    }

    int  do_encoding() const noexcept override {
        
        return _Cvt._Mbcurmax == 1u; 
    }

private:
    _Locinfo::_Cvtvec _Cvt; 
};
#line 2336 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

 template <class _Elem, class _Byte, class _Statype>
class codecvt_byname : public codecvt<_Elem, _Byte, _Statype> { 
public:
    static_assert(!0
                      || _Is_any_of_v<codecvt_byname,

                          codecvt_byname<char16_t, char8_t, mbstate_t>, codecvt_byname<char32_t, char8_t, mbstate_t>,
#line 2345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
                          codecvt_byname<char, char, mbstate_t>, codecvt_byname<wchar_t, char, mbstate_t>>,
        "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit  codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs) {} 

    explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~codecvt_byname() noexcept override {}
};











 extern "C++" struct __declspec(dllimport) ctype_base 
    : locale::facet 
{
    enum { 
        alnum  = 0x04 | 0x02 | 0x01 | 0x100,
        alpha  = 0x02 | 0x01 | 0x100,
        cntrl  = 0x20,
        digit  = 0x04,
        graph  = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
        lower  = 0x02,
        print  = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
        punct  = 0x10,
        space  = 0x08 | 0x40,
        upper  = 0x01,
        xdigit = 0x80,
        blank  = 0x08 | 0x40
    };
    using mask = short; 

     ctype_base(size_t _Refs = 0) noexcept 
        : locale::facet(_Refs) {}

     ~ctype_base() noexcept override {}
};











 extern "C++" template <class _Elem>
class ctype : public ctype_base { 
public:
    
    static_assert(!0 || _Always_false<_Elem>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
        }

        return _First;
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
            }
        }
        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
        if (_Byte == '\0') {
            return _Ch;
        }

        return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) { 
            unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
            if (_Byte != '\0') {
                *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
            }
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Byte;
        if (_Ch == _Elem{}) {
            return '\0';
        }

        if ((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0') {
            return _Dflt;
        }

        return _Byte;
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};






template <class _Elem>
locale::id ctype<_Elem>::id;





extern "C++" template <>
class __declspec(dllimport) ctype<char> : public ctype_base { 
public:
    using _Elem     = char;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
        }

        return _First;
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const _Elem*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    _Elem  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(const mask* _Table = nullptr, bool _Deletetable = false,
        size_t _Refs = 0)
        : ctype_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }

        _Tidy(); 
        if (_Table) { 
            _Ctype._Table = _Table;
            _Ctype._Delfl = _Deletetable ? -1 : 0;
        } else { 
            _Ctype._Table = classic_table();
            _Ctype._Delfl = 0;
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

    const mask*  table() const noexcept {
        return _Ctype._Table;
    }

    static const mask* __cdecl classic_table() noexcept {
        return ::std:: use_facet<ctype>(locale::classic()).table();
    }

     static const size_t table_size = 1 << 8; 

protected:
     ~ctype() noexcept override {
        _Tidy();
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
    }

    void  _Tidy() noexcept { 
        if (0 < _Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        } else if (_Ctype._Delfl < 0) {
            delete[] _Ctype._Table;
        }

        :: free(_Ctype._LocaleName);
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
        }

        return _First;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Byte;
    }

    virtual const _Elem*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

    virtual _Elem  do_narrow(_Elem _Ch, char) const { 
        return _Ch;
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        :: memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
        return _Last;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
};

extern "C++" template <>
class __declspec(dllimport) ctype<wchar_t>
    : public ctype_base { 
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return :: _Getwctypes(_First, _Last, _Dest, &_Ctype);
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        wchar_t _Wc;
        return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(((wint_t)(0xFFFF))) : _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};


extern "C++" template <>
class __declspec(dllimport) ctype<unsigned short>
    : public ctype_base { 
public:
    using _Elem     = unsigned short;
    using char_type = _Elem;

    bool  is(mask _Maskval, _Elem _Ch) const { 
        return do_is(_Maskval, _Ch);
    }

    const _Elem*  is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        return do_is(_First, _Last, _Dest);
    }

    const _Elem*  scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_is(_Maskval, _First, _Last);
    }

    const _Elem*  scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        return do_scan_not(_Maskval, _First, _Last);
    }

    _Elem  tolower(_Elem _Ch) const { 
        return do_tolower(_Ch);
    }

    const _Elem*  tolower(
        _Elem* _First, const _Elem* _Last) const { 
        return do_tolower(_First, _Last);
    }

    _Elem  toupper(_Elem _Ch) const { 
        return do_toupper(_Ch);
    }

    const _Elem*  toupper(
        _Elem* _First, const _Elem* _Last) const { 
        return do_toupper(_First, _Last);
    }

    _Elem  widen(char _Byte) const { 
        return do_widen(_Byte);
    }

    const char*  widen(const char* _First, const char* _Last,
        _Elem* _Dest) const { 
        return do_widen(_First, _Last, _Dest);
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return do_narrow(_Ch, _Dflt);
    }

    const _Elem*  narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        return do_narrow(_First, _Last, _Dflt, _Dest);
    }

     static locale::id id;

    explicit  ctype(size_t _Refs = 0) : ctype_base(_Refs) {
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 2;
    }

protected:
     ~ctype() noexcept override {
        if (_Ctype._Delfl) {
            :: free(const_cast<short*>(_Ctype._Table));
        }

        :: free(_Ctype._LocaleName);
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Ctype = _Lobj._Getctype();
        _Cvt   = _Lobj._Getcvt();
    }

    virtual bool  do_is(
        mask _Maskval, _Elem _Ch) const { 
        return (:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
    }

    virtual const _Elem*  do_is(const _Elem* _First, const _Elem* _Last,
        mask* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        return reinterpret_cast<const _Elem*>(:: _Getwctypes(
            reinterpret_cast<const wchar_t*>(_First), reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
    }

    virtual const _Elem*  do_scan_is(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && !is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual const _Elem*  do_scan_not(mask _Maskval, const _Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        while (_First != _Last && is(_Maskval, *_First)) {
            ++_First;
        }

        return _First;
    }

    virtual _Elem  do_tolower(_Elem _Ch) const { 
        return _Towlower(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_tolower(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towlower(*_First, &_Ctype);
        }

        return _First;
    }

    virtual _Elem  do_toupper(_Elem _Ch) const { 
        return _Towupper(_Ch, &_Ctype);
    }

    virtual const _Elem*  do_toupper(_Elem* _First,
        const _Elem* _Last) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First) {
            *_First = _Towupper(*_First, &_Ctype);
        }

        return _First;
    }

    _Elem  _Dowiden(char _Byte) const { 
        mbstate_t _Mbst = {};
        unsigned short _Wc;

        if (_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0) {
            return static_cast<unsigned short>(((wint_t)(0xFFFF)));
        }

        return _Wc;
    }

    virtual _Elem  do_widen(char _Byte) const { 
        return _Dowiden(_Byte);
    }

    virtual const char*  do_widen(
        const char* _First, const char* _Last, _Elem* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Dowiden(*_First);
        }

        return _First;
    }

    char  _Donarrow(_Elem _Ch, char _Dflt) const { 
        char _Buf[5];
        mbstate_t _Mbst = {};
        return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
    }

    virtual char  do_narrow(_Elem _Ch, char _Dflt) const { 
        return _Donarrow(_Ch, _Dflt);
    }

    virtual const _Elem*  do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt,
        char* _Dest) const { 
        _Adl_verify_range(_First, _Last);
        for (; _First != _Last; ++_First, ++_Dest) {
            *_Dest = _Donarrow(*_First, _Dflt);
        }

        return _First;
    }

private:
    _Locinfo::_Ctypevec _Ctype; 
    _Locinfo::_Cvtvec _Cvt; 
};
#line 3233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"

 template <class _Elem>
class ctype_byname : public ctype<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit  ctype_byname(const char* _Locname, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Locname), _Refs) {} 

    explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
        : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~ctype_byname() noexcept override {}
};

enum class _Case_sensitive : bool { _Nope, _Yes };

template <class _InIt, class _Elem>
int __cdecl _Getloctxt(
    _InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr, const _Case_sensitive _Matching) {
    
    for (size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off) {
        if (_Ptr[_Off] == _Ptr[0]) {
            ++_Numfields; 
        }
    }

    string _Str(_Numfields, '\0'); 
    const ctype<_Elem>& _CType = ::std:: use_facet<ctype<_Elem>>(locale{});

    int _Ans = -2; 
    for (size_t _Column = 1;; ++_Column, (void) ++_First, _Ans = -1) { 
        bool _Prefix  = false; 
        size_t _Off   = 0; 
        size_t _Field = 0; 

        for (; _Field < _Numfields; ++_Field) { 
            while (_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0]) { 
                ++_Off;
            }

            if (_Str[_Field] != '\0') {
                _Off += _Str[_Field]; 
            } else if (_Ptr[_Off += _Column] == _Ptr[0]
                       || _Ptr[_Off] == _Elem{}) { 
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
                _Ans         = static_cast<int>(_Field); 
            } else if (_First == _Last
                       || (_Matching == _Case_sensitive::_Yes
                               ? _Ptr[_Off] != *_First
                               : _CType.tolower(_Ptr[_Off]) != _CType.tolower(static_cast<_Elem>(*_First)))) {
                _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127); 
            } else {
                _Prefix = true; 
            }
        }

        if (!_Prefix || _First == _Last) {
            break; 
        }
    }
    return _Ans; 
}



template class __declspec(dllimport) codecvt<char, char, mbstate_t>;
#line 3302 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
#line 3303 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
}


#pragma warning(pop)
#pragma pack(pop)
#line 3309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
#line 3310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocale"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Dummy>
class _Iosb { 
public:
    enum _Dummy_enum { _Dummy_enum_val = 1 }; 
    enum _Fmtflags { 
        _Fmtmask = 0xffff,
        _Fmtzero = 0
    };

    static constexpr int skipws     = 0x0001;
    static constexpr int unitbuf    = 0x0002;
    static constexpr int uppercase  = 0x0004;
    static constexpr int showbase   = 0x0008;
    static constexpr int showpoint  = 0x0010;
    static constexpr int showpos    = 0x0020;
    static constexpr int left       = 0x0040;
    static constexpr int right      = 0x0080;
    static constexpr int internal   = 0x0100;
    static constexpr int dec        = 0x0200;
    static constexpr int oct        = 0x0400;
    static constexpr int hex        = 0x0800;
    static constexpr int scientific = 0x1000;
    static constexpr int fixed      = 0x2000;

    static constexpr int hexfloat = 0x3000; 

    static constexpr int boolalpha   = 0x4000;
    static constexpr int _Stdio      = 0x8000;
    static constexpr int adjustfield = 0x01C0; 
    static constexpr int basefield   = 0x0E00; 
    static constexpr int floatfield  = 0x3000; 

    enum _Iostate { 
        _Statmask = 0x17
    };

    static constexpr int goodbit = 0x0;
    static constexpr int eofbit  = 0x1;
    static constexpr int failbit = 0x2;
    static constexpr int badbit  = 0x4;

    enum _Openmode { 
        _Openmask = 0xff
    };

    static constexpr int in         = 0x01;
    static constexpr int out        = 0x02;
    static constexpr int ate        = 0x04;
    static constexpr int app        = 0x08;
    static constexpr int trunc      = 0x10;
    static constexpr int _Nocreate  = 0x40;
    static constexpr int _Noreplace = 0x80;
    static constexpr int binary     = 0x20;

    static constexpr int noreplace = _Noreplace;
#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    enum _Seekdir { 
        _Seekbeg,
        _Seekcur,
        _Seekend
    };

    static constexpr int beg = _Seekbeg;
    static constexpr int cur = _Seekcur;
    static constexpr int end = _Seekend;

    enum { 
        _Openprot = 0x40
    };

    static constexpr int _Default_open_prot = 0x40; 
};

 extern "C++" class __declspec(dllimport) ios_base : public _Iosb<int> { 
public:
    using fmtflags = int;
    using iostate  = int;
    using openmode = int;
    using seekdir  = int;




#line 107 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    enum event { 
        erase_event,
        imbue_event,
        copyfmt_event
    };

    using event_callback = void(__cdecl*)(event, ios_base&, int);





#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    class failure : public system_error { 
    public:
        explicit failure(const string& _Message, const error_code& _Errcode = ::std:: make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 

        explicit failure(const char* _Message, const error_code& _Errcode = ::std:: make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message) {} 






#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"
    };

    class __declspec(dllimport) Init { 
    public:
         Init() { 
            _Init_ctor(this);
        }

         ~Init() noexcept { 
            _Init_dtor(this);
        }

    private:
        static void __cdecl _Init_ctor(Init*);
        static void __cdecl _Init_dtor(Init*);

         static int _Init_cnt; 

        static int& __cdecl _Init_cnt_func();
    };

    explicit  operator bool() const noexcept  {
        return !fail();
    }

    [[nodiscard]] bool  operator!() const noexcept  {
        return fail();
    }

    void  clear(iostate _State, bool _Reraise) { 
        _State &= _Statmask;
        _Mystate             = _State;
        const auto _Filtered = _State & _Except;
        if (_Filtered) {
            if (_Reraise) {
                throw;
            }

            const char* _Msg;
            if (_Filtered & ios_base::badbit) {
                _Msg = "ios_base::badbit set";
            } else if (_Filtered & ios_base::failbit) {
                _Msg = "ios_base::failbit set";
            } else {
                _Msg = "ios_base::eofbit set";
            }

            throw failure(_Msg);
        }
    }

    void  clear(iostate _State = goodbit) { 
        clear(_State, false);
    }





#line 196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    [[nodiscard]] iostate  rdstate() const noexcept  {
        return _Mystate;
    }

    void  setstate(
        iostate _State, bool _Exreraise) { 
        clear(rdstate() | _State, _Exreraise);
    }

    void  setstate(iostate _State) { 
        clear(rdstate() | _State, false);
    }





#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    [[nodiscard]] bool  good() const noexcept  {
        return rdstate() == ios_base::goodbit;
    }

    [[nodiscard]] bool  eof() const noexcept  {
        return rdstate() & ios_base::eofbit;
    }

    [[nodiscard]] bool  fail() const noexcept  {
        return rdstate() & (ios_base::badbit | ios_base::failbit);
    }

    [[nodiscard]] bool  bad() const noexcept  {
        return rdstate() & ios_base::badbit;
    }

    [[nodiscard]] iostate  exceptions() const noexcept  {
        return _Except;
    }

    void  exceptions(iostate _Newexcept) { 
        _Except = _Newexcept & _Statmask;
        clear(rdstate());
    }





#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"

    [[nodiscard]] fmtflags  flags() const noexcept  {
        return _Fmtfl;
    }

    fmtflags  flags(fmtflags _Newfmtflags) noexcept  {
        
        const fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                      = _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags) noexcept  {
        
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl |= _Newfmtflags & _Fmtmask;
        return _Oldfmtflags;
    }

    fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask) noexcept  {
        
        const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
        _Fmtfl                                = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
        return _Oldfmtflags;
    }

    void  unsetf(fmtflags _Mask) noexcept  {
        
        _Fmtfl &= ~_Mask;
    }

    [[nodiscard]] streamsize  precision() const noexcept  {
        return _Prec;
    }

    streamsize  precision(streamsize _Newprecision) noexcept  {
        
        const streamsize _Oldprecision = _Prec;
        _Prec                          = _Newprecision;
        return _Oldprecision;
    }

    [[nodiscard]] streamsize  width() const noexcept  {
        return _Wide;
    }

    streamsize  width(streamsize _Newwidth) noexcept  {
        
        const streamsize _Oldwidth = _Wide;
        _Wide                      = _Newwidth;
        return _Oldwidth;
    }

    [[nodiscard]] locale  getloc() const noexcept  { 
        return *_Ploc;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = *_Ploc;
        *_Ploc            = _Loc;
        _Callfns(imbue_event);
        return _Oldlocale;
    }

    [[nodiscard]] static int __cdecl xalloc() { 
        { ::std:: _Lockit _Lock(2); 
        return _Index++;
        }
    }

    [[nodiscard]] long&  iword(int _Idx) {
        return _Findarr(_Idx)._Lo;
    }

    [[nodiscard]] void*&  pword(int _Idx) {
        return _Findarr(_Idx)._Vp;
    }

    void  register_callback(event_callback _Pfn, int _Idx) {
        
        _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
    }

    ios_base&  copyfmt(const ios_base& _Other) { 
        if (this != ::std:: addressof(_Other)) { 
            _Tidy();
            *_Ploc          = *_Other._Ploc;
            _Fmtfl          = _Other._Fmtfl;
            _Prec           = _Other._Prec;
            _Wide           = _Other._Wide;
            _Iosarray* _Ptr = _Other._Arr;

            for (_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next) {
                if (_Ptr->_Lo != 0 || _Ptr->_Vp) { 
                    iword(_Ptr->_Index) = _Ptr->_Lo;
                    pword(_Ptr->_Index) = _Ptr->_Vp;
                }
            }

            for (_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next) {
                register_callback(_Pfa->_Pfn, _Pfa->_Index);
            }

            _Callfns(copyfmt_event); 
            exceptions(_Other._Except); 
        }
        return *this;
    }

    static bool __cdecl sync_with_stdio(bool _Newsync = true) {
        
        { ::std:: _Lockit _Lock(2); 
        const bool _Oldsync = _Sync;
        _Sync               = _Newsync;
        return _Oldsync;
        }
    }

    void  swap(ios_base& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            ::std:: swap(_Mystate, _Right._Mystate);
            ::std:: swap(_Except, _Right._Except);
            ::std:: swap(_Fmtfl, _Right._Fmtfl);
            ::std:: swap(_Prec, _Right._Prec);
            ::std:: swap(_Wide, _Right._Wide);

            ::std:: swap(_Arr, _Right._Arr);
            ::std:: swap(_Calls, _Right._Calls);
            ::std:: swap(_Ploc, _Right._Ploc);
        }
    }

    virtual  ~ios_base() noexcept {
        _Ios_base_dtor(this);
    }

    static void __cdecl _Addstd(ios_base*); 

    size_t _Stdstr{0}; 

protected:
     ios_base() {}

    void  _Init() { 
        _Ploc   = nullptr;
        _Stdstr = 0;
        _Except = goodbit;
        _Fmtfl  = skipws | dec;
        _Prec   = 6;
        _Wide   = 0;
        _Arr    = nullptr;
        _Calls  = nullptr;
        clear(goodbit);
        _Ploc = new locale;
    }

private:
    struct _Iosarray : _Crt_new_delete { 
    public:
         _Iosarray(int _Idx, _Iosarray* _Link)
            : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr) {} 

        _Iosarray* _Next; 
        int _Index; 
        long _Lo; 
        void* _Vp; 
    };

    struct _Fnarray : _Crt_new_delete { 
         _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link)
            : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) {} 

        _Fnarray* _Next; 
        int _Index; 
        event_callback _Pfn; 
    };

    void  _Callfns(event _Ev) { 
        for (_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next) {
            (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
        }
    }

    _Iosarray&  _Findarr(int _Idx) { 
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next) {
            if (_Ptr1->_Index == _Idx) {
                return *_Ptr1; 
            } else if (!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp) {
                _Ptr2 = _Ptr1; 
            }
        }

        if (_Ptr2) { 
            _Ptr2->_Index = _Idx;
            return *_Ptr2;
        }

        _Arr = new _Iosarray(_Idx, _Arr); 
        return *_Arr;
    }

    void  _Tidy() noexcept { 
        _Callfns(erase_event);
        _Iosarray* _Ptr1;
        _Iosarray* _Ptr2;

        for (_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2) { 
            _Ptr2 = _Ptr1->_Next;
            delete _Ptr1;
        }
        _Arr = nullptr;

        _Fnarray* _Pfa1;
        _Fnarray* _Pfa2;
        for (_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2) { 
            _Pfa2 = _Pfa1->_Next;
            delete _Pfa1;
        }
        _Calls = nullptr;
    }

    iostate _Mystate{}; 
    iostate _Except{}; 
    fmtflags _Fmtfl{}; 
    streamsize _Prec{}; 
    streamsize _Wide{}; 
    _Iosarray* _Arr{nullptr}; 
    _Fnarray* _Calls{nullptr}; 
    locale* _Ploc{nullptr}; 

     static int _Index;
     static bool _Sync;

    static void __cdecl _Ios_base_dtor(ios_base*);

public:
    ios_base(const ios_base&)            = delete;
    ios_base& operator=(const ios_base&) = delete;
};
}


#pragma warning(pop)
#pragma pack(pop)
#line 494 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"
#line 495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xiosbase"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 extern "C++" template <class _Elem, class _Traits>
class basic_streambuf { 
protected:
     basic_streambuf() : _Plocale(new locale) {
        _Init();
    }

     basic_streambuf(_Uninitialized) noexcept {}

     basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale{_Right.getloc()}) {
        _Init();
        setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
        setg(_Right.eback(), _Right.gptr(), _Right.egptr());
    }

    basic_streambuf&  operator=(const basic_streambuf& _Right) {
        if (this != ::std:: addressof(_Right)) {
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            pubimbue(_Right.getloc());
        }
        return *this;
    }

    void  swap(basic_streambuf& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Elem* _Pfirst0 = pbase();
            _Elem* _Pnext0  = pptr();
            _Elem* _Pend    = epptr();
            _Elem* _Gfirst0 = eback();
            _Elem* _Gnext0  = gptr();
            _Elem* _Gend    = egptr();

            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            _Right.setp(_Pfirst0, _Pnext0, _Pend);

            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            _Right.setg(_Gfirst0, _Gnext0, _Gend);

            ::std:: swap(_Plocale, _Right._Plocale);
        }
    }

public:
    using char_type   = _Elem;
    using traits_type = _Traits;

    virtual  ~basic_streambuf() noexcept {
        delete _Plocale;
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    pos_type  pubseekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekoff(_Off, _Way, _Mode);
    }






#line 86 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"

    pos_type  pubseekpos(pos_type _Pos,
        ios_base::openmode _Mode = ios_base::in | ios_base::out) { 
        return seekpos(_Pos, _Mode);
    }






#line 98 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"

    basic_streambuf*  pubsetbuf(_Elem* _Buffer,
        streamsize _Count) { 
        return setbuf(_Buffer, _Count);
    }

    locale  pubimbue(const locale& _Newlocale) { 
        locale _Oldlocale = *_Plocale;
        imbue(_Newlocale);
        *_Plocale = _Newlocale;
        return _Oldlocale;
    }

    locale  getloc() const noexcept  { 
        return *_Plocale;
    }

    streamsize  in_avail() {
        streamsize _Res = _Gnavail();
        return 0 < _Res ? _Res : showmanyc();
    }

    int  pubsync() { 
        return sync();
    }

    int_type  sbumpc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
    }

    int_type  sgetc() { 
        return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
    }

    streamsize  sgetn(_Elem* _Ptr,
        streamsize _Count) { 
        return xsgetn(_Ptr, _Count);
    }

    int_type  snextc() { 
        return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())
             : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
                                                              : sgetc();
    }

    int_type  sputbackc(_Elem _Ch) { 
        if (gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1])) {
            return _Traits::to_int_type(*_Gndec());
        }

        return pbackfail(_Traits::to_int_type(_Ch));
    }









#line 160 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"

    int_type  sungetc() { 
        return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
    }

    int_type  sputc(_Elem _Ch) { 
        return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
    }

    streamsize  sputn(const _Elem* _Ptr,
        streamsize _Count) { 
        return xsputn(_Ptr, _Count);
    }

    virtual void  _Lock() {} 

    virtual void  _Unlock() {} 

protected:
    _Elem*  eback() const noexcept  {
        return *_IGfirst;
    }

    _Elem*  gptr() const noexcept  {
        return *_IGnext;
    }

    _Elem*  pbase() const noexcept  {
        return *_IPfirst;
    }

    _Elem*  pptr() const noexcept  {
        return *_IPnext;
    }

    _Elem*  egptr() const noexcept  {
        return *_IGnext + *_IGcount;
    }

    void  gbump(int _Off) noexcept  {
        
        *_IGcount -= _Off;
        *_IGnext += _Off;
    }

    void  setg(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept  {
        
        *_IGfirst = _First;
        *_IGnext  = _Next;
        *_IGcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  epptr() const noexcept  {
        return *_IPnext + *_IPcount;
    }

    _Elem*  _Gndec() noexcept { 
        ++*_IGcount;
        return --*_IGnext;
    }

    _Elem*  _Gninc() noexcept { 
        --*_IGcount;
        return (*_IGnext)++;
    }

    _Elem*  _Gnpreinc() noexcept { 
        --*_IGcount;
        return ++(*_IGnext);
    }

    streamsize  _Gnavail() const noexcept { 
        return *_IGnext ? *_IGcount : 0;
    }

    void  pbump(int _Off) noexcept  {
        
        *_IPcount -= _Off;
        *_IPnext += _Off;
    }

    void  setp(_Elem* _First, _Elem* _Last) noexcept  {
        
        *_IPfirst = _First;
        *_IPnext  = _First;
        *_IPcount = static_cast<int>(_Last - _First);
    }

    void  setp(_Elem* _First, _Elem* _Next, _Elem* _Last) noexcept  {
        
        *_IPfirst = _First;
        *_IPnext  = _Next;
        *_IPcount = static_cast<int>(_Last - _Next);
    }

    _Elem*  _Pninc() noexcept { 
        --*_IPcount;
        return (*_IPnext)++;
    }

    streamsize  _Pnavail() const noexcept { 
        return *_IPnext ? *_IPcount : 0;
    }

    void  _Init() noexcept { 
        _IGfirst = &_Gfirst;
        _IPfirst = &_Pfirst;
        _IGnext  = &_Gnext;
        _IPnext  = &_Pnext;
        _IGcount = &_Gcount;
        _IPcount = &_Pcount;
        setp(nullptr, nullptr);
        setg(nullptr, nullptr, nullptr);
    }

    void  _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc) noexcept {
        
        _IGfirst = _Gf;
        _IPfirst = _Pf;
        _IGnext  = _Gn;
        _IPnext  = _Pn;
        _IGcount = _Gc;
        _IPcount = _Pc;
    }

    virtual int_type  overflow(int_type = _Traits::eof()) { 
        return _Traits::eof();
    }

    virtual int_type  pbackfail(int_type = _Traits::eof()) {
        
        return _Traits::eof();
    }

    virtual streamsize  showmanyc() {
        return 0;
    }

    virtual int_type  underflow() { 
        return _Traits::eof();
    }

    virtual int_type  uflow() { 
        return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
    }

    virtual streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) { 
        const streamsize _Start_count = _Count;

        while (0 < _Count) {
            streamsize _Size = _Gnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                gbump(static_cast<int>(_Size));
            } else {
                const int_type _Meta = uflow();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                
                *_Ptr++ = _Traits::to_char_type(_Meta);
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual streamsize  xsputn(const _Elem* _Ptr, streamsize _Count) {
        
        const streamsize _Start_count = _Count;
        while (0 < _Count) {
            streamsize _Size = _Pnavail();
            if (0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                pbump(static_cast<int>(_Size));
            } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {
                break; 
            } else { 
                ++_Ptr;
                --_Count;
            }
        }

        return _Start_count - _Count;
    }

    virtual pos_type  seekoff(
        off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return pos_type{off_type{-1}};
    }

    virtual pos_type  seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {
        
        return pos_type{off_type{-1}};
    }

    virtual basic_streambuf*  setbuf(_Elem*, streamsize) {
        
        return this;
    }

    virtual int  sync() { 
        return 0;
    }

    virtual void  imbue(const locale&) {} 

private:
    _Elem* _Gfirst{}; 
    _Elem* _Pfirst{}; 
    _Elem** _IGfirst{}; 
    _Elem** _IPfirst{}; 
    _Elem* _Gnext{}; 
    _Elem* _Pnext{}; 
    _Elem** _IGnext{}; 
    _Elem** _IPnext{}; 

    int _Gcount{}; 
    int _Pcount{}; 
    int* _IGcount{}; 
    int* _IPcount{}; 

protected:
    locale* _Plocale{}; 
};




template class __declspec(dllimport) basic_streambuf<char, char_traits<char>>;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t>>;
#line 407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"




#line 412 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"
}



#pragma warning(pop)
#pragma pack(pop)
#line 419 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"
#line 420 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\streambuf"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {

 long __cdecl _Stolx(const char*,     char**, int, int*);
 unsigned long __cdecl _Stoulx(
    const char*,     char**, int, int*);
 long long __cdecl _Stollx(
    const char*,     char**, int, int*);
 unsigned long long __cdecl _Stoullx(
    const char*,     char**, int, int*);

}

namespace std {

inline constexpr size_t _Max_int_dig = 32; 

inline double _Stodx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;

    _Errno_ref  = 0;
    double _Val = :: strtod(_Str, _Endptr);
    *_Perr      = _Errno_ref;
    _Errno_ref  = _Orig;

    return _Val;
}

inline float _Stofx_v3(const char* _Str, char** _Endptr, int* _Perr) noexcept { 
    int& _Errno_ref = (*_errno()); 
    const int _Orig = _Errno_ref;

    _Errno_ref = 0;
    float _Val = :: strtof(_Str, _Endptr);
    *_Perr     = _Errno_ref;
    _Errno_ref = _Orig;

    return _Val;
}

template <class _Elem, size_t _Base_size>
size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch) {
    
    
    return static_cast<size_t>(::std:: _Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
}

inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { 
    const size_t _Count = :: wcslen(_Ptr) + 1;

    wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Count, sizeof(wchar_t)));

    if (!_Ptrdest) {
        _Xbad_alloc();
    }

    :: wmemcpy(_Ptrdest, _Ptr, _Count);
    return _Ptrdest;
}

 template <class _Elem>
class numpunct : public locale::facet { 
private:
    friend _Tidy_guard<numpunct>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
    using char_type   = _Elem;

     __declspec(dllimport) static locale::id id; 

    _Elem decimal_point() const {
        return do_decimal_point();
    }

    _Elem thousands_sep() const {
        return do_thousands_sep();
    }

    string grouping() const {
        return do_grouping();
    }

    string_type falsename() const {
        return do_falsename();
    }

    string_type truename() const {
        return do_truename();
    }

    explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        if (_Kseparator == 0) {
            _Kseparator = 
                _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
        }
        }
    }

    numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        _Init(_Lobj, _Isdef);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);
        }
        return 4;
    }

protected:
     ~numpunct() noexcept override {
        _Tidy();
    }

    numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { 
        _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec) { 
        _Dp         = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
        _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { 
        const lconv* _Ptr      = _Lobj._Getlconv();
        _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); 

        _Grouping  = nullptr;
        _Falsename = nullptr;
        _Truename  = nullptr;

        _Tidy_guard<numpunct> _Guard{this};
        _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
        _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
        _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
        _Guard._Target = nullptr;

        if (_Isdef) { 
            
            _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
        } else {
            _Getvals(_Elem{}, _Ptr, _Cvt);
        }
    }

    virtual _Elem  do_decimal_point() const {
        return _Dp;
    }

    virtual _Elem  do_thousands_sep() const {
        return _Kseparator;
    }

    virtual string  do_grouping() const {
        return string{_Grouping};
    }

    virtual string_type  do_falsename() const {
        return string_type{_Falsename};
    }

    virtual string_type  do_truename() const {
        return string_type{_Truename};
    }

private:
    void _Tidy() noexcept { 
        :: free(const_cast<char*>(_Grouping));
        :: free(const_cast<_Elem*>(_Falsename));
        :: free(const_cast<_Elem*>(_Truename));
    }

    const char* _Grouping; 
    _Elem _Dp; 
    _Elem _Kseparator; 
    const _Elem* _Falsename; 
    const _Elem* _Truename; 
};

 template <class _Elem>
class numpunct_byname : public numpunct<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit numpunct_byname(const char* _Locname, size_t _Refs = 0)
        : numpunct<_Elem>(_Locname, _Refs) {} 

    explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
        : numpunct<_Elem>(_Str.c_str(), _Refs) {} 

protected:
     ~numpunct_byname() noexcept override {}
};







template <class _Elem>
 locale::id numpunct<_Elem>::id;




#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"

struct _Num_get_parse_result {
    
    
    
    int8_t _Base;
    bool _Bad_grouping;
};

 extern "C++" template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_get : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 4;
    }

     static locale::id id; 

protected:
     ~num_get() noexcept override {}

    void _Init(const _Locinfo&) {} 

public:
    explicit  num_get(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _InIt;

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        return do_get(_First, _Last, _Iosbase, _State, _Val);
    }

protected:
    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        bool& _Val) const { 
        _Adl_verify_range(_First, _Last);
        if (_Iosbase.flags() & ios_base::boolalpha) { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
            _Str += _Punct_fac.falsename();
            _Str.push_back(_Elem{});
            _Str += _Punct_fac.truename(); 
            switch (_Getloctxt(_First, _Last, 2, _Str.c_str(), _Case_sensitive::_Yes)) {
            case 0:
                _Val = false;
                break;
            case 1:
                _Val = true;
                break;
            default:
                _Val   = false;
                _State = ios_base::failbit;
                break;
            }
        } else { 
            char _Ac[_Max_int_dig];
            const auto _Parse_result =
                _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
            if (_Parse_result._Base < 0) {
                
                
                _Val   = false;
                _State = ios_base::failbit;
            } else {
                char* _Ep;
                int _Errno;
                const long _Ans = :: _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); 
                if (_Ep == _Ac || _Errno != 0 
                    || _Parse_result._Bad_grouping) { 
                    _Val   = true;
                    _State = ios_base::failbit;
                } else {
                    _Val = _Ans != 0;
                    if (_Ans != 0 && _Ans != 1) {
                        _State = ios_base::failbit;
                    }
                }
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned short& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            const bool _Minus   = _Ac[0] == '-';
            const char* _Digits = _Ac;
            
            
            if (_Minus) { 
                ++_Digits;
            }

            char* _Ep;
            int _Errno;
            const unsigned long _Tmp = :: _Stoulx(_Digits, &_Ep, _Parse_result._Base, &_Errno); 
            _Val                     = static_cast<unsigned short>(_Tmp);
            if (_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff) { 
                _State = ios_base::failbit;
                _Val   = 0xffff;
            } else if (_Minus) { 
                                 
                _Val = static_cast<unsigned short>(0 - _Val);
            }

            if (_Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned int& _Val) const { 
        static_assert(sizeof(unsigned int) == sizeof(unsigned long),
            "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
        unsigned long _Tmp;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp); 
        _Val   = _Tmp;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stolx(_Ac, &_Ep, _Parse_result._Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stoulx(_Ac, &_Ep, _Parse_result._Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            char* _Ep;
            int _Errno;
            _Val = :: _Stollx(_Ac, &_Ep, _Parse_result._Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        unsigned long long& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = 0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = :: _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }






    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        float& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        const auto _Parse_result =
            _Parse_fp_with_locale(_Ac, 768, _First, _Last, _Iosbase.getloc()); 
        if (_Parse_result._Base == 0) { 
            _State = ios_base::failbit;
            _Val   = 0.0f;
        } else {
            int _Errno;
            char* _Ep;
            _Val = ::std:: _Stofx_v3(_Ac, &_Ep, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        double& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[(8 + 768 + 16)];
        const auto _Parse_result =
            _Parse_fp_with_locale(_Ac, 768, _First, _Last, _Iosbase.getloc()); 
        if (_Parse_result._Base == 0) { 
            _State = ios_base::failbit;
            _Val   = 0.0;
        } else {
            int _Errno;
            char* _Ep;
            _Val = ::std:: _Stodx_v3(_Ac, &_Ep, &_Errno); 
            if (_Ep == _Ac || _Errno != 0 
                || _Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }



    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        static_assert(sizeof(double) == sizeof(long double), "Bad assumption: sizeof(double) == sizeof(long double).");
        double _Result;
        _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result); 
        _Val   = _Result;
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        void*& _Val) const { 
        _Adl_verify_range(_First, _Last);
        char _Ac[_Max_int_dig];
        const auto _Parse_result =
            _Parse_int_with_locale(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc()); 
        if (_Parse_result._Base < 0) { 
            _State = ios_base::failbit;
            _Val   = nullptr;
        } else {
            int _Errno;
            char* _Ep;

            _Val = reinterpret_cast<void*>(:: _Stoullx(_Ac, &_Ep, _Parse_result._Base, &_Errno));


#line 641 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"
            if (_Ep == _Ac || _Errno != 0) { 
                _State = ios_base::failbit;
                _Val   = nullptr;
            }

            if (_Parse_result._Bad_grouping) { 
                _State = ios_base::failbit;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    template <int = 0> 
    static _Num_get_parse_result _Parse_int_with_locale(
        char* const _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) {
        
        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

        constexpr int _Numget_signoff = 22;
        constexpr int _Numget_xoff    = 24;
        static constexpr char _Src[]  = "0123456789ABCDEFabcdef-+Xx";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        bool _Bad_grouping = false;

        
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        char* _Ptr = _Ac;

        if (_First != _Last) {
            if (*_First == _Atoms[_Numget_signoff + 1]) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Atoms[_Numget_signoff]) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        _Basefield &= ios_base::basefield;

        int8_t _Base;
        if (_Basefield == ios_base::oct) {
            _Base = 8;
        } else if (_Basefield == ios_base::hex) {
            _Base = 16;
        } else if (_Basefield == ios_base::_Fmtzero) {
            _Base = 0;
        } else {
            _Base = 10;
        }

        bool _Seendigit = false; 
        bool _Nonzero   = false; 

        if (_First != _Last && *_First == _Atoms[0]) { 
            _Seendigit = true;
            ++_First;
            if (_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                && (_Base == 0 || _Base == 16)) {
                _Base      = 16;
                _Seendigit = false;
                ++_First;
            } else if (_Base == 0) {
                _Base = 8;
            }
        }

        const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
        string _Groups(1, static_cast<char>(_Seendigit)); 
        size_t _Groups_arr_idx = 0;

        for (char* const _Pe = &_Ac[_Max_int_dig - 1]; _First != _Last; ++_First) { 
            size_t _Idx = ::std:: _Find_elem(_Atoms, *_First);
            if (_Idx < _Dlen) { 
                *_Ptr = _Src[_Idx];
                if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe) {
                    ++_Ptr;
                    _Nonzero = true;
                }

                _Seendigit = true;
                if (_Groups[_Groups_arr_idx] != 127) {
                    ++_Groups[_Groups_arr_idx];
                }
            } else if (_Kseparator == _Elem{} || *_First != _Kseparator) {
                break; 
            } else if (_Groups[_Groups_arr_idx] == '\0') {
                _Bad_grouping = true; 
            } else { 
                _Groups.push_back('\0');
                ++_Groups_arr_idx;
            }
        }

        if (_Groups_arr_idx != 0) {
            if (_Groups[_Groups_arr_idx] > '\0') {
                ++_Groups_arr_idx; 
            } else {
                _Bad_grouping = true; 
            }
        }

        
        if (_Kseparator != _Elem{}) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        const char* _Grouping_iter      = _Grouping.data();
        const char* const _Grouping_end = _Grouping_iter + _Grouping.size();
        for (char _Current_grouping_count = '\0'; _Seendigit && !_Bad_grouping && _Groups_arr_idx > 0;) {
            if (_Grouping_iter != _Grouping_end) { 
                _Current_grouping_count = *_Grouping_iter; 
                ++_Grouping_iter;
            }

            --_Groups_arr_idx;
            if ((_Current_grouping_count > '\0' && _Current_grouping_count != 127)
                && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)
                    || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
                _Bad_grouping = true; 
            }
            
        }

        if (!_Seendigit) {
            return {static_cast<int8_t>(~_Base), false};
        }

        if (!_Nonzero) {
            *_Ptr++ = '0'; 
        }

        *_Ptr = '\0';
        return {_Base, _Bad_grouping};
    }

    template <int = 0> 
    static _Num_get_parse_result _Parse_fp_with_locale(
        char* const _Ac, const int _Max_sig_dig, _InIt& _First, _InIt& _Last, const locale& _Loc) {
        
        char* _Ptr = _Ac;

        constexpr size_t _Offset_dec_digit_end = 10;
        constexpr size_t _Offset_hex_digit_end = 22;
        constexpr size_t _Offset_neg_sign      = 22;
        constexpr size_t _Offset_pos_sign      = 23;
        constexpr size_t _Offset_upper_x       = 24;
        constexpr size_t _Offset_lower_x       = 25;
        constexpr size_t _Offset_upper_p       = 26;
        constexpr size_t _Offset_lower_p       = 27;
        constexpr size_t _Offset_upper_e       = 14;
        constexpr size_t _Offset_lower_e       = 20;
        static constexpr char _Src[]           = "0123456789ABCDEFabcdef-+XxPp";
        _Elem _Atoms[sizeof(_Src)];
        const auto& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Loc);
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        const _Elem _Positive_sign = _Atoms[_Offset_pos_sign];
        const _Elem _Negative_sign = _Atoms[_Offset_neg_sign];
        const _Elem _Zero_wc       = _Atoms[0];

        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Loc);
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Punct_fac.thousands_sep();

        bool _Bad_grouping = false;

        
        if (!_Grouping.empty()) {
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }
        }

        if (_First != _Last) {
            if (*_First == _Positive_sign) { 
                *_Ptr++ = '+';
                ++_First;
            } else if (*_First == _Negative_sign) { 
                *_Ptr++ = '-';
                ++_First;
            }
        }

        *_Ptr++ = '0'; 

        bool _Parse_hex                = false;
        bool _Seendigit                = false; 
        char _Initial_dec_leading_zero = '\0';
        if (_First != _Last && *_First == _Zero_wc) {
            ++_First;
            if (_First == _Last) { 
                *_Ptr = '\0';
                return {10, _Bad_grouping};
            }

            if (*_First == _Atoms[_Offset_lower_x] || *_First == _Atoms[_Offset_upper_x]) { 
                _Parse_hex = true;
                ++_First; 
                *_Ptr++ = 'x';
            } else {
                _Seendigit = true;
                ++_Initial_dec_leading_zero;
            }
        }

        bool _Has_unaccumulated_digits = false;
        int _Significant               = 0; 
        ptrdiff_t _Power_of_rep_base   = 0; 

        const size_t _Offset_digit_end = _Parse_hex ? _Offset_hex_digit_end : _Offset_dec_digit_end;
        if (_Grouping.empty()) {
            for (size_t _Idx; _First != _Last && (_Idx = ::std:: _Find_elem(_Atoms, *_First)) < _Offset_digit_end;
                 _Seendigit = true, (void) ++_First) {
                if (_Significant >= _Max_sig_dig) {
                    ++_Power_of_rep_base; 
                    if (_Idx > 0) {
                        _Has_unaccumulated_digits = true;
                    }
                } else if (_Idx != 0 || _Significant != 0) { 
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }
        } else {
            
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }

            string _Groups(1, _Initial_dec_leading_zero); 
            size_t _Groups_arr_idx = 0;

            for (; _First != _Last; ++_First) {
                const size_t _Idx = ::std:: _Find_elem(_Atoms, *_First);
                if (_Idx < _Offset_digit_end) { 
                    _Seendigit = true;
                    if (_Significant >= _Max_sig_dig) {
                        ++_Power_of_rep_base; 
                        if (_Idx > 0) {
                            _Has_unaccumulated_digits = true;
                        }
                    } else if (_Idx != 0 || _Significant != 0) { 
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }

                    if (_Groups[_Groups_arr_idx] != 127) {
                        ++_Groups[_Groups_arr_idx];
                    }
                } else if (*_First != _Kseparator) {
                    break; 
                } else if (_Groups[_Groups_arr_idx] == '\0') {
                    _Bad_grouping = true; 
                } else { 
                    _Groups.push_back('\0');
                    ++_Groups_arr_idx;
                }
            }

            if (_Groups_arr_idx != 0) {
                if (_Groups[_Groups_arr_idx] > '\0') {
                    ++_Groups_arr_idx; 
                } else {
                    _Bad_grouping = true; 
                }
            }

            
            while (_First != _Last && *_First == _Kseparator) {
                ++_First;
                _Bad_grouping = true;
            }

            const char* _Grouping_iter      = _Grouping.data();
            const char* const _Grouping_end = _Grouping_iter + _Grouping.size();
            char _Current_grouping_count    = '\0';
            while (!_Bad_grouping && _Groups_arr_idx > 0) {
                if (_Grouping_iter != _Grouping_end) { 
                    _Current_grouping_count = *_Grouping_iter; 
                    ++_Grouping_iter;
                }

                --_Groups_arr_idx;
                if ((_Current_grouping_count > '\0' && _Current_grouping_count != 127)
                    && ((_Groups_arr_idx > 0 && _Groups[_Groups_arr_idx] != _Current_grouping_count)
                        || (_Groups_arr_idx == 0 && _Groups[_Groups_arr_idx] > _Current_grouping_count))) {
                    _Bad_grouping = true; 
                }
                
            }
        }

        if (_Parse_hex && _Seendigit && _Significant == 0) {
            
            *_Ptr++ = '0'; 
        }

        const char _Decimal_point = :: localeconv()->decimal_point[0];
        if (_First != _Last && *_First == _Punct_fac.decimal_point()) { 
            *_Ptr++ = _Decimal_point;
            ++_First;
        }

        if (_Significant == 0) { 
            for (; _First != _Last && *_First == _Zero_wc; _Seendigit = true, (void) ++_First) {
                --_Power_of_rep_base; 
            }
        }

        for (size_t _Idx; _First != _Last && (_Idx = ::std:: _Find_elem(_Atoms, *_First)) < _Offset_digit_end;
             _Seendigit = true, (void) ++_First) {
            if (_Significant < _Max_sig_dig) { 
                *_Ptr++ = _Src[_Idx];
                ++_Significant;
            } else if (_Idx > 0) {
                _Has_unaccumulated_digits = true; 
            }
        }

        if (_Has_unaccumulated_digits) { 
            char& _Last_got_digit = _Ptr[-1] == _Decimal_point ? _Ptr[-2] : _Ptr[-1];
            if (_Last_got_digit == '0' || _Last_got_digit == (_Parse_hex ? '8' : '5')) {
                ++_Last_got_digit;
            }
        }

        const _Elem _Lower_exp_wc = _Atoms[_Parse_hex ? _Offset_lower_p : _Offset_lower_e]; 
        const _Elem _Upper_exp_wc = _Atoms[_Parse_hex ? _Offset_upper_p : _Offset_upper_e]; 

        bool _Exponent_part_negative = false;
        ptrdiff_t _Exponent_part     = 0;
        if (_Seendigit && _First != _Last
            && (*_First == _Lower_exp_wc || *_First == _Upper_exp_wc)) { 
            ++_First;
            _Seendigit   = false;
            _Significant = 0;

            if (_First != _Last) {
                if (*_First == _Positive_sign) { 
                    ++_First;
                } else if (*_First == _Negative_sign) { 
                    _Exponent_part_negative = true;
                    ++_First;
                }
            }

            for (; _First != _Last && *_First == _Zero_wc; ++_First) { 
                _Seendigit = true;
            }

            for (size_t _Idx; _First != _Last && (_Idx = ::std:: _Find_elem(_Atoms, *_First)) < _Offset_dec_digit_end;
                 _Seendigit = true, (void) ++_First) {
                if (_Exponent_part < 9223372036854775807i64 / 10
                    || (_Exponent_part == 9223372036854775807i64 / 10
                        && static_cast<ptrdiff_t>(_Idx) <= 9223372036854775807i64 % 10)) { 
                    _Exponent_part = _Exponent_part * 10 + static_cast<ptrdiff_t>(_Idx);
                } else {
                    _Exponent_part = 9223372036854775807i64; 
                }
            }

            if (_Exponent_part_negative) {
                _Exponent_part = -_Exponent_part;
            }
        }

        if (!_Seendigit) {
            return {0, false};
        }

        constexpr int _Dec_exp_abs_bound = 1100; 
        constexpr int _Hex_exp_abs_bound = 4200; 

        const ptrdiff_t _Exp_abs_bound     = _Parse_hex ? _Hex_exp_abs_bound : _Dec_exp_abs_bound;
        const ptrdiff_t _Exp_rep_abs_bound = _Parse_hex ? _Hex_exp_abs_bound / 4 : _Dec_exp_abs_bound;

        
        
        
        for (ptrdiff_t _Power_of_rep_adjusted = _Power_of_rep_base;;) {
            if (_Exponent_part >= 0 && _Power_of_rep_adjusted >= 0
                && (_Exponent_part >= _Exp_abs_bound || _Power_of_rep_adjusted >= _Exp_rep_abs_bound)) {
                _Exponent_part = _Exp_abs_bound;
                break;
            } else if (_Exponent_part <= 0 && _Power_of_rep_adjusted <= 0
                       && (_Exponent_part <= -_Exp_abs_bound || _Power_of_rep_adjusted <= -_Exp_rep_abs_bound)) {
                _Exponent_part = -_Exp_abs_bound;
                break;
            } else if (::std:: abs(_Exponent_part) <= _Exp_abs_bound
                       && ::std:: abs(_Power_of_rep_adjusted) <= _Exp_rep_abs_bound) {
                
                _Exponent_part += _Parse_hex ? _Power_of_rep_adjusted * 4 : _Power_of_rep_adjusted;
                if (_Exponent_part > _Exp_abs_bound) {
                    _Exponent_part = _Exp_abs_bound;
                } else if (_Exponent_part < -_Exp_abs_bound) {
                    _Exponent_part = -_Exp_abs_bound;
                }
                break;
            } else {
                
                
                const ptrdiff_t _Exponent_part_preadjustment_round_up =
                    _Parse_hex ? (::std:: abs(_Exponent_part) - 1) / 4 + 1 : ::std:: abs(_Exponent_part);
                const ptrdiff_t _Exp_rep_adjustment =
                    (::std:: min)(_Exponent_part_preadjustment_round_up, ::std:: abs(_Power_of_rep_base));

                if (_Exponent_part >= 0) {
                    _Exponent_part -= _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted += _Exp_rep_adjustment;
                } else {
                    _Exponent_part += _Parse_hex ? _Exp_rep_adjustment * 4 : _Exp_rep_adjustment;
                    _Power_of_rep_adjusted -= _Exp_rep_adjustment;
                }
            }
        }

        if (_Exponent_part != 0) {
            *_Ptr++ = _Parse_hex ? 'p' : 'e';
            if (_Exponent_part < 0) {
                *_Ptr++ = '-';
            }

            char* const _Rev_begin = _Ptr;
            for (ptrdiff_t _Exponent_part_abs = ::std:: abs(_Exponent_part); _Exponent_part_abs != 0;
                 _Exponent_part_abs /= 10) {
                *_Ptr++ = static_cast<char>('0' + _Exponent_part_abs % 10);
            }
            ::std:: reverse(_Rev_begin, _Ptr);
        }

        *_Ptr = '\0';
        return {static_cast<int8_t>(_Parse_hex ? 16 : 10), _Bad_grouping};
    }

    
    int __cdecl _Getifld(
        char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) const {
        
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+Xx"; 
        const char* volatile _Ptr    = _Src;
        (void) _Ptr;

        const auto _Parse_result = _Parse_int_with_locale(_Ac, _First, _Last, _Basefield, _Loc);
        if (_Parse_result._Base < 0 || _Parse_result._Bad_grouping) { 
            *_Ac = '\0';
        }
        return _Parse_result._Base < 0 ? ~_Parse_result._Base : _Parse_result._Base;
    }






    
    int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const {
        
        static constexpr char _Src[] = "0123456789-+Ee"; 
        const char* volatile _Ptr    = &_Src[0];
        (void) _Ptr;
        const int _Max_sig_dig   = (*_Phexexp == 1000000000 ? 768 : 36);
        const auto _Parse_result = _Parse_fp_with_locale(_Ac, _Max_sig_dig, _First, _Last, _Iosbase.getloc());
        if (_Parse_result._Base == 0 || _Parse_result._Bad_grouping) { 
            *_Ac = '\0';
        }

        if (_Parse_result._Base == 16) {
            *_Phexexp = 0; 
        }
        return 0; 
    }

    
    int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const {
        
        static constexpr char _Src[] = "0123456789ABCDEFabcdef-+XxPp"; 
        const char* volatile _Ptr    = &_Src[0];
        (void) _Ptr;
        const int _Max_sig_dig   = (*_Phexexp == 1000000000 ? 768 : 36);
        const auto _Parse_result = _Parse_fp_with_locale(_Ac, _Max_sig_dig, _First, _Last, _Iosbase.getloc());
        if (_Parse_result._Base == 0 || _Parse_result._Bad_grouping) { 
            *_Ac = '\0';
        }

        if (_Parse_result._Base == 16) {
            *_Phexexp = 0; 
        }
        return 0; 
    }




};






template <class _Elem, class _InIt>
 locale::id num_get<_Elem, _InIt>::id;





template <class _Ty>
int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {
    
    const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);
    if (_Is_hex) {
        
        if constexpr (is_same_v<_Ty, double>) {
            return ((53 - 1) + 3) / 4;
        } else if constexpr (is_same_v<_Ty, long double>) {
            return ((53 - 1) + 3) / 4;
        } else {
            static_assert(_Always_false<_Ty>, "Expected only double or long double here (not float).");
        }
    }

    if (_Precision > 0) {
        return static_cast<int>(_Precision);
    } else if (_Precision == 0) {
        const bool _Is_default_float = _Float_flags == 0;
        if (_Is_default_float) {
            return 1;
        } else {
            return 0;
        }
    } else {
        constexpr int _Default_precision = 6;
        return _Default_precision;
    }
}

 extern "C++" template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class num_put : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 4;
    }

     static locale::id id; 

protected:
     ~num_put() noexcept override {}

    void  _Init(const _Locinfo&) {} 

public:
    explicit  num_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    using char_type = _Elem;
    using iter_type = _OutIt;

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

    _OutIt  put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        return do_put(_Dest, _Iosbase, _Fill, _Val);
    }

protected:
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { 
        if (!(_Iosbase.flags() & ios_base::boolalpha)) {
            return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
        } else { 
            const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Str;
            if (_Val) {
                _Str.assign(_Punct_fac.truename());
            } else {
                _Str.assign(_Punct_fac.falsename());
            }

            size_t _Fillcount;
            if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {
                _Fillcount = 0;
            } else {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
            }

            if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { 
                _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); 
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount); 
        }
    }

#pragma warning(push)
#pragma warning(disable : 4774) 
    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { 
        char _Buf[2 * _Max_int_dig];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long _Val) const { 
        char _Buf[2 * _Max_int_dig];
        char _Fmt[6];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { 
        char _Buf[2 * _Max_int_dig];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill,
        unsigned long long _Val) const { 
        char _Buf[2 * _Max_int_dig];
        char _Fmt[8];

        return _Iput(_Dest, _Iosbase, _Fill, _Buf,
            static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabs(_Val)) { 
            int _Ptwo;
            (void) :: frexp(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, (::std:: isfinite)(_Val));
    }

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { 
        string _Buf;
        char _Fmt[8];
        const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;
        const bool _Is_fixed        = _Float_flags == ios_base::fixed;
        const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);
        const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); 
        const int _Desired_precision =
            _Float_put_desired_precision<long double>(_Precision, _Float_flags); 
        size_t _Bufsize = static_cast<size_t>(_Desired_precision);
        if (_Is_fixed && 1e10 < :: fabsl(_Val)) { 
            int _Ptwo;
            (void) :: frexpl(_Val, &_Ptwo);
            _Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
        }

        _Buf.resize(_Bufsize + 50); 
        const auto _Ngen = static_cast<size_t>(:: sprintf_s(
            &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));

        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, (::std:: isfinite)(_Val));
    }
#pragma warning(pop)

    virtual _OutIt  do_put(
        _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { 
        char _Buf[2 * _Max_int_dig];

        return _Iput(
            _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(:: sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
    }

private:
    char* __cdecl _Ffmt(
        char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showpoint) {
            *_Ptr++ = '#';
        }

        *_Ptr++ = '.';
        *_Ptr++ = '*'; 
        if (_Spec != '\0') {
            *_Ptr++ = _Spec; 
        }

        char _Ch; 
        ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
        if (_Flags & ios_base::uppercase) {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'A'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'E';
            } else {
                _Ch = 'G';
            }
        } else {
            if (_Ffl == ios_base::fixed) {
                _Ch = 'f';
            } else if (_Ffl == ios_base::hexfloat) {
                _Ch = 'a'; 
            } else if (_Ffl == ios_base::scientific) {
                _Ch = 'e';
            } else {
                _Ch = 'g';
            }
        }
        *_Ptr++ = _Ch;

        *_Ptr = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf,
        size_t _Count) const { 
        return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf, _Count, true);
    }

    template <int = 0> 
    _OutIt _Fput_v3(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf, size_t _Count,
        bool _Is_finite_val) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        const char* _Exps;
        if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat) {
            _Exps = "eE";
        } else { 
            _Exps = "pP";
            if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
                && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
                _Prefix += 2;
            }
        }
        const size_t _Eoff = :: strcspn(&_Buf[0], _Exps); 
        char _Dp[2]        = {"."};
        _Dp[0]             = :: localeconv()->decimal_point[0];
        const size_t _Poff = :: strcspn(&_Buf[0], &_Dp[0]); 

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac  = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping  = _Punct_fac.grouping();
        const _Elem _Kseparator = _Punct_fac.thousands_sep();

        if (_Poff != _Count) {
            _Groupstring[_Poff] = _Punct_fac.decimal_point();
        }

        if (_Is_finite_val) {
            size_t _Off     = _Poff == _Count ? _Eoff : _Poff;
            const char* _Pg = &_Grouping[0];
            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {
                
                _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    char* __cdecl _Ifmt(
        char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { 
        char* _Ptr = _Fmt;
        *_Ptr++    = '%';

        if (_Flags & ios_base::showpos) {
            *_Ptr++ = '+';
        }

        if (_Flags & ios_base::showbase) {
            *_Ptr++ = '#';
        }

        if (_Spec[0] != 'L') {
            *_Ptr++ = _Spec[0]; 
        } else { 
            *_Ptr++ = 'I';
            *_Ptr++ = '6';
            *_Ptr++ = '4';
        }

        ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
        *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'
                                      : _Basefield != ios_base::hex  ? _Spec[1] 
                                      : _Flags & ios_base::uppercase ? 'X'
                                                                     : 'x';
        *_Ptr                         = '\0';
        return _Fmt;
    }

    _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf,
        size_t _Count) const { 
        auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
        if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
            && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {
            _Prefix += 2;
        }

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        basic_string<_Elem> _Groupstring(_Count, _Elem(0)); 
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

        const auto& _Punct_fac = ::std:: use_facet<numpunct<_Elem>>(_Iosbase.getloc());
        const string _Grouping = _Punct_fac.grouping();
        const char* _Pg        = &_Grouping[0];
        if (*_Pg != 127 && '\0' < *_Pg) { 
            const _Elem _Kseparator = _Punct_fac.thousands_sep();
            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {
                
                _Count -= *_Pg;
                _Groupstring.insert(_Count, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        _Count = _Groupstring.size();

        size_t _Fillcount;
        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
        }

        ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
        if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
        } else if (_Adjustfield == ios_base::internal) { 
            _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        } else {
            _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
        }

        _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    _OutIt __cdecl _Put(
        _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {
            *_Dest = *_Ptr;
        }

        return _Dest;
    }

    _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { 
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};






template <class _Elem, class _OutIt>
 locale::id num_put<_Elem, _OutIt>::id;




template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char, istreambuf_iterator<char, char_traits<char>>>;
template class __declspec(dllimport) num_put<char, ostreambuf_iterator<char, char_traits<char>>>;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template class __declspec(dllimport) num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
#line 1655 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"








#line 1664 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"




}


#pragma warning(pop)
#pragma pack(pop)
#line 1674 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"
#line 1675 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocnum"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 extern "C++" template <class _Elem, class _Traits>
class basic_ios : public ios_base { 
public:
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Mysb       = basic_streambuf<_Elem, _Traits>;
    using _Ctype      = ctype<_Elem>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_ios(_Mysb* _Strbuf) {
        init(_Strbuf);
    }

     ~basic_ios() noexcept override {}

    void  clear(iostate _State = goodbit, bool _Reraise = false) {
        
        ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
    }





#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"

    void  setstate(iostate _State, bool _Reraise = false) {
        
        clear(rdstate() | _State, _Reraise);
    }





#line 59 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"

    basic_ios&  copyfmt(const basic_ios& _Right) { 
        _Tiestr = _Right.tie();
        _Fillch = _Right.fill();
        ios_base::copyfmt(_Right);
        return *this;
    }

    _Myos*  tie() const noexcept  {
        return _Tiestr;
    }

    _Myos*  tie(_Myos* _Newtie) noexcept  { 
        _Myos* _Oldtie = _Tiestr;
        _Tiestr        = _Newtie;
        return _Oldtie;
    }

    [[nodiscard]] _Mysb*  rdbuf() const noexcept  {
        return _Mystrbuf;
    }

    _Mysb*  rdbuf(_Mysb* _Strbuf) { 
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        clear();
        return _Oldstrbuf;
    }

    locale  imbue(const locale& _Loc) { 
        locale _Oldlocale = ios_base::imbue(_Loc);
        const auto _Rdbuf = rdbuf();
        if (_Rdbuf) {
            _Rdbuf->pubimbue(_Loc);
        }

        return _Oldlocale;
    }

    _Elem  fill() const noexcept  {
        return _Fillch;
    }

    _Elem  fill(_Elem _Newfill) noexcept  { 
        _Elem _Oldfill = _Fillch;
        _Fillch        = _Newfill;
        return _Oldfill;
    }

    char  narrow(_Elem _Ch, char _Dflt = '\0') const { 
        return ::std:: use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
    }

    _Elem  widen(char _Byte) const { 
        return ::std:: use_facet<_Ctype>(getloc()).widen(_Byte);
    }

    void  move(basic_ios& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  move(basic_ios&& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Mystrbuf = nullptr;
            _Tiestr   = nullptr;
            this->swap(_Right);
        }
    }

    void  swap(basic_ios& _Right) noexcept { 
        ios_base::swap(_Right);
        ::std:: swap(_Fillch, _Right._Fillch);
        ::std:: swap(_Tiestr, _Right._Tiestr);
    }

    void  set_rdbuf(_Mysb* _Strbuf) noexcept  {
        
        _Mystrbuf = _Strbuf;
    }

protected:
    void  init(_Mysb* _Strbuf = nullptr, bool _Isstd = false) {
        
        _Init(); 
        _Mystrbuf = _Strbuf;
        _Tiestr   = nullptr;
        _Fillch   = widen(' ');

        if (!_Mystrbuf) {
            setstate(badbit);
        }

        if (_Isstd) {
            _Addstd(this); 
        }
    }

     basic_ios() {}

private:
    _Mysb* _Mystrbuf{}; 
    _Myos* _Tiestr{}; 
    _Elem _Fillch{}; 

public:
     basic_ios(const basic_ios&)            = delete;
    basic_ios&  operator=(const basic_ios&) = delete;
};




template class __declspec(dllimport) basic_ios<char, char_traits<char>>;
template class __declspec(dllimport) basic_ios<wchar_t, char_traits<wchar_t>>;
#line 178 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"




#line 183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"

 inline ios_base& __cdecl boolalpha(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::boolalpha);
    return _Iosbase;
}

 inline ios_base& __cdecl dec(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::dec, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl fixed(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl hex(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hex, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl hexfloat(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl internal(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl left(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::left, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::boolalpha);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowbase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showbase);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpoint);
    return _Iosbase;
}

 inline ios_base& __cdecl noshowpos(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::showpos);
    return _Iosbase;
}

 inline ios_base& __cdecl noskipws(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::skipws);
    return _Iosbase;
}

 inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::unitbuf);
    return _Iosbase;
}

 inline ios_base& __cdecl nouppercase(ios_base& _Iosbase) { 
    _Iosbase.unsetf(ios_base::uppercase);
    return _Iosbase;
}

 inline ios_base& __cdecl oct(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::oct, ios_base::basefield);
    return _Iosbase;
}

 inline ios_base& __cdecl right(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::right, ios_base::adjustfield);
    return _Iosbase;
}

 inline ios_base& __cdecl scientific(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
    return _Iosbase;
}

 inline ios_base& __cdecl showbase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showbase);
    return _Iosbase;
}

 inline ios_base& __cdecl showpoint(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpoint);
    return _Iosbase;
}

 inline ios_base& __cdecl showpos(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::showpos);
    return _Iosbase;
}

 inline ios_base& __cdecl skipws(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::skipws);
    return _Iosbase;
}

 inline ios_base& __cdecl unitbuf(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::unitbuf);
    return _Iosbase;
}

 inline ios_base& __cdecl uppercase(ios_base& _Iosbase) { 
    _Iosbase.setf(ios_base::uppercase);
    return _Iosbase;
}





#line 309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"

}



#pragma warning(pop)
#pragma pack(pop)
#line 317 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"
#line 318 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ios"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"


#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )










namespace std {

namespace filesystem {
     class path;
}
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"






#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"
#line 41 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"


namespace experimental {
    namespace filesystem {
        inline namespace v1 {
            class path;
        }
    } 
} 
#line 51 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"


template <class _Ty>
inline constexpr bool _Is_any_path = _Is_any_of_v<_Ty

    , experimental::filesystem::path
#line 58 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"

    , filesystem::path
#line 61 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"
    >;


extern "C++"  FILE* __cdecl _Fiopen(const char*, ios_base::openmode, int);
extern "C++"  FILE* __cdecl _Fiopen(const wchar_t*, ios_base::openmode, int);





template <class _Elem>
bool _Fgetc(_Elem& _Ch, FILE* _File) { 
    return :: fread(&_Ch, sizeof(_Elem), 1, _File) == 1;
}

template <>
inline bool _Fgetc(char& _Byte, FILE* _File) { 
    int _Meta;
    if ((_Meta = :: fgetc(_File)) == (-1)) {
        return false;
    } else { 
        _Byte = static_cast<char>(_Meta);
        return true;
    }
}

template <>
inline bool _Fgetc(wchar_t& _Wchar, FILE* _File) { 
    wint_t _Meta;
    if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF))) {
        return false;
    } else { 
        _Wchar = static_cast<wchar_t>(_Meta);
        return true;
    }
}














template <class _Elem>
bool _Fputc(_Elem _Ch, FILE* _File) { 
    return :: fwrite(&_Ch, 1, sizeof(_Elem), _File) == sizeof(_Elem);
}

template <>
inline bool _Fputc(char _Byte, FILE* _File) { 
    return :: fputc(_Byte, _File) != (-1);
}

template <>
inline bool _Fputc(wchar_t _Wchar, FILE* _File) { 
    return :: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF));
}








template <class _Elem>
bool _Ungetc(const _Elem&, FILE*) { 
    return false;
}

template <>
inline bool _Ungetc(const char& _Byte, FILE* _File) { 
    return :: ungetc(static_cast<unsigned char>(_Byte), _File) != (-1);
}

template <>
inline bool _Ungetc(const signed char& _Byte, FILE* _File) { 
    return :: ungetc(static_cast<unsigned char>(_Byte), _File) != (-1);
}

template <>
inline bool _Ungetc(const unsigned char& _Byte, FILE* _File) { 
    return :: ungetc(_Byte, _File) != (-1);
}

template <>
inline bool _Ungetc(const wchar_t& _Wchar, FILE* _File) { 
    return :: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF));
}








 template <class _Elem, class _Traits>
class basic_filebuf : public basic_streambuf<_Elem, _Traits> { 
public:
    using _Mysb = basic_streambuf<_Elem, _Traits>;
    using _Cvt  = codecvt<_Elem, char, typename _Traits::state_type>;

    basic_filebuf() : _Mysb() {
        _Init(nullptr, _Newfl);
    }

    explicit basic_filebuf(FILE* const _File) : _Mysb() { 
        _Init(_File, _Newfl);
    }

     ~basic_filebuf() noexcept override {
        if (_Myfile) {
            _Reset_back(); 
        }

        if (_Closef) {
            close();
        }
    }

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    basic_filebuf(_Uninitialized) noexcept : _Mysb(_Noinit) {}

    basic_filebuf(basic_filebuf&& _Right) {
        _Init(_Right._Myfile, _Newfl); 
        _Init(static_cast<FILE*>(nullptr), _Closefl); 
        _Assign_rv(::std:: move(_Right));
    }

    basic_filebuf& operator=(basic_filebuf&& _Right) {
        _Assign_rv(::std:: move(_Right));
        return *this;
    }

    void _Assign_rv(basic_filebuf&& _Right) {
        if (this != ::std:: addressof(_Right)) {
            close();
            this->swap(_Right);
        }
    }

    void swap(basic_filebuf& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            FILE* _Myfile_sav                       = _Myfile;
            const _Cvt* _Pcvt_sav                   = _Pcvt;
            typename _Traits::state_type _State_sav = _State;
            bool _Wrotesome_sav                     = _Wrotesome;
            bool _Closef_sav                        = _Closef;
            bool _Set_eback_sav                     = _Mysb::eback() == &_Mychar;
            bool _Set_eback_live                    = _Mysb::gptr() == &_Mychar;

            _Elem* _Pfirst0 = _Mysb::pbase();
            _Elem* _Pnext0  = _Mysb::pptr();
            _Elem* _Pend    = _Mysb::epptr();
            _Elem* _Gfirst0 = _Mysb::eback();
            _Elem* _Gnext0  = _Mysb::gptr();
            _Elem* _Gend    = _Mysb::egptr();

            
            _Init(_Right._Myfile, _Right._Myfile ? _Openfl : _Newfl);
            _Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            if (_Right.eback() != &_Right._Mychar) {
                _Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
            } else if (_Right.gptr() != &_Right._Mychar) {
                _Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
            } else {
                _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
            }

            _Pcvt      = _Right._Pcvt;
            _State     = _Right._State;
            _Wrotesome = _Right._Wrotesome;
            _Closef    = _Right._Closef;

            
            _Right._Init(_Myfile_sav, _Myfile_sav ? _Openfl : _Newfl);
            _Right.setp(_Pfirst0, _Pnext0, _Pend);
            if (!_Set_eback_sav) {
                _Right.setg(_Gfirst0, _Gnext0, _Gend);
            } else if (!_Set_eback_live) {
                _Right.setg(&_Right._Mychar, &_Right._Mychar + 1, &_Right._Mychar + 1);
            } else {
                _Right.setg(&_Right._Mychar, &_Right._Mychar, &_Right._Mychar + 1);
            }

            _Right._Pcvt      = _Pcvt_sav;
            _Right._State     = _State_sav;
            _Right._Wrotesome = _Wrotesome_sav;
            _Right._Closef    = _Closef_sav;

            
            ::std:: swap(_Set_eback, _Right._Set_eback);
            ::std:: swap(_Set_egptr, _Right._Set_egptr);

            ::std:: swap(_Mychar, _Right._Mychar);
            ::std:: swap(_Mysb::_Plocale, _Right._Plocale);
        }
    }

    basic_filebuf(const basic_filebuf&)            = delete;
    basic_filebuf& operator=(const basic_filebuf&) = delete;

    enum _Initfl { 
        _Newfl,
        _Openfl,
        _Closefl
    };

    [[nodiscard]] bool is_open() const noexcept  {
        return static_cast<bool>(_Myfile);
    }

    basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        if (_Myfile) {
            return nullptr;
        }

        const auto _File = _Fiopen(_Filename, _Mode, _Prot);
        if (!_File) {
            return nullptr; 
        }

        _Init(_File, _Openfl);
        _Initcvt(::std:: use_facet<_Cvt>(_Mysb::getloc()));
        return this; 
    }

    basic_filebuf* open(const string& _Str, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        return open(_Str.c_str(), _Mode, _Prot);
    }





#line 310 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"

    basic_filebuf* open(const wchar_t* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        if (_Myfile) {
            return nullptr;
        }

        const auto _File = _Fiopen(_Filename, _Mode, _Prot);
        if (!_File) {
            return nullptr; 
        }

        _Init(_File, _Openfl);
        _Initcvt(::std:: use_facet<_Cvt>(_Mysb::getloc()));
        return this; 
    }

    basic_filebuf* open(const wstring& _Str, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        return open(_Str.c_str(), _Mode, _Prot);
    }


    template <class _Path_ish = experimental::filesystem::path>
    basic_filebuf* open(
        const _Identity_t<_Path_ish>& _Path, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        return open(_Path.c_str(), _Mode, _Prot);
    }
#line 340 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"


    template <int = 0, class _Path_ish = filesystem::path>
    basic_filebuf* open(
        const _Identity_t<_Path_ish>& _Path, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {
        
        return open(_Path.c_str(), _Mode, _Prot);
    }
#line 349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"






#line 356 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"



























    basic_filebuf* close() {
        basic_filebuf* _Ans;
        if (_Myfile) { 
            _Reset_back(); 

            _Ans = this;
            if (!_Endwrite()) {
                _Ans = nullptr;
            }

            if (:: fclose(_Myfile) != 0) {
                _Ans = nullptr;
            }
        } else {
            _Ans = nullptr;
        }

        _Init(nullptr, _Closefl);
        return _Ans;
    }

    void  _Lock() override { 
        if (_Myfile) {
            :: _lock_file(_Myfile);
        }
    }

    void  _Unlock() override { 
        if (_Myfile) {
            :: _unlock_file(_Myfile);
        }
    }


    template <class _Filebuf_type>
    friend ios_base::iostate _Print_noformat_unicode(ostream&, string_view);
#line 420 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"

protected:
    int_type  overflow(int_type _Meta = _Traits::eof()) override { 
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            return _Traits::not_eof(_Meta); 
        }

        if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { 
            *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
            return _Meta;
        }

        if (!_Myfile) {
            return _Traits::eof(); 
        }

        _Reset_back(); 
        if (!_Pcvt) { 
            return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();
        }

        
        constexpr size_t _Codecvt_temp_buf = 32;
        char _Str[_Codecvt_temp_buf];
        const _Elem _Ch = _Traits::to_char_type(_Meta);
        const _Elem* _Src;
        char* _Dest;

        
        switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf, _Dest)) {
        case codecvt_base::partial:
        case codecvt_base::ok:
            { 
                const auto _Count = static_cast<size_t>(_Dest - _Str);
                if (0 < _Count && _Count != static_cast<size_t>(:: fwrite(_Str, 1, _Count, _Myfile))) {
                    return _Traits::eof(); 
                }

                _Wrotesome = true; 
                if (_Src != &_Ch) {
                    return _Meta; 
                }

                return _Traits::eof(); 
            }

        case codecvt_base::noconv:
            
            return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

        default:
            return _Traits::eof(); 
        }
    }

    int_type  pbackfail(int_type _Meta = _Traits::eof()) override {
        
        if (_Mysb::gptr() && _Mysb::eback() < _Mysb::gptr()
            && (_Traits::eq_int_type(_Traits::eof(), _Meta)
                || _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
                    _Meta))) { 
            _Mysb::_Gndec();
            return _Traits::not_eof(_Meta);
        } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {
            return _Traits::eof(); 
        } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {
            return _Meta; 
        } else if (_Mysb::gptr() != &_Mychar) { 
            _Mychar = _Traits::to_char_type(_Meta);
            _Set_back(); 
            return _Meta;
        } else {
            return _Traits::eof(); 
        }
    }

    int_type  underflow() override { 
        int_type _Meta;
        if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {
            return _Traits::to_int_type(*_Mysb::gptr()); 
        } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {
            return _Meta; 
        } else { 
            pbackfail(_Meta);
            return _Meta;
        }
    }

    int_type  uflow() override { 
        if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {
            return _Traits::to_int_type(*_Mysb::_Gninc()); 
        }

        if (!_Myfile) {
            return _Traits::eof(); 
        }

        _Reset_back(); 
        if (!_Pcvt) { 
            _Elem _Ch;
            return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();
        }

        
        string _Str;

        for (;;) { 
            const char* _Src;
            int _Meta = :: fgetc(_Myfile);

            if (_Meta == (-1)) {
                return _Traits::eof(); 
            }

            _Str.push_back(static_cast<char>(_Meta)); 

            _Elem _Ch;
            _Elem* _Dest;

            
            switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {
            case codecvt_base::partial:
            case codecvt_base::ok:
                if (_Dest != &_Ch) { 
                    auto _Nleft = _Str.data() + _Str.size() - _Src;
                    while (0 < _Nleft) {
                        :: ungetc(_Src[--_Nleft], _Myfile);
                    }

                    return _Traits::to_int_type(_Ch);
                }

                _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); 
                break;

            case codecvt_base::noconv:
                
                return static_cast<int_type>(_Str.front());

            default:
                return _Traits::eof(); 
            }
        }
    }

    streamsize  xsgetn(_Elem* _Ptr, streamsize _Count) override {
        
        if constexpr (sizeof(_Elem) == 1) {
            if (_Count <= 0) {
                return 0;
            }

            if (_Pcvt) { 
                return _Mysb::xsgetn(_Ptr, _Count);
            }

            
            auto _Count_s           = static_cast<size_t>(_Count);
            const auto _Start_count = _Count;
            const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());
            if (0 < _Available) { 
                const auto _Read_size = (::std:: min)(_Count_s, _Available);
                _Traits::copy(_Ptr, _Mysb::gptr(), _Read_size);
                _Ptr += _Read_size;
                _Count_s -= _Read_size;
                _Mysb::gbump(static_cast<int>(_Read_size));
            }

            if (_Myfile) { 
                _Reset_back(); 
                
                
                constexpr size_t _Read_size = 4095; 
                while (_Read_size < _Count_s) {
                    const auto _Actual_read = :: fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);
                    _Ptr += _Actual_read;
                    _Count_s -= _Actual_read;
                    if (_Actual_read != _Read_size) {
                        return static_cast<streamsize>(_Start_count - _Count_s);
                    }
                }

                if (0 < _Count_s) {
                    _Count_s -= :: fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);
                }
            }

            return static_cast<streamsize>(_Start_count - _Count_s);
        } else { 
            return _Mysb::xsgetn(_Ptr, _Count);
        }
    }

    streamsize  xsputn(const _Elem* _Ptr, streamsize _Count) override {
        
        if constexpr (sizeof(_Elem) == 1) {
            if (_Pcvt) { 
                return _Mysb::xsputn(_Ptr, _Count);
            }

            const streamsize _Start_count = _Count;
            streamsize _Size              = _Mysb::_Pnavail();
            if (0 < _Count && 0 < _Size) { 
                if (_Count < _Size) {
                    _Size = _Count;
                }

                _Traits::copy(_Mysb::pptr(), _Ptr, static_cast<size_t>(_Size));
                _Ptr += _Size;
                _Count -= _Size;
                _Mysb::pbump(static_cast<int>(_Size));
            }

            if (0 < _Count && _Myfile) { 
                _Count -= :: fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);
            }

            return _Start_count - _Count;
        } else { 
            return _Mysb::xsputn(_Ptr, _Count);
        }
    }

    pos_type  seekoff(off_type _Off, ios_base::seekdir _Way,
        ios_base::openmode = ios_base::in | ios_base::out) override { 
        fpos_t _Fileposition;

        if (_Mysb::gptr() == &_Mychar 
            && _Way == ios_base::cur 
            && !_Pcvt) { 
            _Off -= static_cast<off_type>(sizeof(_Elem)); 
        }

        if (!_Myfile || !_Endwrite()
            || ((_Off != 0 || _Way != ios_base::cur) && :: _fseeki64(_Myfile, _Off, _Way) != 0)
            || :: fgetpos(_Myfile, &_Fileposition) != 0) {
            return pos_type{off_type{-1}}; 
        }

        _Reset_back(); 
        return pos_type{_State, _Fileposition}; 
    }

    pos_type  seekpos(pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {
        
        off_type _Off = static_cast<off_type>(_Pos);

        if (!_Myfile || !_Endwrite() || :: fsetpos(_Myfile, &_Off) != 0) {
            return pos_type{off_type{-1}}; 
        }

        _State = _Pos.state();
        _Reset_back(); 
        return pos_type{_State, _Off}; 
    }

    _Mysb*  setbuf(_Elem* _Buffer, streamsize _Count) override { 
        int _Mode;
        if (!_Buffer && _Count == 0) {
            _Mode = 0x0004;
        } else {
            _Mode = 0x0000;
        }

        const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);

        if (!_Myfile || :: setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {
            return nullptr; 
        }

        
        _Init(_Myfile, _Openfl);
        return this;
    }

    int  sync() override { 
        if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= :: fflush(_Myfile)) {
            return 0;
        }

        return -1;
    }

    void  imbue(const locale& _Loc) override {
        
        _Initcvt(::std:: use_facet<_Cvt>(_Loc));
    }

    void _Init(FILE* _File, _Initfl _Which) noexcept { 
        using _State_type = typename _Traits::state_type;

         static _State_type _Stinit; 

        _Closef    = _Which == _Openfl;
        _Wrotesome = false;

        _Mysb::_Init(); 

        if (_File && sizeof(_Elem) == 1) { 
            _Elem** _Pb = nullptr;
            _Elem** _Pn = nullptr;
            int* _Nr    = nullptr;

            ::_get_stream_buffer_pointers(
                _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
            int* _Nw = _Nr;

            _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
        }

        _Myfile = _File;
        _State  = _Stinit;
        _Pcvt   = nullptr; 
    }

    bool _Endwrite() { 
        if (!_Pcvt || !_Wrotesome) {
            return true;
        }

        
        if (_Traits::eq_int_type(_Traits::eof(), overflow())) {
            return false;
        }

        constexpr size_t _Codecvt_temp_buf = 32;
        char _Str[_Codecvt_temp_buf];
        char* _Dest;
        switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { 
        case codecvt_base::ok:
            _Wrotesome = false; 
            [[fallthrough]];

        case codecvt_base::partial:
            { 
                const auto _Count = static_cast<size_t>(_Dest - _Str);
                if (0 < _Count && _Count != static_cast<size_t>(:: fwrite(_Str, 1, _Count, _Myfile))) {
                    return false; 
                }

                return !_Wrotesome;
            }

        case codecvt_base::noconv:
            _Wrotesome = false; 
            return true; 

        default:
            return false; 
        }
    }

    void _Initcvt(const _Cvt& _Newcvt) noexcept { 
        if (_Newcvt.always_noconv()) {
            _Pcvt = nullptr; 
        } else { 
            _Pcvt = ::std:: addressof(_Newcvt);
            _Mysb::_Init(); 
        }
    }

private:
    const _Cvt* _Pcvt; 
    _Elem _Mychar; 
    bool _Wrotesome; 
    typename _Traits::state_type _State; 
    bool _Closef; 
    FILE* _Myfile; 

    void _Reset_back() noexcept { 
        if (_Mysb::eback() == &_Mychar) {
            _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
        }
    }

    void _Set_back() noexcept { 
        if (_Mysb::eback() != &_Mychar) { 
            _Set_eback = _Mysb::eback();
            _Set_egptr = _Mysb::egptr();
        }
        _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
    }

    _Elem* _Set_eback; 
    _Elem* _Set_egptr; 
};

 template <class _Elem, class _Traits>
void swap(basic_filebuf<_Elem, _Traits>& _Left, basic_filebuf<_Elem, _Traits>& _Right) noexcept  {
    _Left.swap(_Right);
}

}



#pragma warning(pop)
#pragma pack(pop)

#line 820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"
#line 821 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_filebuf.hpp"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfilesystem_abi.h"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {
inline constexpr size_t __std_fs_max_path      = 260; 
inline constexpr size_t __std_fs_temp_path_max = __std_fs_max_path + 1;

enum class __std_win_error : unsigned long {
    _Success                   = 0, 
    _Invalid_function          = 1, 
    _File_not_found            = 2, 
    _Path_not_found            = 3, 
    _Access_denied             = 5, 
    _Not_enough_memory         = 8, 
    _No_more_files             = 18, 
    _Sharing_violation         = 32, 
    _Not_supported             = 50, 
    _Error_bad_netpath         = 53, 
    _File_exists               = 80, 
    _Invalid_parameter         = 87, 
    _Insufficient_buffer       = 122, 
    _Invalid_name              = 123, 
    _Directory_not_empty       = 145, 
    _Already_exists            = 183, 
    _Filename_exceeds_range    = 206, 
    _Directory_name_is_invalid = 267, 
    _Reparse_tag_invalid       = 4393L, 
    _Max                       = ~0UL 
};

#pragma warning(push)
#pragma warning(disable : 4061) 
[[nodiscard]] inline bool __std_is_file_not_found(const __std_win_error _Error) noexcept {
    switch (_Error) {
    case __std_win_error::_File_not_found:
    case __std_win_error::_Path_not_found:
    case __std_win_error::_Error_bad_netpath:
    case __std_win_error::_Invalid_name:
        return true;
    default:
        return false;
    }
}
#pragma warning(pop)

enum class __std_fs_dir_handle : intptr_t { _Invalid = -1 };

enum class __std_fs_file_attr : unsigned long {
    _Readonly      = 0x00000001, 
    _Hidden        = 0x00000002, 
    _System        = 0x00000004, 
    _Directory     = 0x00000010, 
    _Archive       = 0x00000020, 
    _Device        = 0x00000040, 
    _Normal        = 0x00000080, 
    _Temporary     = 0x00000100, 
    _Sparse_file   = 0x00000200, 
    _Reparse_point = 0x00000400, 

    _Invalid = 0xFFFFFFFF, 
};
}

 [[nodiscard]] constexpr __std_fs_file_attr operator&(__std_fs_file_attr _Left, __std_fs_file_attr _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_attr>; return static_cast<__std_fs_file_attr>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_file_attr operator|(__std_fs_file_attr _Left, __std_fs_file_attr _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_attr>; return static_cast<__std_fs_file_attr>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_file_attr operator^(__std_fs_file_attr _Left, __std_fs_file_attr _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_attr>; return static_cast<__std_fs_file_attr>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr __std_fs_file_attr& operator&=(__std_fs_file_attr& _Left, __std_fs_file_attr _Right) noexcept { return _Left = _Left & _Right; }  constexpr __std_fs_file_attr& operator|=(__std_fs_file_attr& _Left, __std_fs_file_attr _Right) noexcept { return _Left = _Left | _Right; }  constexpr __std_fs_file_attr& operator^=(__std_fs_file_attr& _Left, __std_fs_file_attr _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr __std_fs_file_attr operator~(__std_fs_file_attr _Left) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_attr>; return static_cast<__std_fs_file_attr>(~static_cast<_IntTy>(_Left)); }

extern "C" {
enum class __std_fs_reparse_tag : unsigned long {
    _None        = 0,
    _Mount_point = (0xA0000003L), 
    _Symlink     = (0xA000000CL), 
};

struct __std_fs_filetime { 
    unsigned long _Low; 
    unsigned long _High; 
}; 

struct __std_fs_find_data { 
    __std_fs_file_attr _Attributes; 
    __std_fs_filetime _Creation_time; 
    __std_fs_filetime _Last_access_time; 
    __std_fs_filetime _Last_write_time; 
    unsigned long _File_size_high; 
    unsigned long _File_size_low; 

    
    

    __std_fs_reparse_tag _Reparse_point_tag; 
    unsigned long _Reserved1; 
    wchar_t _File_name[__std_fs_max_path]; 
    wchar_t _Short_file_name[14]; 
}; 

enum class __std_fs_stats_flags : unsigned long {
    _None = 0,

    _Follow_symlinks = 0x01, 
    _Attributes      = 0x02, 
    _Reparse_tag     = 0x04, 
    _File_size       = 0x08, 
    _Link_count      = 0x10, 
    _Last_write_time = 0x20, 

    _All_data = _Attributes | _Reparse_tag | _File_size | _Link_count | _Last_write_time
};
}

 [[nodiscard]] constexpr __std_fs_stats_flags operator&(__std_fs_stats_flags _Left, __std_fs_stats_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_stats_flags>; return static_cast<__std_fs_stats_flags>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_stats_flags operator|(__std_fs_stats_flags _Left, __std_fs_stats_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_stats_flags>; return static_cast<__std_fs_stats_flags>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_stats_flags operator^(__std_fs_stats_flags _Left, __std_fs_stats_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_stats_flags>; return static_cast<__std_fs_stats_flags>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr __std_fs_stats_flags& operator&=(__std_fs_stats_flags& _Left, __std_fs_stats_flags _Right) noexcept { return _Left = _Left & _Right; }  constexpr __std_fs_stats_flags& operator|=(__std_fs_stats_flags& _Left, __std_fs_stats_flags _Right) noexcept { return _Left = _Left | _Right; }  constexpr __std_fs_stats_flags& operator^=(__std_fs_stats_flags& _Left, __std_fs_stats_flags _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr __std_fs_stats_flags operator~(__std_fs_stats_flags _Left) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_stats_flags>; return static_cast<__std_fs_stats_flags>(~static_cast<_IntTy>(_Left)); }

extern "C" {
struct __std_fs_stats {
    long long _Last_write_time;
    unsigned long long _File_size;
    __std_fs_file_attr _Attributes;
    __std_fs_reparse_tag _Reparse_point_tag;
    unsigned long _Link_count;
    __std_fs_stats_flags _Available; 

    [[nodiscard]] __std_fs_file_attr _Symlink_hint_attributes() const noexcept {
        if (::std:: _Bitmask_includes_any(_Available, __std_fs_stats_flags::_Attributes)) {
            return _Attributes;
        }

        return __std_fs_file_attr::_Invalid;
    }
};

struct __std_fs_reparse_data_buffer { 
    unsigned long _Reparse_tag;
    unsigned short _Reparse_data_length;
    unsigned short _Reserved;
    union {
        struct {
            unsigned short _Substitute_name_offset;
            unsigned short _Substitute_name_length;
            unsigned short _Print_name_offset;
            unsigned short _Print_name_length;
            unsigned long _Flags;
            wchar_t _Path_buffer[1];
        } _Symbolic_link_reparse_buffer;
        struct {
            unsigned short _Substitute_name_offset;
            unsigned short _Substitute_name_length;
            unsigned short _Print_name_offset;
            unsigned short _Print_name_length;
            wchar_t _Path_buffer[1];
        } _Mount_point_reparse_buffer;
        struct {
            unsigned char _Data_buffer[1];
        } _Generic_reparse_buffer;
    };
};

struct __std_ulong_and_error {
    unsigned long _Size;
    __std_win_error _Error;
};

enum class __std_fs_volume_name_kind : unsigned long {
    _Dos  = 0, 
    _Guid = 1, 
    _Nt   = 2, 
    _None = 4 
};

enum class __std_access_rights : unsigned long {
    _Delete                = 0x00010000, 
    _File_read_attributes  = 0x0080, 
    _File_write_attributes = 0x0100, 

    
    
    
    
    
    
    
    
    
    _File_generic_write = 0x00120116,
};
}

 [[nodiscard]] constexpr __std_access_rights operator&(__std_access_rights _Left, __std_access_rights _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_access_rights>; return static_cast<__std_access_rights>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_access_rights operator|(__std_access_rights _Left, __std_access_rights _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_access_rights>; return static_cast<__std_access_rights>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_access_rights operator^(__std_access_rights _Left, __std_access_rights _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_access_rights>; return static_cast<__std_access_rights>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr __std_access_rights& operator&=(__std_access_rights& _Left, __std_access_rights _Right) noexcept { return _Left = _Left & _Right; }  constexpr __std_access_rights& operator|=(__std_access_rights& _Left, __std_access_rights _Right) noexcept { return _Left = _Left | _Right; }  constexpr __std_access_rights& operator^=(__std_access_rights& _Left, __std_access_rights _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr __std_access_rights operator~(__std_access_rights _Left) noexcept { using _IntTy = ::std:: underlying_type_t<__std_access_rights>; return static_cast<__std_access_rights>(~static_cast<_IntTy>(_Left)); }

extern "C" {
enum class __std_fs_file_flags : unsigned long {
    _None               = 0,
    _Backup_semantics   = 0x02000000, 
    _Open_reparse_point = 0x00200000, 
};
}

 [[nodiscard]] constexpr __std_fs_file_flags operator&(__std_fs_file_flags _Left, __std_fs_file_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_flags>; return static_cast<__std_fs_file_flags>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_file_flags operator|(__std_fs_file_flags _Left, __std_fs_file_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_flags>; return static_cast<__std_fs_file_flags>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_file_flags operator^(__std_fs_file_flags _Left, __std_fs_file_flags _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_flags>; return static_cast<__std_fs_file_flags>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr __std_fs_file_flags& operator&=(__std_fs_file_flags& _Left, __std_fs_file_flags _Right) noexcept { return _Left = _Left & _Right; }  constexpr __std_fs_file_flags& operator|=(__std_fs_file_flags& _Left, __std_fs_file_flags _Right) noexcept { return _Left = _Left | _Right; }  constexpr __std_fs_file_flags& operator^=(__std_fs_file_flags& _Left, __std_fs_file_flags _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr __std_fs_file_flags operator~(__std_fs_file_flags _Left) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_file_flags>; return static_cast<__std_fs_file_flags>(~static_cast<_IntTy>(_Left)); }

extern "C" {
enum class __std_fs_file_handle : intptr_t { _Invalid = -1 };

enum class __std_code_page : unsigned int { _Acp = 0, _Utf8 = 65001 };

struct __std_fs_convert_result {
    int _Len;
    __std_win_error _Err;
};

struct __std_fs_file_id { 
    unsigned long long _Volume_serial_number; 
    unsigned char _Id[16]; 
}; 

enum class __std_fs_copy_options {
    _None = 0x0,

    _Existing_mask      = 0xF,
    _Skip_existing      = 0x1,
    _Overwrite_existing = 0x2,
    _Update_existing    = 0x4,
};
}

 [[nodiscard]] constexpr __std_fs_copy_options operator&(__std_fs_copy_options _Left, __std_fs_copy_options _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_copy_options>; return static_cast<__std_fs_copy_options>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_copy_options operator|(__std_fs_copy_options _Left, __std_fs_copy_options _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_copy_options>; return static_cast<__std_fs_copy_options>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr __std_fs_copy_options operator^(__std_fs_copy_options _Left, __std_fs_copy_options _Right) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_copy_options>; return static_cast<__std_fs_copy_options>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr __std_fs_copy_options& operator&=(__std_fs_copy_options& _Left, __std_fs_copy_options _Right) noexcept { return _Left = _Left & _Right; }  constexpr __std_fs_copy_options& operator|=(__std_fs_copy_options& _Left, __std_fs_copy_options _Right) noexcept { return _Left = _Left | _Right; }  constexpr __std_fs_copy_options& operator^=(__std_fs_copy_options& _Left, __std_fs_copy_options _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr __std_fs_copy_options operator~(__std_fs_copy_options _Left) noexcept { using _IntTy = ::std:: underlying_type_t<__std_fs_copy_options>; return static_cast<__std_fs_copy_options>(~static_cast<_IntTy>(_Left)); }

extern "C" {
[[nodiscard]] __std_ulong_and_error __stdcall __std_fs_get_full_path_name(  const wchar_t* _Source,
      unsigned long _Target_size,   wchar_t* _Target) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_open_handle(  __std_fs_file_handle* _Handle,
      const wchar_t* _File_name,   __std_access_rights _Desired_access,
      __std_fs_file_flags _Flags) noexcept;

void __stdcall __std_fs_close_handle(__std_fs_file_handle _Handle) noexcept;

[[nodiscard]]   __std_win_error
    __stdcall __std_fs_get_file_attributes_by_handle(
          __std_fs_file_handle _Handle,   unsigned long* _File_attributes) noexcept;

[[nodiscard]] __std_ulong_and_error __stdcall __std_fs_get_final_path_name_by_handle(  __std_fs_file_handle _Handle,
      wchar_t* _Target,   unsigned long _Target_size,
      __std_fs_volume_name_kind _Flags) noexcept;

struct __std_fs_copy_file_result {
    bool _Copied;
    __std_win_error _Error;
};

[[nodiscard]] __std_fs_copy_file_result __stdcall __std_fs_copy_file(
      const wchar_t* _Source,   const wchar_t* _Target,   __std_fs_copy_options _Options) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_directory_iterator_open(  const wchar_t* _Path_spec,
      __std_fs_dir_handle* _Handle,   __std_fs_find_data* _Results) noexcept;

void __stdcall __std_fs_directory_iterator_close(  __std_fs_dir_handle _Handle) noexcept;

[[nodiscard]]   __std_win_error
    __stdcall __std_fs_get_stats(  const wchar_t* _Path, __std_fs_stats* _Stats,   __std_fs_stats_flags _Flags,
          __std_fs_file_attr _Symlink_attribute_hint = __std_fs_file_attr::_Invalid) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_directory_iterator_advance(
      __std_fs_dir_handle _Handle,   __std_fs_find_data* _Results) noexcept;

[[nodiscard]] __std_code_page __stdcall __std_fs_code_page() noexcept;

[[nodiscard]] __std_fs_convert_result __stdcall __std_fs_convert_narrow_to_wide(  __std_code_page _Code_page,
      const char* _Input_str,   int _Input_len,
      wchar_t* _Output_str,   int _Output_len) noexcept;

[[nodiscard]] __std_fs_convert_result __stdcall __std_fs_convert_wide_to_narrow(  __std_code_page _Code_page,
      const wchar_t* _Input_str,   int _Input_len,
      char* _Output_str,   int _Output_len) noexcept;

[[nodiscard]] __std_fs_convert_result __stdcall __std_fs_convert_wide_to_narrow_replace_chars(
      __std_code_page _Code_page,   const wchar_t* _Input_str,   int _Input_len,
      char* _Output_str,   int _Output_len) noexcept;

[[nodiscard]]   __std_win_error
    __stdcall __std_fs_get_file_id(  __std_fs_file_id* _Id,   const wchar_t* _Path) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_set_last_write_time(
      long long _Last_write_filetime,   const wchar_t* _Path) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_change_permissions(
      const wchar_t* _Path,   bool _Follow_symlinks,   bool _Readonly) noexcept;

[[nodiscard]]   __std_ulong_and_error
    __stdcall __std_fs_get_temp_path(  wchar_t* _Target) noexcept;

[[nodiscard]]   __std_ulong_and_error
    __stdcall __std_fs_get_current_path(
          unsigned long _Target_size,   wchar_t* _Target) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_set_current_path(  const wchar_t* _Target) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_create_directory_symbolic_link(
      const wchar_t* _Symlink_file_name,   const wchar_t* _Target_file_name) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_create_hard_link(
      const wchar_t* _File_name,   const wchar_t* _Existing_file_name) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_create_symbolic_link(
      const wchar_t* _Symlink_file_name,   const wchar_t* _Target_file_name) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_read_reparse_data_buffer(  __std_fs_file_handle _Handle,
      void* _Buffer,   unsigned long _Buffer_size) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_write_reparse_data_buffer(
      __std_fs_file_handle _Handle,   const __std_fs_reparse_data_buffer* _Buffer) noexcept;

[[nodiscard]] bool __stdcall __std_fs_is_junction_from_reparse_data_buffer(
      const __std_fs_reparse_data_buffer* _Buffer) noexcept;

[[nodiscard]]   __std_win_error
    __stdcall __std_fs_read_name_from_reparse_data_buffer(
          __std_fs_reparse_data_buffer* _Handle,   wchar_t** _Offset,   unsigned short* _Length) noexcept;

struct __std_fs_create_directory_result {
    bool _Created;
    __std_win_error _Error;
};

[[nodiscard]] __std_fs_create_directory_result __stdcall __std_fs_create_directory(
      const wchar_t* _New_directory) noexcept;

struct __std_fs_remove_result {
    bool _Removed;
    __std_win_error _Error;
};

[[nodiscard]] __std_fs_remove_result __stdcall __std_fs_remove(  const wchar_t* _Target) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_rename(
      const wchar_t* _Source,   const wchar_t* _Target) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_resize_file(  const wchar_t* _Target, uintmax_t _New_size) noexcept;

[[nodiscard]] __std_win_error __stdcall __std_fs_space(  const wchar_t* _Target,   uintmax_t* _Available,
      uintmax_t* _Total_bytes,   uintmax_t* _Free_bytes) noexcept;
}

namespace std {
struct _Fs_file {
    __std_fs_file_handle _Raw;

    explicit _Fs_file(void* const _Handle) : _Raw{reinterpret_cast<intptr_t>(_Handle)} {}

    _Fs_file(const wchar_t* const _File_name, const __std_access_rights _Desired_access,
        const __std_fs_file_flags _Flags, __std_win_error* const _Err) {
        *_Err = __std_fs_open_handle(&_Raw, _File_name, _Desired_access, _Flags);
    }

    _Fs_file(const _Fs_file&)            = delete;
    _Fs_file& operator=(const _Fs_file&) = delete;

    ~_Fs_file() {
        __std_fs_close_handle(_Raw);
    }

    [[nodiscard]] void* _Get() const {
        return reinterpret_cast<void*>(_Raw);
    }
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfilesystem_abi.h"
#line 389 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xfilesystem_abi.h"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" {

enum class __std_unicode_console_handle : intptr_t { _Invalid = -1 };

struct __std_unicode_console_retrieval_result {
    __std_unicode_console_handle _Console_handle;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    __std_win_error _Error;
};

[[nodiscard]]   __std_unicode_console_retrieval_result
    __stdcall __std_get_unicode_console_handle_from_file_stream(  FILE* _Stream) noexcept;

[[nodiscard]]   __std_win_error
    __stdcall __std_print_to_unicode_console(  __std_unicode_console_handle _Console_handle,
          const char* _Str,   size_t _Str_size) noexcept;

}

namespace std {

[[nodiscard]] consteval bool _Is_ordinary_literal_encoding_utf8() {
    


#line 63 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"
    return false;
#line 65 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_print.hpp"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"












































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_format_ucd_tables.hpp"
































































#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

template <class _ValueEnum, size_t _NumRanges, bool _Is_binary_property>
struct _Unicode_property_data {
    uint32_t _Lower_bounds[_NumRanges];
    uint16_t _Props_and_size[_NumRanges];
    [[nodiscard]] constexpr _ValueEnum _Get_property_for_codepoint(const uint32_t _Code_point) const noexcept {
        ptrdiff_t _Upper_idx = ::std:: upper_bound(_Lower_bounds, ::std:: end(_Lower_bounds), _Code_point) - _Lower_bounds;
        constexpr auto _No_value_constant = static_cast<_ValueEnum>(0xffui8);
        if (_Upper_idx == 0) {
            return _No_value_constant;
        }
        --_Upper_idx;
        const uint32_t _Lower_bound = _Lower_bounds[_Upper_idx];
        const uint16_t _Data        = _Props_and_size[_Upper_idx];
        ;
        if constexpr (_Is_binary_property) {
            if (_Code_point < _Lower_bound + _Data) {
                return static_cast<_ValueEnum>(0);
            }
        } else {
            const uint16_t _Size   = static_cast<uint16_t>(_Data & 0x0FFF);
            const _ValueEnum _Prop = static_cast<_ValueEnum>((_Data & 0xF000) >> 12);
            if (_Code_point < _Lower_bound + _Size) {
                return _Prop;
            }
        }
        return _No_value_constant;
    }
};


































enum class _Grapheme_Break_property_values : uint8_t {
    _CR_value,
    _Control_value,
    _Extend_value,
    _L_value,
    _LF_value,
    _LV_value,
    _LVT_value,
    _Prepend_value,
    _Regional_Indicator_value,
    _SpacingMark_value,
    _T_value,
    _V_value,
    _ZWJ_value,
    _No_value = 255
};



inline constexpr _Unicode_property_data<_Grapheme_Break_property_values, 1371, false> _Grapheme_Break_property_data{
    {0x0, 0xa, 0xb, 0xd, 0xe, 0x7f, 0xad, 0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x600, 0x610, 0x61c, 0x64b,
        0x670, 0x6d6, 0x6dd, 0x6df, 0x6e7, 0x6ea, 0x70f, 0x711, 0x730, 0x7a6, 0x7eb, 0x7fd, 0x816, 0x81b, 0x825, 0x829,
        0x859, 0x890, 0x898, 0x8ca, 0x8e2, 0x8e3, 0x903, 0x93a, 0x93b, 0x93c, 0x93e, 0x941, 0x949, 0x94d, 0x94e, 0x951,
        0x962, 0x981, 0x982, 0x9bc, 0x9be, 0x9bf, 0x9c1, 0x9c7, 0x9cb, 0x9cd, 0x9d7, 0x9e2, 0x9fe, 0xa01, 0xa03, 0xa3c,
        0xa3e, 0xa41, 0xa47, 0xa4b, 0xa51, 0xa70, 0xa75, 0xa81, 0xa83, 0xabc, 0xabe, 0xac1, 0xac7, 0xac9, 0xacb, 0xacd,
        0xae2, 0xafa, 0xb01, 0xb02, 0xb3c, 0xb3e, 0xb40, 0xb41, 0xb47, 0xb4b, 0xb4d, 0xb55, 0xb62, 0xb82, 0xbbe, 0xbbf,
        0xbc0, 0xbc1, 0xbc6, 0xbca, 0xbcd, 0xbd7, 0xc00, 0xc01, 0xc04, 0xc3c, 0xc3e, 0xc41, 0xc46, 0xc4a, 0xc55, 0xc62,
        0xc81, 0xc82, 0xcbc, 0xcbe, 0xcbf, 0xcc0, 0xcc2, 0xcc3, 0xcc6, 0xcc7, 0xcca, 0xccc, 0xcd5, 0xce2, 0xcf3, 0xd00,
        0xd02, 0xd3b, 0xd3e, 0xd3f, 0xd41, 0xd46, 0xd4a, 0xd4d, 0xd4e, 0xd57, 0xd62, 0xd81, 0xd82, 0xdca, 0xdcf, 0xdd0,
        0xdd2, 0xdd6, 0xdd8, 0xddf, 0xdf2, 0xe31, 0xe33, 0xe34, 0xe47, 0xeb1, 0xeb3, 0xeb4, 0xec8, 0xf18, 0xf35, 0xf37,
        0xf39, 0xf3e, 0xf71, 0xf7f, 0xf80, 0xf86, 0xf8d, 0xf99, 0xfc6, 0x102d, 0x1031, 0x1032, 0x1039, 0x103b, 0x103d,
        0x1056, 0x1058, 0x105e, 0x1071, 0x1082, 0x1084, 0x1085, 0x108d, 0x109d, 0x1100, 0x1160, 0x11a8, 0x135d, 0x1712,
        0x1715, 0x1732, 0x1734, 0x1752, 0x1772, 0x17b4, 0x17b6, 0x17b7, 0x17be, 0x17c6, 0x17c7, 0x17c9, 0x17dd, 0x180b,
        0x180e, 0x180f, 0x1885, 0x18a9, 0x1920, 0x1923, 0x1927, 0x1929, 0x1930, 0x1932, 0x1933, 0x1939, 0x1a17, 0x1a19,
        0x1a1b, 0x1a55, 0x1a56, 0x1a57, 0x1a58, 0x1a60, 0x1a62, 0x1a65, 0x1a6d, 0x1a73, 0x1a7f, 0x1ab0, 0x1b00, 0x1b04,
        0x1b34, 0x1b3b, 0x1b3c, 0x1b3d, 0x1b42, 0x1b43, 0x1b6b, 0x1b80, 0x1b82, 0x1ba1, 0x1ba2, 0x1ba6, 0x1ba8, 0x1baa,
        0x1bab, 0x1be6, 0x1be7, 0x1be8, 0x1bea, 0x1bed, 0x1bee, 0x1bef, 0x1bf2, 0x1c24, 0x1c2c, 0x1c34, 0x1c36, 0x1cd0,
        0x1cd4, 0x1ce1, 0x1ce2, 0x1ced, 0x1cf4, 0x1cf7, 0x1cf8, 0x1dc0, 0x200b, 0x200c, 0x200d, 0x200e, 0x2028, 0x2060,
        0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f, 0xa674, 0xa69e, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa823,
        0xa825, 0xa827, 0xa82c, 0xa880, 0xa8b4, 0xa8c4, 0xa8e0, 0xa8ff, 0xa926, 0xa947, 0xa952, 0xa960, 0xa980, 0xa983,
        0xa9b3, 0xa9b4, 0xa9b6, 0xa9ba, 0xa9bc, 0xa9be, 0xa9e5, 0xaa29, 0xaa2f, 0xaa31, 0xaa33, 0xaa35, 0xaa43, 0xaa4c,
        0xaa4d, 0xaa7c, 0xaab0, 0xaab2, 0xaab7, 0xaabe, 0xaac1, 0xaaeb, 0xaaec, 0xaaee, 0xaaf5, 0xaaf6, 0xabe3, 0xabe5,
        0xabe6, 0xabe8, 0xabe9, 0xabec, 0xabed, 0xac00, 0xac01, 0xac1c, 0xac1d, 0xac38, 0xac39, 0xac54, 0xac55, 0xac70,
        0xac71, 0xac8c, 0xac8d, 0xaca8, 0xaca9, 0xacc4, 0xacc5, 0xace0, 0xace1, 0xacfc, 0xacfd, 0xad18, 0xad19, 0xad34,
        0xad35, 0xad50, 0xad51, 0xad6c, 0xad6d, 0xad88, 0xad89, 0xada4, 0xada5, 0xadc0, 0xadc1, 0xaddc, 0xaddd, 0xadf8,
        0xadf9, 0xae14, 0xae15, 0xae30, 0xae31, 0xae4c, 0xae4d, 0xae68, 0xae69, 0xae84, 0xae85, 0xaea0, 0xaea1, 0xaebc,
        0xaebd, 0xaed8, 0xaed9, 0xaef4, 0xaef5, 0xaf10, 0xaf11, 0xaf2c, 0xaf2d, 0xaf48, 0xaf49, 0xaf64, 0xaf65, 0xaf80,
        0xaf81, 0xaf9c, 0xaf9d, 0xafb8, 0xafb9, 0xafd4, 0xafd5, 0xaff0, 0xaff1, 0xb00c, 0xb00d, 0xb028, 0xb029, 0xb044,
        0xb045, 0xb060, 0xb061, 0xb07c, 0xb07d, 0xb098, 0xb099, 0xb0b4, 0xb0b5, 0xb0d0, 0xb0d1, 0xb0ec, 0xb0ed, 0xb108,
        0xb109, 0xb124, 0xb125, 0xb140, 0xb141, 0xb15c, 0xb15d, 0xb178, 0xb179, 0xb194, 0xb195, 0xb1b0, 0xb1b1, 0xb1cc,
        0xb1cd, 0xb1e8, 0xb1e9, 0xb204, 0xb205, 0xb220, 0xb221, 0xb23c, 0xb23d, 0xb258, 0xb259, 0xb274, 0xb275, 0xb290,
        0xb291, 0xb2ac, 0xb2ad, 0xb2c8, 0xb2c9, 0xb2e4, 0xb2e5, 0xb300, 0xb301, 0xb31c, 0xb31d, 0xb338, 0xb339, 0xb354,
        0xb355, 0xb370, 0xb371, 0xb38c, 0xb38d, 0xb3a8, 0xb3a9, 0xb3c4, 0xb3c5, 0xb3e0, 0xb3e1, 0xb3fc, 0xb3fd, 0xb418,
        0xb419, 0xb434, 0xb435, 0xb450, 0xb451, 0xb46c, 0xb46d, 0xb488, 0xb489, 0xb4a4, 0xb4a5, 0xb4c0, 0xb4c1, 0xb4dc,
        0xb4dd, 0xb4f8, 0xb4f9, 0xb514, 0xb515, 0xb530, 0xb531, 0xb54c, 0xb54d, 0xb568, 0xb569, 0xb584, 0xb585, 0xb5a0,
        0xb5a1, 0xb5bc, 0xb5bd, 0xb5d8, 0xb5d9, 0xb5f4, 0xb5f5, 0xb610, 0xb611, 0xb62c, 0xb62d, 0xb648, 0xb649, 0xb664,
        0xb665, 0xb680, 0xb681, 0xb69c, 0xb69d, 0xb6b8, 0xb6b9, 0xb6d4, 0xb6d5, 0xb6f0, 0xb6f1, 0xb70c, 0xb70d, 0xb728,
        0xb729, 0xb744, 0xb745, 0xb760, 0xb761, 0xb77c, 0xb77d, 0xb798, 0xb799, 0xb7b4, 0xb7b5, 0xb7d0, 0xb7d1, 0xb7ec,
        0xb7ed, 0xb808, 0xb809, 0xb824, 0xb825, 0xb840, 0xb841, 0xb85c, 0xb85d, 0xb878, 0xb879, 0xb894, 0xb895, 0xb8b0,
        0xb8b1, 0xb8cc, 0xb8cd, 0xb8e8, 0xb8e9, 0xb904, 0xb905, 0xb920, 0xb921, 0xb93c, 0xb93d, 0xb958, 0xb959, 0xb974,
        0xb975, 0xb990, 0xb991, 0xb9ac, 0xb9ad, 0xb9c8, 0xb9c9, 0xb9e4, 0xb9e5, 0xba00, 0xba01, 0xba1c, 0xba1d, 0xba38,
        0xba39, 0xba54, 0xba55, 0xba70, 0xba71, 0xba8c, 0xba8d, 0xbaa8, 0xbaa9, 0xbac4, 0xbac5, 0xbae0, 0xbae1, 0xbafc,
        0xbafd, 0xbb18, 0xbb19, 0xbb34, 0xbb35, 0xbb50, 0xbb51, 0xbb6c, 0xbb6d, 0xbb88, 0xbb89, 0xbba4, 0xbba5, 0xbbc0,
        0xbbc1, 0xbbdc, 0xbbdd, 0xbbf8, 0xbbf9, 0xbc14, 0xbc15, 0xbc30, 0xbc31, 0xbc4c, 0xbc4d, 0xbc68, 0xbc69, 0xbc84,
        0xbc85, 0xbca0, 0xbca1, 0xbcbc, 0xbcbd, 0xbcd8, 0xbcd9, 0xbcf4, 0xbcf5, 0xbd10, 0xbd11, 0xbd2c, 0xbd2d, 0xbd48,
        0xbd49, 0xbd64, 0xbd65, 0xbd80, 0xbd81, 0xbd9c, 0xbd9d, 0xbdb8, 0xbdb9, 0xbdd4, 0xbdd5, 0xbdf0, 0xbdf1, 0xbe0c,
        0xbe0d, 0xbe28, 0xbe29, 0xbe44, 0xbe45, 0xbe60, 0xbe61, 0xbe7c, 0xbe7d, 0xbe98, 0xbe99, 0xbeb4, 0xbeb5, 0xbed0,
        0xbed1, 0xbeec, 0xbeed, 0xbf08, 0xbf09, 0xbf24, 0xbf25, 0xbf40, 0xbf41, 0xbf5c, 0xbf5d, 0xbf78, 0xbf79, 0xbf94,
        0xbf95, 0xbfb0, 0xbfb1, 0xbfcc, 0xbfcd, 0xbfe8, 0xbfe9, 0xc004, 0xc005, 0xc020, 0xc021, 0xc03c, 0xc03d, 0xc058,
        0xc059, 0xc074, 0xc075, 0xc090, 0xc091, 0xc0ac, 0xc0ad, 0xc0c8, 0xc0c9, 0xc0e4, 0xc0e5, 0xc100, 0xc101, 0xc11c,
        0xc11d, 0xc138, 0xc139, 0xc154, 0xc155, 0xc170, 0xc171, 0xc18c, 0xc18d, 0xc1a8, 0xc1a9, 0xc1c4, 0xc1c5, 0xc1e0,
        0xc1e1, 0xc1fc, 0xc1fd, 0xc218, 0xc219, 0xc234, 0xc235, 0xc250, 0xc251, 0xc26c, 0xc26d, 0xc288, 0xc289, 0xc2a4,
        0xc2a5, 0xc2c0, 0xc2c1, 0xc2dc, 0xc2dd, 0xc2f8, 0xc2f9, 0xc314, 0xc315, 0xc330, 0xc331, 0xc34c, 0xc34d, 0xc368,
        0xc369, 0xc384, 0xc385, 0xc3a0, 0xc3a1, 0xc3bc, 0xc3bd, 0xc3d8, 0xc3d9, 0xc3f4, 0xc3f5, 0xc410, 0xc411, 0xc42c,
        0xc42d, 0xc448, 0xc449, 0xc464, 0xc465, 0xc480, 0xc481, 0xc49c, 0xc49d, 0xc4b8, 0xc4b9, 0xc4d4, 0xc4d5, 0xc4f0,
        0xc4f1, 0xc50c, 0xc50d, 0xc528, 0xc529, 0xc544, 0xc545, 0xc560, 0xc561, 0xc57c, 0xc57d, 0xc598, 0xc599, 0xc5b4,
        0xc5b5, 0xc5d0, 0xc5d1, 0xc5ec, 0xc5ed, 0xc608, 0xc609, 0xc624, 0xc625, 0xc640, 0xc641, 0xc65c, 0xc65d, 0xc678,
        0xc679, 0xc694, 0xc695, 0xc6b0, 0xc6b1, 0xc6cc, 0xc6cd, 0xc6e8, 0xc6e9, 0xc704, 0xc705, 0xc720, 0xc721, 0xc73c,
        0xc73d, 0xc758, 0xc759, 0xc774, 0xc775, 0xc790, 0xc791, 0xc7ac, 0xc7ad, 0xc7c8, 0xc7c9, 0xc7e4, 0xc7e5, 0xc800,
        0xc801, 0xc81c, 0xc81d, 0xc838, 0xc839, 0xc854, 0xc855, 0xc870, 0xc871, 0xc88c, 0xc88d, 0xc8a8, 0xc8a9, 0xc8c4,
        0xc8c5, 0xc8e0, 0xc8e1, 0xc8fc, 0xc8fd, 0xc918, 0xc919, 0xc934, 0xc935, 0xc950, 0xc951, 0xc96c, 0xc96d, 0xc988,
        0xc989, 0xc9a4, 0xc9a5, 0xc9c0, 0xc9c1, 0xc9dc, 0xc9dd, 0xc9f8, 0xc9f9, 0xca14, 0xca15, 0xca30, 0xca31, 0xca4c,
        0xca4d, 0xca68, 0xca69, 0xca84, 0xca85, 0xcaa0, 0xcaa1, 0xcabc, 0xcabd, 0xcad8, 0xcad9, 0xcaf4, 0xcaf5, 0xcb10,
        0xcb11, 0xcb2c, 0xcb2d, 0xcb48, 0xcb49, 0xcb64, 0xcb65, 0xcb80, 0xcb81, 0xcb9c, 0xcb9d, 0xcbb8, 0xcbb9, 0xcbd4,
        0xcbd5, 0xcbf0, 0xcbf1, 0xcc0c, 0xcc0d, 0xcc28, 0xcc29, 0xcc44, 0xcc45, 0xcc60, 0xcc61, 0xcc7c, 0xcc7d, 0xcc98,
        0xcc99, 0xccb4, 0xccb5, 0xccd0, 0xccd1, 0xccec, 0xcced, 0xcd08, 0xcd09, 0xcd24, 0xcd25, 0xcd40, 0xcd41, 0xcd5c,
        0xcd5d, 0xcd78, 0xcd79, 0xcd94, 0xcd95, 0xcdb0, 0xcdb1, 0xcdcc, 0xcdcd, 0xcde8, 0xcde9, 0xce04, 0xce05, 0xce20,
        0xce21, 0xce3c, 0xce3d, 0xce58, 0xce59, 0xce74, 0xce75, 0xce90, 0xce91, 0xceac, 0xcead, 0xcec8, 0xcec9, 0xcee4,
        0xcee5, 0xcf00, 0xcf01, 0xcf1c, 0xcf1d, 0xcf38, 0xcf39, 0xcf54, 0xcf55, 0xcf70, 0xcf71, 0xcf8c, 0xcf8d, 0xcfa8,
        0xcfa9, 0xcfc4, 0xcfc5, 0xcfe0, 0xcfe1, 0xcffc, 0xcffd, 0xd018, 0xd019, 0xd034, 0xd035, 0xd050, 0xd051, 0xd06c,
        0xd06d, 0xd088, 0xd089, 0xd0a4, 0xd0a5, 0xd0c0, 0xd0c1, 0xd0dc, 0xd0dd, 0xd0f8, 0xd0f9, 0xd114, 0xd115, 0xd130,
        0xd131, 0xd14c, 0xd14d, 0xd168, 0xd169, 0xd184, 0xd185, 0xd1a0, 0xd1a1, 0xd1bc, 0xd1bd, 0xd1d8, 0xd1d9, 0xd1f4,
        0xd1f5, 0xd210, 0xd211, 0xd22c, 0xd22d, 0xd248, 0xd249, 0xd264, 0xd265, 0xd280, 0xd281, 0xd29c, 0xd29d, 0xd2b8,
        0xd2b9, 0xd2d4, 0xd2d5, 0xd2f0, 0xd2f1, 0xd30c, 0xd30d, 0xd328, 0xd329, 0xd344, 0xd345, 0xd360, 0xd361, 0xd37c,
        0xd37d, 0xd398, 0xd399, 0xd3b4, 0xd3b5, 0xd3d0, 0xd3d1, 0xd3ec, 0xd3ed, 0xd408, 0xd409, 0xd424, 0xd425, 0xd440,
        0xd441, 0xd45c, 0xd45d, 0xd478, 0xd479, 0xd494, 0xd495, 0xd4b0, 0xd4b1, 0xd4cc, 0xd4cd, 0xd4e8, 0xd4e9, 0xd504,
        0xd505, 0xd520, 0xd521, 0xd53c, 0xd53d, 0xd558, 0xd559, 0xd574, 0xd575, 0xd590, 0xd591, 0xd5ac, 0xd5ad, 0xd5c8,
        0xd5c9, 0xd5e4, 0xd5e5, 0xd600, 0xd601, 0xd61c, 0xd61d, 0xd638, 0xd639, 0xd654, 0xd655, 0xd670, 0xd671, 0xd68c,
        0xd68d, 0xd6a8, 0xd6a9, 0xd6c4, 0xd6c5, 0xd6e0, 0xd6e1, 0xd6fc, 0xd6fd, 0xd718, 0xd719, 0xd734, 0xd735, 0xd750,
        0xd751, 0xd76c, 0xd76d, 0xd788, 0xd789, 0xd7b0, 0xd7cb, 0xfb1e, 0xfe00, 0xfe20, 0xfeff, 0xff9e, 0xfff0, 0x101fd,
        0x102e0, 0x10376, 0x10a01, 0x10a05, 0x10a0c, 0x10a38, 0x10a3f, 0x10ae5, 0x10d24, 0x10eab, 0x10efd, 0x10f46,
        0x10f82, 0x11000, 0x11001, 0x11002, 0x11038, 0x11070, 0x11073, 0x1107f, 0x11082, 0x110b0, 0x110b3, 0x110b7,
        0x110b9, 0x110bd, 0x110c2, 0x110cd, 0x11100, 0x11127, 0x1112c, 0x1112d, 0x11145, 0x11173, 0x11180, 0x11182,
        0x111b3, 0x111b6, 0x111bf, 0x111c2, 0x111c9, 0x111ce, 0x111cf, 0x1122c, 0x1122f, 0x11232, 0x11234, 0x11235,
        0x11236, 0x1123e, 0x11241, 0x112df, 0x112e0, 0x112e3, 0x11300, 0x11302, 0x1133b, 0x1133e, 0x1133f, 0x11340,
        0x11341, 0x11347, 0x1134b, 0x11357, 0x11362, 0x11366, 0x11370, 0x11435, 0x11438, 0x11440, 0x11442, 0x11445,
        0x11446, 0x1145e, 0x114b0, 0x114b1, 0x114b3, 0x114b9, 0x114ba, 0x114bb, 0x114bd, 0x114be, 0x114bf, 0x114c1,
        0x114c2, 0x115af, 0x115b0, 0x115b2, 0x115b8, 0x115bc, 0x115be, 0x115bf, 0x115dc, 0x11630, 0x11633, 0x1163b,
        0x1163d, 0x1163e, 0x1163f, 0x116ab, 0x116ac, 0x116ad, 0x116ae, 0x116b0, 0x116b6, 0x116b7, 0x1171d, 0x11722,
        0x11726, 0x11727, 0x1182c, 0x1182f, 0x11838, 0x11839, 0x11930, 0x11931, 0x11937, 0x1193b, 0x1193d, 0x1193e,
        0x1193f, 0x11940, 0x11941, 0x11942, 0x11943, 0x119d1, 0x119d4, 0x119da, 0x119dc, 0x119e0, 0x119e4, 0x11a01,
        0x11a33, 0x11a39, 0x11a3a, 0x11a3b, 0x11a47, 0x11a51, 0x11a57, 0x11a59, 0x11a84, 0x11a8a, 0x11a97, 0x11a98,
        0x11c2f, 0x11c30, 0x11c38, 0x11c3e, 0x11c3f, 0x11c92, 0x11ca9, 0x11caa, 0x11cb1, 0x11cb2, 0x11cb4, 0x11cb5,
        0x11d31, 0x11d3a, 0x11d3c, 0x11d3f, 0x11d46, 0x11d47, 0x11d8a, 0x11d90, 0x11d93, 0x11d95, 0x11d96, 0x11d97,
        0x11ef3, 0x11ef5, 0x11f00, 0x11f02, 0x11f03, 0x11f34, 0x11f36, 0x11f3e, 0x11f40, 0x11f41, 0x11f42, 0x13430,
        0x13440, 0x13447, 0x16af0, 0x16b30, 0x16f4f, 0x16f51, 0x16f8f, 0x16fe4, 0x16ff0, 0x1bc9d, 0x1bca0, 0x1cf00,
        0x1cf30, 0x1d165, 0x1d166, 0x1d167, 0x1d16d, 0x1d16e, 0x1d173, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242, 0x1da00,
        0x1da3b, 0x1da75, 0x1da84, 0x1da9b, 0x1daa1, 0x1e000, 0x1e008, 0x1e01b, 0x1e023, 0x1e026, 0x1e08f, 0x1e130,
        0x1e2ae, 0x1e2ec, 0x1e4ec, 0x1e8d0, 0x1e944, 0x1f1e6, 0x1f3fb, 0xe0000, 0xe0020, 0xe0080, 0xe0100, 0xe01f0},
    {0x100a, 0x4001, 0x1002, 0x1, 0x1012, 0x1021, 0x1001, 0x2070, 0x2007, 0x202d, 0x2001, 0x2002, 0x2002, 0x2001,
        0x7006, 0x200b, 0x1001, 0x2015, 0x2001, 0x2007, 0x7001, 0x2006, 0x2002, 0x2004, 0x7001, 0x2001, 0x201b, 0x200b,
        0x2009, 0x2001, 0x2004, 0x2009, 0x2003, 0x2005, 0x2003, 0x7002, 0x2008, 0x2018, 0x7001, 0x2020, 0x9001, 0x2001,
        0x9001, 0x2001, 0x9003, 0x2008, 0x9004, 0x2001, 0x9002, 0x2007, 0x2002, 0x2001, 0x9002, 0x2001, 0x2001, 0x9002,
        0x2004, 0x9002, 0x9002, 0x2001, 0x2001, 0x2002, 0x2001, 0x2002, 0x9001, 0x2001, 0x9003, 0x2002, 0x2002, 0x2003,
        0x2001, 0x2002, 0x2001, 0x2002, 0x9001, 0x2001, 0x9003, 0x2005, 0x2002, 0x9001, 0x9002, 0x2001, 0x2002, 0x2006,
        0x2001, 0x9002, 0x2001, 0x2002, 0x9001, 0x2004, 0x9002, 0x9002, 0x2001, 0x2003, 0x2002, 0x2001, 0x2001, 0x9001,
        0x2001, 0x9002, 0x9003, 0x9003, 0x2001, 0x2001, 0x2001, 0x9003, 0x2001, 0x2001, 0x2003, 0x9004, 0x2003, 0x2004,
        0x2002, 0x2002, 0x2001, 0x9002, 0x2001, 0x9001, 0x2001, 0x9002, 0x2001, 0x9002, 0x2001, 0x9002, 0x9002, 0x2002,
        0x2002, 0x2002, 0x9001, 0x2002, 0x9002, 0x2002, 0x2001, 0x9002, 0x2004, 0x9003, 0x9003, 0x2001, 0x7001, 0x2001,
        0x2002, 0x2001, 0x9002, 0x2001, 0x2001, 0x9002, 0x2003, 0x2001, 0x9007, 0x2001, 0x9002, 0x2001, 0x9001, 0x2007,
        0x2008, 0x2001, 0x9001, 0x2009, 0x2007, 0x2002, 0x2001, 0x2001, 0x2001, 0x9002, 0x200e, 0x9001, 0x2005, 0x2002,
        0x200b, 0x2024, 0x2001, 0x2004, 0x9001, 0x2006, 0x2002, 0x9002, 0x2002, 0x9002, 0x2002, 0x2003, 0x2004, 0x2001,
        0x9001, 0x2002, 0x2001, 0x2001, 0x3060, 0xb048, 0xa058, 0x2003, 0x2003, 0x9001, 0x2002, 0x9001, 0x2002, 0x2002,
        0x2002, 0x9001, 0x2007, 0x9008, 0x2001, 0x9002, 0x200b, 0x2001, 0x2003, 0x1001, 0x2001, 0x2002, 0x2001, 0x2003,
        0x9004, 0x2002, 0x9003, 0x9002, 0x2001, 0x9006, 0x2003, 0x2002, 0x9002, 0x2001, 0x9001, 0x2001, 0x9001, 0x2007,
        0x2001, 0x2001, 0x2008, 0x9006, 0x200a, 0x2001, 0x201f, 0x2004, 0x9001, 0x2007, 0x9001, 0x2001, 0x9005, 0x2001,
        0x9002, 0x2009, 0x2002, 0x9001, 0x9001, 0x2004, 0x9002, 0x2002, 0x9001, 0x2003, 0x2001, 0x9001, 0x2002, 0x9003,
        0x2001, 0x9001, 0x2003, 0x9002, 0x9008, 0x2008, 0x9002, 0x2002, 0x2003, 0x200d, 0x9001, 0x2007, 0x2001, 0x2001,
        0x9001, 0x2002, 0x2040, 0x1001, 0x2001, 0xc001, 0x1002, 0x1007, 0x1010, 0x2021, 0x2003, 0x2001, 0x2020, 0x2006,
        0x2002, 0x2004, 0x200a, 0x2002, 0x2002, 0x2001, 0x2001, 0x2001, 0x9002, 0x2002, 0x9001, 0x2001, 0x9002, 0x9010,
        0x2002, 0x2012, 0x2001, 0x2008, 0x200b, 0x9002, 0x301d, 0x2003, 0x9001, 0x2001, 0x9002, 0x2004, 0x9002, 0x2002,
        0x9003, 0x2001, 0x2006, 0x9002, 0x2002, 0x9002, 0x2002, 0x2001, 0x2001, 0x9001, 0x2001, 0x2001, 0x2003, 0x2002,
        0x2002, 0x2001, 0x9001, 0x2002, 0x9002, 0x9001, 0x2001, 0x9002, 0x2001, 0x9002, 0x2001, 0x9002, 0x9001, 0x2001,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b, 0x5001, 0x601b,
        0xb017, 0xa031, 0x2001, 0x2010, 0x2010, 0x1001, 0x2002, 0x100c, 0x2001, 0x2001, 0x2005, 0x2003, 0x2002, 0x2004,
        0x2003, 0x2001, 0x2002, 0x2004, 0x2002, 0x2003, 0x200b, 0x2004, 0x9001, 0x2001, 0x9001, 0x200f, 0x2001, 0x2002,
        0x2003, 0x9001, 0x9003, 0x2004, 0x9002, 0x2002, 0x7001, 0x2001, 0x7001, 0x2003, 0x2005, 0x9001, 0x2008, 0x9002,
        0x2001, 0x2002, 0x9001, 0x9003, 0x2009, 0x9002, 0x7002, 0x2004, 0x9001, 0x2001, 0x9003, 0x2003, 0x9002, 0x2001,
        0x9001, 0x2002, 0x2001, 0x2001, 0x2001, 0x9003, 0x2008, 0x2002, 0x9002, 0x2002, 0x2001, 0x9001, 0x2001, 0x9004,
        0x9002, 0x9003, 0x2001, 0x9002, 0x2007, 0x2005, 0x9003, 0x2008, 0x9002, 0x2003, 0x9001, 0x2001, 0x2001, 0x2001,
        0x9002, 0x2006, 0x9001, 0x2001, 0x9002, 0x2001, 0x9001, 0x2002, 0x9001, 0x2002, 0x2001, 0x9002, 0x2004, 0x9004,
        0x2002, 0x9001, 0x2002, 0x2002, 0x9003, 0x2008, 0x9002, 0x2001, 0x9001, 0x2002, 0x2001, 0x9001, 0x2001, 0x9002,
        0x2006, 0x9001, 0x2001, 0x2003, 0x2004, 0x9001, 0x2005, 0x9003, 0x2009, 0x9001, 0x2002, 0x2001, 0x9005, 0x9002,
        0x2002, 0x9001, 0x2001, 0x7001, 0x9001, 0x7001, 0x9001, 0x2001, 0x9003, 0x2004, 0x2002, 0x9004, 0x2001, 0x9001,
        0x200a, 0x2006, 0x9001, 0x7001, 0x2004, 0x2001, 0x2006, 0x9002, 0x2003, 0x7006, 0x200d, 0x9001, 0x2002, 0x9001,
        0x2007, 0x2006, 0x9001, 0x2001, 0x2016, 0x9001, 0x2007, 0x9001, 0x2002, 0x9001, 0x2002, 0x2006, 0x2001, 0x2002,
        0x2007, 0x7001, 0x2001, 0x9005, 0x2002, 0x9002, 0x2001, 0x9001, 0x2001, 0x2002, 0x9002, 0x2002, 0x7001, 0x9001,
        0x9002, 0x2005, 0x9002, 0x2001, 0x9001, 0x2001, 0x1010, 0x2001, 0x200f, 0x2005, 0x2007, 0x2001, 0x9037, 0x2004,
        0x2001, 0x9002, 0x2002, 0x1004, 0x202e, 0x2017, 0x2001, 0x9001, 0x2003, 0x9001, 0x2005, 0x1008, 0x2008, 0x2007,
        0x2004, 0x2003, 0x2037, 0x2032, 0x2001, 0x2001, 0x2005, 0x200f, 0x2007, 0x2011, 0x2007, 0x2002, 0x2005, 0x2001,
        0x2007, 0x2001, 0x2004, 0x2004, 0x2007, 0x2007, 0x801a, 0x2005, 0x1020, 0x2060, 0x1080, 0x20f0, 0x1e10}};



enum class _Extended_Pictographic_property_values : uint8_t { _Extended_Pictographic_value, _No_value = 255 };



inline constexpr _Unicode_property_data<_Extended_Pictographic_property_values, 78, true>
    _Extended_Pictographic_property_data{
        {0xa9, 0xae, 0x203c, 0x2049, 0x2122, 0x2139, 0x2194, 0x21a9, 0x231a, 0x2328, 0x2388, 0x23cf, 0x23e9, 0x23f8,
            0x24c2, 0x25aa, 0x25b6, 0x25c0, 0x25fb, 0x2600, 0x2607, 0x2614, 0x2690, 0x2708, 0x2714, 0x2716, 0x271d,
            0x2721, 0x2728, 0x2733, 0x2744, 0x2747, 0x274c, 0x274e, 0x2753, 0x2757, 0x2763, 0x2795, 0x27a1, 0x27b0,
            0x27bf, 0x2934, 0x2b05, 0x2b1b, 0x2b50, 0x2b55, 0x3030, 0x303d, 0x3297, 0x3299, 0x1f000, 0x1f10d, 0x1f12f,
            0x1f16c, 0x1f17e, 0x1f18e, 0x1f191, 0x1f1ad, 0x1f201, 0x1f21a, 0x1f22f, 0x1f232, 0x1f23c, 0x1f249, 0x1f400,
            0x1f546, 0x1f680, 0x1f774, 0x1f7d5, 0x1f80c, 0x1f848, 0x1f85a, 0x1f888, 0x1f8ae, 0x1f90c, 0x1f93c, 0x1f947,
            0x1fc00},
        {0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x6, 0x2, 0x2, 0x1, 0x1, 0x1, 0xb, 0x3, 0x1, 0x2, 0x1, 0x1, 0x4, 0x6, 0xc, 0x72,
            0x76, 0xb, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x1, 0x1, 0x1, 0x1, 0x3, 0x1, 0x5, 0x3, 0x1, 0x1, 0x1, 0x2, 0x3,
            0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x100, 0x3, 0x1, 0x6, 0x2, 0x1, 0xa, 0x39, 0xf, 0x1, 0x1, 0x9, 0x4,
            0x1b2, 0x13e, 0x10a, 0x80, 0xc, 0x2b, 0x4, 0x8, 0x6, 0x8, 0x52, 0x2f, 0xa, 0x1b9, 0x3fe}};



enum class __printable_property_values : uint8_t { _Yes_value, _No_value = 255 };



inline constexpr _Unicode_property_data<__printable_property_values, 711, true> __printable_property_data{
    {0x20, 0xa1, 0xae, 0x37a, 0x384, 0x38c, 0x38e, 0x3a3, 0x531, 0x559, 0x58d, 0x591, 0x5d0, 0x5ef, 0x606, 0x61d, 0x6de,
        0x710, 0x74d, 0x7c0, 0x7fd, 0x830, 0x840, 0x85e, 0x860, 0x870, 0x898, 0x8e3, 0x985, 0x98f, 0x993, 0x9aa, 0x9b2,
        0x9b6, 0x9bc, 0x9c7, 0x9cb, 0x9d7, 0x9dc, 0x9df, 0x9e6, 0xa01, 0xa05, 0xa0f, 0xa13, 0xa2a, 0xa32, 0xa35, 0xa38,
        0xa3c, 0xa3e, 0xa47, 0xa4b, 0xa51, 0xa59, 0xa5e, 0xa66, 0xa81, 0xa85, 0xa8f, 0xa93, 0xaaa, 0xab2, 0xab5, 0xabc,
        0xac7, 0xacb, 0xad0, 0xae0, 0xae6, 0xaf9, 0xb01, 0xb05, 0xb0f, 0xb13, 0xb2a, 0xb32, 0xb35, 0xb3c, 0xb47, 0xb4b,
        0xb55, 0xb5c, 0xb5f, 0xb66, 0xb82, 0xb85, 0xb8e, 0xb92, 0xb99, 0xb9c, 0xb9e, 0xba3, 0xba8, 0xbae, 0xbbe, 0xbc6,
        0xbca, 0xbd0, 0xbd7, 0xbe6, 0xc00, 0xc0e, 0xc12, 0xc2a, 0xc3c, 0xc46, 0xc4a, 0xc55, 0xc58, 0xc5d, 0xc60, 0xc66,
        0xc77, 0xc8e, 0xc92, 0xcaa, 0xcb5, 0xcbc, 0xcc6, 0xcca, 0xcd5, 0xcdd, 0xce0, 0xce6, 0xcf1, 0xd00, 0xd0e, 0xd12,
        0xd46, 0xd4a, 0xd54, 0xd66, 0xd81, 0xd85, 0xd9a, 0xdb3, 0xdbd, 0xdc0, 0xdca, 0xdcf, 0xdd6, 0xdd8, 0xde6, 0xdf2,
        0xe01, 0xe3f, 0xe81, 0xe84, 0xe86, 0xe8c, 0xea5, 0xea7, 0xec0, 0xec6, 0xec8, 0xed0, 0xedc, 0xf00, 0xf49, 0xf71,
        0xf99, 0xfbe, 0xfce, 0x1000, 0x10c7, 0x10cd, 0x10d0, 0x124a, 0x1250, 0x1258, 0x125a, 0x1260, 0x128a, 0x1290,
        0x12b2, 0x12b8, 0x12c0, 0x12c2, 0x12c8, 0x12d8, 0x1312, 0x1318, 0x135d, 0x1380, 0x13a0, 0x13f8, 0x1400, 0x1681,
        0x16a0, 0x1700, 0x171f, 0x1740, 0x1760, 0x176e, 0x1772, 0x1780, 0x17e0, 0x17f0, 0x1800, 0x180f, 0x1820, 0x1880,
        0x18b0, 0x1900, 0x1920, 0x1930, 0x1940, 0x1944, 0x1970, 0x1980, 0x19b0, 0x19d0, 0x19de, 0x1a1e, 0x1a60, 0x1a7f,
        0x1a90, 0x1aa0, 0x1ab0, 0x1b00, 0x1b50, 0x1b80, 0x1bfc, 0x1c3b, 0x1c4d, 0x1c90, 0x1cbd, 0x1cd0, 0x1d00, 0x1f18,
        0x1f20, 0x1f48, 0x1f50, 0x1f59, 0x1f5b, 0x1f5d, 0x1f5f, 0x1f80, 0x1fb6, 0x1fc6, 0x1fd6, 0x1fdd, 0x1ff2, 0x1ff6,
        0x2010, 0x2030, 0x2070, 0x2074, 0x2090, 0x20a0, 0x20d0, 0x2100, 0x2190, 0x2440, 0x2460, 0x2b76, 0x2b97, 0x2cf9,
        0x2d27, 0x2d2d, 0x2d30, 0x2d6f, 0x2d7f, 0x2da0, 0x2da8, 0x2db0, 0x2db8, 0x2dc0, 0x2dc8, 0x2dd0, 0x2dd8, 0x2de0,
        0x2e80, 0x2e9b, 0x2f00, 0x2ff0, 0x3001, 0x3041, 0x3099, 0x3105, 0x3131, 0x3190, 0x31f0, 0x3220, 0xa490, 0xa4d0,
        0xa640, 0xa700, 0xa7d0, 0xa7d3, 0xa7d5, 0xa7f2, 0xa830, 0xa840, 0xa880, 0xa8ce, 0xa8e0, 0xa95f, 0xa980, 0xa9cf,
        0xa9de, 0xaa00, 0xaa40, 0xaa50, 0xaa5c, 0xaadb, 0xab01, 0xab09, 0xab11, 0xab20, 0xab28, 0xab30, 0xab70, 0xabf0,
        0xac00, 0xd7b0, 0xd7cb, 0xf900, 0xfa70, 0xfb00, 0xfb13, 0xfb1d, 0xfb38, 0xfb3e, 0xfb40, 0xfb43, 0xfb46, 0xfbd3,
        0xfd92, 0xfdcf, 0xfdf0, 0xfe20, 0xfe54, 0xfe68, 0xfe70, 0xfe76, 0xff01, 0xffc2, 0xffca, 0xffd2, 0xffda, 0xffe0,
        0xffe8, 0xfffc, 0x10000, 0x1000d, 0x10028, 0x1003c, 0x1003f, 0x10050, 0x10080, 0x10100, 0x10107, 0x10137,
        0x10190, 0x101a0, 0x101d0, 0x10280, 0x102a0, 0x102e0, 0x10300, 0x1032d, 0x10350, 0x10380, 0x1039f, 0x103c8,
        0x10400, 0x104a0, 0x104b0, 0x104d8, 0x10500, 0x10530, 0x1056f, 0x1057c, 0x1058c, 0x10594, 0x10597, 0x105a3,
        0x105b3, 0x105bb, 0x10600, 0x10740, 0x10760, 0x10780, 0x10787, 0x107b2, 0x10800, 0x10808, 0x1080a, 0x10837,
        0x1083c, 0x1083f, 0x10857, 0x108a7, 0x108e0, 0x108f4, 0x108fb, 0x1091f, 0x1093f, 0x10980, 0x109bc, 0x109d2,
        0x10a05, 0x10a0c, 0x10a15, 0x10a19, 0x10a38, 0x10a3f, 0x10a50, 0x10a60, 0x10ac0, 0x10aeb, 0x10b00, 0x10b39,
        0x10b58, 0x10b78, 0x10b99, 0x10ba9, 0x10c00, 0x10c80, 0x10cc0, 0x10cfa, 0x10d30, 0x10e60, 0x10e80, 0x10eab,
        0x10eb0, 0x10efd, 0x10f30, 0x10f70, 0x10fb0, 0x10fe0, 0x11000, 0x11052, 0x1107f, 0x110be, 0x110d0, 0x110f0,
        0x11100, 0x11136, 0x11150, 0x11180, 0x111e1, 0x11200, 0x11213, 0x11280, 0x11288, 0x1128a, 0x1128f, 0x1129f,
        0x112b0, 0x112f0, 0x11300, 0x11305, 0x1130f, 0x11313, 0x1132a, 0x11332, 0x11335, 0x1133b, 0x11347, 0x1134b,
        0x11350, 0x11357, 0x1135d, 0x11366, 0x11370, 0x11400, 0x1145d, 0x11480, 0x114d0, 0x11580, 0x115b8, 0x11600,
        0x11650, 0x11660, 0x11680, 0x116c0, 0x11700, 0x1171d, 0x11730, 0x11800, 0x118a0, 0x118ff, 0x11909, 0x1190c,
        0x11915, 0x11918, 0x11937, 0x1193b, 0x11950, 0x119a0, 0x119aa, 0x119da, 0x11a00, 0x11a50, 0x11ab0, 0x11b00,
        0x11c00, 0x11c0a, 0x11c38, 0x11c50, 0x11c70, 0x11c92, 0x11ca9, 0x11d00, 0x11d08, 0x11d0b, 0x11d3a, 0x11d3c,
        0x11d3f, 0x11d50, 0x11d60, 0x11d67, 0x11d6a, 0x11d90, 0x11d93, 0x11da0, 0x11ee0, 0x11f00, 0x11f12, 0x11f3e,
        0x11fb0, 0x11fc0, 0x11fff, 0x12400, 0x12470, 0x12480, 0x12f90, 0x13000, 0x13440, 0x14400, 0x16800, 0x16a40,
        0x16a60, 0x16a6e, 0x16ac0, 0x16ad0, 0x16af0, 0x16b00, 0x16b50, 0x16b5b, 0x16b63, 0x16b7d, 0x16e40, 0x16f00,
        0x16f4f, 0x16f8f, 0x16fe0, 0x16ff0, 0x17000, 0x18800, 0x18d00, 0x1aff0, 0x1aff5, 0x1affd, 0x1b000, 0x1b132,
        0x1b150, 0x1b155, 0x1b164, 0x1b170, 0x1bc00, 0x1bc70, 0x1bc80, 0x1bc90, 0x1bc9c, 0x1cf00, 0x1cf30, 0x1cf50,
        0x1d000, 0x1d100, 0x1d129, 0x1d17b, 0x1d200, 0x1d2c0, 0x1d2e0, 0x1d300, 0x1d360, 0x1d400, 0x1d456, 0x1d49e,
        0x1d4a2, 0x1d4a5, 0x1d4a9, 0x1d4ae, 0x1d4bb, 0x1d4bd, 0x1d4c5, 0x1d507, 0x1d50d, 0x1d516, 0x1d51e, 0x1d53b,
        0x1d540, 0x1d546, 0x1d54a, 0x1d552, 0x1d6a8, 0x1d7ce, 0x1da9b, 0x1daa1, 0x1df00, 0x1df25, 0x1e000, 0x1e008,
        0x1e01b, 0x1e023, 0x1e026, 0x1e030, 0x1e08f, 0x1e100, 0x1e130, 0x1e140, 0x1e14e, 0x1e290, 0x1e2c0, 0x1e2ff,
        0x1e4d0, 0x1e7e0, 0x1e7e8, 0x1e7ed, 0x1e7f0, 0x1e800, 0x1e8c7, 0x1e900, 0x1e950, 0x1e95e, 0x1ec71, 0x1ed01,
        0x1ee00, 0x1ee05, 0x1ee21, 0x1ee24, 0x1ee27, 0x1ee29, 0x1ee34, 0x1ee39, 0x1ee3b, 0x1ee42, 0x1ee47, 0x1ee49,
        0x1ee4b, 0x1ee4d, 0x1ee51, 0x1ee54, 0x1ee57, 0x1ee59, 0x1ee5b, 0x1ee5d, 0x1ee5f, 0x1ee61, 0x1ee64, 0x1ee67,
        0x1ee6c, 0x1ee74, 0x1ee79, 0x1ee7e, 0x1ee80, 0x1ee8b, 0x1eea1, 0x1eea5, 0x1eeab, 0x1eef0, 0x1f000, 0x1f030,
        0x1f0a0, 0x1f0b1, 0x1f0c1, 0x1f0d1, 0x1f100, 0x1f1e6, 0x1f210, 0x1f240, 0x1f250, 0x1f260, 0x1f300, 0x1f6dc,
        0x1f6f0, 0x1f700, 0x1f77b, 0x1f7e0, 0x1f7f0, 0x1f800, 0x1f810, 0x1f850, 0x1f860, 0x1f890, 0x1f8b0, 0x1f900,
        0x1fa60, 0x1fa70, 0x1fa80, 0x1fa90, 0x1fabf, 0x1face, 0x1fae0, 0x1faf0, 0x1fb00, 0x1fb94, 0x1fbf0, 0x20000,
        0x2a700, 0x2b740, 0x2b820, 0x2ceb0, 0x2f800, 0x30000, 0x31350, 0xe0100},
    {0x5f, 0xc, 0x2ca, 0x6, 0x7, 0x1, 0x14, 0x18d, 0x26, 0x32, 0x3, 0x37, 0x1b, 0x6, 0x16, 0xc0, 0x30, 0x3b, 0x65, 0x3b,
        0x31, 0xf, 0x1c, 0x1, 0xb, 0x1f, 0x4a, 0xa1, 0x8, 0x2, 0x16, 0x7, 0x1, 0x4, 0x9, 0x2, 0x4, 0x1, 0x2, 0x5, 0x19,
        0x3, 0x6, 0x2, 0x16, 0x7, 0x2, 0x2, 0x2, 0x1, 0x5, 0x2, 0x3, 0x1, 0x4, 0x1, 0x11, 0x3, 0x9, 0x3, 0x16, 0x7, 0x2,
        0x5, 0xa, 0x3, 0x3, 0x1, 0x4, 0xc, 0x7, 0x3, 0x8, 0x2, 0x16, 0x7, 0x2, 0x5, 0x9, 0x2, 0x3, 0x3, 0x2, 0x5, 0x12,
        0x2, 0x6, 0x3, 0x4, 0x2, 0x1, 0x2, 0x2, 0x3, 0xc, 0x5, 0x3, 0x4, 0x1, 0x1, 0x15, 0xd, 0x3, 0x17, 0x10, 0x9, 0x3,
        0x4, 0x2, 0x3, 0x1, 0x4, 0xa, 0x16, 0x3, 0x17, 0xa, 0x5, 0x9, 0x3, 0x4, 0x2, 0x2, 0x4, 0xa, 0x3, 0xd, 0x3, 0x33,
        0x3, 0x6, 0x10, 0x1a, 0x3, 0x12, 0x18, 0x9, 0x1, 0x7, 0x1, 0x6, 0x1, 0x8, 0xa, 0x3, 0x3a, 0x1d, 0x2, 0x1, 0x5,
        0x18, 0x1, 0x17, 0x5, 0x1, 0x7, 0xa, 0x4, 0x48, 0x24, 0x27, 0x24, 0xf, 0xd, 0xc6, 0x1, 0x1, 0x179, 0x4, 0x7,
        0x1, 0x4, 0x29, 0x4, 0x21, 0x4, 0x7, 0x1, 0x4, 0xf, 0x39, 0x4, 0x43, 0x20, 0x1a, 0x56, 0x6, 0x280, 0x1c, 0x59,
        0x16, 0x18, 0x14, 0xd, 0x3, 0x2, 0x5e, 0xa, 0xa, 0xe, 0xb, 0x59, 0x2b, 0x46, 0x1f, 0xc, 0xc, 0x1, 0x2a, 0x5,
        0x2c, 0x1a, 0xb, 0x3e, 0x41, 0x1d, 0xb, 0xa, 0xe, 0x1f, 0x4d, 0x2f, 0x74, 0x3c, 0xf, 0x3c, 0x2b, 0xb, 0x2b,
        0x216, 0x6, 0x26, 0x6, 0x8, 0x1, 0x1, 0x1, 0x1f, 0x35, 0xf, 0xe, 0x6, 0x13, 0x3, 0x9, 0x18, 0x2f, 0x2, 0x1b,
        0xd, 0x21, 0x21, 0x8c, 0x297, 0xb, 0x714, 0x20, 0x15d, 0x2d, 0x1, 0x1, 0x38, 0x2, 0x18, 0x7, 0x7, 0x7, 0x7, 0x7,
        0x7, 0x7, 0x7, 0x7e, 0x1a, 0x59, 0xd6, 0xc, 0x3f, 0x56, 0x67, 0x2b, 0x5e, 0x54, 0x2f, 0x726d, 0x37, 0x15c, 0xb8,
        0xcb, 0x2, 0x1, 0x5, 0x3b, 0xa, 0x38, 0x46, 0xc, 0x74, 0x1e, 0x4e, 0xb, 0x21, 0x37, 0xe, 0xa, 0x67, 0x1c, 0x6,
        0x6, 0x6, 0x7, 0x7, 0x3c, 0x7e, 0xa, 0x2ba4, 0x17, 0x31, 0x16e, 0x6a, 0x7, 0x5, 0x1a, 0x5, 0x1, 0x2, 0x2, 0x7d,
        0x1bd, 0x36, 0x1, 0x2a, 0x33, 0x13, 0x4, 0x5, 0x87, 0xbe, 0x6, 0x6, 0x6, 0x3, 0x7, 0x7, 0x2, 0xc, 0x1a, 0x13,
        0x2, 0xf, 0xe, 0x7b, 0x3, 0x2d, 0x58, 0xd, 0x1, 0x2e, 0x1d, 0x31, 0x1c, 0x24, 0x1e, 0x2b, 0x1e, 0x25, 0xe, 0x9e,
        0xa, 0x24, 0x24, 0x28, 0x34, 0xc, 0xf, 0x7, 0x2, 0xb, 0xf, 0x7, 0x2, 0x137, 0x16, 0x8, 0x6, 0x2a, 0x9, 0x6, 0x1,
        0x2c, 0x2, 0x1, 0x17, 0x48, 0x9, 0x13, 0x2, 0x21, 0x1b, 0x1, 0x38, 0x14, 0x32, 0x2, 0x8, 0x3, 0x1d, 0x3, 0xa,
        0x9, 0x40, 0x27, 0xc, 0x36, 0x1d, 0x1b, 0x1a, 0x4, 0x7, 0x49, 0x33, 0x33, 0x2e, 0xa, 0x1f, 0x2a, 0x3, 0x2, 0x2b,
        0x2a, 0x1a, 0x1c, 0x17, 0x4e, 0x24, 0x3e, 0x5, 0x19, 0xa, 0x35, 0x12, 0x27, 0x60, 0x14, 0x12, 0x2f, 0x7, 0x1,
        0x4, 0xf, 0xb, 0x3b, 0xa, 0x4, 0x8, 0x2, 0x16, 0x7, 0x2, 0x5, 0xa, 0x2, 0x3, 0x1, 0x1, 0x7, 0x7, 0x5, 0x5c, 0x5,
        0x48, 0xa, 0x36, 0x26, 0x45, 0xa, 0xd, 0x3a, 0xa, 0x1b, 0xf, 0x17, 0x3c, 0x53, 0x8, 0x1, 0x8, 0x2, 0x1e, 0x2,
        0xc, 0xa, 0x8, 0x2e, 0xb, 0x48, 0x53, 0x49, 0xa, 0x9, 0x2d, 0xe, 0x1d, 0x20, 0x16, 0xe, 0x7, 0x2, 0x2c, 0x1,
        0x2, 0x9, 0xa, 0x6, 0x2, 0x25, 0x2, 0x6, 0xa, 0x19, 0x11, 0x29, 0x1c, 0x1, 0x32, 0x39b, 0x6f, 0x5, 0xc4, 0x63,
        0x430, 0x16, 0x247, 0x239, 0x1f, 0xa, 0x51, 0xa, 0x1e, 0x6, 0x46, 0xa, 0x7, 0x15, 0x13, 0x5b, 0x4b, 0x39, 0x11,
        0x5, 0x2, 0x17f8, 0x4d6, 0x9, 0x4, 0x7, 0x2, 0x123, 0x1, 0x3, 0x1, 0x4, 0x18c, 0x6b, 0xd, 0x9, 0xa, 0x4, 0x2e,
        0x17, 0x74, 0xf6, 0x27, 0x4a, 0x70, 0x46, 0x14, 0x14, 0x57, 0x19, 0x55, 0x47, 0x2, 0x1, 0x2, 0x4, 0xc, 0x1, 0x7,
        0x41, 0x4, 0x8, 0x7, 0x1c, 0x4, 0x5, 0x1, 0x7, 0x154, 0x124, 0x2be, 0x5, 0xf, 0x1f, 0x6, 0x7, 0x11, 0x7, 0x2,
        0x5, 0x3e, 0x1, 0x2d, 0xe, 0xa, 0x2, 0x1f, 0x3a, 0x1, 0x2a, 0x7, 0x4, 0x2, 0xf, 0xc5, 0x10, 0x4c, 0xa, 0x2,
        0x44, 0x3d, 0x4, 0x1b, 0x2, 0x1, 0x1, 0xa, 0x4, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x3, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1,
        0x1, 0x2, 0x1, 0x4, 0x7, 0x4, 0x4, 0x1, 0xa, 0x11, 0x3, 0x5, 0x11, 0x2, 0x2c, 0x64, 0xf, 0xf, 0xf, 0x25, 0xae,
        0x1d, 0x2c, 0x9, 0x2, 0x6, 0x3d8, 0x11, 0xd, 0x77, 0x5f, 0xc, 0x1, 0xc, 0x38, 0xa, 0x28, 0x1e, 0x2, 0x154, 0xe,
        0xd, 0x9, 0x2e, 0x7, 0xe, 0x9, 0x9, 0x93, 0x37, 0xa, 0xa6e0, 0x103a, 0xde, 0x1682, 0x1d31, 0x21e, 0x134b,
        0x1060, 0xf0}};



enum class _Grapheme_Extend_property_values : uint8_t { _Grapheme_Extend_value, _No_value = 255 };



inline constexpr _Unicode_property_data<_Grapheme_Extend_property_values, 363, true> _Grapheme_Extend_property_data{
    {0x300, 0x483, 0x591, 0x5bf, 0x5c1, 0x5c4, 0x5c7, 0x610, 0x64b, 0x670, 0x6d6, 0x6df, 0x6e7, 0x6ea, 0x711, 0x730,
        0x7a6, 0x7eb, 0x7fd, 0x816, 0x81b, 0x825, 0x829, 0x859, 0x898, 0x8ca, 0x8e3, 0x93a, 0x93c, 0x941, 0x94d, 0x951,
        0x962, 0x981, 0x9bc, 0x9be, 0x9c1, 0x9cd, 0x9d7, 0x9e2, 0x9fe, 0xa01, 0xa3c, 0xa41, 0xa47, 0xa4b, 0xa51, 0xa70,
        0xa75, 0xa81, 0xabc, 0xac1, 0xac7, 0xacd, 0xae2, 0xafa, 0xb01, 0xb3c, 0xb3e, 0xb41, 0xb4d, 0xb55, 0xb62, 0xb82,
        0xbbe, 0xbc0, 0xbcd, 0xbd7, 0xc00, 0xc04, 0xc3c, 0xc3e, 0xc46, 0xc4a, 0xc55, 0xc62, 0xc81, 0xcbc, 0xcbf, 0xcc2,
        0xcc6, 0xccc, 0xcd5, 0xce2, 0xd00, 0xd3b, 0xd3e, 0xd41, 0xd4d, 0xd57, 0xd62, 0xd81, 0xdca, 0xdcf, 0xdd2, 0xdd6,
        0xddf, 0xe31, 0xe34, 0xe47, 0xeb1, 0xeb4, 0xec8, 0xf18, 0xf35, 0xf37, 0xf39, 0xf71, 0xf80, 0xf86, 0xf8d, 0xf99,
        0xfc6, 0x102d, 0x1032, 0x1039, 0x103d, 0x1058, 0x105e, 0x1071, 0x1082, 0x1085, 0x108d, 0x109d, 0x135d, 0x1712,
        0x1732, 0x1752, 0x1772, 0x17b4, 0x17b7, 0x17c6, 0x17c9, 0x17dd, 0x180b, 0x180f, 0x1885, 0x18a9, 0x1920, 0x1927,
        0x1932, 0x1939, 0x1a17, 0x1a1b, 0x1a56, 0x1a58, 0x1a60, 0x1a62, 0x1a65, 0x1a73, 0x1a7f, 0x1ab0, 0x1b00, 0x1b34,
        0x1b3c, 0x1b42, 0x1b6b, 0x1b80, 0x1ba2, 0x1ba8, 0x1bab, 0x1be6, 0x1be8, 0x1bed, 0x1bef, 0x1c2c, 0x1c36, 0x1cd0,
        0x1cd4, 0x1ce2, 0x1ced, 0x1cf4, 0x1cf8, 0x1dc0, 0x200c, 0x20d0, 0x2cef, 0x2d7f, 0x2de0, 0x302a, 0x3099, 0xa66f,
        0xa674, 0xa69e, 0xa6f0, 0xa802, 0xa806, 0xa80b, 0xa825, 0xa82c, 0xa8c4, 0xa8e0, 0xa8ff, 0xa926, 0xa947, 0xa980,
        0xa9b3, 0xa9b6, 0xa9bc, 0xa9e5, 0xaa29, 0xaa31, 0xaa35, 0xaa43, 0xaa4c, 0xaa7c, 0xaab0, 0xaab2, 0xaab7, 0xaabe,
        0xaac1, 0xaaec, 0xaaf6, 0xabe5, 0xabe8, 0xabed, 0xfb1e, 0xfe00, 0xfe20, 0xff9e, 0x101fd, 0x102e0, 0x10376,
        0x10a01, 0x10a05, 0x10a0c, 0x10a38, 0x10a3f, 0x10ae5, 0x10d24, 0x10eab, 0x10efd, 0x10f46, 0x10f82, 0x11001,
        0x11038, 0x11070, 0x11073, 0x1107f, 0x110b3, 0x110b9, 0x110c2, 0x11100, 0x11127, 0x1112d, 0x11173, 0x11180,
        0x111b6, 0x111c9, 0x111cf, 0x1122f, 0x11234, 0x11236, 0x1123e, 0x11241, 0x112df, 0x112e3, 0x11300, 0x1133b,
        0x1133e, 0x11340, 0x11357, 0x11366, 0x11370, 0x11438, 0x11442, 0x11446, 0x1145e, 0x114b0, 0x114b3, 0x114ba,
        0x114bd, 0x114bf, 0x114c2, 0x115af, 0x115b2, 0x115bc, 0x115bf, 0x115dc, 0x11633, 0x1163d, 0x1163f, 0x116ab,
        0x116ad, 0x116b0, 0x116b7, 0x1171d, 0x11722, 0x11727, 0x1182f, 0x11839, 0x11930, 0x1193b, 0x1193e, 0x11943,
        0x119d4, 0x119da, 0x119e0, 0x11a01, 0x11a33, 0x11a3b, 0x11a47, 0x11a51, 0x11a59, 0x11a8a, 0x11a98, 0x11c30,
        0x11c38, 0x11c3f, 0x11c92, 0x11caa, 0x11cb2, 0x11cb5, 0x11d31, 0x11d3a, 0x11d3c, 0x11d3f, 0x11d47, 0x11d90,
        0x11d95, 0x11d97, 0x11ef3, 0x11f00, 0x11f36, 0x11f40, 0x11f42, 0x13440, 0x13447, 0x16af0, 0x16b30, 0x16f4f,
        0x16f8f, 0x16fe4, 0x1bc9d, 0x1cf00, 0x1cf30, 0x1d165, 0x1d167, 0x1d16e, 0x1d17b, 0x1d185, 0x1d1aa, 0x1d242,
        0x1da00, 0x1da3b, 0x1da75, 0x1da84, 0x1da9b, 0x1daa1, 0x1e000, 0x1e008, 0x1e01b, 0x1e023, 0x1e026, 0x1e08f,
        0x1e130, 0x1e2ae, 0x1e2ec, 0x1e4ec, 0x1e8d0, 0x1e944, 0xe0020, 0xe0100},
    {0x70, 0x7, 0x2d, 0x1, 0x2, 0x2, 0x1, 0xb, 0x15, 0x1, 0x7, 0x6, 0x2, 0x4, 0x1, 0x1b, 0xb, 0x9, 0x1, 0x4, 0x9, 0x3,
        0x5, 0x3, 0x8, 0x18, 0x20, 0x1, 0x1, 0x8, 0x1, 0x7, 0x2, 0x1, 0x1, 0x1, 0x4, 0x1, 0x1, 0x2, 0x1, 0x2, 0x1, 0x2,
        0x2, 0x3, 0x1, 0x2, 0x1, 0x2, 0x1, 0x5, 0x2, 0x1, 0x2, 0x6, 0x1, 0x1, 0x2, 0x4, 0x1, 0x3, 0x2, 0x1, 0x1, 0x1,
        0x1, 0x1, 0x1, 0x1, 0x1, 0x3, 0x3, 0x4, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x1, 0x4,
        0x1, 0x1, 0x2, 0x1, 0x1, 0x1, 0x3, 0x1, 0x1, 0x1, 0x7, 0x8, 0x1, 0x9, 0x7, 0x2, 0x1, 0x1, 0x1, 0xe, 0x5, 0x2,
        0xb, 0x24, 0x1, 0x4, 0x6, 0x2, 0x2, 0x2, 0x3, 0x4, 0x1, 0x2, 0x1, 0x1, 0x3, 0x3, 0x2, 0x2, 0x2, 0x2, 0x7, 0x1,
        0xb, 0x1, 0x3, 0x1, 0x2, 0x1, 0x3, 0x2, 0x1, 0x3, 0x2, 0x1, 0x1, 0x7, 0x1, 0x1, 0x8, 0xa, 0x1, 0x1f, 0x4, 0x7,
        0x1, 0x1, 0x9, 0x2, 0x4, 0x2, 0x3, 0x1, 0x2, 0x1, 0x3, 0x8, 0x2, 0x3, 0xd, 0x7, 0x1, 0x1, 0x2, 0x40, 0x1, 0x21,
        0x3, 0x1, 0x20, 0x6, 0x2, 0x4, 0xa, 0x2, 0x2, 0x1, 0x1, 0x1, 0x2, 0x1, 0x2, 0x12, 0x1, 0x8, 0xb, 0x3, 0x1, 0x4,
        0x2, 0x1, 0x6, 0x2, 0x2, 0x1, 0x1, 0x1, 0x1, 0x3, 0x2, 0x2, 0x1, 0x2, 0x1, 0x1, 0x1, 0x1, 0x1, 0x10, 0x10, 0x2,
        0x1, 0x1, 0x5, 0x3, 0x2, 0x4, 0x3, 0x1, 0x2, 0x4, 0x2, 0x3, 0xb, 0x4, 0x1, 0xf, 0x1, 0x2, 0x3, 0x4, 0x2, 0x1,
        0x3, 0x5, 0x8, 0x1, 0x2, 0x9, 0x4, 0x1, 0x3, 0x1, 0x2, 0x1, 0x1, 0x1, 0x8, 0x2, 0x2, 0x1, 0x1, 0x1, 0x7, 0x5,
        0x8, 0x3, 0x1, 0x1, 0x1, 0x6, 0x1, 0x1, 0x2, 0x2, 0x1, 0x4, 0x2, 0x2, 0x2, 0x8, 0x1, 0x2, 0x1, 0x1, 0x6, 0x1,
        0x3, 0x4, 0x5, 0x9, 0x2, 0x1, 0x2, 0x1, 0x1, 0x4, 0x2, 0x1, 0xa, 0x6, 0x4, 0x1, 0x6, 0x3, 0xd, 0x2, 0x7, 0x6,
        0x1, 0x16, 0x7, 0x2, 0x2, 0x6, 0x1, 0x2, 0x7, 0x1, 0x2, 0x1, 0x1, 0x2, 0x2, 0x5, 0x1, 0x1, 0x1, 0xf, 0x5, 0x7,
        0x1, 0x4, 0x1, 0x2, 0x2e, 0x17, 0x1, 0x3, 0x5, 0x8, 0x7, 0x4, 0x3, 0x37, 0x32, 0x1, 0x1, 0x5, 0xf, 0x7, 0x11,
        0x7, 0x2, 0x5, 0x1, 0x7, 0x1, 0x4, 0x4, 0x7, 0x7, 0x60, 0xf0}};

}



#pragma warning(pop)
#pragma pack(pop)

#line 532 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_format_ucd_tables.hpp"
#line 533 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_format_ucd_tables.hpp"
#pragma external_header(pop)
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"











#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"


















#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"

#line 23 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"



#line 27 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
extern "C" {
extern int __isa_available;
}

inline constexpr int _Stl_isa_available_sse42 = 2; 
inline constexpr int _Stl_isa_available_avx2  = 5; 

template <class _UInt>
inline constexpr int _Unsigned_integer_digits = sizeof(_UInt) * 8;




template <class _Ty>
[[nodiscard]] constexpr int _Countl_zero_fallback(_Ty _Val) noexcept {
    _Ty _Yx = 0;

    unsigned int _Nx = _Unsigned_integer_digits<_Ty>;
    unsigned int _Cx = _Unsigned_integer_digits<_Ty> / 2;
    do {
        _Yx = static_cast<_Ty>(_Val >> _Cx);
        if (_Yx != 0) {
            _Nx -= _Cx;
            _Val = _Yx;
        }
        _Cx >>= 1;
    } while (_Cx != 0);
    return static_cast<int>(_Nx) - static_cast<int>(_Val);
}





#line 71 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"



template <class _Ty>
[[nodiscard]] int _Countl_zero_lzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;

    if constexpr (_Digits <= 16) {
        return static_cast<int>(__lzcnt16(_Val) - (16 - _Digits));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__lzcnt(_Val));
    } else {









        return static_cast<int>(__lzcnt64(_Val));
#line 94 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
}

template <class _Ty>
[[nodiscard]] int _Countl_zero_bsr(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        if (!_BitScanReverse(&_Result, _Val)) {
            return _Digits;
        }
    } else {











        if (!_BitScanReverse64(&_Result, _Val)) {
            return _Digits;
        }
#line 122 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
    return static_cast<int>(_Digits - 1 - _Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countl_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_lzcnt = __isa_available >= _Stl_isa_available_avx2;
    if (_Definitely_have_lzcnt) {
        return _Countl_zero_lzcnt(_Val);
    } else {
        return _Countl_zero_bsr(_Val);
    }
#line 138 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
}
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"










































#line 183 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"




template <class _Ty>
[[nodiscard]] constexpr int _Countr_zero_fallback(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    return _Digits - _Countl_zero_fallback(static_cast<_Ty>(static_cast<_Ty>(~_Val) & static_cast<_Ty>(_Val - 1)));
}



template <class _Ty>
[[nodiscard]] constexpr int _Popcount_fallback(_Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;







#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    
    _Val = static_cast<_Ty>(_Val - ((_Val >> 1) & static_cast<_Ty>(0x5555'5555'5555'5555ull)));
    _Val = static_cast<_Ty>((_Val & static_cast<_Ty>(0x3333'3333'3333'3333ull))
                            + ((_Val >> 2) & static_cast<_Ty>(0x3333'3333'3333'3333ull)));
    _Val = static_cast<_Ty>((_Val + (_Val >> 4)) & static_cast<_Ty>(0x0F0F'0F0F'0F0F'0F0Full));
    
    _Val = static_cast<_Ty>(_Val * static_cast<_Ty>(0x0101'0101'0101'0101ull));
    
    return static_cast<int>(_Val >> (_Digits - 8));
}





#line 224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"








#line 233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"

template <class _Ty>
[[nodiscard]] int _Countr_zero_tzcnt(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    constexpr _Ty _Max    = static_cast<_Ty>(-1); 

    if constexpr (_Digits <= 32) {
        
        
        
        return static_cast<int>(_tzcnt_u32(static_cast<unsigned int>(~_Max | _Val)));
    } else {









        return static_cast<int>(_tzcnt_u64(_Val));
#line 256 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
}




template <class _Ty>
[[nodiscard]] int _Countr_zero_bsf(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    constexpr _Ty _Max    = static_cast<_Ty>(-1); 

    unsigned long _Result;
    if constexpr (_Digits <= 32) {
        
        
        
        if (!_BitScanForward(&_Result, static_cast<unsigned int>(~_Max | _Val))) {
            return _Digits;
        }
    } else {













        if (!_BitScanForward64(&_Result, _Val)) {
            return _Digits;
        }
#line 293 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
    return static_cast<int>(_Result);
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_countr_zero(const _Ty _Val) noexcept {



    const bool _Definitely_have_tzcnt = __isa_available >= _Stl_isa_available_avx2;
    if (_Definitely_have_tzcnt) {
        return _Countr_zero_tzcnt(_Val);
    } else {
        return _Countr_zero_bsf(_Val);
    }
#line 309 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
}

#line 312 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"





#line 319 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"


template <class _Ty>
[[nodiscard]] int _Unchecked_x86_x64_popcount(const _Ty _Val) noexcept {
    constexpr int _Digits = _Unsigned_integer_digits<_Ty>;
    if constexpr (_Digits <= 16) {
        return static_cast<int>(__popcnt16(_Val));
    } else if constexpr (_Digits == 32) {
        return static_cast<int>(__popcnt(_Val));
    } else {



        return static_cast<int>(__popcnt64(_Val));
#line 334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
}

template <class _Ty>
[[nodiscard]] int _Checked_x86_x64_popcount(const _Ty _Val) noexcept {

    const bool _Definitely_have_popcnt = __isa_available >= _Stl_isa_available_sse42;
    if (!_Definitely_have_popcnt) {
        return _Popcount_fallback(_Val);
    }
#line 345 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    return _Unchecked_x86_x64_popcount(_Val);
}
#line 348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"






#line 355 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"

template <class _Ty>
inline constexpr bool _Is_standard_unsigned_integer =
    _Is_any_of_v<remove_cv_t<_Ty>, unsigned char, unsigned short, unsigned int, unsigned long, unsigned long long>;

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Countr_zero(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    {
        return _Checked_x86_x64_countr_zero(_Val);
    }
#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    return _Countr_zero_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_countr_zero_impl(_Fn _Callback) {
    

    if (!::std:: is_constant_evaluated()) {



        const bool _Definitely_have_tzcnt = __isa_available >= _Stl_isa_available_avx2;
        if (_Definitely_have_tzcnt) {
            return _Callback([](_Ty _Val) { return _Countr_zero_tzcnt(_Val); });
        } else {
            return _Callback([](_Ty _Val) { return _Countr_zero_bsf(_Val); });
        }
#line 388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
#line 390 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    
    return _Callback([](_Ty _Val) { return _Countr_zero_fallback(_Val); });
}

template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int _Popcount(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated())
#line 400 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    {

        return _Checked_x86_x64_popcount(_Val);


#line 406 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
#line 408 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    return _Popcount_fallback(_Val);
}

template <class _Ty, class _Fn>
constexpr decltype(auto) _Select_popcount_impl(_Fn _Callback) {
    


    if (!::std:: is_constant_evaluated())
#line 418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    {


        const bool _Definitely_have_popcnt = __isa_available >= _Stl_isa_available_sse42;
        if (!_Definitely_have_popcnt) {
            return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
        }
#line 426 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
        return _Callback([](_Ty _Val) { return _Unchecked_x86_x64_popcount(_Val); });


#line 430 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    }
#line 432 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
    return _Callback([](_Ty _Val) { return _Popcount_fallback(_Val); });
}




}





#pragma warning(pop)
#pragma pack(pop)
#line 447 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
#line 448 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\__msvc_bit_utils.hpp"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"





#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

 template <class _To, class _From,
    enable_if_t<conjunction_v<bool_constant<sizeof(_To) == sizeof(_From)>, is_trivially_copyable<_To>,
                    is_trivially_copyable<_From>>,
        int> = 0>
[[nodiscard]] constexpr _To bit_cast(const _From& _Val) noexcept {
    return __builtin_bit_cast(_To, _Val);
}


[[nodiscard]] constexpr unsigned short _Byteswap_ushort(const unsigned short _Val) noexcept {
    if (::std:: is_constant_evaluated()) {
        return static_cast<unsigned short>((_Val << 8) | (_Val >> 8));
    } else {
        return _byteswap_ushort(_Val);
    }
}

[[nodiscard]] constexpr unsigned long _Byteswap_ulong(const unsigned long _Val) noexcept {
    if (::std:: is_constant_evaluated()) {
        return (_Val << 24) | ((_Val << 8) & 0x00FF'0000) | ((_Val >> 8) & 0x0000'FF00) | (_Val >> 24);
    } else {
        return _byteswap_ulong(_Val);
    }
}

[[nodiscard]] constexpr unsigned long long _Byteswap_uint64(const unsigned long long _Val) noexcept {
    if (::std:: is_constant_evaluated()) {
        return (_Val << 56) | ((_Val << 40) & 0x00FF'0000'0000'0000) | ((_Val << 24) & 0x0000'FF00'0000'0000)
             | ((_Val << 8) & 0x0000'00FF'0000'0000) | ((_Val >> 8) & 0x0000'0000'FF00'0000)
             | ((_Val >> 24) & 0x0000'0000'00FF'0000) | ((_Val >> 40) & 0x0000'0000'0000'FF00) | (_Val >> 56);
    } else {
        return _byteswap_uint64(_Val);
    }
}

 template <class _Ty, enable_if_t<is_integral_v<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty byteswap(const _Ty _Val) noexcept {
    if constexpr (sizeof(_Ty) == 1) {
        return _Val;
    } else if constexpr (sizeof(_Ty) == 2) {
        return static_cast<_Ty>(_Byteswap_ushort(static_cast<unsigned short>(_Val)));
    } else if constexpr (sizeof(_Ty) == 4) {
        return static_cast<_Ty>(_Byteswap_ulong(static_cast<unsigned long>(_Val)));
    } else if constexpr (sizeof(_Ty) == 8) {
        return static_cast<_Ty>(_Byteswap_uint64(static_cast<unsigned long long>(_Val)));
    } else {
        static_assert(_Always_false<_Ty>, "Unexpected integer size");
    }
}
#line 79 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_zero(_Ty _Val) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr bool has_single_bit(const _Ty _Val) noexcept {
    return _Val != 0 && (_Val & (_Val - 1)) == 0;
}

inline void _Precondition_violation_in_bit_ceil() noexcept {}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_ceil(const _Ty _Val) noexcept  {
    if (_Val <= 1u) {
        return _Ty{1};
    }

    const int _Num = _Unsigned_integer_digits<_Ty> - ::std:: countl_zero(static_cast<_Ty>(_Val - 1));

    if constexpr (sizeof(_Ty) < sizeof(unsigned int)) { 
        if (::std:: is_constant_evaluated()) {
            
            
            
            
            
            
            
            
            
            if (_Num == _Unsigned_integer_digits<_Ty>) {
                _Precondition_violation_in_bit_ceil();
            }
        }
    }

    return static_cast<_Ty>(_Ty{1} << _Num);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty bit_floor(const _Ty _Val) noexcept {
    if (_Val == 0) {
        return 0;
    }

    return static_cast<_Ty>(_Ty{1} << (_Unsigned_integer_digits<_Ty> - 1 - ::std:: countl_zero(_Val)));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int bit_width(const _Ty _Val) noexcept {
    return _Unsigned_integer_digits<_Ty> - ::std:: countl_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotr(_Ty _Val, int _Rotation) noexcept;

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr _Ty rotl(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = _Unsigned_integer_digits<_Ty>;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotl64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotl(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotl16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
            ;
            return _rotl8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val << _Remainder) | static_cast<_Ty>(_Val >> (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotr(_Val, -_Remainder);
    }
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> >
[[nodiscard]] constexpr _Ty rotr(const _Ty _Val, const int _Rotation) noexcept {
    constexpr auto _Digits = _Unsigned_integer_digits<_Ty>;

    if (!::std:: is_constant_evaluated()) {
        if constexpr (_Digits == 64) {
            return _rotr64(_Val, _Rotation);
        } else if constexpr (_Digits == 32) {
            return _rotr(_Val, _Rotation);
        } else if constexpr (_Digits == 16) {
            return _rotr16(_Val, static_cast<unsigned char>(_Rotation));
        } else {
            ;
            return _rotr8(_Val, static_cast<unsigned char>(_Rotation));
        }
    }

    const auto _Remainder = _Rotation % _Digits;
    if (_Remainder > 0) {
        return static_cast<_Ty>(
            static_cast<_Ty>(_Val >> _Remainder) | static_cast<_Ty>(_Val << (_Digits - _Remainder)));
    } else if (_Remainder == 0) {
        return _Val;
    } else { 
        return ::std:: rotl(_Val, -_Remainder);
    }
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> >
[[nodiscard]] constexpr int countl_zero(const _Ty _Val) noexcept {


    if (!::std:: is_constant_evaluated()) {
        return _Checked_x86_x64_countl_zero(_Val);
    }




#line 203 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"
#line 204 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"

    return _Countl_zero_fallback(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countl_one(const _Ty _Val) noexcept {
    return ::std:: countl_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countr_zero(const _Ty _Val) noexcept {
    return _Countr_zero(_Val);
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int countr_one(const _Ty _Val) noexcept {
    return _Countr_zero(static_cast<_Ty>(~_Val));
}

 template <class _Ty, enable_if_t<_Is_standard_unsigned_integer<_Ty>, int> = 0>
[[nodiscard]] constexpr int popcount(const _Ty _Val) noexcept {
    return _Popcount(_Val);
}

 enum class endian { little = 0, big = 1, native = little };

}


#pragma warning(pop)
#pragma pack(pop)
#line 236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"
#line 237 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"
#line 238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\bit"
#pragma external_header(pop)
#line 48 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

[[nodiscard]] inline unsigned long _Floor_of_log_2(size_t _Value) noexcept { 
    _Value |= size_t{1}; 
    unsigned long _Result;














    _BitScanReverse64(&_Result, _Value); 


#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"
#line 46 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"

    return _Result;
}

[[nodiscard]] inline unsigned long _Ceiling_of_log_2(const size_t _Value) noexcept { 
                                                                                  
    return 1 + _Floor_of_log_2(_Value - 1);
}

[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint32_t _Value) noexcept {
    unsigned long _Index; 

    if (_BitScanReverse(&_Index, _Value)) {
        return _Index + 1;
    }

    return 0;
}

[[nodiscard]] inline uint32_t _Bit_scan_reverse(const uint64_t _Value) noexcept {
    unsigned long _Index; 


    if (_BitScanReverse64(&_Index, _Value)) {
        return _Index + 1;
    }












#line 85 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"

    return 0;
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 96 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"
#line 97 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xbit_ops.h"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv.h"
















#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 enum class chars_format {
    scientific = 0b001,
    fixed      = 0b010,
    hex        = 0b100,
    general    = fixed | scientific,
};

 [[nodiscard]] constexpr chars_format operator&(chars_format _Left, chars_format _Right) noexcept { using _IntTy = ::std:: underlying_type_t<chars_format>; return static_cast<chars_format>(static_cast<_IntTy>(_Left) & static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr chars_format operator|(chars_format _Left, chars_format _Right) noexcept { using _IntTy = ::std:: underlying_type_t<chars_format>; return static_cast<chars_format>(static_cast<_IntTy>(_Left) | static_cast<_IntTy>(_Right)); }  [[nodiscard]] constexpr chars_format operator^(chars_format _Left, chars_format _Right) noexcept { using _IntTy = ::std:: underlying_type_t<chars_format>; return static_cast<chars_format>(static_cast<_IntTy>(_Left) ^ static_cast<_IntTy>(_Right)); }  constexpr chars_format& operator&=(chars_format& _Left, chars_format _Right) noexcept { return _Left = _Left & _Right; }  constexpr chars_format& operator|=(chars_format& _Left, chars_format _Right) noexcept { return _Left = _Left | _Right; }  constexpr chars_format& operator^=(chars_format& _Left, chars_format _Right) noexcept { return _Left = _Left ^ _Right; }  [[nodiscard]] constexpr chars_format operator~(chars_format _Left) noexcept { using _IntTy = ::std:: underlying_type_t<chars_format>; return static_cast<chars_format>(~static_cast<_IntTy>(_Left)); }

 struct to_chars_result {
    char* ptr;
    errc ec;

    [[nodiscard]] friend bool operator==(const to_chars_result&, const to_chars_result&) = default;
#line 42 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv.h"
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv.h"
#line 53 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv.h"
#pragma external_header(pop)
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"











































#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu_tables.h"











































#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu_tables.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {











template <class _CharT> inline constexpr _CharT __DIGIT_TABLE[] = {_CharT{}};

template <> inline constexpr char __DIGIT_TABLE<char>[200] = {
  '0','0','0','1','0','2','0','3','0','4','0','5','0','6','0','7','0','8','0','9',
  '1','0','1','1','1','2','1','3','1','4','1','5','1','6','1','7','1','8','1','9',
  '2','0','2','1','2','2','2','3','2','4','2','5','2','6','2','7','2','8','2','9',
  '3','0','3','1','3','2','3','3','3','4','3','5','3','6','3','7','3','8','3','9',
  '4','0','4','1','4','2','4','3','4','4','4','5','4','6','4','7','4','8','4','9',
  '5','0','5','1','5','2','5','3','5','4','5','5','5','6','5','7','5','8','5','9',
  '6','0','6','1','6','2','6','3','6','4','6','5','6','6','6','7','6','8','6','9',
  '7','0','7','1','7','2','7','3','7','4','7','5','7','6','7','7','7','8','7','9',
  '8','0','8','1','8','2','8','3','8','4','8','5','8','6','8','7','8','8','8','9',
  '9','0','9','1','9','2','9','3','9','4','9','5','9','6','9','7','9','8','9','9'
};

template <> inline constexpr wchar_t __DIGIT_TABLE<wchar_t>[200] = {
  L'0',L'0',L'0',L'1',L'0',L'2',L'0',L'3',L'0',L'4',L'0',L'5',L'0',L'6',L'0',L'7',L'0',L'8',L'0',L'9',
  L'1',L'0',L'1',L'1',L'1',L'2',L'1',L'3',L'1',L'4',L'1',L'5',L'1',L'6',L'1',L'7',L'1',L'8',L'1',L'9',
  L'2',L'0',L'2',L'1',L'2',L'2',L'2',L'3',L'2',L'4',L'2',L'5',L'2',L'6',L'2',L'7',L'2',L'8',L'2',L'9',
  L'3',L'0',L'3',L'1',L'3',L'2',L'3',L'3',L'3',L'4',L'3',L'5',L'3',L'6',L'3',L'7',L'3',L'8',L'3',L'9',
  L'4',L'0',L'4',L'1',L'4',L'2',L'4',L'3',L'4',L'4',L'4',L'5',L'4',L'6',L'4',L'7',L'4',L'8',L'4',L'9',
  L'5',L'0',L'5',L'1',L'5',L'2',L'5',L'3',L'5',L'4',L'5',L'5',L'5',L'6',L'5',L'7',L'5',L'8',L'5',L'9',
  L'6',L'0',L'6',L'1',L'6',L'2',L'6',L'3',L'6',L'4',L'6',L'5',L'6',L'6',L'6',L'7',L'6',L'8',L'6',L'9',
  L'7',L'0',L'7',L'1',L'7',L'2',L'7',L'3',L'7',L'4',L'7',L'5',L'7',L'6',L'7',L'7',L'7',L'8',L'7',L'9',
  L'8',L'0',L'8',L'1',L'8',L'2',L'8',L'3',L'8',L'4',L'8',L'5',L'8',L'6',L'8',L'7',L'8',L'8',L'8',L'9',
  L'9',L'0',L'9',L'1',L'9',L'2',L'9',L'3',L'9',L'4',L'9',L'5',L'9',L'6',L'9',L'7',L'9',L'8',L'9',L'9'
};






extern const uint64_t __DOUBLE_POW5_INV_SPLIT[292][2];

extern const uint64_t __DOUBLE_POW5_SPLIT[326][2];





inline constexpr int __TABLE_SIZE = 64;

inline constexpr uint16_t __POW10_OFFSET[__TABLE_SIZE] = {
  0, 2, 5, 8, 12, 16, 21, 26, 32, 39,
  46, 54, 62, 71, 80, 90, 100, 111, 122, 134,
  146, 159, 173, 187, 202, 217, 233, 249, 266, 283,
  301, 319, 338, 357, 377, 397, 418, 440, 462, 485,
  508, 532, 556, 581, 606, 632, 658, 685, 712, 740,
  769, 798, 828, 858, 889, 920, 952, 984, 1017, 1050,
  1084, 1118, 1153, 1188
};

extern const uint64_t __POW10_SPLIT[1224][3];

inline constexpr int __TABLE_SIZE_2 = 69;
inline constexpr int __ADDITIONAL_BITS_2 = 120;

inline constexpr uint16_t __POW10_OFFSET_2[__TABLE_SIZE_2] = {
     0,    2,    6,   12,   20,   29,   40,   52,   66,   80,
    95,  112,  130,  150,  170,  192,  215,  240,  265,  292,
   320,  350,  381,  413,  446,  480,  516,  552,  590,  629,
   670,  712,  755,  799,  845,  892,  940,  989, 1040, 1092,
  1145, 1199, 1254, 1311, 1369, 1428, 1488, 1550, 1613, 1678,
  1743, 1810, 1878, 1947, 2017, 2088, 2161, 2235, 2311, 2387,
  2465, 2544, 2625, 2706, 2789, 2873, 2959, 3046, 3133
};

inline constexpr uint8_t __MIN_BLOCK_2[__TABLE_SIZE_2] = {
     0,    0,    0,    0,    0,    0,    1,    1,    2,    3,
     3,    4,    4,    5,    5,    6,    6,    7,    7,    8,
     8,    9,    9,   10,   11,   11,   12,   12,   13,   13,
    14,   14,   15,   15,   16,   16,   17,   17,   18,   19,
    19,   20,   20,   21,   21,   22,   22,   23,   23,   24,
    24,   25,   26,   26,   27,   27,   28,   28,   29,   29,
    30,   30,   31,   31,   32,   32,   33,   34,    0
};

extern const uint64_t __POW10_SPLIT_2[3133][3];





}



#pragma warning(pop)
#pragma pack(pop)

#line 157 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu_tables.h"
#line 158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu_tables.h"
#pragma external_header(pop)
#line 45 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"






#line 52 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"



#line 56 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"



#line 60 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {








[[nodiscard]] inline uint32_t __decimalLength9(const uint32_t __v) {
  
  
  
  ;
  if (__v >= 100000000) { return 9; }
  if (__v >= 10000000) { return 8; }
  if (__v >= 1000000) { return 7; }
  if (__v >= 100000) { return 6; }
  if (__v >= 10000) { return 5; }
  if (__v >= 1000) { return 4; }
  if (__v >= 100) { return 3; }
  if (__v >= 10) { return 2; }
  return 1;
}


[[nodiscard]] inline int32_t __pow5bits(const int32_t __e) {
  
  
  
  ;
  ;
  return static_cast<int32_t>(((static_cast<uint32_t>(__e) * 1217359) >> 19) + 1);
}


[[nodiscard]] inline uint32_t __log10Pow2(const int32_t __e) {
  
  ;
  ;
  return (static_cast<uint32_t>(__e) * 78913) >> 18;
}


[[nodiscard]] inline uint32_t __log10Pow5(const int32_t __e) {
  
  ;
  ;
  return (static_cast<uint32_t>(__e) * 732923) >> 20;
}

[[nodiscard]] inline uint32_t __float_to_bits(const float __f) {
  uint32_t __bits = 0;
  :: memcpy(&__bits, &__f, sizeof(float));
  return __bits;
}

[[nodiscard]] inline uint64_t __double_to_bits(const double __d) {
  uint64_t __bits = 0;
  :: memcpy(&__bits, &__d, sizeof(double));
  return __bits;
}





inline constexpr int __DOUBLE_MANTISSA_BITS = 52;
inline constexpr int __DOUBLE_BIAS = 1023;

inline constexpr int __DOUBLE_POW5_INV_BITCOUNT = 122;
inline constexpr int __DOUBLE_POW5_BITCOUNT = 121;







[[nodiscard]] inline uint64_t __ryu_umul128(const uint64_t __a, const uint64_t __b, uint64_t* const __productHi) {
  return _umul128(__a, __b, __productHi);
}

[[nodiscard]] inline uint64_t __ryu_shiftright128(const uint64_t __lo, const uint64_t __hi, const uint32_t __dist) {
  
  
  
  
  
  
  
  ;
  return __shiftright128(__lo, __hi, static_cast<unsigned char>(__dist));
}















































#line 210 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"




























































[[nodiscard]] inline uint64_t __div5(const uint64_t __x) {
  return __x / 5;
}

[[nodiscard]] inline uint64_t __div10(const uint64_t __x) {
  return __x / 10;
}

[[nodiscard]] inline uint64_t __div100(const uint64_t __x) {
  return __x / 100;
}

[[nodiscard]] inline uint64_t __div1e8(const uint64_t __x) {
  return __x / 100000000;
}

[[nodiscard]] inline uint64_t __div1e9(const uint64_t __x) {
  return __x / 1000000000;
}

[[nodiscard]] inline uint32_t __mod1e9(const uint64_t __x) {
  return static_cast<uint32_t>(__x - 1000000000 * __div1e9(__x));
}

#line 295 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"

[[nodiscard]] inline uint32_t __pow5Factor(uint64_t __value) {
  uint32_t __count = 0;
  for (;;) {
    ;
    const uint64_t __q = __div5(__value);
    const uint32_t __r = static_cast<uint32_t>(__value) - 5 * static_cast<uint32_t>(__q);
    if (__r != 0) {
      break;
    }
    __value = __q;
    ++__count;
  }
  return __count;
}


[[nodiscard]] inline bool __multipleOfPowerOf5(const uint64_t __value, const uint32_t __p) {
  
  return __pow5Factor(__value) >= __p;
}


[[nodiscard]] inline bool __multipleOfPowerOf2(const uint64_t __value, const uint32_t __p) {
  ;
  ;
  
  return (__value & ((1ull << __p) - 1)) == 0;
}





inline constexpr int __POW10_ADDITIONAL_BITS = 120;



[[nodiscard]] inline uint64_t __umul256_hi128_lo64(
  const uint64_t __aHi, const uint64_t __aLo, const uint64_t __bHi, const uint64_t __bLo) {
  uint64_t __b00Hi;
  const uint64_t __b00Lo = __ryu_umul128(__aLo, __bLo, &__b00Hi);
  uint64_t __b01Hi;
  const uint64_t __b01Lo = __ryu_umul128(__aLo, __bHi, &__b01Hi);
  uint64_t __b10Hi;
  const uint64_t __b10Lo = __ryu_umul128(__aHi, __bLo, &__b10Hi);
  uint64_t __b11Hi;
  const uint64_t __b11Lo = __ryu_umul128(__aHi, __bHi, &__b11Hi);
  (void) __b00Lo; 
  (void) __b11Hi; 
  const uint64_t __temp1Lo = __b10Lo + __b00Hi;
  const uint64_t __temp1Hi = __b10Hi + (__temp1Lo < __b10Lo);
  const uint64_t __temp2Lo = __b01Lo + __temp1Lo;
  const uint64_t __temp2Hi = __b01Hi + (__temp2Lo < __b01Lo);
  return __b11Lo + __temp1Hi + __temp2Hi;
}

[[nodiscard]] inline uint32_t __uint128_mod1e9(const uint64_t __vHi, const uint64_t __vLo) {
  
  
  const uint64_t __multiplied = __umul256_hi128_lo64(__vHi, __vLo, 0x89705F4136B4A597u, 0x31680A88F8953031u);

  
  const uint32_t __shifted = static_cast<uint32_t>(__multiplied >> 29);

  return static_cast<uint32_t>(__vLo) - 1000000000 * __shifted;
}
#line 363 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"

[[nodiscard]] inline uint32_t __mulShift_mod1e9(const uint64_t __m, const uint64_t* const __mul, const int32_t __j) {
  uint64_t __high0;                                               
  const uint64_t __low0 = __ryu_umul128(__m, __mul[0], &__high0); 
  uint64_t __high1;                                               
  const uint64_t __low1 = __ryu_umul128(__m, __mul[1], &__high1); 
  uint64_t __high2;                                               
  const uint64_t __low2 = __ryu_umul128(__m, __mul[2], &__high2); 
  const uint64_t __s0low = __low0;                  
  (void) __s0low; 
  const uint64_t __s0high = __low1 + __high0;       
  const uint32_t __c1 = __s0high < __low1;
  const uint64_t __s1low = __low2 + __high1 + __c1; 
  const uint32_t __c2 = __s1low < __low2; 
  const uint64_t __s1high = __high2 + __c2;         
  ;
  ;

  const uint32_t __dist = static_cast<uint32_t>(__j - 128); 
  const uint64_t __shiftedhigh = __s1high >> __dist;
  const uint64_t __shiftedlow = __ryu_shiftright128(__s1low, __s1high, __dist);
  return __uint128_mod1e9(__shiftedhigh, __shiftedlow);











#line 397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
}



template <class _CharT>
void __append_n_digits(const uint32_t __olength, uint32_t __digits, _CharT* const __result) {
  uint32_t __i = 0;
  while (__digits >= 10000) {



    const uint32_t __c = __digits % 10000;
#line 410 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
    __digits /= 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    :: memcpy(__result + __olength - __i - 2, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 4, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    __i += 4;
  }
  if (__digits >= 100) {
    const uint32_t __c = (__digits % 100) << 1;
    __digits /= 100;
    :: memcpy(__result + __olength - __i - 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    __i += 2;
  }
  if (__digits >= 10) {
    const uint32_t __c = __digits << 1;
    :: memcpy(__result + __olength - __i - 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
  } else {
    __result[0] = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + __digits);
  }
}

inline void __append_d_digits(const uint32_t __olength, uint32_t __digits, char* const __result) {
  uint32_t __i = 0;
  while (__digits >= 10000) {



    const uint32_t __c = __digits % 10000;
#line 439 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
    __digits /= 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    :: memcpy(__result + __olength + 1 - __i - 2, __DIGIT_TABLE<char> + __c0, 2);
    :: memcpy(__result + __olength + 1 - __i - 4, __DIGIT_TABLE<char> + __c1, 2);
    __i += 4;
  }
  if (__digits >= 100) {
    const uint32_t __c = (__digits % 100) << 1;
    __digits /= 100;
    :: memcpy(__result + __olength + 1 - __i - 2, __DIGIT_TABLE<char> + __c, 2);
    __i += 2;
  }
  if (__digits >= 10) {
    const uint32_t __c = __digits << 1;
    __result[2] = __DIGIT_TABLE<char>[__c + 1];
    __result[1] = '.';
    __result[0] = __DIGIT_TABLE<char>[__c];
  } else {
    __result[1] = '.';
    __result[0] = static_cast<char>('0' + __digits);
  }
}

template <class _CharT>
void __append_c_digits(const uint32_t __count, uint32_t __digits, _CharT* const __result) {
  uint32_t __i = 0;
  for (; __i < __count - 1; __i += 2) {
    const uint32_t __c = (__digits % 100) << 1;
    __digits /= 100;
    :: memcpy(__result + __count - __i - 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
  }
  if (__i < __count) {
    const _CharT __c = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + (__digits % 10));
    __result[__count - __i - 1] = __c;
  }
}

template <class _CharT>
void __append_nine_digits(uint32_t __digits, _CharT* const __result) {
  if (__digits == 0) {
    ::std:: fill_n(__result, 9, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    return;
  }

  for (uint32_t __i = 0; __i < 5; __i += 4) {



    const uint32_t __c = __digits % 10000;
#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
    __digits /= 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    :: memcpy(__result + 7 - __i, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
    :: memcpy(__result + 5 - __i, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
  }
  __result[0] = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + __digits);
}

[[nodiscard]] inline uint32_t __indexForExponent(const uint32_t __e) {
  return (__e + 15) / 16;
}

[[nodiscard]] inline uint32_t __pow10BitsForIndex(const uint32_t __idx) {
  return 16 * __idx + __POW10_ADDITIONAL_BITS;
}

[[nodiscard]] inline uint32_t __lengthForIndex(const uint32_t __idx) {
  
  return (__log10Pow2(16 * static_cast<int32_t>(__idx)) + 1 + 16 + 8) / 9;
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> __d2fixed_buffered_n(_CharT* _First, _CharT* const _Last, const double __d,
  const uint32_t __precision) {
  _CharT* const _Original_first = _First;

  const uint64_t __bits = __double_to_bits(__d);

  
  if (__bits == 0) {
    const int32_t _Total_zero_length = 1 
      + static_cast<int32_t>(__precision != 0) 
      + static_cast<int32_t>(__precision); 

    if (_Last - _First < _Total_zero_length) {
      return { _Last, errc::value_too_large };
    }

    *_First++ = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
    if (__precision > 0) {
      *_First++ = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
      ::std:: fill_n(_First, __precision, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
      _First += __precision;
    }
    return { _First, errc{} };
  }

  
  const uint64_t __ieeeMantissa = __bits & ((1ull << __DOUBLE_MANTISSA_BITS) - 1);
  const uint32_t __ieeeExponent = static_cast<uint32_t>(__bits >> __DOUBLE_MANTISSA_BITS);

  int32_t __e2;
  uint64_t __m2;
  if (__ieeeExponent == 0) {
    __e2 = 1 - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS;
    __m2 = __ieeeMantissa;
  } else {
    __e2 = static_cast<int32_t>(__ieeeExponent) - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS;
    __m2 = (1ull << __DOUBLE_MANTISSA_BITS) | __ieeeMantissa;
  }

  bool __nonzero = false;
  if (__e2 >= -52) {
    const uint32_t __idx = __e2 < 0 ? 0 : __indexForExponent(static_cast<uint32_t>(__e2));
    const uint32_t __p10bits = __pow10BitsForIndex(__idx);
    const int32_t __len = static_cast<int32_t>(__lengthForIndex(__idx));
    for (int32_t __i = __len - 1; __i >= 0; --__i) {
      const uint32_t __j = __p10bits - __e2;
      
      
      const uint32_t __digits = __mulShift_mod1e9(__m2 << 8, __POW10_SPLIT[__POW10_OFFSET[__idx] + __i],
        static_cast<int32_t>(__j + 8));
      if (__nonzero) {
        if (_Last - _First < 9) {
          return { _Last, errc::value_too_large };
        }
        __append_nine_digits(__digits, _First);
        _First += 9;
      } else if (__digits != 0) {
        const uint32_t __olength = __decimalLength9(__digits);
        if (_Last - _First < static_cast<ptrdiff_t>(__olength)) {
          return { _Last, errc::value_too_large };
        }
        __append_n_digits(__olength, __digits, _First);
        _First += __olength;
        __nonzero = true;
      }
    }
  }
  if (!__nonzero) {
    if (_First == _Last) {
      return { _Last, errc::value_too_large };
    }
    *_First++ = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
  }
  if (__precision > 0) {
    if (_First == _Last) {
      return { _Last, errc::value_too_large };
    }
    *_First++ = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
  }
  if (__e2 < 0) {
    const int32_t __idx = -__e2 / 16;
    const uint32_t __blocks = __precision / 9 + 1;
    
    int __roundUp = 0;
    uint32_t __i = 0;
    if (__blocks <= __MIN_BLOCK_2[__idx]) {
      __i = __blocks;
      if (_Last - _First < static_cast<ptrdiff_t>(__precision)) {
        return { _Last, errc::value_too_large };
      }
      ::std:: fill_n(_First, __precision, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
      _First += __precision;
    } else if (__i < __MIN_BLOCK_2[__idx]) {
      __i = __MIN_BLOCK_2[__idx];
      if (_Last - _First < static_cast<ptrdiff_t>(9 * __i)) {
        return { _Last, errc::value_too_large };
      }
      ::std:: fill_n(_First, 9 * __i, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
      _First += 9 * __i;
    }
    for (; __i < __blocks; ++__i) {
      const int32_t __j = __ADDITIONAL_BITS_2 + (-__e2 - 16 * __idx);
      const uint32_t __p = __POW10_OFFSET_2[__idx] + __i - __MIN_BLOCK_2[__idx];
      if (__p >= __POW10_OFFSET_2[__idx + 1]) {
        
        
        const uint32_t __fill = __precision - 9 * __i;
        if (_Last - _First < static_cast<ptrdiff_t>(__fill)) {
          return { _Last, errc::value_too_large };
        }
        ::std:: fill_n(_First, __fill, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
        _First += __fill;
        break;
      }
      
      
      uint32_t __digits = __mulShift_mod1e9(__m2 << 8, __POW10_SPLIT_2[__p], __j + 8);
      if (__i < __blocks - 1) {
        if (_Last - _First < 9) {
          return { _Last, errc::value_too_large };
        }
        __append_nine_digits(__digits, _First);
        _First += 9;
      } else {
        const uint32_t __maximum = __precision - 9 * __i;
        uint32_t __lastDigit = 0;
        for (uint32_t __k = 0; __k < 9 - __maximum; ++__k) {
          __lastDigit = __digits % 10;
          __digits /= 10;
        }
        if (__lastDigit != 5) {
          __roundUp = __lastDigit > 5;
        } else {
          
          const int32_t __requiredTwos = -__e2 - static_cast<int32_t>(__precision) - 1;
          const bool __trailingZeros = __requiredTwos <= 0
            || (__requiredTwos < 60 && __multipleOfPowerOf2(__m2, static_cast<uint32_t>(__requiredTwos)));
          __roundUp = __trailingZeros ? 2 : 1;
        }
        if (__maximum > 0) {
          if (_Last - _First < static_cast<ptrdiff_t>(__maximum)) {
            return { _Last, errc::value_too_large };
          }
          __append_c_digits(__maximum, __digits, _First);
          _First += __maximum;
        }
        break;
      }
    }
    if (__roundUp != 0) {
      _CharT* _Round = _First;
      _CharT* _Dot = _Last;
      while (true) {
        if (_Round == _Original_first) {
          _Round[0] = static_cast<_CharT>(is_same_v<_CharT, char> ? '1' : L'1');
          if (_Dot != _Last) {
            _Dot[0] = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
            _Dot[1] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
          }
          if (_First == _Last) {
            return { _Last, errc::value_too_large };
          }
          *_First++ = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
          break;
        }
        --_Round;
        const _CharT __c = _Round[0];
        if (__c == static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.')) {
          _Dot = _Round;
        } else if (__c == static_cast<_CharT>(is_same_v<_CharT, char> ? '9' : L'9')) {
          _Round[0] = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
          __roundUp = 1;
        } else {
          if (__roundUp == 1 || __c % 2 != 0) {
            _Round[0] = static_cast<_CharT>(__c + 1);
          }
          break;
        }
      }
    }
  } else {
    if (_Last - _First < static_cast<ptrdiff_t>(__precision)) {
      return { _Last, errc::value_too_large };
    }
    ::std:: fill_n(_First, __precision, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    _First += __precision;
  }
  return { _First, errc{} };
}

[[nodiscard]] inline to_chars_result __d2exp_buffered_n(char* _First, char* const _Last, const double __d,
  uint32_t __precision) {
  char* const _Original_first = _First;

  const uint64_t __bits = __double_to_bits(__d);

  
  if (__bits == 0) {
    const int32_t _Total_zero_length = 1 
      + static_cast<int32_t>(__precision != 0) 
      + static_cast<int32_t>(__precision) 
      + 4; 
    if (_Last - _First < _Total_zero_length) {
      return { _Last, errc::value_too_large };
    }
    *_First++ = '0';
    if (__precision > 0) {
      *_First++ = '.';
      :: memset(_First, '0', __precision);
      _First += __precision;
    }
    :: memcpy(_First, "e+00", 4);
    _First += 4;
    return { _First, errc{} };
  }

  
  const uint64_t __ieeeMantissa = __bits & ((1ull << __DOUBLE_MANTISSA_BITS) - 1);
  const uint32_t __ieeeExponent = static_cast<uint32_t>(__bits >> __DOUBLE_MANTISSA_BITS);

  int32_t __e2;
  uint64_t __m2;
  if (__ieeeExponent == 0) {
    __e2 = 1 - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS;
    __m2 = __ieeeMantissa;
  } else {
    __e2 = static_cast<int32_t>(__ieeeExponent) - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS;
    __m2 = (1ull << __DOUBLE_MANTISSA_BITS) | __ieeeMantissa;
  }

  const bool __printDecimalPoint = __precision > 0;
  ++__precision;
  uint32_t __digits = 0;
  uint32_t __printedDigits = 0;
  uint32_t __availableDigits = 0;
  int32_t __exp = 0;
  if (__e2 >= -52) {
    const uint32_t __idx = __e2 < 0 ? 0 : __indexForExponent(static_cast<uint32_t>(__e2));
    const uint32_t __p10bits = __pow10BitsForIndex(__idx);
    const int32_t __len = static_cast<int32_t>(__lengthForIndex(__idx));
    for (int32_t __i = __len - 1; __i >= 0; --__i) {
      const uint32_t __j = __p10bits - __e2;
      
      
      __digits = __mulShift_mod1e9(__m2 << 8, __POW10_SPLIT[__POW10_OFFSET[__idx] + __i],
        static_cast<int32_t>(__j + 8));
      if (__printedDigits != 0) {
        if (__printedDigits + 9 > __precision) {
          __availableDigits = 9;
          break;
        }
        if (_Last - _First < 9) {
          return { _Last, errc::value_too_large };
        }
        __append_nine_digits(__digits, _First);
        _First += 9;
        __printedDigits += 9;
      } else if (__digits != 0) {
        __availableDigits = __decimalLength9(__digits);
        __exp = __i * 9 + static_cast<int32_t>(__availableDigits) - 1;
        if (__availableDigits > __precision) {
          break;
        }
        if (__printDecimalPoint) {
          if (_Last - _First < static_cast<ptrdiff_t>(__availableDigits + 1)) {
            return { _Last, errc::value_too_large };
          }
          __append_d_digits(__availableDigits, __digits, _First);
          _First += __availableDigits + 1; 
        } else {
          if (_First == _Last) {
            return { _Last, errc::value_too_large };
          }
          *_First++ = static_cast<char>('0' + __digits);
        }
        __printedDigits = __availableDigits;
        __availableDigits = 0;
      }
    }
  }

  if (__e2 < 0 && __availableDigits == 0) {
    const int32_t __idx = -__e2 / 16;
    for (int32_t __i = __MIN_BLOCK_2[__idx]; __i < 200; ++__i) {
      const int32_t __j = __ADDITIONAL_BITS_2 + (-__e2 - 16 * __idx);
      const uint32_t __p = __POW10_OFFSET_2[__idx] + static_cast<uint32_t>(__i) - __MIN_BLOCK_2[__idx];
      
      
      __digits = (__p >= __POW10_OFFSET_2[__idx + 1]) ? 0 : __mulShift_mod1e9(__m2 << 8, __POW10_SPLIT_2[__p], __j + 8);
      if (__printedDigits != 0) {
        if (__printedDigits + 9 > __precision) {
          __availableDigits = 9;
          break;
        }
        if (_Last - _First < 9) {
          return { _Last, errc::value_too_large };
        }
        __append_nine_digits(__digits, _First);
        _First += 9;
        __printedDigits += 9;
      } else if (__digits != 0) {
        __availableDigits = __decimalLength9(__digits);
        __exp = -(__i + 1) * 9 + static_cast<int32_t>(__availableDigits) - 1;
        if (__availableDigits > __precision) {
          break;
        }
        if (__printDecimalPoint) {
          if (_Last - _First < static_cast<ptrdiff_t>(__availableDigits + 1)) {
            return { _Last, errc::value_too_large };
          }
          __append_d_digits(__availableDigits, __digits, _First);
          _First += __availableDigits + 1; 
        } else {
          if (_First == _Last) {
            return { _Last, errc::value_too_large };
          }
          *_First++ = static_cast<char>('0' + __digits);
        }
        __printedDigits = __availableDigits;
        __availableDigits = 0;
      }
    }
  }

  const uint32_t __maximum = __precision - __printedDigits;
  if (__availableDigits == 0) {
    __digits = 0;
  }
  uint32_t __lastDigit = 0;
  if (__availableDigits > __maximum) {
    for (uint32_t __k = 0; __k < __availableDigits - __maximum; ++__k) {
      __lastDigit = __digits % 10;
      __digits /= 10;
    }
  }
  
  int __roundUp = 0;
  if (__lastDigit != 5) {
    __roundUp = __lastDigit > 5;
  } else {
    
    
    const int32_t __rexp = static_cast<int32_t>(__precision) - __exp;
    const int32_t __requiredTwos = -__e2 - __rexp;
    bool __trailingZeros = __requiredTwos <= 0
      || (__requiredTwos < 60 && __multipleOfPowerOf2(__m2, static_cast<uint32_t>(__requiredTwos)));
    if (__rexp < 0) {
      const int32_t __requiredFives = -__rexp;
      __trailingZeros = __trailingZeros && __multipleOfPowerOf5(__m2, static_cast<uint32_t>(__requiredFives));
    }
    __roundUp = __trailingZeros ? 2 : 1;
  }
  if (__printedDigits != 0) {
    if (_Last - _First < static_cast<ptrdiff_t>(__maximum)) {
      return { _Last, errc::value_too_large };
    }
    if (__digits == 0) {
      :: memset(_First, '0', __maximum);
    } else {
      __append_c_digits(__maximum, __digits, _First);
    }
    _First += __maximum;
  } else {
    if (__printDecimalPoint) {
      if (_Last - _First < static_cast<ptrdiff_t>(__maximum + 1)) {
        return { _Last, errc::value_too_large };
      }
      __append_d_digits(__maximum, __digits, _First);
      _First += __maximum + 1; 
    } else {
      if (_First == _Last) {
        return { _Last, errc::value_too_large };
      }
      *_First++ = static_cast<char>('0' + __digits);
    }
  }
  if (__roundUp != 0) {
    char* _Round = _First;
    while (true) {
      if (_Round == _Original_first) {
        _Round[0] = '1';
        ++__exp;
        break;
      }
      --_Round;
      const char __c = _Round[0];
      if (__c == '.') {
        
      } else if (__c == '9') {
        _Round[0] = '0';
        __roundUp = 1;
      } else {
        if (__roundUp == 1 || __c % 2 != 0) {
          _Round[0] = static_cast<char>(__c + 1);
        }
        break;
      }
    }
  }

  char _Sign_character;

  if (__exp < 0) {
    _Sign_character = '-';
    __exp = -__exp;
  } else {
    _Sign_character = '+';
  }

  const int _Exponent_part_length = __exp >= 100
    ? 5 
    : 4; 

  if (_Last - _First < _Exponent_part_length) {
    return { _Last, errc::value_too_large };
  }

  *_First++ = 'e';
  *_First++ = _Sign_character;

  if (__exp >= 100) {
    const int32_t __c = __exp % 10;
    :: memcpy(_First, __DIGIT_TABLE<char> + 2 * (__exp / 10), 2);
    _First[2] = static_cast<char>('0' + __c);
    _First += 3;
  } else {
    :: memcpy(_First, __DIGIT_TABLE<char> + 2 * __exp, 2);
    _First += 2;
  }

  return { _First, errc{} };
}





inline constexpr int __FLOAT_MANTISSA_BITS = 23;
inline constexpr int __FLOAT_BIAS = 127;


inline constexpr int __FLOAT_POW5_INV_BITCOUNT = 59;
inline constexpr uint64_t __FLOAT_POW5_INV_SPLIT[31] = {
  576460752303423489u, 461168601842738791u, 368934881474191033u, 295147905179352826u,
  472236648286964522u, 377789318629571618u, 302231454903657294u, 483570327845851670u,
  386856262276681336u, 309485009821345069u, 495176015714152110u, 396140812571321688u,
  316912650057057351u, 507060240091291761u, 405648192073033409u, 324518553658426727u,
  519229685853482763u, 415383748682786211u, 332306998946228969u, 531691198313966350u,
  425352958651173080u, 340282366920938464u, 544451787073501542u, 435561429658801234u,
  348449143727040987u, 557518629963265579u, 446014903970612463u, 356811923176489971u,
  570899077082383953u, 456719261665907162u, 365375409332725730u
};
inline constexpr int __FLOAT_POW5_BITCOUNT = 61;
inline constexpr uint64_t __FLOAT_POW5_SPLIT[47] = {
  1152921504606846976u, 1441151880758558720u, 1801439850948198400u, 2251799813685248000u,
  1407374883553280000u, 1759218604441600000u, 2199023255552000000u, 1374389534720000000u,
  1717986918400000000u, 2147483648000000000u, 1342177280000000000u, 1677721600000000000u,
  2097152000000000000u, 1310720000000000000u, 1638400000000000000u, 2048000000000000000u,
  1280000000000000000u, 1600000000000000000u, 2000000000000000000u, 1250000000000000000u,
  1562500000000000000u, 1953125000000000000u, 1220703125000000000u, 1525878906250000000u,
  1907348632812500000u, 1192092895507812500u, 1490116119384765625u, 1862645149230957031u,
  1164153218269348144u, 1455191522836685180u, 1818989403545856475u, 2273736754432320594u,
  1421085471520200371u, 1776356839400250464u, 2220446049250313080u, 1387778780781445675u,
  1734723475976807094u, 2168404344971008868u, 1355252715606880542u, 1694065894508600678u,
  2117582368135750847u, 1323488980084844279u, 1654361225106055349u, 2067951531382569187u,
  1292469707114105741u, 1615587133892632177u, 2019483917365790221u
};

[[nodiscard]] inline uint32_t __pow5Factor(uint32_t __value) {
  uint32_t __count = 0;
  for (;;) {
    ;
    const uint32_t __q = __value / 5;
    const uint32_t __r = __value % 5;
    if (__r != 0) {
      break;
    }
    __value = __q;
    ++__count;
  }
  return __count;
}


[[nodiscard]] inline bool __multipleOfPowerOf5(const uint32_t __value, const uint32_t __p) {
  return __pow5Factor(__value) >= __p;
}


[[nodiscard]] inline bool __multipleOfPowerOf2(const uint32_t __value, const uint32_t __p) {
  ;
  ;
  
  return (__value & ((1u << __p) - 1)) == 0;
}

[[nodiscard]] inline uint32_t __mulShift(const uint32_t __m, const uint64_t __factor, const int32_t __shift) {
  ;

  
  
  const uint32_t __factorLo = static_cast<uint32_t>(__factor);
  const uint32_t __factorHi = static_cast<uint32_t>(__factor >> 32);
  const uint64_t __bits0 = static_cast<uint64_t>(__m) * __factorLo;
  const uint64_t __bits1 = static_cast<uint64_t>(__m) * __factorHi;












  const uint64_t __sum = (__bits0 >> 32) + __bits1;
  const uint64_t __shiftedSum = __sum >> (__shift - 32);
  ;
  return static_cast<uint32_t>(__shiftedSum);
#line 1035 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
}

[[nodiscard]] inline uint32_t __mulPow5InvDivPow2(const uint32_t __m, const uint32_t __q, const int32_t __j) {
  return __mulShift(__m, __FLOAT_POW5_INV_SPLIT[__q], __j);
}

[[nodiscard]] inline uint32_t __mulPow5divPow2(const uint32_t __m, const uint32_t __i, const int32_t __j) {
  return __mulShift(__m, __FLOAT_POW5_SPLIT[__i], __j);
}


struct __floating_decimal_32 {
  uint32_t __mantissa;
  int32_t __exponent;
};

[[nodiscard]] inline __floating_decimal_32 __f2d(const uint32_t __ieeeMantissa, const uint32_t __ieeeExponent) {
  int32_t __e2;
  uint32_t __m2;
  if (__ieeeExponent == 0) {
    
    __e2 = 1 - __FLOAT_BIAS - __FLOAT_MANTISSA_BITS - 2;
    __m2 = __ieeeMantissa;
  } else {
    __e2 = static_cast<int32_t>(__ieeeExponent) - __FLOAT_BIAS - __FLOAT_MANTISSA_BITS - 2;
    __m2 = (1u << __FLOAT_MANTISSA_BITS) | __ieeeMantissa;
  }
  const bool __even = (__m2 & 1) == 0;
  const bool __acceptBounds = __even;

  
  const uint32_t __mv = 4 * __m2;
  const uint32_t __mp = 4 * __m2 + 2;
  
  const uint32_t __mmShift = __ieeeMantissa != 0 || __ieeeExponent <= 1;
  const uint32_t __mm = 4 * __m2 - 1 - __mmShift;

  
  uint32_t __vr, __vp, __vm;
  int32_t __e10;
  bool __vmIsTrailingZeros = false;
  bool __vrIsTrailingZeros = false;
  uint8_t __lastRemovedDigit = 0;
  if (__e2 >= 0) {
    const uint32_t __q = __log10Pow2(__e2);
    __e10 = static_cast<int32_t>(__q);
    const int32_t __k = __FLOAT_POW5_INV_BITCOUNT + __pow5bits(static_cast<int32_t>(__q)) - 1;
    const int32_t __i = -__e2 + static_cast<int32_t>(__q) + __k;
    __vr = __mulPow5InvDivPow2(__mv, __q, __i);
    __vp = __mulPow5InvDivPow2(__mp, __q, __i);
    __vm = __mulPow5InvDivPow2(__mm, __q, __i);
    if (__q != 0 && (__vp - 1) / 10 <= __vm / 10) {
      
      
      
      const int32_t __l = __FLOAT_POW5_INV_BITCOUNT + __pow5bits(static_cast<int32_t>(__q - 1)) - 1;
      __lastRemovedDigit = static_cast<uint8_t>(__mulPow5InvDivPow2(__mv, __q - 1,
        -__e2 + static_cast<int32_t>(__q) - 1 + __l) % 10);
    }
    if (__q <= 9) {
      
      
      if (__mv % 5 == 0) {
        __vrIsTrailingZeros = __multipleOfPowerOf5(__mv, __q);
      } else if (__acceptBounds) {
        __vmIsTrailingZeros = __multipleOfPowerOf5(__mm, __q);
      } else {
        __vp -= __multipleOfPowerOf5(__mp, __q);
      }
    }
  } else {
    const uint32_t __q = __log10Pow5(-__e2);
    __e10 = static_cast<int32_t>(__q) + __e2;
    const int32_t __i = -__e2 - static_cast<int32_t>(__q);
    const int32_t __k = __pow5bits(__i) - __FLOAT_POW5_BITCOUNT;
    int32_t __j = static_cast<int32_t>(__q) - __k;
    __vr = __mulPow5divPow2(__mv, static_cast<uint32_t>(__i), __j);
    __vp = __mulPow5divPow2(__mp, static_cast<uint32_t>(__i), __j);
    __vm = __mulPow5divPow2(__mm, static_cast<uint32_t>(__i), __j);
    if (__q != 0 && (__vp - 1) / 10 <= __vm / 10) {
      __j = static_cast<int32_t>(__q) - 1 - (__pow5bits(__i + 1) - __FLOAT_POW5_BITCOUNT);
      __lastRemovedDigit = static_cast<uint8_t>(__mulPow5divPow2(__mv, static_cast<uint32_t>(__i + 1), __j) % 10);
    }
    if (__q <= 1) {
      
      
      __vrIsTrailingZeros = true;
      if (__acceptBounds) {
        
        __vmIsTrailingZeros = __mmShift == 1;
      } else {
        
        --__vp;
      }
    } else if (__q < 31) { 
      __vrIsTrailingZeros = __multipleOfPowerOf2(__mv, __q - 1);
    }
  }

  
  int32_t __removed = 0;
  uint32_t _Output;
  if (__vmIsTrailingZeros || __vrIsTrailingZeros) {
    
    while (__vp / 10 > __vm / 10) {



      __vmIsTrailingZeros &= __vm % 10 == 0;
#line 1145 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
      __vrIsTrailingZeros &= __lastRemovedDigit == 0;
      __lastRemovedDigit = static_cast<uint8_t>(__vr % 10);
      __vr /= 10;
      __vp /= 10;
      __vm /= 10;
      ++__removed;
    }
    if (__vmIsTrailingZeros) {
      while (__vm % 10 == 0) {
        __vrIsTrailingZeros &= __lastRemovedDigit == 0;
        __lastRemovedDigit = static_cast<uint8_t>(__vr % 10);
        __vr /= 10;
        __vp /= 10;
        __vm /= 10;
        ++__removed;
      }
    }
    if (__vrIsTrailingZeros && __lastRemovedDigit == 5 && __vr % 2 == 0) {
      
      __lastRemovedDigit = 4;
    }
    
    _Output = __vr + ((__vr == __vm && (!__acceptBounds || !__vmIsTrailingZeros)) || __lastRemovedDigit >= 5);
  } else {
    
    
    
    while (__vp / 10 > __vm / 10) {
      __lastRemovedDigit = static_cast<uint8_t>(__vr % 10);
      __vr /= 10;
      __vp /= 10;
      __vm /= 10;
      ++__removed;
    }
    
    _Output = __vr + (__vr == __vm || __lastRemovedDigit >= 5);
  }
  const int32_t __exp = __e10 + __removed;

  __floating_decimal_32 __fd;
  __fd.__exponent = __exp;
  __fd.__mantissa = _Output;
  return __fd;
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> _Large_integer_to_chars(_CharT* const _First, _CharT* const _Last,
  const uint32_t _Mantissa2, const int32_t _Exponent2) {

  

  
  
  
  
  

  
  

  
  

  ;
  ; 

  
  
  
  

  
  
  
  
  

  constexpr uint32_t _Data_size = 4;
  uint32_t _Data[_Data_size]{};

  
  uint32_t _Maxidx = ((24 + static_cast<uint32_t>(_Exponent2) + 31) / 32) - 1;
  ;

  const uint32_t _Bit_shift = static_cast<uint32_t>(_Exponent2) % 32;
  if (_Bit_shift <= 8) { 
    _Data[_Maxidx] = _Mantissa2 << _Bit_shift;
  } else { 
    _Data[_Maxidx - 1] = _Mantissa2 << _Bit_shift;
    _Data[_Maxidx] = _Mantissa2 >> (32 - _Bit_shift);
  }

  
  
  uint32_t _Blocks[4];
  int32_t _Filled_blocks = 0;
  
  
  
  

  if (_Maxidx != 0) { 
                      
    for (;;) {
      

      const uint32_t _Most_significant_elem = _Data[_Maxidx];
      const uint32_t _Initial_remainder = _Most_significant_elem % 1000000000;
      const uint32_t _Initial_quotient = _Most_significant_elem / 1000000000;
      _Data[_Maxidx] = _Initial_quotient;
      uint64_t _Remainder = _Initial_remainder;

      
      uint32_t _Idx = _Maxidx;
      do {
        --_Idx; 

        
        _Remainder = (_Remainder << 32) | _Data[_Idx];

        
        const uint32_t _Quotient = static_cast<uint32_t>(__div1e9(_Remainder));

        
        
        _Remainder = static_cast<uint32_t>(_Remainder) - 1000000000u * _Quotient;

        _Data[_Idx] = _Quotient;
      } while (_Idx != 0);

      
      _Blocks[_Filled_blocks++] = static_cast<uint32_t>(_Remainder);

      if (_Initial_quotient == 0) { 
        --_Maxidx; 
        if (_Maxidx == 0) {
          break; 
        }
      }
    }
  }

  ;
  for (uint32_t _Idx = 1; _Idx < _Data_size; ++_Idx) {
    ;
  }

  const uint32_t _Data_olength = _Data[0] >= 1000000000 ? 10 : __decimalLength9(_Data[0]);
  const uint32_t _Total_fixed_length = _Data_olength + 9 * _Filled_blocks;

  if (_Last - _First < static_cast<ptrdiff_t>(_Total_fixed_length)) {
    return { _Last, errc::value_too_large };
  }

  _CharT* _Result = _First;

  
  
  __append_n_digits(_Data_olength, _Data[0], _Result);
  _Result += _Data_olength;

  
  for (int32_t _Idx = _Filled_blocks - 1; _Idx >= 0; --_Idx) {
    __append_nine_digits(_Blocks[_Idx], _Result);
    _Result += 9;
  }

  return { _Result, errc{} };
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> __to_chars(_CharT* const _First, _CharT* const _Last, const __floating_decimal_32 __v,
  chars_format _Fmt, const uint32_t __ieeeMantissa, const uint32_t __ieeeExponent) {
  
  uint32_t _Output = __v.__mantissa;
  const int32_t _Ryu_exponent = __v.__exponent;
  const uint32_t __olength = __decimalLength9(_Output);
  int32_t _Scientific_exponent = _Ryu_exponent + static_cast<int32_t>(__olength) - 1;

  if (_Fmt == chars_format{}) {
    int32_t _Lower;
    int32_t _Upper;

    if (__olength == 1) {
      
      
      
      _Lower = -3;
      _Upper = 4;
    } else {
      
      
      
      _Lower = -static_cast<int32_t>(__olength + 3);
      _Upper = 5;
    }

    if (_Lower <= _Ryu_exponent && _Ryu_exponent <= _Upper) {
      _Fmt = chars_format::fixed;
    } else {
      _Fmt = chars_format::scientific;
    }
  } else if (_Fmt == chars_format::general) {
    
    
    
    
    
    if (-4 <= _Scientific_exponent && _Scientific_exponent < 6) {
      _Fmt = chars_format::fixed;
    } else {
      _Fmt = chars_format::scientific;
    }
  }

  if (_Fmt == chars_format::fixed) {
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    const int32_t _Whole_digits = static_cast<int32_t>(__olength) + _Ryu_exponent;

    uint32_t _Total_fixed_length;
    if (_Ryu_exponent >= 0) { 
      _Total_fixed_length = static_cast<uint32_t>(_Whole_digits);
      if (_Output == 1) {
        
        
        
        static constexpr uint8_t _Adjustment[39] = {
          0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,1 };
        _Total_fixed_length -= _Adjustment[_Ryu_exponent];
        
      }
    } else if (_Whole_digits > 0) { 
      _Total_fixed_length = __olength + 1;
    } else { 
      _Total_fixed_length = static_cast<uint32_t>(2 - _Ryu_exponent);
    }

    if (_Last - _First < static_cast<ptrdiff_t>(_Total_fixed_length)) {
      return { _Last, errc::value_too_large };
    }

    _CharT* _Mid;
    if (_Ryu_exponent > 0) { 
      bool _Can_use_ryu;

      if (_Ryu_exponent > 10) { 
        _Can_use_ryu = false;
      } else {
        
        
        

        
        
        
        
        

        

        
        
        

        
        
        

        
        static constexpr uint32_t _Max_shifted_mantissa[11] = {
          16777215, 3355443, 671088, 134217, 26843, 5368, 1073, 214, 42, 8, 1 };

        unsigned long _Trailing_zero_bits;
        (void) _BitScanForward(&_Trailing_zero_bits, __v.__mantissa); 
        const uint32_t _Shifted_mantissa = __v.__mantissa >> _Trailing_zero_bits;
        _Can_use_ryu = _Shifted_mantissa <= _Max_shifted_mantissa[_Ryu_exponent];
      }

      if (!_Can_use_ryu) {
        const uint32_t _Mantissa2 = __ieeeMantissa | (1u << __FLOAT_MANTISSA_BITS); 
        const int32_t _Exponent2 = static_cast<int32_t>(__ieeeExponent)
          - __FLOAT_BIAS - __FLOAT_MANTISSA_BITS; 

        
        return _Large_integer_to_chars(_First, _Last, _Mantissa2, _Exponent2);
      }

      
      
      _Mid = _First + __olength;
    } else { 
      
      _Mid = _First + _Total_fixed_length;
    }

    while (_Output >= 10000) {



      const uint32_t __c = _Output % 10000;
#line 1462 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
      _Output /= 10000;
      const uint32_t __c0 = (__c % 100) << 1;
      const uint32_t __c1 = (__c / 100) << 1;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    }
    if (_Output >= 100) {
      const uint32_t __c = (_Output % 100) << 1;
      _Output /= 100;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    }
    if (_Output >= 10) {
      const uint32_t __c = _Output << 1;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    } else {
      *--_Mid = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + _Output);
    }

    if (_Ryu_exponent > 0) { 
      
      ::std:: fill_n(_First + __olength, _Ryu_exponent, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    } else if (_Ryu_exponent == 0) { 
      
    } else if (_Whole_digits > 0) { 
      
      :: memmove(_First, _First + 1, static_cast<size_t>(_Whole_digits) * sizeof(_CharT));
      _First[_Whole_digits] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
    } else { 
      
      _First[0] = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
      _First[1] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
      ::std:: fill_n(_First + 2, -_Whole_digits, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    }

    return { _First + _Total_fixed_length, errc{} };
  }

  const uint32_t _Total_scientific_length =
    __olength + (__olength > 1) + 4; 
  if (_Last - _First < static_cast<ptrdiff_t>(_Total_scientific_length)) {
    return { _Last, errc::value_too_large };
  }
  _CharT* const __result = _First;

  
  uint32_t __i = 0;
  while (_Output >= 10000) {



    const uint32_t __c = _Output % 10000;
#line 1514 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
    _Output /= 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    :: memcpy(__result + __olength - __i - 1, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 3, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    __i += 4;
  }
  if (_Output >= 100) {
    const uint32_t __c = (_Output % 100) << 1;
    _Output /= 100;
    :: memcpy(__result + __olength - __i - 1, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    __i += 2;
  }
  if (_Output >= 10) {
    const uint32_t __c = _Output << 1;
    
    __result[2] = __DIGIT_TABLE<_CharT>[__c + 1];
    __result[0] = __DIGIT_TABLE<_CharT>[__c];
  } else {
    __result[0] = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + _Output);
  }

  
  uint32_t __index;
  if (__olength > 1) {
    __result[1] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
    __index = __olength + 1;
  } else {
    __index = 1;
  }

  
  __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? 'e' : L'e');
  if (_Scientific_exponent < 0) {
    __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? '-' : L'-');
    _Scientific_exponent = -_Scientific_exponent;
  } else {
    __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? '+' : L'+');
  }

  :: memcpy(__result + __index, __DIGIT_TABLE<_CharT> + 2 * _Scientific_exponent, 2 * sizeof(_CharT));
  __index += 2;

  return { _First + _Total_scientific_length, errc{} };
}

[[nodiscard]] inline to_chars_result _Convert_to_chars_result(const pair<char*, errc>& _Pair) {
    return {_Pair.first, _Pair.second};
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> __f2s_buffered_n(_CharT* const _First, _CharT* const _Last, const float __f,
  const chars_format _Fmt) {

  
  const uint32_t __bits = __float_to_bits(__f);

  
  if (__bits == 0) {
    if (_Fmt == chars_format::scientific) {
      if (_Last - _First < 5) {
        return { _Last, errc::value_too_large };
      }

      if constexpr (is_same_v<_CharT, char>) {
        :: memcpy(_First, "0e+00", 5);
      } else {
        :: memcpy(_First, L"0e+00", 5 * sizeof(wchar_t));
      }

      return { _First + 5, errc{} };
    }

    
    if (_First == _Last) {
      return { _Last, errc::value_too_large };
    }

    *_First = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');

    return { _First + 1, errc{} };
  }

  
  const uint32_t __ieeeMantissa = __bits & ((1u << __FLOAT_MANTISSA_BITS) - 1);
  const uint32_t __ieeeExponent = __bits >> __FLOAT_MANTISSA_BITS;

  
  
  if (_Fmt == chars_format::fixed) {
    const uint32_t _Mantissa2 = __ieeeMantissa | (1u << __FLOAT_MANTISSA_BITS); 
    const int32_t _Exponent2 = static_cast<int32_t>(__ieeeExponent)
      - __FLOAT_BIAS - __FLOAT_MANTISSA_BITS; 

    
    

    if (_Exponent2 > 0) {
      return _Large_integer_to_chars(_First, _Last, _Mantissa2, _Exponent2);
    }
  }

  const __floating_decimal_32 __v = __f2d(__ieeeMantissa, __ieeeExponent);
  return __to_chars(_First, _Last, __v, _Fmt, __ieeeMantissa, __ieeeExponent);
}












































[[nodiscard]] inline uint64_t __mulShift(const uint64_t __m, const uint64_t* const __mul, const int32_t __j) {
  
  uint64_t __high1;                                               
  const uint64_t __low1 = __ryu_umul128(__m, __mul[1], &__high1); 
  uint64_t __high0;                                               
  (void) __ryu_umul128(__m, __mul[0], &__high0);                  
  const uint64_t __sum = __high0 + __low1;
  if (__sum < __high0) {
    ++__high1; 
  }
  return __ryu_shiftright128(__sum, __high1, static_cast<uint32_t>(__j - 64));
}

[[nodiscard]] inline uint64_t __mulShiftAll(const uint64_t __m, const uint64_t* const __mul, const int32_t __j,
  uint64_t* const __vp, uint64_t* const __vm, const uint32_t __mmShift) {
  *__vp = __mulShift(4 * __m + 2, __mul, __j);
  *__vm = __mulShift(4 * __m - 1 - __mmShift, __mul, __j);
  return __mulShift(4 * __m, __mul, __j);
}




































#line 1719 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"

[[nodiscard]] inline uint32_t __decimalLength17(const uint64_t __v) {
  
  
  
  
  ;
  if (__v >= 10000000000000000u) { return 17; }
  if (__v >= 1000000000000000u) { return 16; }
  if (__v >= 100000000000000u) { return 15; }
  if (__v >= 10000000000000u) { return 14; }
  if (__v >= 1000000000000u) { return 13; }
  if (__v >= 100000000000u) { return 12; }
  if (__v >= 10000000000u) { return 11; }
  if (__v >= 1000000000u) { return 10; }
  if (__v >= 100000000u) { return 9; }
  if (__v >= 10000000u) { return 8; }
  if (__v >= 1000000u) { return 7; }
  if (__v >= 100000u) { return 6; }
  if (__v >= 10000u) { return 5; }
  if (__v >= 1000u) { return 4; }
  if (__v >= 100u) { return 3; }
  if (__v >= 10u) { return 2; }
  return 1;
}


struct __floating_decimal_64 {
  uint64_t __mantissa;
  int32_t __exponent;
};

[[nodiscard]] inline __floating_decimal_64 __d2d(const uint64_t __ieeeMantissa, const uint32_t __ieeeExponent) {
  int32_t __e2;
  uint64_t __m2;
  if (__ieeeExponent == 0) {
    
    __e2 = 1 - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS - 2;
    __m2 = __ieeeMantissa;
  } else {
    __e2 = static_cast<int32_t>(__ieeeExponent) - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS - 2;
    __m2 = (1ull << __DOUBLE_MANTISSA_BITS) | __ieeeMantissa;
  }
  const bool __even = (__m2 & 1) == 0;
  const bool __acceptBounds = __even;

  
  const uint64_t __mv = 4 * __m2;
  
  const uint32_t __mmShift = __ieeeMantissa != 0 || __ieeeExponent <= 1;
  
  
  

  
  uint64_t __vr, __vp, __vm;
  int32_t __e10;
  bool __vmIsTrailingZeros = false;
  bool __vrIsTrailingZeros = false;
  if (__e2 >= 0) {
    
    
    const uint32_t __q = __log10Pow2(__e2) - (__e2 > 3);
    __e10 = static_cast<int32_t>(__q);
    const int32_t __k = __DOUBLE_POW5_INV_BITCOUNT + __pow5bits(static_cast<int32_t>(__q)) - 1;
    const int32_t __i = -__e2 + static_cast<int32_t>(__q) + __k;
    __vr = __mulShiftAll(__m2, __DOUBLE_POW5_INV_SPLIT[__q], __i, &__vp, &__vm, __mmShift);
    if (__q <= 21) {
      
      
      
      const uint32_t __mvMod5 = static_cast<uint32_t>(__mv) - 5 * static_cast<uint32_t>(__div5(__mv));
      if (__mvMod5 == 0) {
        __vrIsTrailingZeros = __multipleOfPowerOf5(__mv, __q);
      } else if (__acceptBounds) {
        
        
        
        __vmIsTrailingZeros = __multipleOfPowerOf5(__mv - 1 - __mmShift, __q);
      } else {
        
        __vp -= __multipleOfPowerOf5(__mv + 2, __q);
      }
    }
  } else {
    
    const uint32_t __q = __log10Pow5(-__e2) - (-__e2 > 1);
    __e10 = static_cast<int32_t>(__q) + __e2;
    const int32_t __i = -__e2 - static_cast<int32_t>(__q);
    const int32_t __k = __pow5bits(__i) - __DOUBLE_POW5_BITCOUNT;
    const int32_t __j = static_cast<int32_t>(__q) - __k;
    __vr = __mulShiftAll(__m2, __DOUBLE_POW5_SPLIT[__i], __j, &__vp, &__vm, __mmShift);
    if (__q <= 1) {
      
      
      __vrIsTrailingZeros = true;
      if (__acceptBounds) {
        
        __vmIsTrailingZeros = __mmShift == 1;
      } else {
        
        --__vp;
      }
    } else if (__q < 63) { 
      
      
      
      
      
      __vrIsTrailingZeros = __multipleOfPowerOf2(__mv, __q - 1);
    }
  }

  
  int32_t __removed = 0;
  uint8_t __lastRemovedDigit = 0;
  uint64_t _Output;
  
  if (__vmIsTrailingZeros || __vrIsTrailingZeros) {
    
    for (;;) {
      const uint64_t __vpDiv10 = __div10(__vp);
      const uint64_t __vmDiv10 = __div10(__vm);
      if (__vpDiv10 <= __vmDiv10) {
        break;
      }
      const uint32_t __vmMod10 = static_cast<uint32_t>(__vm) - 10 * static_cast<uint32_t>(__vmDiv10);
      const uint64_t __vrDiv10 = __div10(__vr);
      const uint32_t __vrMod10 = static_cast<uint32_t>(__vr) - 10 * static_cast<uint32_t>(__vrDiv10);
      __vmIsTrailingZeros &= __vmMod10 == 0;
      __vrIsTrailingZeros &= __lastRemovedDigit == 0;
      __lastRemovedDigit = static_cast<uint8_t>(__vrMod10);
      __vr = __vrDiv10;
      __vp = __vpDiv10;
      __vm = __vmDiv10;
      ++__removed;
    }
    if (__vmIsTrailingZeros) {
      for (;;) {
        const uint64_t __vmDiv10 = __div10(__vm);
        const uint32_t __vmMod10 = static_cast<uint32_t>(__vm) - 10 * static_cast<uint32_t>(__vmDiv10);
        if (__vmMod10 != 0) {
          break;
        }
        const uint64_t __vpDiv10 = __div10(__vp);
        const uint64_t __vrDiv10 = __div10(__vr);
        const uint32_t __vrMod10 = static_cast<uint32_t>(__vr) - 10 * static_cast<uint32_t>(__vrDiv10);
        __vrIsTrailingZeros &= __lastRemovedDigit == 0;
        __lastRemovedDigit = static_cast<uint8_t>(__vrMod10);
        __vr = __vrDiv10;
        __vp = __vpDiv10;
        __vm = __vmDiv10;
        ++__removed;
      }
    }
    if (__vrIsTrailingZeros && __lastRemovedDigit == 5 && __vr % 2 == 0) {
      
      __lastRemovedDigit = 4;
    }
    
    _Output = __vr + ((__vr == __vm && (!__acceptBounds || !__vmIsTrailingZeros)) || __lastRemovedDigit >= 5);
  } else {
    
    bool __roundUp = false;
    const uint64_t __vpDiv100 = __div100(__vp);
    const uint64_t __vmDiv100 = __div100(__vm);
    if (__vpDiv100 > __vmDiv100) { 
      const uint64_t __vrDiv100 = __div100(__vr);
      const uint32_t __vrMod100 = static_cast<uint32_t>(__vr) - 100 * static_cast<uint32_t>(__vrDiv100);
      __roundUp = __vrMod100 >= 50;
      __vr = __vrDiv100;
      __vp = __vpDiv100;
      __vm = __vmDiv100;
      __removed += 2;
    }
    
    
    
    
    for (;;) {
      const uint64_t __vpDiv10 = __div10(__vp);
      const uint64_t __vmDiv10 = __div10(__vm);
      if (__vpDiv10 <= __vmDiv10) {
        break;
      }
      const uint64_t __vrDiv10 = __div10(__vr);
      const uint32_t __vrMod10 = static_cast<uint32_t>(__vr) - 10 * static_cast<uint32_t>(__vrDiv10);
      __roundUp = __vrMod10 >= 5;
      __vr = __vrDiv10;
      __vp = __vpDiv10;
      __vm = __vmDiv10;
      ++__removed;
    }
    
    _Output = __vr + (__vr == __vm || __roundUp);
  }
  const int32_t __exp = __e10 + __removed;

  __floating_decimal_64 __fd;
  __fd.__exponent = __exp;
  __fd.__mantissa = _Output;
  return __fd;
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> __to_chars(_CharT* const _First, _CharT* const _Last, const __floating_decimal_64 __v,
  chars_format _Fmt, const double __f) {
  
  uint64_t _Output = __v.__mantissa;
  const int32_t _Ryu_exponent = __v.__exponent;
  const uint32_t __olength = __decimalLength17(_Output);
  int32_t _Scientific_exponent = _Ryu_exponent + static_cast<int32_t>(__olength) - 1;

  if (_Fmt == chars_format{}) {
    int32_t _Lower;
    int32_t _Upper;

    if (__olength == 1) {
      
      
      
      _Lower = -3;
      _Upper = 4;
    } else {
      
      
      
      _Lower = -static_cast<int32_t>(__olength + 3);
      _Upper = 5;
    }

    if (_Lower <= _Ryu_exponent && _Ryu_exponent <= _Upper) {
      _Fmt = chars_format::fixed;
    } else {
      _Fmt = chars_format::scientific;
    }
  } else if (_Fmt == chars_format::general) {
    
    
    
    
    
    if (-4 <= _Scientific_exponent && _Scientific_exponent < 6) {
      _Fmt = chars_format::fixed;
    } else {
      _Fmt = chars_format::scientific;
    }
  }

  if (_Fmt == chars_format::fixed) {
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    const int32_t _Whole_digits = static_cast<int32_t>(__olength) + _Ryu_exponent;

    uint32_t _Total_fixed_length;
    if (_Ryu_exponent >= 0) { 
      _Total_fixed_length = static_cast<uint32_t>(_Whole_digits);
      if (_Output == 1) {
        
        
        
        static constexpr uint8_t _Adjustment[309] = {
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0,
          1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,
          1,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,0,1,0,1,1,0,1,
          1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,
          0,1,0,1,0,1,1,1,0,0,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,
          1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,1,1,0,
          0,1,0,1,1,1,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,0,1,0 };
        _Total_fixed_length -= _Adjustment[_Ryu_exponent];
        
      }
    } else if (_Whole_digits > 0) { 
      _Total_fixed_length = __olength + 1;
    } else { 
      _Total_fixed_length = static_cast<uint32_t>(2 - _Ryu_exponent);
    }

    if (_Last - _First < static_cast<ptrdiff_t>(_Total_fixed_length)) {
      return { _Last, errc::value_too_large };
    }

    _CharT* _Mid;
    if (_Ryu_exponent > 0) { 
      bool _Can_use_ryu;

      if (_Ryu_exponent > 22) { 
        _Can_use_ryu = false;
      } else {
        
        
        

        
        
        
        
        

        

        
        
        

        
        
        

        
        static constexpr uint64_t _Max_shifted_mantissa[23] = {
          9007199254740991u, 1801439850948198u, 360287970189639u, 72057594037927u, 14411518807585u,
          2882303761517u, 576460752303u, 115292150460u, 23058430092u, 4611686018u, 922337203u, 184467440u,
          36893488u, 7378697u, 1475739u, 295147u, 59029u, 11805u, 2361u, 472u, 94u, 18u, 3u };

        unsigned long _Trailing_zero_bits;

        (void) _BitScanForward64(&_Trailing_zero_bits, __v.__mantissa); 









#line 2062 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
        const uint64_t _Shifted_mantissa = __v.__mantissa >> _Trailing_zero_bits;
        _Can_use_ryu = _Shifted_mantissa <= _Max_shifted_mantissa[_Ryu_exponent];
      }

      if (!_Can_use_ryu) {
        
        
        
        return __d2fixed_buffered_n(_First, _Last, __f, 0);
      }

      
      
      _Mid = _First + __olength;
    } else { 
      
      _Mid = _First + _Total_fixed_length;
    }

    
    
    
    
    if ((_Output >> 32) != 0) {
      
      const uint64_t __q = __div1e8(_Output);
      uint32_t __output2 = static_cast<uint32_t>(_Output - 100000000 * __q);
      _Output = __q;

      const uint32_t __c = __output2 % 10000;
      __output2 /= 10000;
      const uint32_t __d = __output2 % 10000;
      const uint32_t __c0 = (__c % 100) << 1;
      const uint32_t __c1 = (__c / 100) << 1;
      const uint32_t __d0 = (__d % 100) << 1;
      const uint32_t __d1 = (__d / 100) << 1;

      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __d0, 2 * sizeof(_CharT));
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __d1, 2 * sizeof(_CharT));
    }
    uint32_t __output2 = static_cast<uint32_t>(_Output);
    while (__output2 >= 10000) {



      const uint32_t __c = __output2 % 10000;
#line 2111 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
      __output2 /= 10000;
      const uint32_t __c0 = (__c % 100) << 1;
      const uint32_t __c1 = (__c / 100) << 1;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    }
    if (__output2 >= 100) {
      const uint32_t __c = (__output2 % 100) << 1;
      __output2 /= 100;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    }
    if (__output2 >= 10) {
      const uint32_t __c = __output2 << 1;
      :: memcpy(_Mid -= 2, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    } else {
      *--_Mid = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + __output2);
    }

    if (_Ryu_exponent > 0) { 
      
      ::std:: fill_n(_First + __olength, _Ryu_exponent, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    } else if (_Ryu_exponent == 0) { 
      
    } else if (_Whole_digits > 0) { 
      
      :: memmove(_First, _First + 1, static_cast<size_t>(_Whole_digits) * sizeof(_CharT));
      _First[_Whole_digits] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
    } else { 
      
      _First[0] = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');
      _First[1] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
      ::std:: fill_n(_First + 2, -_Whole_digits, static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0'));
    }

    return { _First + _Total_fixed_length, errc{} };
  }

  const uint32_t _Total_scientific_length = __olength + (__olength > 1) 
    + (-100 < _Scientific_exponent && _Scientific_exponent < 100 ? 4 : 5); 
  if (_Last - _First < static_cast<ptrdiff_t>(_Total_scientific_length)) {
    return { _Last, errc::value_too_large };
  }
  _CharT* const __result = _First;

  
  uint32_t __i = 0;
  
  
  
  
  if ((_Output >> 32) != 0) {
    
    const uint64_t __q = __div1e8(_Output);
    uint32_t __output2 = static_cast<uint32_t>(_Output) - 100000000 * static_cast<uint32_t>(__q);
    _Output = __q;

    const uint32_t __c = __output2 % 10000;
    __output2 /= 10000;
    const uint32_t __d = __output2 % 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    const uint32_t __d0 = (__d % 100) << 1;
    const uint32_t __d1 = (__d / 100) << 1;
    :: memcpy(__result + __olength - __i - 1, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 3, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 5, __DIGIT_TABLE<_CharT> + __d0, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 7, __DIGIT_TABLE<_CharT> + __d1, 2 * sizeof(_CharT));
    __i += 8;
  }
  uint32_t __output2 = static_cast<uint32_t>(_Output);
  while (__output2 >= 10000) {



    const uint32_t __c = __output2 % 10000;
#line 2187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
    __output2 /= 10000;
    const uint32_t __c0 = (__c % 100) << 1;
    const uint32_t __c1 = (__c / 100) << 1;
    :: memcpy(__result + __olength - __i - 1, __DIGIT_TABLE<_CharT> + __c0, 2 * sizeof(_CharT));
    :: memcpy(__result + __olength - __i - 3, __DIGIT_TABLE<_CharT> + __c1, 2 * sizeof(_CharT));
    __i += 4;
  }
  if (__output2 >= 100) {
    const uint32_t __c = (__output2 % 100) << 1;
    __output2 /= 100;
    :: memcpy(__result + __olength - __i - 1, __DIGIT_TABLE<_CharT> + __c, 2 * sizeof(_CharT));
    __i += 2;
  }
  if (__output2 >= 10) {
    const uint32_t __c = __output2 << 1;
    
    __result[2] = __DIGIT_TABLE<_CharT>[__c + 1];
    __result[0] = __DIGIT_TABLE<_CharT>[__c];
  } else {
    __result[0] = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + __output2);
  }

  
  uint32_t __index;
  if (__olength > 1) {
    __result[1] = static_cast<_CharT>(is_same_v<_CharT, char> ? '.' : L'.');
    __index = __olength + 1;
  } else {
    __index = 1;
  }

  
  __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? 'e' : L'e');
  if (_Scientific_exponent < 0) {
    __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? '-' : L'-');
    _Scientific_exponent = -_Scientific_exponent;
  } else {
    __result[__index++] = static_cast<_CharT>(is_same_v<_CharT, char> ? '+' : L'+');
  }

  if (_Scientific_exponent >= 100) {
    const int32_t __c = _Scientific_exponent % 10;
    :: memcpy(__result + __index, __DIGIT_TABLE<_CharT> + 2 * (_Scientific_exponent / 10), 2 * sizeof(_CharT));
    __result[__index + 2] = static_cast<_CharT>(static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0') + __c);
    __index += 3;
  } else {
    :: memcpy(__result + __index, __DIGIT_TABLE<_CharT> + 2 * _Scientific_exponent, 2 * sizeof(_CharT));
    __index += 2;
  }

  return { _First + _Total_scientific_length, errc{} };
}

[[nodiscard]] inline bool __d2d_small_int(const uint64_t __ieeeMantissa, const uint32_t __ieeeExponent,
  __floating_decimal_64* const __v) {
  const uint64_t __m2 = (1ull << __DOUBLE_MANTISSA_BITS) | __ieeeMantissa;
  const int32_t __e2 = static_cast<int32_t>(__ieeeExponent) - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS;

  if (__e2 > 0) {
    
    
    return false;
  }

  if (__e2 < -52) {
    
    return false;
  }

  
  
  const uint64_t __mask = (1ull << -__e2) - 1;
  const uint64_t __fraction = __m2 & __mask;
  if (__fraction != 0) {
    return false;
  }

  
  
  
  __v->__mantissa = __m2 >> -__e2;
  __v->__exponent = 0;
  return true;
}

template <class _CharT>
[[nodiscard]] pair<_CharT*, errc> __d2s_buffered_n(_CharT* const _First, _CharT* const _Last, const double __f,
  const chars_format _Fmt) {

  
  const uint64_t __bits = __double_to_bits(__f);

  
  if (__bits == 0) {
    if (_Fmt == chars_format::scientific) {
      if (_Last - _First < 5) {
        return { _Last, errc::value_too_large };
      }

      if constexpr (is_same_v<_CharT, char>) {
        :: memcpy(_First, "0e+00", 5);
      } else {
        :: memcpy(_First, L"0e+00", 5 * sizeof(wchar_t));
      }

      return { _First + 5, errc{} };
    }

    
    if (_First == _Last) {
      return { _Last, errc::value_too_large };
    }

    *_First = static_cast<_CharT>(is_same_v<_CharT, char> ? '0' : L'0');

    return { _First + 1, errc{} };
  }

  
  const uint64_t __ieeeMantissa = __bits & ((1ull << __DOUBLE_MANTISSA_BITS) - 1);
  const uint32_t __ieeeExponent = static_cast<uint32_t>(__bits >> __DOUBLE_MANTISSA_BITS);

  if (_Fmt == chars_format::fixed) {
    
    const int32_t _Exponent2 = static_cast<int32_t>(__ieeeExponent)
      - __DOUBLE_BIAS - __DOUBLE_MANTISSA_BITS; 

    
    

    
    
    
    
    

    
    
    
    
    if (_Exponent2 > 0) {
      return __d2fixed_buffered_n(_First, _Last, __f, 0);
    }
  }

  __floating_decimal_64 __v;
  const bool __isSmallInt = __d2d_small_int(__ieeeMantissa, __ieeeExponent, &__v);
  if (__isSmallInt) {
    
    
    
    
    for (;;) {
      const uint64_t __q = __div10(__v.__mantissa);
      const uint32_t __r = static_cast<uint32_t>(__v.__mantissa) - 10 * static_cast<uint32_t>(__q);
      if (__r != 0) {
        break;
      }
      __v.__mantissa = __q;
      ++__v.__exponent;
    }
  } else {
    __v = __d2d(__ieeeMantissa, __ieeeExponent);
  }

  return __to_chars(_First, _Last, __v, _Fmt, __f);
}





template <class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars_ryu(
    char* const _First, char* const _Last, const _Floating _Value, const chars_format _Fmt) noexcept {
    if constexpr (is_same_v<_Floating, float>) {
        return _Convert_to_chars_result(__f2s_buffered_n(_First, _Last, _Value, _Fmt));
    } else {
        return _Convert_to_chars_result(__d2s_buffered_n(_First, _Last, _Value, _Fmt));
    }
}

template <class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars_scientific_precision(
    char* const _First, char* const _Last, const _Floating _Value, int _Precision) noexcept {

    
    
    

    if (_Precision < 0) {
        _Precision = 6;
    } else if (_Precision < 1'000'000'000) {
        
    } else {
        
        
        return {_Last, errc::value_too_large};
    }

    return __d2exp_buffered_n(_First, _Last, _Value, static_cast<uint32_t>(_Precision));
}

template <class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars_fixed_precision(
    char* const _First, char* const _Last, const _Floating _Value, int _Precision) noexcept {

    
    
    

    if (_Precision < 0) {
        _Precision = 6;
    } else if (_Precision < 1'000'000'000) {
        
    } else {
        
        
        return {_Last, errc::value_too_large};
    }

    return _Convert_to_chars_result(__d2fixed_buffered_n(_First, _Last, _Value, static_cast<uint32_t>(_Precision)));
}

}






#pragma warning(pop)
#pragma pack(pop)

#line 2422 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
#line 2423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_ryu.h"
#pragma external_header(pop)
#line 18 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_tables.h"












#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_tables.h"



#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )


























































namespace std {

template <class _Floating>
struct _General_precision_tables_2;

template <>
struct _General_precision_tables_2<float> {
    static constexpr int _Max_special_P = 7;

    static const uint32_t _Special_X_table[63];

    static constexpr int _Max_P = 39;

    static const uint32_t _Ordinary_X_table[44];
};

template <>
struct _General_precision_tables_2<double> {
    static constexpr int _Max_special_P = 15;

    static const uint64_t _Special_X_table[195];

    static constexpr int _Max_P = 309;

    static const uint64_t _Ordinary_X_table[314];
};

}



#pragma warning(pop)
#pragma pack(pop)

#line 113 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_tables.h"
#line 114 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xcharconv_tables.h"
#pragma external_header(pop)
#line 19 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"




#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )






namespace std {
inline constexpr char _Charconv_digits[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e',
    'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
;

template <class _RawTy>
[[nodiscard]] constexpr to_chars_result _Integer_to_chars(
    char* _First, char* const _Last, const _RawTy _Raw_value, const int _Base) noexcept {
    _Adl_verify_range(_First, _Last);
    ;

    using _Unsigned = make_unsigned_t<_RawTy>;

    _Unsigned _Value = static_cast<_Unsigned>(_Raw_value);

    if constexpr (is_signed_v<_RawTy>) {
        if (_Raw_value < 0) {
            if (_First == _Last) {
                return {_Last, errc::value_too_large};
            }

            *_First++ = '-';

            _Value = static_cast<_Unsigned>(0 - _Value);
        }
    }

    constexpr size_t _Buff_size = sizeof(_Unsigned) * 8; 
    char _Buff[_Buff_size];
    char* const _Buff_end = _Buff + _Buff_size;
    char* _RNext          = _Buff_end;

    switch (_Base) {
    case 10:
        { 
            
            constexpr bool _Use_chunks = sizeof(_Unsigned) > sizeof(size_t);

            if constexpr (_Use_chunks) { 
                                         
                while (_Value > 0xFFFF'FFFFU) {
                    
                    unsigned long _Chunk = static_cast<unsigned long>(_Value % 1'000'000'000);
                    _Value               = static_cast<_Unsigned>(_Value / 1'000'000'000);

                    for (int _Idx = 0; _Idx != 9; ++_Idx) {
                        *--_RNext = static_cast<char>('0' + _Chunk % 10);
                        _Chunk /= 10;
                    }
                }
            }

            using _Truncated = conditional_t<_Use_chunks, unsigned long, _Unsigned>;

            _Truncated _Trunc = static_cast<_Truncated>(_Value);

            do {
                *--_RNext = static_cast<char>('0' + _Trunc % 10);
                _Trunc /= 10;
            } while (_Trunc != 0);
            break;
        }

    case 2:
        do {
            *--_RNext = static_cast<char>('0' + (_Value & 0b1));
            _Value >>= 1;
        } while (_Value != 0);
        break;

    case 4:
        do {
            *--_RNext = static_cast<char>('0' + (_Value & 0b11));
            _Value >>= 2;
        } while (_Value != 0);
        break;

    case 8:
        do {
            *--_RNext = static_cast<char>('0' + (_Value & 0b111));
            _Value >>= 3;
        } while (_Value != 0);
        break;

    case 16:
        do {
            *--_RNext = _Charconv_digits[_Value & 0b1111];
            _Value >>= 4;
        } while (_Value != 0);
        break;

    case 32:
        do {
            *--_RNext = _Charconv_digits[_Value & 0b11111];
            _Value >>= 5;
        } while (_Value != 0);
        break;

    case 3:
    case 5:
    case 6:
    case 7:
    case 9:
        do {
            *--_RNext = static_cast<char>('0' + _Value % _Base);
            _Value    = static_cast<_Unsigned>(_Value / _Base);
        } while (_Value != 0);
        break;

    default:
        do {
            *--_RNext = _Charconv_digits[_Value % _Base];
            _Value    = static_cast<_Unsigned>(_Value / _Base);
        } while (_Value != 0);
        break;
    }

    const ptrdiff_t _Digits_written = _Buff_end - _RNext;

    if (_Last - _First < _Digits_written) {
        return {_Last, errc::value_too_large};
    }

    _Copy_n_unchecked4(_RNext, _Digits_written, _First);

    return {_First + _Digits_written, errc{}};
}

 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const char _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const signed char _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(char* const _First, char* const _Last, const unsigned char _Value,
    const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const short _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(char* const _First, char* const _Last, const unsigned short _Value,
    const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const int _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(char* const _First, char* const _Last, const unsigned int _Value,
    const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const long _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(char* const _First, char* const _Last, const unsigned long _Value,
    const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(
    char* const _First, char* const _Last, const long long _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}
 constexpr to_chars_result to_chars(char* const _First, char* const _Last,
    const unsigned long long _Value, const int _Base = 10) noexcept  {
    return _Integer_to_chars(_First, _Last, _Value, _Base);
}

 to_chars_result to_chars(char* _First, char* _Last, bool _Value, int _Base = 10) = delete;

 struct from_chars_result {
    const char* ptr;
    errc ec;

    [[nodiscard]] friend bool operator==(const from_chars_result&, const from_chars_result&) = default;
#line 213 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
};


inline constexpr unsigned char _Digit_from_byte[] = {255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255,
    255, 255, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
    255, 255, 255, 255, 255, 255, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
    31, 32, 33, 34, 35, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
;

[[nodiscard]] constexpr unsigned char _Digit_from_char(const char _Ch) noexcept {
    
    return _Digit_from_byte[static_cast<unsigned char>(_Ch)];
}

template <class _RawTy>
[[nodiscard]] constexpr from_chars_result _Integer_from_chars(
    const char* const _First, const char* const _Last, _RawTy& _Raw_value, const int _Base) noexcept {
    _Adl_verify_range(_First, _Last);
    ;

    bool _Minus_sign = false;

    const char* _Next = _First;

    if constexpr (is_signed_v<_RawTy>) {
        if (_Next != _Last && *_Next == '-') {
            _Minus_sign = true;
            ++_Next;
        }
    }

    using _Unsigned = make_unsigned_t<_RawTy>;

    constexpr _Unsigned _Uint_max    = static_cast<_Unsigned>(-1);
    constexpr _Unsigned _Int_max     = static_cast<_Unsigned>(_Uint_max >> 1);
#pragma warning(push)
#pragma warning(disable : 26450) 
    constexpr _Unsigned _Abs_int_min = static_cast<_Unsigned>(_Int_max + 1);
#pragma warning(pop)

    _Unsigned _Risky_val;
    _Unsigned _Max_digit;

    if constexpr (is_signed_v<_RawTy>) {
        if (_Minus_sign) {
            _Risky_val = static_cast<_Unsigned>(_Abs_int_min / _Base);
            _Max_digit = static_cast<_Unsigned>(_Abs_int_min % _Base);
        } else {
            _Risky_val = static_cast<_Unsigned>(_Int_max / _Base);
            _Max_digit = static_cast<_Unsigned>(_Int_max % _Base);
        }
    } else {
        _Risky_val = static_cast<_Unsigned>(_Uint_max / _Base);
        _Max_digit = static_cast<_Unsigned>(_Uint_max % _Base);
    }

    _Unsigned _Value = 0;

    bool _Overflowed = false;

    for (; _Next != _Last; ++_Next) {
        const unsigned char _Digit = _Digit_from_char(*_Next);

        if (_Digit >= _Base) {
            break;
        }

        if (_Value < _Risky_val 
            || (_Value == _Risky_val && _Digit <= _Max_digit)) { 
            _Value = static_cast<_Unsigned>(_Value * _Base + _Digit);
        } else { 
            _Overflowed = true; 
        }
    }

    if (_Next - _First == static_cast<ptrdiff_t>(_Minus_sign)) {
        return {_First, errc::invalid_argument};
    }

    if (_Overflowed) {
        return {_Next, errc::result_out_of_range};
    }

    if constexpr (is_signed_v<_RawTy>) {
        if (_Minus_sign) {
            _Value = static_cast<_Unsigned>(0 - _Value);
        }
    }

    _Raw_value = static_cast<_RawTy>(_Value); 

    return {_Next, errc{}};
}

 constexpr from_chars_result from_chars(
    const char* const _First, const char* const _Last, char& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    signed char& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    unsigned char& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last, short& _Value,
    const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    unsigned short& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(
    const char* const _First, const char* const _Last, int& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    unsigned int& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(
    const char* const _First, const char* const _Last, long& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    unsigned long& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    long long& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}
 constexpr from_chars_result from_chars(const char* const _First, const char* const _Last,
    unsigned long long& _Value, const int _Base = 10) noexcept  {
    return _Integer_from_chars(_First, _Last, _Value, _Base);
}









































struct _Big_integer_flt {
#pragma warning(push)
#pragma warning(disable : 26495) 
                                 
    _Big_integer_flt() noexcept : _Myused(0) {}
#pragma warning(pop)

    _Big_integer_flt(const _Big_integer_flt& _Other) noexcept : _Myused(_Other._Myused) {
        :: memcpy(_Mydata, _Other._Mydata, _Other._Myused * sizeof(uint32_t));
    }

    _Big_integer_flt& operator=(const _Big_integer_flt& _Other) noexcept {
        _Myused = _Other._Myused;
        :: memmove(_Mydata, _Other._Mydata, _Other._Myused * sizeof(uint32_t));
        return *this;
    }

    [[nodiscard]] bool operator<(const _Big_integer_flt& _Rhs) const noexcept {
        if (_Myused != _Rhs._Myused) {
            return _Myused < _Rhs._Myused;
        }

        for (uint32_t _Ix = _Myused - 1; _Ix != static_cast<uint32_t>(-1); --_Ix) {
            if (_Mydata[_Ix] != _Rhs._Mydata[_Ix]) {
                return _Mydata[_Ix] < _Rhs._Mydata[_Ix];
            }
        }

        return false;
    }

    static constexpr uint32_t _Maximum_bits = 1074 
                                            + 2552 
                                            + 54; 

    static constexpr uint32_t _Element_bits = 32;

    static constexpr uint32_t _Element_count = (_Maximum_bits + _Element_bits - 1) / _Element_bits;

    uint32_t _Myused; 
    uint32_t _Mydata[_Element_count]; 
};

[[nodiscard]] inline _Big_integer_flt _Make_big_integer_flt_one() noexcept {
    _Big_integer_flt _Xval{};
    _Xval._Mydata[0] = 1;
    _Xval._Myused    = 1;
    return _Xval;
}

[[nodiscard]] inline uint32_t _Bit_scan_reverse(const _Big_integer_flt& _Xval) noexcept {
    if (_Xval._Myused == 0) {
        return 0;
    }

    const uint32_t _Bx = _Xval._Myused - 1;

    unsigned long _Index; 

    ; 
    _BitScanReverse(&_Index, _Xval._Mydata[_Bx]); 

    return _Index + 1 + _Bx * _Big_integer_flt::_Element_bits;
}



[[nodiscard]] inline bool _Shift_left(_Big_integer_flt& _Xval, const uint32_t _Nx) noexcept {
    if (_Xval._Myused == 0) {
        return true;
    }

    const uint32_t _Unit_shift = _Nx / _Big_integer_flt::_Element_bits;
    const uint32_t _Bit_shift  = _Nx % _Big_integer_flt::_Element_bits;

    if (_Xval._Myused + _Unit_shift > _Big_integer_flt::_Element_count) {
        
        _Xval._Myused = 0;
        return false;
    }

    if (_Bit_shift == 0) {
        :: memmove(_Xval._Mydata + _Unit_shift, _Xval._Mydata, _Xval._Myused * sizeof(uint32_t));
        _Xval._Myused += _Unit_shift;
    } else {
        const bool _Bit_shifts_into_next_unit =
            _Bit_shift > (_Big_integer_flt::_Element_bits - _Bit_scan_reverse(_Xval._Mydata[_Xval._Myused - 1]));

        const uint32_t _New_used = _Xval._Myused + _Unit_shift + static_cast<uint32_t>(_Bit_shifts_into_next_unit);

        if (_New_used > _Big_integer_flt::_Element_count) {
            
            _Xval._Myused = 0;
            return false;
        }

        const uint32_t _Msb_bits = _Bit_shift;
        const uint32_t _Lsb_bits = _Big_integer_flt::_Element_bits - _Msb_bits;

        const uint32_t _Lsb_mask = (1UL << _Lsb_bits) - 1UL;
        const uint32_t _Msb_mask = ~_Lsb_mask;

        
        for (uint32_t _Dest_index = _New_used - 1; _Dest_index != _Unit_shift - 1; --_Dest_index) {
            

            
            const uint32_t _Upper_source_index = _Dest_index - _Unit_shift;

            
            const uint32_t _Lower_source_index = _Dest_index - _Unit_shift - 1;

            const uint32_t _Upper_source = _Upper_source_index < _Xval._Myused ? _Xval._Mydata[_Upper_source_index] : 0;
            const uint32_t _Lower_source = _Lower_source_index < _Xval._Myused ? _Xval._Mydata[_Lower_source_index] : 0;

            const uint32_t _Shifted_upper_source = (_Upper_source & _Lsb_mask) << _Msb_bits;
            const uint32_t _Shifted_lower_source = (_Lower_source & _Msb_mask) >> _Lsb_bits;

            const uint32_t _Combined_shifted_source = _Shifted_upper_source | _Shifted_lower_source;

            _Xval._Mydata[_Dest_index] = _Combined_shifted_source;
        }

        _Xval._Myused = _New_used;
    }

    :: memset(_Xval._Mydata, 0, _Unit_shift * sizeof(uint32_t));

    return true;
}



[[nodiscard]] inline bool _Add(_Big_integer_flt& _Xval, const uint32_t _Value) noexcept {
    if (_Value == 0) {
        return true;
    }

    uint32_t _Carry = _Value;
    for (uint32_t _Ix = 0; _Ix != _Xval._Myused; ++_Ix) {
        const uint64_t _Result = static_cast<uint64_t>(_Xval._Mydata[_Ix]) + _Carry;
        _Xval._Mydata[_Ix]     = static_cast<uint32_t>(_Result);
        _Carry                 = static_cast<uint32_t>(_Result >> 32);
    }

    if (_Carry != 0) {
        if (_Xval._Myused < _Big_integer_flt::_Element_count) {
            _Xval._Mydata[_Xval._Myused] = _Carry;
            ++_Xval._Myused;
        } else {
            _Xval._Myused = 0;
            return false;
        }
    }

    return true;
}

[[nodiscard]] inline uint32_t _Add_carry(uint32_t& _Ux1, const uint32_t _Ux2, const uint32_t _U_carry) noexcept {
    const uint64_t _Uu = static_cast<uint64_t>(_Ux1) + _Ux2 + _U_carry;
    _Ux1               = static_cast<uint32_t>(_Uu);
    return static_cast<uint32_t>(_Uu >> 32);
}

[[nodiscard]] inline uint32_t _Add_multiply_carry(
    uint32_t& _U_add, const uint32_t _U_mul_1, const uint32_t _U_mul_2, const uint32_t _U_carry) noexcept {
    const uint64_t _Uu_res = static_cast<uint64_t>(_U_mul_1) * _U_mul_2 + _U_add + _U_carry;
    _U_add                 = static_cast<uint32_t>(_Uu_res);
    return static_cast<uint32_t>(_Uu_res >> 32);
}

[[nodiscard]] inline uint32_t _Multiply_core(
    uint32_t* const _Multiplicand, const uint32_t _Multiplicand_count, const uint32_t _Multiplier) noexcept {
    uint32_t _Carry = 0;
    for (uint32_t _Ix = 0; _Ix != _Multiplicand_count; ++_Ix) {
        const uint64_t _Result = static_cast<uint64_t>(_Multiplicand[_Ix]) * _Multiplier + _Carry;
        _Multiplicand[_Ix]     = static_cast<uint32_t>(_Result);
        _Carry                 = static_cast<uint32_t>(_Result >> 32);
    }

    return _Carry;
}



[[nodiscard]] inline bool _Multiply(_Big_integer_flt& _Multiplicand, const uint32_t _Multiplier) noexcept {
    if (_Multiplier == 0) {
        _Multiplicand._Myused = 0;
        return true;
    }

    if (_Multiplier == 1) {
        return true;
    }

    if (_Multiplicand._Myused == 0) {
        return true;
    }

    const uint32_t _Carry = _Multiply_core(_Multiplicand._Mydata, _Multiplicand._Myused, _Multiplier);
    if (_Carry != 0) {
        if (_Multiplicand._Myused < _Big_integer_flt::_Element_count) {
            _Multiplicand._Mydata[_Multiplicand._Myused] = _Carry;
            ++_Multiplicand._Myused;
        } else {
            _Multiplicand._Myused = 0;
            return false;
        }
    }

    return true;
}





[[nodiscard]] inline bool _Multiply(_Big_integer_flt& _Multiplicand, const _Big_integer_flt& _Multiplier) noexcept {
    if (_Multiplicand._Myused == 0) {
        return true;
    }

    if (_Multiplier._Myused == 0) {
        _Multiplicand._Myused = 0;
        return true;
    }

    if (_Multiplier._Myused == 1) {
        return _Multiply(_Multiplicand, _Multiplier._Mydata[0]); 
    }

    if (_Multiplicand._Myused == 1) {
        const uint32_t _Small_multiplier = _Multiplicand._Mydata[0];
        _Multiplicand                    = _Multiplier;
        return _Multiply(_Multiplicand, _Small_multiplier); 
    }

    
    const bool _Multiplier_is_shorter = _Multiplier._Myused < _Multiplicand._Myused;
    const uint32_t* const _Rgu1       = _Multiplier_is_shorter ? _Multiplier._Mydata : _Multiplicand._Mydata;
    const uint32_t* const _Rgu2       = _Multiplier_is_shorter ? _Multiplicand._Mydata : _Multiplier._Mydata;

    const uint32_t _Cu1 = _Multiplier_is_shorter ? _Multiplier._Myused : _Multiplicand._Myused;
    const uint32_t _Cu2 = _Multiplier_is_shorter ? _Multiplicand._Myused : _Multiplier._Myused;

    _Big_integer_flt _Result{};
    for (uint32_t _Iu1 = 0; _Iu1 != _Cu1; ++_Iu1) {
        const uint32_t _U_cur = _Rgu1[_Iu1];
        if (_U_cur == 0) {
            if (_Iu1 == _Result._Myused) {
                _Result._Mydata[_Iu1] = 0;
                _Result._Myused       = _Iu1 + 1;
            }

            continue;
        }

        uint32_t _U_carry = 0;
        uint32_t _Iu_res  = _Iu1;
        for (uint32_t _Iu2 = 0; _Iu2 != _Cu2 && _Iu_res != _Big_integer_flt::_Element_count; ++_Iu2, ++_Iu_res) {
            if (_Iu_res == _Result._Myused) {
                _Result._Mydata[_Iu_res] = 0;
                _Result._Myused          = _Iu_res + 1;
            }

            _U_carry = _Add_multiply_carry(_Result._Mydata[_Iu_res], _U_cur, _Rgu2[_Iu2], _U_carry);
        }

        while (_U_carry != 0 && _Iu_res != _Big_integer_flt::_Element_count) {
            if (_Iu_res == _Result._Myused) {
                _Result._Mydata[_Iu_res] = 0;
                _Result._Myused          = _Iu_res + 1;
            }

            _U_carry = _Add_carry(_Result._Mydata[_Iu_res++], 0, _U_carry);
        }

        if (_Iu_res == _Big_integer_flt::_Element_count) {
            _Multiplicand._Myused = 0;
            return false;
        }
    }

    
    _Multiplicand = _Result;
    return true;
}

extern const uint32_t _Large_power_data[578];



[[nodiscard]] inline bool _Multiply_by_power_of_ten(_Big_integer_flt& _Xval, const uint32_t _Power) noexcept {
    
    
    
    
    

    
    

    struct _Unpack_index {
        uint16_t _Offset; 
        uint8_t _Zeroes; 
        uint8_t _Size; 
    };

    static constexpr _Unpack_index _Large_power_indices[] = {{0, 0, 2}, {2, 0, 3}, {5, 0, 4}, {9, 1, 4}, {13, 1, 5},
        {18, 1, 6}, {24, 2, 6}, {30, 2, 7}, {37, 2, 8}, {45, 3, 8}, {53, 3, 9}, {62, 3, 10}, {72, 4, 10}, {82, 4, 11},
        {93, 4, 12}, {105, 5, 12}, {117, 5, 13}, {130, 5, 14}, {144, 5, 15}, {159, 6, 15}, {174, 6, 16}, {190, 6, 17},
        {207, 7, 17}, {224, 7, 18}, {242, 7, 19}, {261, 8, 19}, {280, 8, 21}, {301, 8, 22}, {323, 9, 22}, {345, 9, 23},
        {368, 9, 24}, {392, 10, 24}, {416, 10, 25}, {441, 10, 26}, {467, 10, 27}, {494, 11, 27}, {521, 11, 28},
        {549, 11, 29}};

    for (uint32_t _Large_power = _Power / 10; _Large_power != 0;) {
        const uint32_t _Current_power =
            (::std:: min)(_Large_power, static_cast<uint32_t>(::std:: size(_Large_power_indices)));

        const _Unpack_index& _Index = _Large_power_indices[_Current_power - 1];
        _Big_integer_flt _Multiplier{};
        _Multiplier._Myused = static_cast<uint32_t>(_Index._Size + _Index._Zeroes);

        const uint32_t* const _Source = _Large_power_data + _Index._Offset;

        :: memset(_Multiplier._Mydata, 0, _Index._Zeroes * sizeof(uint32_t));
        :: memcpy(_Multiplier._Mydata + _Index._Zeroes, _Source, _Index._Size * sizeof(uint32_t));

        if (!_Multiply(_Xval, _Multiplier)) { 
            return false;
        }

        _Large_power -= _Current_power;
    }

    static constexpr uint32_t _Small_powers_of_ten[9] = {
        10, 100, 1'000, 10'000, 100'000, 1'000'000, 10'000'000, 100'000'000, 1'000'000'000};

    const uint32_t _Small_power = _Power % 10;

    if (_Small_power == 0) {
        return true;
    }

    return _Multiply(_Xval, _Small_powers_of_ten[_Small_power - 1]); 
}


[[nodiscard]] inline uint32_t _Count_sequential_high_zeroes(const uint32_t _Ux) noexcept {
    unsigned long _Index; 
    return _BitScanReverse(&_Index, _Ux) ? 31 - _Index : 32;
}





[[nodiscard]] inline uint64_t _Divide(_Big_integer_flt& _Numerator, const _Big_integer_flt& _Denominator) noexcept {
    
    if (_Numerator._Myused == 0) {
        return 0;
    }

    
    ; 

    uint32_t _Max_numerator_element_index         = _Numerator._Myused - 1;
    const uint32_t _Max_denominator_element_index = _Denominator._Myused - 1;

    
    
    if (_Max_denominator_element_index == 0) {
        const uint32_t _Small_denominator = _Denominator._Mydata[0];

        if (_Max_numerator_element_index == 0) {
            const uint32_t _Small_numerator = _Numerator._Mydata[0];

            if (_Small_denominator == 1) {
                _Numerator._Myused = 0;
                return _Small_numerator;
            }

            _Numerator._Mydata[0] = _Small_numerator % _Small_denominator;
            _Numerator._Myused    = _Numerator._Mydata[0] > 0 ? 1u : 0u;
            return _Small_numerator / _Small_denominator;
        }

        if (_Small_denominator == 1) {
            uint64_t _Quotient = _Numerator._Mydata[1];
            _Quotient <<= 32;
            _Quotient |= _Numerator._Mydata[0];
            _Numerator._Myused = 0;
            return _Quotient;
        }

        
        uint64_t _Quotient = 0;

        uint64_t _Uu = 0;
        for (uint32_t _Iv = _Max_numerator_element_index; _Iv != static_cast<uint32_t>(-1); --_Iv) {
            _Uu       = (_Uu << 32) | _Numerator._Mydata[_Iv];
            _Quotient = (_Quotient << 32) + static_cast<uint32_t>(_Uu / _Small_denominator);
            _Uu %= _Small_denominator;
        }

        _Numerator._Mydata[1] = static_cast<uint32_t>(_Uu >> 32);
        _Numerator._Mydata[0] = static_cast<uint32_t>(_Uu);

        if (_Numerator._Mydata[1] > 0) {
            _Numerator._Myused = 2u;
        } else if (_Numerator._Mydata[0] > 0) {
            _Numerator._Myused = 1u;
        } else {
            _Numerator._Myused = 0u;
        }

        return _Quotient;
    }

    if (_Max_denominator_element_index > _Max_numerator_element_index) {
        return 0;
    }

    const uint32_t _Cu_den = _Max_denominator_element_index + 1;
    const int32_t _Cu_diff = static_cast<int32_t>(_Max_numerator_element_index - _Max_denominator_element_index);

    
    int32_t _Cu_quo = _Cu_diff;
    for (int32_t _Iu = static_cast<int32_t>(_Max_numerator_element_index);; --_Iu) {
        if (_Iu < _Cu_diff) {
            ++_Cu_quo;
            break;
        }

        if (_Denominator._Mydata[_Iu - _Cu_diff] != _Numerator._Mydata[_Iu]) {
            if (_Denominator._Mydata[_Iu - _Cu_diff] < _Numerator._Mydata[_Iu]) {
                ++_Cu_quo;
            }

            break;
        }
    }

    if (_Cu_quo == 0) {
        return 0;
    }

    
    uint32_t _U_den      = _Denominator._Mydata[_Cu_den - 1];
    uint32_t _U_den_next = _Denominator._Mydata[_Cu_den - 2];

    const uint32_t _Cbit_shift_left  = _Count_sequential_high_zeroes(_U_den);
    const uint32_t _Cbit_shift_right = 32 - _Cbit_shift_left;
    if (_Cbit_shift_left > 0) {
        _U_den = (_U_den << _Cbit_shift_left) | (_U_den_next >> _Cbit_shift_right);
        _U_den_next <<= _Cbit_shift_left;

        if (_Cu_den > 2) {
            _U_den_next |= _Denominator._Mydata[_Cu_den - 3] >> _Cbit_shift_right;
        }
    }

    uint64_t _Quotient = 0;
    for (int32_t _Iu = _Cu_quo; --_Iu >= 0;) {
        
        const uint32_t _U_num_hi =
            (_Iu + _Cu_den <= _Max_numerator_element_index) ? _Numerator._Mydata[_Iu + _Cu_den] : 0;

        uint64_t _Uu_num =
            (static_cast<uint64_t>(_U_num_hi) << 32) | static_cast<uint64_t>(_Numerator._Mydata[_Iu + _Cu_den - 1]);

        uint32_t _U_num_next = _Numerator._Mydata[_Iu + _Cu_den - 2];
        if (_Cbit_shift_left > 0) {
            _Uu_num = (_Uu_num << _Cbit_shift_left) | (_U_num_next >> _Cbit_shift_right);
            _U_num_next <<= _Cbit_shift_left;

            if (_Iu + _Cu_den >= 3) {
                _U_num_next |= _Numerator._Mydata[_Iu + _Cu_den - 3] >> _Cbit_shift_right;
            }
        }

        
        uint64_t _Uu_quo = _Uu_num / _U_den;
        uint64_t _Uu_rem = static_cast<uint32_t>(_Uu_num % _U_den);

        if (_Uu_quo > 0xffffffffui32) {
            _Uu_rem += _U_den * (_Uu_quo - 0xffffffffui32);
            _Uu_quo = 0xffffffffui32;
        }

        while (_Uu_rem <= 0xffffffffui32 && _Uu_quo * _U_den_next > ((_Uu_rem << 32) | _U_num_next)) {
            --_Uu_quo;
            _Uu_rem += _U_den;
        }

        
        
        if (_Uu_quo > 0) {
            uint64_t _Uu_borrow = 0;

            for (uint32_t _Iu2 = 0; _Iu2 < _Cu_den; ++_Iu2) {
                _Uu_borrow += _Uu_quo * _Denominator._Mydata[_Iu2];

                const uint32_t _U_sub = static_cast<uint32_t>(_Uu_borrow);
                _Uu_borrow >>= 32;
                if (_Numerator._Mydata[_Iu + _Iu2] < _U_sub) {
                    ++_Uu_borrow;
                }

                _Numerator._Mydata[_Iu + _Iu2] -= _U_sub;
            }

            if (_U_num_hi < _Uu_borrow) {
                
                uint32_t _U_carry = 0;
                for (uint32_t _Iu2 = 0; _Iu2 < _Cu_den; ++_Iu2) {
                    const uint64_t _Sum = static_cast<uint64_t>(_Numerator._Mydata[_Iu + _Iu2])
                                        + static_cast<uint64_t>(_Denominator._Mydata[_Iu2]) + _U_carry;

                    _Numerator._Mydata[_Iu + _Iu2] = static_cast<uint32_t>(_Sum);
                    _U_carry                       = static_cast<uint32_t>(_Sum >> 32);
                }

                --_Uu_quo;
            }

            _Max_numerator_element_index = _Iu + _Cu_den - 1;
        }

        _Quotient = (_Quotient << 32) + static_cast<uint32_t>(_Uu_quo);
    }

    
    uint32_t _Used = _Max_numerator_element_index + 1;

    while (_Used != 0 && _Numerator._Mydata[_Used - 1] == 0) {
        --_Used;
    }

    _Numerator._Myused = _Used;

    return _Quotient;
}






















struct _Floating_point_string {
    bool _Myis_negative;
    int32_t _Myexponent;
    uint32_t _Mymantissa_count;
    uint8_t _Mymantissa[768];
};


template <class _FloatingType>
void _Assemble_floating_point_zero(const bool _Is_negative, _FloatingType& _Result) noexcept {
    using _Floating_traits = _Floating_type_traits<_FloatingType>;
    using _Uint_type       = typename _Floating_traits::_Uint_type;

    _Uint_type _Sign_component = _Is_negative;
    _Sign_component <<= _Floating_traits::_Sign_shift;

    _Result = _Bit_cast<_FloatingType>(_Sign_component);
}


template <class _FloatingType>
void _Assemble_floating_point_infinity(const bool _Is_negative, _FloatingType& _Result) noexcept {
    using _Floating_traits = _Floating_type_traits<_FloatingType>;
    using _Uint_type       = typename _Floating_traits::_Uint_type;

    _Uint_type _Sign_component = _Is_negative;
    _Sign_component <<= _Floating_traits::_Sign_shift;

    constexpr _Uint_type _Exponent_component = _Floating_traits::_Shifted_exponent_mask;

    _Result = _Bit_cast<_FloatingType>(_Sign_component | _Exponent_component);
}










[[nodiscard]] inline bool _Should_round_up(
    const bool _Lsb_bit, const bool _Round_bit, const bool _Has_tail_bits) noexcept {
    
    
    
    
    

    
    
    
    
    return _Round_bit && (_Has_tail_bits || _Lsb_bit);
}




[[nodiscard]] inline uint64_t _Right_shift_with_rounding(
    const uint64_t _Value, const uint32_t _Shift, const bool _Has_zero_tail) noexcept {
    constexpr uint32_t _Total_number_of_bits = 64;
    if (_Shift >= _Total_number_of_bits) {
        if (_Shift == _Total_number_of_bits) {
#pragma warning(push)
#pragma warning(disable : 26454) 
            constexpr uint64_t _Extra_bits_mask = (1ULL << (_Total_number_of_bits - 1)) - 1;
#pragma warning(pop)
            constexpr uint64_t _Round_bit_mask  = (1ULL << (_Total_number_of_bits - 1));

            const bool _Round_bit = (_Value & _Round_bit_mask) != 0;
            const bool _Tail_bits = !_Has_zero_tail || (_Value & _Extra_bits_mask) != 0;

            
            
            return static_cast<uint64_t>(_Round_bit && _Tail_bits);
        } else {
            
            return 0;
        }
    }

    
    
    
    

    
    
    

    

    
    
    
    

    
    
    const uint64_t _Lsb_bit = _Value;

    
    
    const uint64_t _Round_bit = _Value << 1;

    
    
    
    
    

    
    
    
    
    const uint64_t _Has_tail_bits = _Round_bit - static_cast<uint64_t>(_Has_zero_tail);

    
    
    const uint64_t _Should_round = ((_Round_bit & (_Has_tail_bits | _Lsb_bit)) >> _Shift) & uint64_t{1};

    
    return (_Value >> _Shift) + _Should_round;
}











template <class _FloatingType>
void _Assemble_floating_point_value_no_shift(const bool _Is_negative, const int32_t _Exponent,
    const typename _Floating_type_traits<_FloatingType>::_Uint_type _Mantissa, _FloatingType& _Result) noexcept {
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    using _Floating_traits = _Floating_type_traits<_FloatingType>;
    using _Uint_type       = typename _Floating_traits::_Uint_type;

    _Uint_type _Sign_component = _Is_negative;
    _Sign_component <<= _Floating_traits::_Sign_shift;

    _Uint_type _Exponent_component = static_cast<uint32_t>(_Exponent + (_Floating_traits::_Exponent_bias - 1));
    _Exponent_component <<= _Floating_traits::_Exponent_shift;

    _Result = _Bit_cast<_FloatingType>(_Sign_component | (_Exponent_component + _Mantissa));
}














template <class _FloatingType>
[[nodiscard]] errc _Assemble_floating_point_value(const uint64_t _Initial_mantissa, const int32_t _Initial_exponent,
    const bool _Is_negative, const bool _Has_zero_tail, _FloatingType& _Result) noexcept {
    using _Traits = _Floating_type_traits<_FloatingType>;

    
    
    
    const uint32_t _Initial_mantissa_bits = _Bit_scan_reverse(_Initial_mantissa);
    const int32_t _Normal_mantissa_shift  = static_cast<int32_t>(_Traits::_Mantissa_bits - _Initial_mantissa_bits);
    const int32_t _Normal_exponent        = _Initial_exponent - _Normal_mantissa_shift;

    if (_Normal_exponent > _Traits::_Maximum_binary_exponent) {
        
        _Assemble_floating_point_infinity(_Is_negative, _Result);
        return errc::result_out_of_range; 
    }

    uint64_t _Mantissa = _Initial_mantissa;
    int32_t _Exponent  = _Normal_exponent;
    errc _Error_code{};

    if (_Normal_exponent < _Traits::_Minimum_binary_exponent) {
        
        

        
        
        _Exponent = _Traits::_Minimum_binary_exponent;

        
        const int32_t _Denormal_mantissa_shift = _Initial_exponent - _Exponent;

        if (_Denormal_mantissa_shift < 0) {
            _Mantissa =
                _Right_shift_with_rounding(_Mantissa, static_cast<uint32_t>(-_Denormal_mantissa_shift), _Has_zero_tail);

            
            
            if (_Mantissa == 0) {
                _Error_code = errc::result_out_of_range; 
            }

            
            
            
            
            
            

            
            

            
            
        } else {
            _Mantissa <<= _Denormal_mantissa_shift;
        }
    } else {
        if (_Normal_mantissa_shift < 0) {
            _Mantissa =
                _Right_shift_with_rounding(_Mantissa, static_cast<uint32_t>(-_Normal_mantissa_shift), _Has_zero_tail);

            
            
            

            
            
            if (_Mantissa > _Traits::_Normal_mantissa_mask && _Exponent == _Traits::_Maximum_binary_exponent) {
                _Error_code = errc::result_out_of_range; 
                                                         
            }
        } else {
            _Mantissa <<= _Normal_mantissa_shift;
        }
    }

    
    using _Uint_type = typename _Traits::_Uint_type;

    _Assemble_floating_point_value_no_shift(_Is_negative, _Exponent, static_cast<_Uint_type>(_Mantissa), _Result);

    return _Error_code;
}





template <class _FloatingType>
[[nodiscard]] errc _Assemble_floating_point_value_from_big_integer_flt(const _Big_integer_flt& _Integer_value,
    const uint32_t _Integer_bits_of_precision, const bool _Is_negative, const bool _Has_nonzero_fractional_part,
    _FloatingType& _Result) noexcept {
    using _Traits = _Floating_type_traits<_FloatingType>;

    constexpr int32_t _Base_exponent = _Traits::_Mantissa_bits - 1;

    
    
    if (_Integer_bits_of_precision <= 64) {
        constexpr int32_t _Exponent = _Base_exponent;

        const uint32_t _Mantissa_low  = _Integer_value._Myused > 0 ? _Integer_value._Mydata[0] : 0;
        const uint32_t _Mantissa_high = _Integer_value._Myused > 1 ? _Integer_value._Mydata[1] : 0;
        const uint64_t _Mantissa      = _Mantissa_low + (static_cast<uint64_t>(_Mantissa_high) << 32);

        return _Assemble_floating_point_value(
            _Mantissa, _Exponent, _Is_negative, !_Has_nonzero_fractional_part, _Result);
    }

    const uint32_t _Top_element_bits  = _Integer_bits_of_precision % 32;
    const uint32_t _Top_element_index = _Integer_bits_of_precision / 32;

    const uint32_t _Middle_element_index = _Top_element_index - 1;
    const uint32_t _Bottom_element_index = _Top_element_index - 2;

    
    if (_Top_element_bits == 0) {
        const int32_t _Exponent = static_cast<int32_t>(_Base_exponent + _Bottom_element_index * 32);

        const uint64_t _Mantissa = _Integer_value._Mydata[_Bottom_element_index]
                                 + (static_cast<uint64_t>(_Integer_value._Mydata[_Middle_element_index]) << 32);

        bool _Has_zero_tail = !_Has_nonzero_fractional_part;
        for (uint32_t _Ix = 0; _Has_zero_tail && _Ix != _Bottom_element_index; ++_Ix) {
            _Has_zero_tail = _Integer_value._Mydata[_Ix] == 0;
        }

        return _Assemble_floating_point_value(_Mantissa, _Exponent, _Is_negative, _Has_zero_tail, _Result);
    }

    
    const uint32_t _Top_element_mask  = (1u << _Top_element_bits) - 1;
    const uint32_t _Top_element_shift = 64 - _Top_element_bits; 

    const uint32_t _Middle_element_shift = _Top_element_shift - 32; 

    const uint32_t _Bottom_element_bits  = 32 - _Top_element_bits;
    const uint32_t _Bottom_element_mask  = ~_Top_element_mask;
    const uint32_t _Bottom_element_shift = 32 - _Bottom_element_bits; 

    const int32_t _Exponent = static_cast<int32_t>(_Base_exponent + _Bottom_element_index * 32 + _Top_element_bits);

    const uint64_t _Mantissa =
        (static_cast<uint64_t>(_Integer_value._Mydata[_Top_element_index] & _Top_element_mask) << _Top_element_shift)
        + (static_cast<uint64_t>(_Integer_value._Mydata[_Middle_element_index]) << _Middle_element_shift)
        + (static_cast<uint64_t>(_Integer_value._Mydata[_Bottom_element_index] & _Bottom_element_mask)
            >> _Bottom_element_shift);

    bool _Has_zero_tail =
        !_Has_nonzero_fractional_part && (_Integer_value._Mydata[_Bottom_element_index] & _Top_element_mask) == 0;

    for (uint32_t _Ix = 0; _Has_zero_tail && _Ix != _Bottom_element_index; ++_Ix) {
        _Has_zero_tail = _Integer_value._Mydata[_Ix] == 0;
    }

    return _Assemble_floating_point_value(_Mantissa, _Exponent, _Is_negative, _Has_zero_tail, _Result);
}



inline void _Accumulate_decimal_digits_into_big_integer_flt(
    const uint8_t* const _First_digit, const uint8_t* const _Last_digit, _Big_integer_flt& _Result) noexcept {
    
    
    uint32_t _Accumulator       = 0;
    uint32_t _Accumulator_count = 0;
    for (const uint8_t* _It = _First_digit; _It != _Last_digit; ++_It) {
        if (_Accumulator_count == 9) {
            [[maybe_unused]] const bool _Success1 = _Multiply(_Result, 1'000'000'000); 
            ;
            [[maybe_unused]] const bool _Success2 = _Add(_Result, _Accumulator); 
            ;

            _Accumulator       = 0;
            _Accumulator_count = 0;
        }

        _Accumulator *= 10;
        _Accumulator += *_It;
        ++_Accumulator_count;
    }

    if (_Accumulator_count != 0) {
        [[maybe_unused]] const bool _Success3 =
            _Multiply_by_power_of_ten(_Result, _Accumulator_count); 
        ;
        [[maybe_unused]] const bool _Success4 = _Add(_Result, _Accumulator); 
        ;
    }
}




template <class _FloatingType>
[[nodiscard]] errc _Convert_decimal_string_to_floating_type(
    const _Floating_point_string& _Data, _FloatingType& _Result, bool _Has_zero_tail) noexcept {
    using _Traits = _Floating_type_traits<_FloatingType>;

    
    
    
    constexpr uint32_t _Required_bits_of_precision = static_cast<uint32_t>(_Traits::_Mantissa_bits + 1);

    
    
    
    
    
    const uint32_t _Positive_exponent      = static_cast<uint32_t>((::std:: max)(0, _Data._Myexponent));
    const uint32_t _Integer_digits_present = (::std:: min)(_Positive_exponent, _Data._Mymantissa_count);
    const uint32_t _Integer_digits_missing = _Positive_exponent - _Integer_digits_present;
    const uint8_t* const _Integer_first    = _Data._Mymantissa;
    const uint8_t* const _Integer_last     = _Data._Mymantissa + _Integer_digits_present;

    const uint8_t* const _Fractional_first    = _Integer_last;
    const uint8_t* const _Fractional_last     = _Data._Mymantissa + _Data._Mymantissa_count;
    const uint32_t _Fractional_digits_present = static_cast<uint32_t>(_Fractional_last - _Fractional_first);

    
    _Big_integer_flt _Integer_value{};
    _Accumulate_decimal_digits_into_big_integer_flt(_Integer_first, _Integer_last, _Integer_value);

    if (_Integer_digits_missing > 0) {
        if (!_Multiply_by_power_of_ten(_Integer_value, _Integer_digits_missing)) {
            _Assemble_floating_point_infinity(_Data._Myis_negative, _Result);
            return errc::result_out_of_range; 
        }
    }

    
    
    
    const uint32_t _Integer_bits_of_precision = _Bit_scan_reverse(_Integer_value);
    {
        const bool _Has_zero_fractional_part = _Fractional_digits_present == 0 && _Has_zero_tail;

        if (_Integer_bits_of_precision >= _Required_bits_of_precision || _Has_zero_fractional_part) {
            return _Assemble_floating_point_value_from_big_integer_flt(
                _Integer_value, _Integer_bits_of_precision, _Data._Myis_negative, !_Has_zero_fractional_part, _Result);
        }
    }

    
    
    
    
    
    _Big_integer_flt _Fractional_numerator{};
    _Accumulate_decimal_digits_into_big_integer_flt(_Fractional_first, _Fractional_last, _Fractional_numerator);

    const uint32_t _Fractional_denominator_exponent =
        _Data._Myexponent < 0 ? _Fractional_digits_present + static_cast<uint32_t>(-_Data._Myexponent)
                              : _Fractional_digits_present;

    _Big_integer_flt _Fractional_denominator = _Make_big_integer_flt_one();
    if (!_Multiply_by_power_of_ten(_Fractional_denominator, _Fractional_denominator_exponent)) {
        
        
        _Assemble_floating_point_zero(_Data._Myis_negative, _Result);
        return errc::result_out_of_range; 
    }

    
    
    
    
    const uint32_t _Fractional_numerator_bits   = _Bit_scan_reverse(_Fractional_numerator);
    const uint32_t _Fractional_denominator_bits = _Bit_scan_reverse(_Fractional_denominator);

    const uint32_t _Fractional_shift = _Fractional_denominator_bits > _Fractional_numerator_bits
                                         ? _Fractional_denominator_bits - _Fractional_numerator_bits
                                         : 0;

    if (_Fractional_shift > 0) {
        [[maybe_unused]] const bool _Shift_success1 =
            _Shift_left(_Fractional_numerator, _Fractional_shift); 
        ;
    }

    const uint32_t _Required_fractional_bits_of_precision = _Required_bits_of_precision - _Integer_bits_of_precision;

    uint32_t _Remaining_bits_of_precision_required = _Required_fractional_bits_of_precision;
    if (_Integer_bits_of_precision > 0) {
        
        
        
        

        
        
        
        
        if (_Fractional_shift > _Remaining_bits_of_precision_required) {
            return _Assemble_floating_point_value_from_big_integer_flt(_Integer_value, _Integer_bits_of_precision,
                _Data._Myis_negative, _Fractional_digits_present != 0 || !_Has_zero_tail, _Result);
        }

        _Remaining_bits_of_precision_required -= _Fractional_shift;
    }

    
    
    
    const uint32_t _Fractional_exponent =
        _Fractional_numerator < _Fractional_denominator ? _Fractional_shift + 1 : _Fractional_shift;

    [[maybe_unused]] const bool _Shift_success2 =
        _Shift_left(_Fractional_numerator, _Remaining_bits_of_precision_required); 
    ;

    uint64_t _Fractional_mantissa = _Divide(_Fractional_numerator, _Fractional_denominator);

    _Has_zero_tail = _Has_zero_tail && _Fractional_numerator._Myused == 0;

    
    const uint32_t _Fractional_mantissa_bits = _Bit_scan_reverse(_Fractional_mantissa);
    if (_Fractional_mantissa_bits > _Required_fractional_bits_of_precision) {
        const uint32_t _Shift = _Fractional_mantissa_bits - _Required_fractional_bits_of_precision;
        _Has_zero_tail        = _Has_zero_tail && (_Fractional_mantissa & ((1ULL << _Shift) - 1)) == 0;
        _Fractional_mantissa >>= _Shift;
    }

    
    const uint32_t _Integer_mantissa_low  = _Integer_value._Myused > 0 ? _Integer_value._Mydata[0] : 0;
    const uint32_t _Integer_mantissa_high = _Integer_value._Myused > 1 ? _Integer_value._Mydata[1] : 0;
    const uint64_t _Integer_mantissa = _Integer_mantissa_low + (static_cast<uint64_t>(_Integer_mantissa_high) << 32);

    const uint64_t _Complete_mantissa =
        (_Integer_mantissa << _Required_fractional_bits_of_precision) + _Fractional_mantissa;

    
    
    
    
    
    
    
    const int32_t _Final_exponent = _Integer_bits_of_precision > 0
                                      ? static_cast<int32_t>(_Integer_bits_of_precision - 2)
                                      : -static_cast<int32_t>(_Fractional_exponent) - 1;

    return _Assemble_floating_point_value(
        _Complete_mantissa, _Final_exponent, _Data._Myis_negative, _Has_zero_tail, _Result);
}

template <class _FloatingType>
[[nodiscard]] errc _Convert_hexadecimal_string_to_floating_type(
    const _Floating_point_string& _Data, _FloatingType& _Result, bool _Has_zero_tail) noexcept {
    using _Traits = _Floating_type_traits<_FloatingType>;

    uint64_t _Mantissa = 0;
    int32_t _Exponent  = _Data._Myexponent + _Traits::_Mantissa_bits - 1;

    
    const uint8_t* const _Mantissa_last = _Data._Mymantissa + _Data._Mymantissa_count;
    const uint8_t* _Mantissa_it         = _Data._Mymantissa;
    while (_Mantissa_it != _Mantissa_last && _Mantissa <= _Traits::_Normal_mantissa_mask) {
        _Mantissa *= 16;
        _Mantissa += *_Mantissa_it++;
        _Exponent -= 4; 
    }

    while (_Has_zero_tail && _Mantissa_it != _Mantissa_last) {
        _Has_zero_tail = *_Mantissa_it++ == 0;
    }

    return _Assemble_floating_point_value(_Mantissa, _Exponent, _Data._Myis_negative, _Has_zero_tail, _Result);
}


















































template <class _Floating>
[[nodiscard]] from_chars_result _Ordinary_floating_from_chars(const char* const _First, const char* const _Last,
    _Floating& _Value, const chars_format _Fmt, const bool _Minus_sign, const char* _Next) noexcept {
    

    const bool _Is_hexadecimal = _Fmt == chars_format::hex;
    const int _Base{_Is_hexadecimal ? 16 : 10};

    
    
    _Floating_point_string _Fp_string;

    
    _Fp_string._Myis_negative = _Minus_sign;

    uint8_t* const _Mantissa_first = _Fp_string._Mymantissa;
    uint8_t* const _Mantissa_last  = ::std:: end(_Fp_string._Mymantissa);
    uint8_t* _Mantissa_it          = _Mantissa_first;

    
    const char* const _Whole_begin = _Next;

    
    for (; _Next != _Last && *_Next == '0'; ++_Next) {
    }
    const char* const _Leading_zero_end = _Next;

    bool _Has_zero_tail = true;

    
    for (; _Next != _Last; ++_Next) {
        const unsigned char _Digit_value = _Digit_from_char(*_Next);

        if (_Digit_value >= _Base) {
            break;
        }

        if (_Mantissa_it != _Mantissa_last) {
            *_Mantissa_it++ = _Digit_value;
        } else {
            _Has_zero_tail = _Has_zero_tail && _Digit_value == 0;
        }
    }
    const char* const _Whole_end = _Next;

    
    
    
    
    
    ptrdiff_t _Exponent_adjustment = _Whole_end - _Leading_zero_end;

    
    if (_Next != _Last && *_Next == '.') {
        ++_Next;
    }
    const char* const _Dot_end = _Next;

    

    
    
    if (_Exponent_adjustment == 0) {
        for (; _Next != _Last && *_Next == '0'; ++_Next) {
        }

        _Exponent_adjustment = _Dot_end - _Next;
    }

    
    for (; _Next != _Last; ++_Next) {
        const unsigned char _Digit_value = _Digit_from_char(*_Next);

        if (_Digit_value >= _Base) {
            break;
        }

        if (_Mantissa_it != _Mantissa_last) {
            *_Mantissa_it++ = _Digit_value;
        } else {
            _Has_zero_tail = _Has_zero_tail && _Digit_value == 0;
        }
    }
    const char* const _Frac_end = _Next;

    
    if (_Whole_begin == _Whole_end && _Dot_end == _Frac_end) {
        return {_First, errc::invalid_argument};
    }

    const char _Exponent_prefix{_Is_hexadecimal ? 'p' : 'e'};

    bool _Exponent_is_negative = false;
    bool _Exp_abs_too_large    = false;
    ptrdiff_t _Exponent        = 0;

    constexpr int _Maximum_temporary_decimal_exponent = 5200;
    constexpr int _Minimum_temporary_decimal_exponent = -5200;

    if (_Fmt != chars_format::fixed 
                                    
                                    
        && _Next != _Last && (static_cast<unsigned char>(*_Next) | 0x20) == _Exponent_prefix) { 
        const char* _Unread = _Next + 1;

        if (_Unread != _Last && (*_Unread == '+' || *_Unread == '-')) { 
            _Exponent_is_negative = *_Unread == '-';
            ++_Unread;
        }

        while (_Unread != _Last) {
            const unsigned char _Digit_value = _Digit_from_char(*_Unread);

            if (_Digit_value >= 10) {
                break;
            }

            

            if (_Exponent < 9223372036854775807i64 / 10 || (_Exponent == 9223372036854775807i64 / 10 && _Digit_value <= 9223372036854775807i64 % 10)) {
                _Exponent = _Exponent * 10 + _Digit_value;
            } else {
                _Exp_abs_too_large = true;
            }

            ++_Unread;
            _Next = _Unread; 
        }

        if (_Exponent_is_negative) {
            _Exponent = -_Exponent;
        }
    }

    
    const char* const _Exponent_end = _Next;

    if (_Fmt == chars_format::scientific
        && _Frac_end == _Exponent_end) { 
                                         
                                         
        return {_First, errc::invalid_argument};
    }

    
    while (_Mantissa_it != _Mantissa_first && *(_Mantissa_it - 1) == 0) {
        --_Mantissa_it;
    }

    
    
    
    
    if (_Mantissa_it == _Mantissa_first) {
        ;
        _Assemble_floating_point_zero(_Fp_string._Myis_negative, _Value);
        return {_Next, errc{}};
    }

    
    if (_Exp_abs_too_large) {
        if (_Exponent > 0) {
            _Assemble_floating_point_infinity(_Fp_string._Myis_negative, _Value);
            return {_Next, errc::result_out_of_range};
        } else {
            _Assemble_floating_point_zero(_Fp_string._Myis_negative, _Value);
            return {_Next, errc::result_out_of_range};
        }
    }

    
    if (_Exponent > 0 && _Exponent_adjustment < 0) {
        if (_Is_hexadecimal) {
            const ptrdiff_t _Further_adjustment = (::std:: max)(-((_Exponent - 1) / 4 + 1), _Exponent_adjustment);
            _Exponent += _Further_adjustment * 4;
            _Exponent_adjustment -= _Further_adjustment;
        } else {
            const ptrdiff_t _Further_adjustment = (::std:: max)(-_Exponent, _Exponent_adjustment);
            _Exponent += _Further_adjustment;
            _Exponent_adjustment -= _Further_adjustment;
        }
    } else if (_Exponent < 0 && _Exponent_adjustment > 0) {
        if (_Is_hexadecimal) {
            const ptrdiff_t _Further_adjustment = (::std:: min)((-_Exponent - 1) / 4 + 1, _Exponent_adjustment);
            _Exponent += _Further_adjustment * 4;
            _Exponent_adjustment -= _Further_adjustment;
        } else {
            const ptrdiff_t _Further_adjustment = (::std:: min)(-_Exponent, _Exponent_adjustment);
            _Exponent += _Further_adjustment;
            _Exponent_adjustment -= _Further_adjustment;
        }
    }

    
    
    
    const int _Exponent_adjustment_multiplier{_Is_hexadecimal ? 4 : 1};

    
    
    if (_Exponent > _Maximum_temporary_decimal_exponent
        || _Exponent_adjustment > _Maximum_temporary_decimal_exponent / _Exponent_adjustment_multiplier) {
        _Assemble_floating_point_infinity(_Fp_string._Myis_negative, _Value);
        return {_Next, errc::result_out_of_range}; 
    }

    if (_Exponent < _Minimum_temporary_decimal_exponent
        || _Exponent_adjustment < _Minimum_temporary_decimal_exponent / _Exponent_adjustment_multiplier) {
        _Assemble_floating_point_zero(_Fp_string._Myis_negative, _Value);
        return {_Next, errc::result_out_of_range}; 
    }

    _Exponent += _Exponent_adjustment * _Exponent_adjustment_multiplier;

    
    
    if (_Exponent > _Maximum_temporary_decimal_exponent) {
        _Assemble_floating_point_infinity(_Fp_string._Myis_negative, _Value);
        return {_Next, errc::result_out_of_range}; 
    }

    if (_Exponent < _Minimum_temporary_decimal_exponent) {
        _Assemble_floating_point_zero(_Fp_string._Myis_negative, _Value);
        return {_Next, errc::result_out_of_range}; 
    }

    _Fp_string._Myexponent       = static_cast<int32_t>(_Exponent);
    _Fp_string._Mymantissa_count = static_cast<uint32_t>(_Mantissa_it - _Mantissa_first);

    if (_Is_hexadecimal) {
        const errc _Ec = _Convert_hexadecimal_string_to_floating_type(_Fp_string, _Value, _Has_zero_tail);
        return {_Next, _Ec};
    } else {
        const errc _Ec = _Convert_decimal_string_to_floating_type(_Fp_string, _Value, _Has_zero_tail);
        return {_Next, _Ec};
    }

    
}

[[nodiscard]] inline bool _Starts_with_case_insensitive(
    const char* _First, const char* const _Last, const char* _Lowercase) noexcept {
    
    for (; _First != _Last && *_Lowercase != '\0'; ++_First, ++_Lowercase) {
        if ((static_cast<unsigned char>(*_First) | 0x20) != *_Lowercase) {
            return false;
        }
    }

    return *_Lowercase == '\0';
}

template <class _Floating>
[[nodiscard]] from_chars_result _Infinity_from_chars(const char* const _First, const char* const _Last, _Floating& _Value,
    const bool _Minus_sign, const char* _Next) noexcept {
    
    if (!_Starts_with_case_insensitive(_Next + 1, _Last, "nf")) { 
        return {_First, errc::invalid_argument};
    }

    
    _Next += 3;

    if (_Starts_with_case_insensitive(_Next, _Last, "inity")) { 
        _Next += 5;
    }

    _Assemble_floating_point_infinity(_Minus_sign, _Value);

    return {_Next, errc{}};
}

template <class _Floating>
[[nodiscard]] from_chars_result _Nan_from_chars(const char* const _First, const char* const _Last, _Floating& _Value,
    bool _Minus_sign, const char* _Next) noexcept {
    
    if (!_Starts_with_case_insensitive(_Next + 1, _Last, "an")) { 
        return {_First, errc::invalid_argument};
    }

    
    _Next += 3;

    bool _Quiet = true;

    if (_Next != _Last && *_Next == '(') { 
        const char* const _Seq_begin = _Next + 1;

        for (const char* _Temp = _Seq_begin; _Temp != _Last; ++_Temp) {
            if (*_Temp == ')') { 
                _Next = _Temp + 1;

                if (_Temp - _Seq_begin == 3
                    && _Starts_with_case_insensitive(_Seq_begin, _Temp, "ind")) { 
                    
                    
                    _Minus_sign = true;
                } else if (_Temp - _Seq_begin == 4
                           && _Starts_with_case_insensitive(_Seq_begin, _Temp, "snan")) { 
                    _Quiet = false;
                }

                break;
            } else if (*_Temp == '_' || ('0' <= *_Temp && *_Temp <= '9') || ('A' <= *_Temp && *_Temp <= 'Z')
                       || ('a' <= *_Temp && *_Temp <= 'z')) { 
            } else { 
                break;
            }
        }
    }

    
    
    
    

    using _Traits    = _Floating_type_traits<_Floating>;
    using _Uint_type = typename _Traits::_Uint_type;

    _Uint_type _Uint_value = _Traits::_Shifted_exponent_mask;

    if (_Minus_sign) {
        _Uint_value |= _Traits::_Shifted_sign_mask;
    }

    if (_Quiet) {
        _Uint_value |= _Traits::_Special_nan_mantissa_mask;
    } else {
        _Uint_value |= 1;
    }

    _Value = _Bit_cast<_Floating>(_Uint_value);

    return {_Next, errc{}};
}

template <class _Floating>
[[nodiscard]] from_chars_result _Floating_from_chars(
    const char* const _First, const char* const _Last, _Floating& _Value, const chars_format _Fmt) noexcept {
    _Adl_verify_range(_First, _Last);

    ;
#line 1911 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"

    bool _Minus_sign = false;

    const char* _Next = _First;

    if (_Next == _Last) {
        return {_First, errc::invalid_argument};
    }

    if (*_Next == '-') {
        _Minus_sign = true;
        ++_Next;

        if (_Next == _Last) {
            return {_First, errc::invalid_argument};
        }
    }

    
    
    
    
    
    
    
    
    
    const unsigned char _Folded_start = static_cast<unsigned char>(static_cast<unsigned char>(*_Next) | 0x20);

    if (_Folded_start <= 'f') { 
        return _Ordinary_floating_from_chars(_First, _Last, _Value, _Fmt, _Minus_sign, _Next);
    } else if (_Folded_start == 'i') { 
        return _Infinity_from_chars(_First, _Last, _Value, _Minus_sign, _Next);
    } else if (_Folded_start == 'n') { 
        return _Nan_from_chars(_First, _Last, _Value, _Minus_sign, _Next);
    } else { 
        return {_First, errc::invalid_argument};
    }
}

 inline from_chars_result from_chars(const char* const _First, const char* const _Last, float& _Value,
    const chars_format _Fmt = chars_format::general) noexcept  {
    return _Floating_from_chars(_First, _Last, _Value, _Fmt);
}
 inline from_chars_result from_chars(const char* const _First, const char* const _Last, double& _Value,
    const chars_format _Fmt = chars_format::general) noexcept  {
    return _Floating_from_chars(_First, _Last, _Value, _Fmt);
}
 inline from_chars_result from_chars(const char* const _First, const char* const _Last, long double& _Value,
    const chars_format _Fmt = chars_format::general) noexcept  {
    double _Dbl; 
    const from_chars_result _Result = _Floating_from_chars(_First, _Last, _Dbl, _Fmt);

    if (_Result.ec == errc{}) {
        _Value = _Dbl;
    }

    return _Result;
}

template <class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars_hex_precision(
    char* _First, char* const _Last, const _Floating _Value, int _Precision) noexcept {

    
    

    
    
    
    constexpr int _Full_precision         = is_same_v<_Floating, float> ? 6 : 13;
    constexpr int _Adjusted_explicit_bits = _Full_precision * 4;

    if (_Precision < 0) {
        
        
        
        _Precision = _Full_precision;
    }

    
    using _Traits    = _Floating_type_traits<_Floating>;
    using _Uint_type = typename _Traits::_Uint_type;

    const _Uint_type _Uint_value    = _Bit_cast<_Uint_type>(_Value);
    const _Uint_type _Ieee_mantissa = _Uint_value & _Traits::_Denormal_mantissa_mask;
    const int32_t _Ieee_exponent    = static_cast<int32_t>(_Uint_value >> _Traits::_Exponent_shift);

    
    
    
    _Uint_type _Adjusted_mantissa;

    if constexpr (is_same_v<_Floating, float>) {
        _Adjusted_mantissa = _Ieee_mantissa << 1; 
    } else {
        _Adjusted_mantissa = _Ieee_mantissa; 
    }

    int32_t _Unbiased_exponent;

    if (_Ieee_exponent == 0) { 
        

        if (_Ieee_mantissa == 0) { 
            
            _Unbiased_exponent = 0;
        } else { 
            _Unbiased_exponent = 1 - _Traits::_Exponent_bias;
        }
    } else { 
        _Adjusted_mantissa |= _Uint_type{1} << _Adjusted_explicit_bits; 
        _Unbiased_exponent = _Ieee_exponent - _Traits::_Exponent_bias;
    }

    

    
    char _Sign_character;
    uint32_t _Absolute_exponent;

    if (_Unbiased_exponent < 0) {
        _Sign_character    = '-';
        _Absolute_exponent = static_cast<uint32_t>(-_Unbiased_exponent);
    } else {
        _Sign_character    = '+';
        _Absolute_exponent = static_cast<uint32_t>(_Unbiased_exponent);
    }

    

    
    {
        int32_t _Exponent_length;

        if (_Absolute_exponent < 10) {
            _Exponent_length = 1;
        } else if (_Absolute_exponent < 100) {
            _Exponent_length = 2;
        } else if constexpr (is_same_v<_Floating, float>) {
            _Exponent_length = 3;
        } else if (_Absolute_exponent < 1000) {
            _Exponent_length = 3;
        } else {
            _Exponent_length = 4;
        }

        
        ptrdiff_t _Buffer_size = _Last - _First;

        if (_Buffer_size < _Precision) {
            return {_Last, errc::value_too_large};
        }

        _Buffer_size -= _Precision;

        const int32_t _Length_excluding_precision = 1 
                                                  + static_cast<int32_t>(_Precision > 0) 
                                                  
                                                  + 2 
                                                  + _Exponent_length; 

        if (_Buffer_size < _Length_excluding_precision) {
            return {_Last, errc::value_too_large};
        }
    }

    
    if (_Precision < _Full_precision) {
        

        
        const int _Dropped_bits = (_Full_precision - _Precision) * 4;

        

        
        
        

        
        
        

        
        
        
        
        
        

        
        
        
        

        
        
        const _Uint_type _Lsb_bit = _Adjusted_mantissa;

        
        
        const _Uint_type _Round_bit = _Adjusted_mantissa << 1;

        
        
        
        
        

        
        
        const _Uint_type _Has_tail_bits = _Round_bit - 1;

        
        
        const _Uint_type _Should_round = _Round_bit & (_Has_tail_bits | _Lsb_bit) & (_Uint_type{1} << _Dropped_bits);

        
        _Adjusted_mantissa += _Should_round;
    }

    
    {
        const uint32_t _Nibble = static_cast<uint32_t>(_Adjusted_mantissa >> _Adjusted_explicit_bits);
        ;
        const char _Leading_hexit = static_cast<char>('0' + _Nibble);

        *_First++ = _Leading_hexit;

        constexpr _Uint_type _Mask = (_Uint_type{1} << _Adjusted_explicit_bits) - 1;
        _Adjusted_mantissa &= _Mask;
    }

    

    
    
    if (_Precision > 0) {
        *_First++ = '.';

        int32_t _Number_of_bits_remaining = _Adjusted_explicit_bits; 

        for (;;) {
            ;
            ;
            _Number_of_bits_remaining -= 4;

            const uint32_t _Nibble = static_cast<uint32_t>(_Adjusted_mantissa >> _Number_of_bits_remaining);
            ;
            const char _Hexit = _Charconv_digits[_Nibble];

            *_First++ = _Hexit;

            
            --_Precision;
            if (_Precision == 0) {
                break; 
            }
            

            if (_Number_of_bits_remaining == 0) {
                
                :: memset(_First, '0', static_cast<size_t>(_Precision));
                _First += _Precision;
                break;
            }

            
            
            const _Uint_type _Mask = (_Uint_type{1} << _Number_of_bits_remaining) - 1;
            _Adjusted_mantissa &= _Mask;
        }
    }

    

    
    

    

    *_First++ = 'p';
    *_First++ = _Sign_character;

    
    return ::std:: to_chars(_First, _Last, _Absolute_exponent);
}

template <class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars_hex_shortest(
    char* _First, char* const _Last, const _Floating _Value) noexcept {

    
    
    
    
    

    using _Traits    = _Floating_type_traits<_Floating>;
    using _Uint_type = typename _Traits::_Uint_type;

    const _Uint_type _Uint_value = _Bit_cast<_Uint_type>(_Value);

    if (_Uint_value == 0) { 
        
        
        const char* const _Str = "0p+0";
        constexpr size_t _Len  = 4;

        if (_Last - _First < static_cast<ptrdiff_t>(_Len)) {
            return {_Last, errc::value_too_large};
        }

        :: memcpy(_First, _Str, _Len);

        return {_First + _Len, errc{}};
    }

    const _Uint_type _Ieee_mantissa = _Uint_value & _Traits::_Denormal_mantissa_mask;
    const int32_t _Ieee_exponent    = static_cast<int32_t>(_Uint_value >> _Traits::_Exponent_shift);

    char _Leading_hexit; 
    int32_t _Unbiased_exponent;

    if (_Ieee_exponent == 0) { 
        _Leading_hexit     = '0';
        _Unbiased_exponent = 1 - _Traits::_Exponent_bias;
    } else { 
        _Leading_hexit     = '1';
        _Unbiased_exponent = _Ieee_exponent - _Traits::_Exponent_bias;
    }

    

    if (_First == _Last) {
        return {_Last, errc::value_too_large};
    }

    *_First++ = _Leading_hexit;

    if (_Ieee_mantissa == 0) {
        
    } else {
        if (_First == _Last) {
            return {_Last, errc::value_too_large};
        }

        *_First++ = '.';

        
        
        
        _Uint_type _Adjusted_mantissa;
        int32_t _Number_of_bits_remaining;

        if constexpr (is_same_v<_Floating, float>) {
            _Adjusted_mantissa        = _Ieee_mantissa << 1; 
            _Number_of_bits_remaining = 24; 
        } else {
            _Adjusted_mantissa        = _Ieee_mantissa; 
            _Number_of_bits_remaining = 52; 
        }

        
        
        
        
        
        do {
            ;
            ;
            _Number_of_bits_remaining -= 4;

            const uint32_t _Nibble = static_cast<uint32_t>(_Adjusted_mantissa >> _Number_of_bits_remaining);
            ;
            const char _Hexit = _Charconv_digits[_Nibble];

            if (_First == _Last) {
                return {_Last, errc::value_too_large};
            }

            *_First++ = _Hexit;

            const _Uint_type _Mask = (_Uint_type{1} << _Number_of_bits_remaining) - 1;
            _Adjusted_mantissa &= _Mask;

        } while (_Adjusted_mantissa != 0);
    }

    
    

    

    
    

    if (_Last - _First < 2) {
        return {_Last, errc::value_too_large};
    }

    *_First++ = 'p';

    if (_Unbiased_exponent < 0) {
        *_First++          = '-';
        _Unbiased_exponent = -_Unbiased_exponent;
    } else {
        *_First++ = '+';
    }

    
    return ::std:: to_chars(_First, _Last, static_cast<uint32_t>(_Unbiased_exponent));
}

template <class _Floating>
[[nodiscard]] inline to_chars_result _Floating_to_chars_general_precision(
    char* _First, char* const _Last, const _Floating _Value, int _Precision) noexcept {

    using _Traits    = _Floating_type_traits<_Floating>;
    using _Uint_type = typename _Traits::_Uint_type;

    const _Uint_type _Uint_value = _Bit_cast<_Uint_type>(_Value);

    if (_Uint_value == 0) { 
        if (_First == _Last) {
            return {_Last, errc::value_too_large};
        }

        *_First++ = '0';

        return {_First, errc{}};
    }

    
    
    
    

    
    
    if (_Precision < 0) {
        _Precision = 6;
    } else if (_Precision == 0) {
        _Precision = 1;
    } else if (_Precision < 1'000'000) {
        
    } else {
        
        
        
        _Precision = 1'000'000;
    }

    

    
    
    

    
    

    using _Tables = _General_precision_tables_2<_Floating>;

    const _Uint_type* _Table_begin;
    const _Uint_type* _Table_end;

    if (_Precision <= _Tables::_Max_special_P) {
        _Table_begin = _Tables::_Special_X_table + (_Precision - 1) * (_Precision + 10) / 2;
        _Table_end   = _Table_begin + _Precision + 5;
    } else {
        _Table_begin = _Tables::_Ordinary_X_table;
        _Table_end   = _Table_begin + (::std:: min)(_Precision, _Tables::_Max_P) + 5;
    }

    
    
    const _Uint_type* const _Table_lower_bound = [=] {
        if constexpr (!is_same_v<_Floating, float>) {
            if (_Precision > 155) { 
                return ::std:: lower_bound(_Table_begin, _Table_end, _Uint_value, less{});
            }
        }

        return ::std:: find_if(_Table_begin, _Table_end, [=](const _Uint_type _Elem) { return _Uint_value <= _Elem; });
    }();

    const ptrdiff_t _Table_index     = _Table_lower_bound - _Table_begin;
    const int _Scientific_exponent_X = static_cast<int>(_Table_index - 5);
    const bool _Use_fixed_notation   = _Precision > _Scientific_exponent_X && _Scientific_exponent_X >= -4;

    
    
    
    
    
    

    constexpr int _Max_output_length =
        is_same_v<_Floating, float> ? 117 : 773; 
    constexpr int _Max_fixed_precision =
        is_same_v<_Floating, float> ? 37 : 66; 
    constexpr int _Max_scientific_precision =
        is_same_v<_Floating, float> ? 111 : 766; 

    
    
    

    char _Buffer[_Max_output_length];
    const char* const _Significand_first = _Buffer; 
    const char* _Significand_last        = nullptr;
    const char* _Exponent_first          = nullptr; 
    const char* _Exponent_last           = nullptr;
    int _Effective_precision; 

    
    
    if (_Use_fixed_notation) {
        _Effective_precision = (::std:: min)(_Precision - (_Scientific_exponent_X + 1), _Max_fixed_precision);
        const to_chars_result _Buf_result =
            _Floating_to_chars_fixed_precision(_Buffer, ::std:: end(_Buffer), _Value, _Effective_precision);
        ;
        _Significand_last = _Buf_result.ptr;
    } else {
        _Effective_precision = (::std:: min)(_Precision - 1, _Max_scientific_precision);
        const to_chars_result _Buf_result =
            _Floating_to_chars_scientific_precision(_Buffer, ::std:: end(_Buffer), _Value, _Effective_precision);
        ;
        _Significand_last = ::std:: find(_Buffer, _Buf_result.ptr, 'e');
        _Exponent_first   = _Significand_last;
        _Exponent_last    = _Buf_result.ptr;
    }

    
    if (_Effective_precision > 0) {
        while (_Significand_last[-1] == '0') { 
            --_Significand_last;
        }

        if (_Significand_last[-1] == '.') {
            --_Significand_last;
        }
    }

    
    const ptrdiff_t _Significand_distance = _Significand_last - _Significand_first;
    if (_Last - _First < _Significand_distance) {
        return {_Last, errc::value_too_large};
    }
    :: memcpy(_First, _Significand_first, static_cast<size_t>(_Significand_distance));
    _First += _Significand_distance;

    
    if (!_Use_fixed_notation) {
        const ptrdiff_t _Exponent_distance = _Exponent_last - _Exponent_first;
        if (_Last - _First < _Exponent_distance) {
            return {_Last, errc::value_too_large};
        }
        :: memcpy(_First, _Exponent_first, static_cast<size_t>(_Exponent_distance));
        _First += _Exponent_distance;
    }

    return {_First, errc{}};
}

enum class _Floating_to_chars_overload { _Plain, _Format_only, _Format_precision };

template <_Floating_to_chars_overload _Overload, class _Floating>
[[nodiscard]] to_chars_result _Floating_to_chars(
    char* _First, char* const _Last, _Floating _Value, const chars_format _Fmt, const int _Precision) noexcept {
    _Adl_verify_range(_First, _Last);

    if constexpr (_Overload == _Floating_to_chars_overload::_Plain) {
        ; 
    } else {
        ;
#line 2491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
    }

    using _Traits    = _Floating_type_traits<_Floating>;
    using _Uint_type = typename _Traits::_Uint_type;

    _Uint_type _Uint_value = _Bit_cast<_Uint_type>(_Value);

    const bool _Was_negative = (_Uint_value & _Traits::_Shifted_sign_mask) != 0;

    if (_Was_negative) { 
        if (_First == _Last) {
            return {_Last, errc::value_too_large};
        }

        *_First++ = '-';

        _Uint_value &= ~_Traits::_Shifted_sign_mask;
        _Value = _Bit_cast<_Floating>(_Uint_value);
    }

    if ((_Uint_value & _Traits::_Shifted_exponent_mask) == _Traits::_Shifted_exponent_mask) {
        
        const char* _Str;
        size_t _Len;

        const _Uint_type _Mantissa = _Uint_value & _Traits::_Denormal_mantissa_mask;

        if (_Mantissa == 0) {
            _Str = "inf";
            _Len = 3;
        } else if (_Was_negative && _Mantissa == _Traits::_Special_nan_mantissa_mask) {
            
            
            _Str = "nan(ind)";
            _Len = 8;
        } else if ((_Mantissa & _Traits::_Special_nan_mantissa_mask) != 0) {
            _Str = "nan";
            _Len = 3;
        } else {
            _Str = "nan(snan)";
            _Len = 9;
        }

        if (_Last - _First < static_cast<ptrdiff_t>(_Len)) {
            return {_Last, errc::value_too_large};
        }

        :: memcpy(_First, _Str, _Len);

        return {_First + _Len, errc{}};
    }

    if constexpr (_Overload == _Floating_to_chars_overload::_Plain) {
        return _Floating_to_chars_ryu(_First, _Last, _Value, chars_format{});
    } else if constexpr (_Overload == _Floating_to_chars_overload::_Format_only) {
        if (_Fmt == chars_format::hex) {
            return _Floating_to_chars_hex_shortest(_First, _Last, _Value);
        }

        return _Floating_to_chars_ryu(_First, _Last, _Value, _Fmt);
    } else if constexpr (_Overload == _Floating_to_chars_overload::_Format_precision) {
        switch (_Fmt) {
        case chars_format::scientific:
            return _Floating_to_chars_scientific_precision(_First, _Last, _Value, _Precision);
        case chars_format::fixed:
            return _Floating_to_chars_fixed_precision(_First, _Last, _Value, _Precision);
        case chars_format::general:
            return _Floating_to_chars_general_precision(_First, _Last, _Value, _Precision);
        case chars_format::hex:
        default: 
            return _Floating_to_chars_hex_precision(_First, _Last, _Value, _Precision);
        }
    }
}

 inline to_chars_result to_chars(char* const _First, char* const _Last, const float _Value) noexcept
 {
    return _Floating_to_chars<_Floating_to_chars_overload::_Plain>(_First, _Last, _Value, chars_format{}, 0);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const double _Value) noexcept
 {
    return _Floating_to_chars<_Floating_to_chars_overload::_Plain>(_First, _Last, _Value, chars_format{}, 0);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const long double _Value) noexcept
 {
    return _Floating_to_chars<_Floating_to_chars_overload::_Plain>(
        _First, _Last, static_cast<double>(_Value), chars_format{}, 0);
}
 inline to_chars_result to_chars(
    char* const _First, char* const _Last, const float _Value, const chars_format _Fmt) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_only>(_First, _Last, _Value, _Fmt, 0);
}
 inline to_chars_result to_chars(
    char* const _First, char* const _Last, const double _Value, const chars_format _Fmt) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_only>(_First, _Last, _Value, _Fmt, 0);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const long double _Value,
    const chars_format _Fmt) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_only>(
        _First, _Last, static_cast<double>(_Value), _Fmt, 0);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const float _Value,
    const chars_format _Fmt, const int _Precision) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_precision>(_First, _Last, _Value, _Fmt, _Precision);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const double _Value,
    const chars_format _Fmt, const int _Precision) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_precision>(_First, _Last, _Value, _Fmt, _Precision);
}
 inline to_chars_result to_chars(char* const _First, char* const _Last, const long double _Value,
    const chars_format _Fmt, const int _Precision) noexcept  {
    return _Floating_to_chars<_Floating_to_chars_overload::_Format_precision>(
        _First, _Last, static_cast<double>(_Value), _Fmt, _Precision);
}

}



#pragma warning(pop)
#pragma pack(pop)
#line 2613 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#line 2614 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#line 2615 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\charconv"
#pragma external_header(pop)
#line 49 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocbuf"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
__pragma(warning(push)) __pragma(warning(disable : 4996))
 template <class _Codecvt, class _Elem = wchar_t, class _Traits = char_traits<_Elem>>
class [[deprecated( "warning STL4017: " "std::wbuffer_convert, std::wstring_convert, and the <codecvt> header (containing std::codecvt_mode, " "std::codecvt_utf8, std::codecvt_utf16, and std::codecvt_utf8_utf16) are deprecated in C++17. " "(The std::codecvt class template is NOT deprecated.) " "The C++ Standard doesn't provide equivalent non-deprecated functionality; " "consider using MultiByteToWideChar() and WideCharToMultiByte() from <Windows.h> instead. " "You can define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] wbuffer_convert
    : public basic_streambuf<_Elem, _Traits> { 
private:
    enum _Mode { _Unused, _Wrote, _Need, _Got, _Eof };
    enum { _STRING_INC = 8 };

public:
    using _Mysb        = streambuf;
    using _Byte_traits = char_traits<char>;

    using int_type   = typename _Traits::int_type;
    using pos_type   = typename _Traits::pos_type;
    using off_type   = typename _Traits::off_type;
    using state_type = typename _Codecvt::state_type;

    wbuffer_convert() : _State(), _Pcvt(new _Codecvt), _Mystrbuf(nullptr), _Status(_Unused), _Nback(0) {
        
        _Loc = locale{_Loc, _Pcvt};
    }

    explicit wbuffer_convert(_Mysb* _Strbuf)
        : _State(), _Pcvt(new _Codecvt), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0) {
        
        _Loc = locale{_Loc, _Pcvt};
    }

    wbuffer_convert(_Mysb* _Strbuf, const _Codecvt* _Pcvt_arg)
        : _State(), _Pcvt(_Pcvt_arg), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0) {
        
        _Loc = locale{_Loc, _Pcvt};
    }

    wbuffer_convert(_Mysb* _Strbuf, const _Codecvt* _Pcvt_arg, state_type _State_arg)
        : _State(_State_arg), _Pcvt(_Pcvt_arg), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0) {
        
        _Loc = locale{_Loc, _Pcvt};
    }

    ~wbuffer_convert() noexcept override {
        while (_Status == _Wrote) { 
            if (_Str.size() < _STRING_INC) {
                _Str.assign(_STRING_INC, '\0');
            }

            char* _Buf = &_Str[0];
            char* _Dest;
            switch (_Pcvt->unshift(_State, _Buf, _Buf + _Str.size(), _Dest)) { 
            case _Codecvt::ok:
                _Status = _Unused; 
                [[fallthrough]];

            case _Codecvt::partial:
                { 
                    ptrdiff_t _Count = _Dest - _Buf;
                    if (0 < _Count
                        && _Byte_traits::eq_int_type(
                            _Byte_traits::eof(), static_cast<_Byte_traits::int_type>(_Mystrbuf->sputn(_Buf, _Count)))) {
                        return; 
                    }

                    if (_Status == _Wrote && _Count == 0) {
                        _Str.append(_STRING_INC, '\0'); 
                    }

                    break;
                }

            case _Codecvt::noconv:
                return; 

            default:
                return; 
            }
        }
    }

    [[nodiscard]] _Mysb* rdbuf() const {
        return _Mystrbuf;
    }

    _Mysb* rdbuf(_Mysb* _Strbuf) { 
        _Mysb* _Oldstrbuf = _Mystrbuf;
        _Mystrbuf         = _Strbuf;
        return _Oldstrbuf;
    }

    [[nodiscard]] state_type state() const {
        return _State;
    }

    wbuffer_convert(const wbuffer_convert&)            = delete;
    wbuffer_convert& operator=(const wbuffer_convert&) = delete;

protected:
    int_type overflow(int_type _Meta = _Traits::eof()) override { 
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            return _Traits::not_eof(_Meta); 
        } else if (!_Mystrbuf || 0 < _Nback || (_Status != _Unused && _Status != _Wrote)) {
            return _Traits::eof(); 
        } else { 
            const _Elem _Ch = _Traits::to_char_type(_Meta);

            if (_Str.size() < _STRING_INC) {
                _Str.assign(_STRING_INC, '\0');
            }

            for (_Status = _Wrote;;) {
                char* _Buf = &_Str[0];
                const _Elem* _Src;
                char* _Dest;

                
                switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Buf, _Buf + _Str.size(), _Dest)) {
                case _Codecvt::partial:
                case _Codecvt::ok:
                    { 
                        ptrdiff_t _Count = _Dest - _Buf;
                        if (0 < _Count
                            && _Byte_traits::eq_int_type(_Byte_traits::eof(),
                                static_cast<_Byte_traits::int_type>(_Mystrbuf->sputn(_Buf, _Count)))) {
                            return _Traits::eof(); 
                        }

                        if (_Src != &_Ch) {
                            return _Meta; 
                        }

                        if (0 >= _Count) {
                            if (_Str.size() >= 4 * _STRING_INC) {
                                return _Traits::eof(); 
                            }

                            _Str.append(_STRING_INC, '\0'); 
                        }

                        break;
                    }

                case _Codecvt::noconv:
                    if (_Traits::eq_int_type(
                            _Traits::eof(), static_cast<int_type>(_Mystrbuf->sputn(reinterpret_cast<const char*>(&_Ch),
                                                static_cast<streamsize>(sizeof(_Elem)))))) {
                        return _Traits::eof();
                    }

                    return _Meta; 

                default:
                    return _Traits::eof(); 
                }
            }
        }
    }

    int_type pbackfail(int_type _Meta = _Traits::eof()) override { 
        if (::std:: size(_Myback) <= _Nback || _Status == _Wrote) {
            return _Traits::eof(); 
        } else { 
            if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _Myback[_Nback] = _Traits::to_char_type(_Meta);
            }

            ++_Nback;
            if (_Status == _Unused) {
                _Status = _Got;
            }

            return _Meta;
        }
    }

    int_type underflow() override { 
        int_type _Meta;

        if (0 >= _Nback) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem())) {
                return _Meta; 
            }

            _Myback[_Nback++] = _Traits::to_char_type(_Meta);
        }

        return _Traits::to_int_type(_Myback[_Nback - 1]);
    }

#pragma warning(push)
#pragma warning(disable : 6385) 
                                
    int_type uflow() override { 
        int_type _Meta;

        if (0 >= _Nback) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem())) {
                return _Meta; 
            }

            _Myback[_Nback++] = _Traits::to_char_type(_Meta);
        }

        return _Traits::to_int_type(_Myback[--_Nback]);
    }
#pragma warning(pop)

    pos_type seekoff(off_type, ios_base::seekdir,
        ios_base::openmode = static_cast<ios_base::openmode>(ios_base::in | ios_base::out)) override {
        return pos_type{off_type{-1}}; 
    }

    pos_type seekpos(
        pos_type, ios_base::openmode = static_cast<ios_base::openmode>(ios_base::in | ios_base::out)) override {
        return pos_type{off_type{-1}}; 
    }

private:
    int_type _Get_elem() { 
        if (_Mystrbuf && _Status != _Wrote) { 
            if (_Status != _Eof) {
                if (_Str.empty()) {
                    _Status = _Need;
                } else {
                    _Status = _Got;
                }
            }

            while (_Status != _Eof) { 
                char* _Buf = &_Str[0];
                _Elem _Ch;
                _Elem* _Dest;
                const char* _Src;
                int _Meta;

                if (_Status == _Need) {
                    if (_Byte_traits::eq_int_type(_Byte_traits::eof(), _Meta = _Mystrbuf->sbumpc())) {
                        _Status = _Eof;
                    } else {
                        _Str.push_back(_Byte_traits::to_char_type(_Meta));
                    }
                }

                
                switch (_Pcvt->in(_State, _Buf, _Buf + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest)) {
                case _Codecvt::partial:
                case _Codecvt::ok:
                    _Str.erase(0, static_cast<size_t>(_Src - _Buf)); 
                    if (_Dest != &_Ch) {
                        return _Traits::to_int_type(_Ch);
                    }

                    break;

                case _Codecvt::noconv:
                    if (_Str.size() < sizeof(_Elem)) {
                        break; 
                    }

                    :: memcpy(&_Ch, _Buf, sizeof(_Elem)); 
                    _Str.erase(0, sizeof(_Elem));
                    return _Traits::to_int_type(_Ch); 

                default:
                    _Status = _Eof; 
                    break;
                }
            }
        }

        return _Traits::eof();
    }

    state_type _State; 
    const _Codecvt* _Pcvt; 
    _Mysb* _Mystrbuf; 
    _Mode _Status; 
    size_t _Nback; 
    _Elem _Myback[8]; 
    string _Str; 
    locale _Loc; 
};

 template <class _Codecvt, class _Elem = wchar_t, class _Walloc = allocator<_Elem>,
    class _Balloc = allocator<char>>
class [[deprecated( "warning STL4017: " "std::wbuffer_convert, std::wstring_convert, and the <codecvt> header (containing std::codecvt_mode, " "std::codecvt_utf8, std::codecvt_utf16, and std::codecvt_utf8_utf16) are deprecated in C++17. " "(The std::codecvt class template is NOT deprecated.) " "The C++ Standard doesn't provide equivalent non-deprecated functionality; " "consider using MultiByteToWideChar() and WideCharToMultiByte() from <Windows.h> instead. " "You can define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] wstring_convert { 
private:
    enum { _BUF_INC = 8, _BUF_MAX = 16 };
    void _Init(const _Codecvt* _Pcvt_arg = new _Codecvt) { 
        _State = state_type{};
        _Pcvt  = _Pcvt_arg;
        _Loc   = locale{_Loc, _Pcvt};
        _Nconv = 0;
    }

public:
    using byte_string = basic_string<char, char_traits<char>, _Balloc>;
    using wide_string = basic_string<_Elem, char_traits<_Elem>, _Walloc>;
    using state_type  = typename _Codecvt::state_type;
    using int_type    = typename wide_string::traits_type::int_type;

    wstring_convert() : _Has_state(false), _Has_berr(false), _Has_werr(false) { 
        _Init();
    }

    explicit wstring_convert(const _Codecvt* _Pcvt_arg)
        : _Has_state(false), _Has_berr(false), _Has_werr(false) { 
        _Init(_Pcvt_arg);
    }

    wstring_convert(const _Codecvt* _Pcvt_arg, state_type _State_arg)
        : _Has_state(true), _Has_berr(false), _Has_werr(false) { 
        _Init(_Pcvt_arg);
        _State = _State_arg;
    }

    explicit wstring_convert(const byte_string& _Berr_arg)
        : _Berr(_Berr_arg), _Has_state(false), _Has_berr(true), _Has_werr(false) { 
        _Init();
    }

    wstring_convert(const byte_string& _Berr_arg, const wide_string& _Werr_arg)
        : _Berr(_Berr_arg), _Werr(_Werr_arg), _Has_state(false), _Has_berr(true),
          _Has_werr(true) { 
        _Init();
    }

    virtual ~wstring_convert() noexcept {}

    [[nodiscard]] size_t converted() const noexcept { 
        return _Nconv;
    }

    [[nodiscard]] state_type state() const {
        return _State;
    }

    [[nodiscard]] wide_string from_bytes(char _Byte) { 
        return from_bytes(&_Byte, &_Byte + 1);
    }

    [[nodiscard]] wide_string from_bytes(const char* _Ptr) { 
        return from_bytes(_Ptr, _Ptr + :: strlen(_Ptr));
    }

    [[nodiscard]] wide_string from_bytes(const byte_string& _Bstr) { 
        const char* _Ptr = _Bstr.c_str();
        return from_bytes(_Ptr, _Ptr + _Bstr.size());
    }

    [[nodiscard]] wide_string from_bytes(
        const char* _First, const char* _Last) { 
        wide_string _Wbuf;
        wide_string _Wstr;
        const char* _First_sav = _First;

        if (!_Has_state) {
            _State = state_type{}; 
        }

        _Wbuf.append(_BUF_INC, _Elem{});
        for (_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav)) {
            
            _Elem* _Dest = &_Wbuf[0];
            _Elem* _Dnext;

            
            switch (_Pcvt->in(_State, _First, _Last, _First, _Dest, _Dest + _Wbuf.size(), _Dnext)) {
            case _Codecvt::partial:
            case _Codecvt::ok:
                if (_Dest < _Dnext) {
                    _Wstr.append(_Dest, static_cast<size_t>(_Dnext - _Dest));
                } else if (_Wbuf.size() < _BUF_MAX) {
                    _Wbuf.append(_BUF_INC, _Elem{});
                } else if (_Has_werr) {
                    return _Werr;
                } else {
                    _Throw_range_error("bad conversion");
                }

                break;

            case _Codecvt::noconv:
                for (; _First != _Last; ++_First) {
                    _Wstr.push_back(static_cast<_Elem>(static_cast<unsigned char>(*_First)));
                }

                break; 

            default:
                if (_Has_werr) {
                    return _Werr;
                } else {
                    _Throw_range_error("bad conversion");
                }
            }
        }
        return _Wstr;
    }

    [[nodiscard]] byte_string to_bytes(_Elem _Char) { 
        return to_bytes(&_Char, &_Char + 1);
    }

    [[nodiscard]] byte_string to_bytes(const _Elem* _Wptr) { 
        const _Elem* _Next = _Wptr;
        while (*_Next != 0) {
            ++_Next;
        }

        return to_bytes(_Wptr, _Next);
    }

    [[nodiscard]] byte_string to_bytes(const wide_string& _Wstr) { 
        const _Elem* _Wptr = _Wstr.c_str();
        return to_bytes(_Wptr, _Wptr + _Wstr.size());
    }

    [[nodiscard]] byte_string to_bytes(
        const _Elem* _First, const _Elem* _Last) { 
        byte_string _Bbuf;
        byte_string _Bstr;
        const _Elem* _First_sav = _First;

        if (!_Has_state) {
            _State = state_type{}; 
        }

        _Bbuf.append(_BUF_INC, '\0');
        for (_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav)) {
            
            char* _Dest = &_Bbuf[0];
            char* _Dnext;

            
            switch (_Pcvt->out(_State, _First, _Last, _First, _Dest, _Dest + _Bbuf.size(), _Dnext)) {
            case _Codecvt::partial:
            case _Codecvt::ok:
                if (_Dest < _Dnext) {
                    _Bstr.append(_Dest, static_cast<size_t>(_Dnext - _Dest));
                } else if (_Bbuf.size() < _BUF_MAX) {
                    _Bbuf.append(_BUF_INC, '\0');
                } else if (_Has_berr) {
                    return _Berr;
                } else {
                    _Throw_range_error("bad conversion");
                }

                break;

            case _Codecvt::noconv:
                for (; _First != _Last; ++_First) {
                    _Bstr.push_back(static_cast<char>(static_cast<int_type>(*_First)));
                }

                break; 

            default:
                if (_Has_berr) {
                    return _Berr;
                } else {
                    _Throw_range_error("bad conversion");
                }
            }
        }
        return _Bstr;
    }

    wstring_convert(const wstring_convert&)            = delete;
    wstring_convert& operator=(const wstring_convert&) = delete;

private:
    const _Codecvt* _Pcvt; 
    locale _Loc; 
    byte_string _Berr;
    wide_string _Werr;
    state_type _State; 
    bool _Has_state;
    bool _Has_berr;
    bool _Has_werr;
    size_t _Nconv;
};
__pragma(warning(pop))
}


#pragma warning(pop)
#pragma pack(pop)
#line 507 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocbuf"
#line 508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocbuf"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmes"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 struct messages_base 
    : locale::facet 
{
    using catalog = int;

    messages_base() noexcept 
        : messages_base(0) {}
    explicit messages_base(size_t _Refs) noexcept : locale::facet(_Refs) {}
};

 template <class _Elem>
class messages : public messages_base { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type   = _Elem;
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

    catalog open(const string& _Catname, const locale& _Loc) const { 
        return do_open(_Catname, _Loc);
    }

    string_type get(catalog _Catval, int _Set, int _Message,
        const string_type& _Dflt) const { 
        return do_get(_Catval, _Set, _Message, _Dflt);
    }

    void close(catalog _Catval) const { 
        do_close(_Catval);
    }

     __declspec(dllimport) static locale::id id; 

    explicit messages(size_t _Refs = 0) : messages_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    messages(const _Locinfo& _Lobj, size_t _Refs = 0) : messages_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new messages<_Elem>(_Locinfo(_Ploc->_C_str()));
        }

        return 6;
    }

protected:
    messages(const char* _Locname, size_t _Refs = 0) : messages_base(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj);
        }
    }

     ~messages() noexcept override {}

    void _Init(const _Locinfo&) {} 

    virtual catalog  do_open(const string&, const locale&) const { 
        return -1;
    }

    virtual string_type  do_get(catalog, int, int,
        const string_type& _Dflt) const { 
        return _Dflt;
    }

    virtual void  do_close(catalog) const {} 
};






template <class _Elem>
 locale::id messages<_Elem>::id;





 template <class _Elem>
class messages_byname : public messages<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit messages_byname(const char* _Locname, size_t _Refs = 0)
        : messages<_Elem>(_Locname, _Refs) {} 

    explicit messages_byname(const string& _Str, size_t _Refs = 0)
        : messages<_Elem>(_Str.c_str(), _Refs) {} 

protected:
     ~messages_byname() noexcept override {}
};




template  locale::id messages<char>::id;
template  locale::id messages<wchar_t>::id;
#line 128 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmes"




#line 133 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmes"
}


#pragma warning(pop)
#pragma pack(pop)
#line 139 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmes"
#line 140 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmes"
#pragma external_header(pop)
#line 12 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmon"












#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 struct money_base 
    : locale::facet 
{
    enum { 
        symbol = '$',
        sign   = '+',
        space  = ' ',
        value  = 'v',
        none   = 'x'
    };
    using part = int;

    struct pattern { 
        char field[4];
    };

    money_base(size_t _Refs = 0) noexcept 
        : locale::facet(_Refs) {}
};

template <class _Elem>
class _Mpunct : public money_base { 
public:
    friend _Tidy_guard<_Mpunct>;

    using char_type   = _Elem;
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

    _Elem decimal_point() const {
        return do_decimal_point();
    }

    _Elem thousands_sep() const {
        return do_thousands_sep();
    }

    string grouping() const {
        return do_grouping();
    }

    string_type curr_symbol() const {
        return do_curr_symbol();
    }

    string_type positive_sign() const {
        return do_positive_sign();
    }

    string_type negative_sign() const {
        return do_negative_sign();
    }

    int frac_digits() const {
        return do_frac_digits();
    }

    pattern pos_format() const {
        return do_pos_format();
    }

    pattern neg_format() const {
        return do_neg_format();
    }

    explicit _Mpunct(size_t _Refs, bool _Intl)
        : money_base(_Refs), _International(_Intl) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    _Mpunct(const _Locinfo& _Lobj, size_t _Refs, bool _Intl, bool _Isdef = false)
        : money_base(_Refs), _International(_Intl) {
        _Init(_Lobj, _Isdef);
    }

protected:
    _Mpunct(const char* _Locname, size_t _Refs, bool _Intl, bool _Isdef = false)
        : money_base(_Refs), _International(_Intl) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj, _Isdef);
        }
    }

     ~_Mpunct() noexcept override {
        _Tidy();
    }

    template <class _Elem2>
    void _Getvals(_Elem2, const lconv* _Ptr) { 
        _Currencysign = _Maklocstr(
            _International ? _Ptr->int_curr_symbol : _Ptr->currency_symbol, static_cast<_Elem2*>(nullptr), _Cvt);
        _Plussign = _Maklocstr(4 < static_cast<unsigned int>(_Ptr->p_sign_posn) ? "" : _Ptr->positive_sign,
            static_cast<_Elem2*>(nullptr), _Cvt);
        _Minussign = _Maklocstr(4 < static_cast<unsigned int>(_Ptr->n_sign_posn) ? "-" : _Ptr->negative_sign,
            static_cast<_Elem2*>(nullptr), _Cvt);
        _Decimalpoint = _Maklocchr(_Ptr->mon_decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
        _Kseparator   = _Maklocchr(_Ptr->mon_thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
    }

    void _Getvals(wchar_t, const lconv* _Ptr) { 
        _Currencysign = reinterpret_cast<const _Elem*>(
            _Maklocwcs(_International ? _Ptr->_W_int_curr_symbol : _Ptr->_W_currency_symbol));
        _Plussign = reinterpret_cast<const _Elem*>(
            _Maklocwcs(4 < static_cast<unsigned int>(_Ptr->p_sign_posn) ? L"" : _Ptr->_W_positive_sign));
        _Minussign = reinterpret_cast<const _Elem*>(
            _Maklocwcs(4 < static_cast<unsigned int>(_Ptr->n_sign_posn) ? L"-" : _Ptr->_W_negative_sign));
        _Decimalpoint = static_cast<_Elem>(_Ptr->_W_mon_decimal_point[0]);
        _Kseparator   = static_cast<_Elem>(_Ptr->_W_mon_thousands_sep[0]);
    }

    void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { 
        _Cvt              = _Lobj._Getcvt();
        const lconv* _Ptr = _Lobj._Getlconv();

        _Grouping     = nullptr;
        _Currencysign = nullptr;
        _Plussign     = nullptr;
        _Minussign    = nullptr;

        _Tidy_guard<_Mpunct> _Guard{this};
        _Grouping = _Maklocstr(_Ptr->mon_grouping, static_cast<char*>(nullptr), _Cvt);
        _Getvals(_Elem{}, _Ptr);
        _Guard._Target = nullptr;

        _Fracdigits = _International ? _Ptr->int_frac_digits : _Ptr->frac_digits;
        if (_Fracdigits < 0 || 127 <= _Fracdigits) {
            _Fracdigits = 0;
        }

        _Makpat(_Plusformat, static_cast<unsigned int>(_Ptr->p_sep_by_space),
            static_cast<unsigned int>(_Ptr->p_cs_precedes), static_cast<unsigned int>(_Ptr->p_sign_posn));
        _Makpat(_Minusformat, static_cast<unsigned int>(_Ptr->n_sep_by_space),
            static_cast<unsigned int>(_Ptr->n_cs_precedes), static_cast<unsigned int>(_Ptr->n_sign_posn));

        if (_Isdef) { 
            :: memcpy(&_Plusformat, "$+xv", 4);
            :: memcpy(&_Minusformat, "$+xv", 4);
        }
    }

    virtual _Elem  do_decimal_point() const {
        return _Decimalpoint;
    }

    virtual _Elem  do_thousands_sep() const {
        return _Kseparator;
    }

    virtual string  do_grouping() const {
        return string{_Grouping};
    }

    virtual string_type  do_curr_symbol() const {
        return string_type{_Currencysign};
    }

    virtual string_type  do_positive_sign() const {
        return string_type{_Plussign};
    }

    virtual string_type  do_negative_sign() const {
        return string_type{_Minussign};
    }

    virtual int  do_frac_digits() const {
        return _Fracdigits;
    }

    virtual pattern  do_pos_format() const {
        return _Plusformat;
    }

    virtual pattern  do_neg_format() const {
        return _Minusformat;
    }

private:
    void _Makpat(pattern& _Pattern, unsigned int _Sepbyspace, unsigned int _Symbolprecedes,
        unsigned int _Signposition) { 

        const char* _Ptr;

        if (_International || 2 < _Sepbyspace || 1 < _Symbolprecedes || 4 < _Signposition) {
            
            _Ptr = "$+xv";
        } else {
            
            _Ptr =
                "+v$x" "+v$x" "v$+x" "v+$x" "v$+x"
                "+$vx" "+$vx" "$v+x" "+$vx" "$+vx"
                "+v $" "+v $" "v $+" "v +$" "v $+"
                "+$ v" "+$ v" "$ v+" "+$ v" "$+ v"
                "+xv$" "+ v$" "v$ +" "v+ $" "v$ +"
                "+x$v" "+ $v" "$v +" "+ $v" "$ +v";
            
            _Ptr += _Signposition * 4 
                  + _Symbolprecedes * 20 
                  + _Sepbyspace * 40; 
        }

        :: memcpy(_Pattern.field, _Ptr, sizeof(_Pattern.field));
    }

    void _Tidy() noexcept { 
        :: free(const_cast<char*>(_Grouping));
        :: free(const_cast<_Elem*>(_Currencysign));
        :: free(const_cast<_Elem*>(_Plussign));
        :: free(const_cast<_Elem*>(_Minussign));
    }

    const char* _Grouping; 
    _Elem _Decimalpoint; 
    _Elem _Kseparator; 
    const _Elem* _Currencysign; 
    const _Elem* _Plussign; 
    const _Elem* _Minussign; 
    int _Fracdigits; 
    pattern _Plusformat; 
    pattern _Minusformat; 
    bool _International; 

    _Locinfo::_Cvtvec _Cvt; 
};

 template <class _Elem, bool _Intl = false>
class moneypunct : public _Mpunct<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

     __declspec(dllimport) static const bool intl; 
     __declspec(dllimport) static locale::id id; 

    explicit moneypunct(size_t _Refs = 0) : _Mpunct<_Elem>(_Refs, _Intl) {} 

    moneypunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
        : _Mpunct<_Elem>(_Lobj, _Refs, _Intl, _Isdef) {}

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new moneypunct<_Elem, _Intl>(_Locinfo(_Ploc->_C_str()), 0, true);
        }

        return 3;
    }

protected:
    moneypunct(const char* _Locname, size_t _Refs = 0) : _Mpunct<_Elem>(_Locname, _Refs, _Intl) {}

     ~moneypunct() noexcept override {}
};






template <class _Elem, bool _Intl>
 const bool moneypunct<_Elem, _Intl>::intl = _Intl;

template <class _Elem, bool _Intl>
 locale::id moneypunct<_Elem, _Intl>::id;





 template <class _Elem, bool _Intl = false>
class moneypunct_byname : public moneypunct<_Elem, _Intl> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit moneypunct_byname(const char* _Locname, size_t _Refs = 0)
        : moneypunct<_Elem, _Intl>(_Locname, _Refs) {} 

    explicit moneypunct_byname(const string& _Str, size_t _Refs = 0)
        : moneypunct<_Elem, _Intl>(_Str.c_str(), _Refs) {} 

protected:
     ~moneypunct_byname() noexcept override {}
};

 template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class money_get : public locale::facet { 
private:
    using _Mypunct0 = moneypunct<_Elem, false>;
    using _Mypunct1 = moneypunct<_Elem, true>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type   = _Elem;
    using iter_type   = _InIt;
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

    _InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
        long double& _Val) const { 
        return do_get(_First, _Last, _Intl, _Iosbase, _State, _Val);
    }

    _InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State,
        string_type& _Val) const { 
        return do_get(_First, _Last, _Intl, _Iosbase, _State, _Val);
    }

     __declspec(dllimport) static locale::id id; 

    explicit money_get(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    money_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new money_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 3;
    }

protected:
     ~money_get() noexcept override {}

    void _Init(const _Locinfo&) {} 

    virtual _InIt  do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase,
        ios_base::iostate& _State,
        long double& _Val) const { 
        _Elem _Atoms[sizeof("0123456789-")];
        string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        if (_Str.empty()) {
            _State |= ios_base::failbit; 
        } else { 
            const char* _Eb = _Str.c_str();
            char* _Ep;
            int _Errno             = 0;
            const long double _Ans = _Stodx_v3(_Eb, &_Ep, &_Errno); 

            if (_Ep == _Eb || _Errno != 0) {
                _State |= ios_base::failbit;
            } else {
                _Val = _Ans; 
            }
        }
        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase,
        ios_base::iostate& _State,
        string_type& _Val) const { 
        _Elem _Atoms[sizeof("0123456789-")];
        string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);
        size_t _Len = _Str.size();

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        if (_Len == 0) {
            _State |= ios_base::failbit; 
        } else { 
            size_t _Idx = 0;
            _Val.resize(_Len);
            if (_Str[0] == '-') {
                _Val[_Idx++] = _Atoms[10];
            }

            for (; _Idx < _Len; ++_Idx) {
                _Val[_Idx] = _Atoms[_Str[_Idx] - '0']; 
            }
        }
        return _First;
    }

private:
    string _Getmfld(_InIt& _First, _InIt& _Last, bool _Intl, ios_base& _Iosbase,
        _Elem (&_Atoms)[12]) const { 
        _Adl_verify_range(_First, _Last);
        const _Mpunct<_Elem>* _Ppunct_fac;
        if (_Intl) {
            _Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct1>(_Iosbase.getloc())); 
        } else {
            _Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct0>(_Iosbase.getloc())); 
        }

        bool _Bad = false;
        bool _Neg = false;
        string_type _Sign;
        const money_base::pattern _Pattern = _Ppunct_fac->neg_format();
        string _Val;
        size_t _Idx;
        static constexpr char _Src[]   = "0123456789-";
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        for (size_t _Off = 0; !_Bad && _Off < 4; ++_Off) {
            switch (_Pattern.field[_Off]) { 
            case money_base::symbol:
                { 
                    string_type _Symbol = _Ppunct_fac->curr_symbol();
                    typename string_type::const_iterator _Source;

                    if ((!(_Iosbase.flags() & ios_base::showbase) && _First != _Last && *_First != *_Symbol.c_str())
                        || (_Off == 3 && _Sign.size() <= 1
                            && (_First == _Last || *_First != *_Symbol.c_str()))) { 
                                                                                    
                                                                                    
                        _Symbol.erase();
                    }

                    _Source = _Symbol.begin();
                    while (_First != _Last && _Source != _Symbol.end() && *_First == *_Source) {
                        
                        ++_Source;
                        ++_First;
                    }

                    if (_Source != _Symbol.end()) {
                        _Bad = true; 
                    }
                    break;
                }

            case money_base::sign: 
                if (_First != _Last) {
                    if (0 < _Ppunct_fac->positive_sign().size()
                        && _Ppunct_fac->positive_sign()[0] == *_First) { 
                        ++_First;
                        _Sign = _Ppunct_fac->positive_sign();
                    } else if (0 < _Ppunct_fac->negative_sign().size()
                               && _Ppunct_fac->negative_sign()[0] == *_First) { 
                        ++_First;
                        _Sign = _Ppunct_fac->negative_sign();
                        _Neg  = true;
                    } else if (0 != _Ppunct_fac->positive_sign().size() && 0 == _Ppunct_fac->negative_sign().size()) {
                        _Neg = true;
                    }
                }

                break; 

            case money_base::value:
                { 
                    int _Fracdigseen        = 0;
                    int _Fracdigits         = _Ppunct_fac->frac_digits();
                    const string _Grouping  = _Ppunct_fac->grouping();
                    const _Elem _Kseparator = _Grouping.empty() ? _Elem{} : _Ppunct_fac->thousands_sep();

                    if (_Kseparator == _Elem{} || 127 <= static_cast<unsigned char>(*_Grouping.c_str())) {
                        for (; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; ++_First) {
                            _Val += _Src[_Idx]; 
                        }
                    } else { 
                        string _Groups;
                        _Groups.push_back('\0');
                        size_t _Group = 0;

                        for (; _First != _Last; ++_First) {
                            if ((_Idx = _Find_elem(_Atoms, *_First)) < 10) { 
                                _Val += _Src[_Idx];
                                if (_Groups[_Group] != 127) {
                                    ++_Groups[_Group];
                                }
                            } else if (_Groups[_Group] == '\0' || *_First != _Kseparator) {
                                break; 
                            } else { 
                                _Groups.push_back('\0');
                                ++_Group;
                            }
                        }

                        if (_Group != 0) { 
                            if ('\0' < _Groups[_Group]) {
                                ++_Group; 
                            } else {
                                _Bad = true; 
                            }
                        }

                        for (const char* _Pg = _Grouping.c_str(); !_Bad && 0 < _Group;) {
                            if (*_Pg == 127) {
                                break; 
                            }

                            if ((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group])) {
                                _Bad = true; 
                            } else if ('\0' < _Pg[1]) {
                                ++_Pg; 
                            }
                        }

                        if (_Bad) {
                            break; 
                        }
                    }

                    const _Elem _Point = _Ppunct_fac->decimal_point();
                    if (_First != _Last && _Point != _Elem{}
                        && *_First == _Point) { 
                        while (++_First != _Last && _Fracdigseen < _Fracdigits
                               && (_Idx = _Find_elem(_Atoms, *_First)) < 10) {
                            _Val += _Src[_Idx];
                            ++_Fracdigseen;
                        }

                        if (_Fracdigseen < _Fracdigits) {
                            _Bad = true; 
                        }
                    }

                    if (_Val.empty()) {
                        _Bad = true; 
                    } else {
                        for (; _Fracdigseen < _Fracdigits; ++_Fracdigseen) {
                            _Val += '0'; 
                        }
                    }

                    break;
                }

            case money_base::space:
            case money_base::none:
                { 
                    if (_Off == 3) {
                        break; 
                    }

                    bool _Seen = false;

                    for (; _First != _Last && _Ctype_fac.is(ctype_base::space, *_First); ++_First) {
                        _Seen = true; 
                    }

                    if (_Pattern.field[_Off] == money_base::space && !_Seen) {
                        _Bad = true; 
                    }
                } 
            } 
        }

        if (!_Bad && 1 < _Sign.size()) { 
            auto _Source = _Sign.begin();

            while (++_Source != _Sign.end() && _First != _Last && *_First == *_Source) {
                ++_First;
            }

            if (_Source != _Sign.end()) {
                _Bad = true; 
            }
        }

        if (_Bad) {
            _Val.erase(); 
        } else if (_Neg) {
            _Val.insert(0, 1, '-'); 
        }

        return _Val;
    }
};






template <class _Elem, class _InIt>
 locale::id money_get<_Elem, _InIt>::id;





 template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class money_put : public locale::facet { 
private:
    using _Mypunct0 = moneypunct<_Elem, false>;
    using _Mypunct1 = moneypunct<_Elem, true>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type   = _Elem;
    using iter_type   = _OutIt;
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

    _OutIt put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill,
        long double _Val) const { 
        return do_put(_Dest, _Intl, _Iosbase, _Fill, _Val);
    }

    _OutIt put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill,
        const string_type& _Val) const { 
        return do_put(_Dest, _Intl, _Iosbase, _Fill, _Val);
    }

     __declspec(dllimport) static locale::id id; 

    explicit money_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    money_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new money_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 3;
    }

protected:
     ~money_put() noexcept override {}

    void _Init(const _Locinfo&) {} 

    virtual _OutIt  do_put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill,
        long double _Val) const { 
        bool _Negative = false;
        if (_Val < 0) {
            _Negative = true;
            _Val      = -_Val;
        }

        size_t _Exp;
        for (_Exp = 0; 1e35 <= _Val && _Exp < 5000; _Exp += 10) {
            _Val /= 1e10; 
        }

        char _Buf[40];

        
        const int _Count = :: sprintf_s(_Buf, sizeof(_Buf), "%.0Lf", _Val);

        if (_Count < 0) {
            return _Dest; 
        }

        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        const _Elem _Elem0             = _Ctype_fac.widen('0');

        string_type _Val2(static_cast<size_t>(_Count), _Elem{});
        _Ctype_fac.widen(_Buf, _Buf + _Count, &_Val2[0]);
        _Val2.append(_Exp, _Elem0); 
        return _Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2, _Elem0);
    }

    virtual _OutIt  do_put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill,
        const string_type& _Val) const { 
        static constexpr char _Src[] = "0123456789-";
        _Elem _Atoms[sizeof(_Src)];
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Iosbase.getloc());
        _Ctype_fac.widen(::std:: begin(_Src), ::std:: end(_Src), _Atoms);

        bool _Negative = false;
        size_t _Idx0   = 0;
        if (!_Val.empty() && _Val[0] == _Atoms[10]) { 
            _Negative = true;
            ++_Idx0;
        }

        size_t _Size = _Val.size();
        size_t _Idx  = _Idx0;
        for (; _Idx < _Size && _Find_elem(_Atoms, _Val[_Idx]) < 10; ++_Idx) { 
        }

        string_type _Val2(&_Val[_Idx0], _Idx - _Idx0);
        if (_Val2.empty()) { 
            _Val2.push_back(_Atoms[0]);
        }

        return _Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2, _Atoms[0]);
    }

private:
    _OutIt _Putmfld(
        _OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, bool _Neg, string_type _Val, _Elem _Elem0) const {
        
        const _Mpunct<_Elem>* _Ppunct_fac;
        if (_Intl) {
            _Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct1>(_Iosbase.getloc())); 
        } else {
            _Ppunct_fac = ::std:: addressof(::std:: use_facet<_Mypunct0>(_Iosbase.getloc())); 
        }

        const string _Grouping = _Ppunct_fac->grouping();
        int _Ifracdigits       = _Ppunct_fac->frac_digits();
        const auto _Fracdigits = static_cast<unsigned int>(_Ifracdigits < 0 ? -_Ifracdigits : _Ifracdigits);

        if (_Val.size() <= _Fracdigits) {
            _Val.insert(0, _Fracdigits - _Val.size() + 1, _Elem0);
        } else if (*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str()) {
            
            const _Elem _Kseparator = _Ppunct_fac->thousands_sep();
            const char* _Pg         = _Grouping.c_str();
            size_t _Off             = _Val.size() - _Fracdigits; 

            while (*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off) {
                
                _Val.insert(_Off -= *_Pg, 1, _Kseparator);
                if ('\0' < _Pg[1]) {
                    ++_Pg; 
                }
            }
        }

        money_base::pattern _Pattern;
        string_type _Sign;
        if (_Neg) { 
            _Pattern = _Ppunct_fac->neg_format();
            _Sign    = _Ppunct_fac->negative_sign();
        } else { 
            _Pattern = _Ppunct_fac->pos_format();
            _Sign    = _Ppunct_fac->positive_sign();
        }

        string_type _Symbol;
        if (_Iosbase.flags() & ios_base::showbase) {
            _Symbol = _Ppunct_fac->curr_symbol(); 
        }

        bool _Intern = false;
        size_t _Fillcount;
        size_t _Off;
        for (_Fillcount = 0, _Off = 0; _Off < 4; ++_Off) {
            switch (_Pattern.field[_Off]) { 
            case money_base::symbol: 
                _Fillcount += _Symbol.size();
                break;

            case money_base::sign: 
                _Fillcount += _Sign.size();
                break;

            case money_base::value: 
                _Fillcount += _Val.size() + (0 < _Fracdigits ? 1 : 0)
                            + (_Val.size() <= _Fracdigits ? _Fracdigits - _Val.size() + 1 : 0);
                break;

            case money_base::space: 
                ++_Fillcount; 
                [[fallthrough]];

            case money_base::none: 
                if (_Off != 3) {
                    _Intern = true; 
                }

                break;
            }
        }

        if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Fillcount) {
            _Fillcount = 0;
        } else {
            _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Fillcount;
        }

        ios_base::fmtflags _Afl = _Iosbase.flags() & ios_base::adjustfield;
        if (_Afl != ios_base::left && (_Afl != ios_base::internal || !_Intern)) { 
            _Dest      = _Rep(_Dest, _Fill, _Fillcount);
            _Fillcount = 0;
        }

        for (_Off = 0; _Off < 4; ++_Off) {
            switch (_Pattern.field[_Off]) { 
            case money_base::symbol: 
                _Dest = _Put(_Dest, _Symbol.begin(), _Symbol.size());
                break;

            case money_base::sign: 
                if (0 < _Sign.size()) {
                    _Dest = _Put(_Dest, _Sign.begin(), 1);
                }

                break;

            case money_base::value: 
                if (_Fracdigits == 0) {
                    _Dest = _Put(_Dest, _Val.begin(), _Val.size()); 
                } else if (_Val.size() <= _Fracdigits) { 
                    *_Dest++ = _Elem0;
                    *_Dest++ = _Ppunct_fac->decimal_point();
                    _Dest    = _Rep(_Dest, _Elem0, _Fracdigits - _Val.size()); 
                    _Dest    = _Put(_Dest, _Val.begin(), _Val.size());
                } else { 
                    _Dest    = _Put(_Dest, _Val.begin(), _Val.size() - _Fracdigits); 
                    *_Dest++ = _Ppunct_fac->decimal_point();
                    _Dest =
                        _Put(_Dest, _Val.end() - static_cast<ptrdiff_t>(_Fracdigits), _Fracdigits); 
                }
                break;

            case money_base::space: 
                _Dest = _Rep(_Dest, _Fill, 1);
                [[fallthrough]];

            case money_base::none: 
                if (_Afl == ios_base::internal) { 
                    _Dest      = _Rep(_Dest, _Fill, _Fillcount);
                    _Fillcount = 0;
                }
            }
        }

        if (1 < _Sign.size()) {
            _Dest = _Put(_Dest, _Sign.begin() + 1, _Sign.size() - 1); 
        }

        _Iosbase.width(0);
        return _Rep(_Dest, _Fill, _Fillcount); 
    }

    static _OutIt _Put(_OutIt _Dest, typename string_type::const_iterator _Source, size_t _Count) {
        
        for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Source) {
            *_Dest = *_Source;
        }

        return _Dest;
    }

    static _OutIt _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) { 
        for (; 0 < _Count; --_Count, (void) ++_Dest) {
            *_Dest = _Ch;
        }

        return _Dest;
    }
};






template <class _Elem, class _OutIt>
 locale::id money_put<_Elem, _OutIt>::id;




template  const bool moneypunct<char, true>::intl;
template  const bool moneypunct<char, false>::intl;
template  locale::id moneypunct<char, true>::id;
template  locale::id moneypunct<char, false>::id;
template  locale::id money_get<char, istreambuf_iterator<char, char_traits<char>>>::id;
template  locale::id money_put<char, ostreambuf_iterator<char, char_traits<char>>>::id;

template  const bool moneypunct<wchar_t, true>::intl;
template  const bool moneypunct<wchar_t, false>::intl;
template  locale::id moneypunct<wchar_t, true>::id;
template  locale::id moneypunct<wchar_t, false>::id;
template  locale::id money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>::id;
template  locale::id money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>::id;
#line 897 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmon"











#line 909 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmon"





}



#pragma warning(pop)
#pragma pack(pop)
#line 921 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmon"
#line 922 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xlocmon"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"













#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _InIt, class _Elem>
ios_base::iostate _Getint_v2(_InIt& _First, _InIt& _Last, int _Lo, int _Hi, int& _Val, int& _Digits_read,
    const ctype<_Elem>& _Ctype_fac) { 
    ;
    const int _Hi_digits = (_Hi <= 9 ? 1 : _Hi <= 99 ? 2 : _Hi <= 999 ? 3 : 4);
    char _Ac[_Max_int_dig];
    char* _Ep;
    char* _Ptr = _Ac;
    char _Ch;

    _Digits_read = 0;

    while (_First != _Last && _Digits_read < _Hi_digits && _Ctype_fac.is(ctype_base::space, *_First)) {
        ++_First;
        ++_Digits_read;
    }

    if (_First != _Last && _Digits_read < _Hi_digits) {
        if ((_Ch = _Ctype_fac.narrow(*_First)) == '+') { 
            *_Ptr++ = '+';
            ++_First;
        } else if (_Ch == '-') { 
            *_Ptr++ = '-';
            ++_First;
        }
    }

    for (; _First != _Last && _Digits_read < _Hi_digits && _Ctype_fac.narrow(*_First) == '0'; ++_First) {
        ++_Digits_read; 
    }

    if (_Digits_read > 0) {
        *_Ptr++ = '0'; 
    }

    for (char* const _Pe = &_Ac[_Max_int_dig - 1];
         _First != _Last && '0' <= (_Ch = _Ctype_fac.narrow(*_First)) && _Ch <= '9' && _Digits_read < _Hi_digits;
         ++_Digits_read, (void) ++_First) { 
        *_Ptr = _Ch;
        if (_Ptr < _Pe) {
            ++_Ptr; 
        }
    }

    if (_Digits_read == 0) {
        _Ptr = _Ac;
    }

    *_Ptr                    = '\0';
    int _Errno               = 0;
    const long _Ans          = :: _Stolx(_Ac, &_Ep, 10, &_Errno);
    ios_base::iostate _State = ios_base::goodbit;

    if (_First == _Last) {
        _State |= ios_base::eofbit;
    }

    if (_Ep == _Ac || _Errno != 0 || _Ans < _Lo || _Hi < _Ans) {
        _State |= ios_base::failbit; 
    } else {
        _Val = _Ans; 
    }

    return _State;
}

 extern "C++" struct __declspec(dllimport) time_base 
    : locale::facet 
{
    enum dateorder { 
        no_order,
        dmy,
        mdy,
        ymd,
        ydm
    };

     time_base(size_t _Refs = 0) noexcept 
        : locale::facet(_Refs) {}

     ~time_base() noexcept override {}
};

 extern "C++" template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class time_get : public time_base { 
private:
    friend _Tidy_guard<time_get>;

public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type = _Elem;
    using iter_type = _InIt;
    using _Ctype    = ctype<_Elem>;

     static locale::id id; 

    dateorder  date_order() const {
        return do_date_order();
    }

    _InIt  get_time(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt) const { 
        return do_get_time(_First, _Last, _Iosbase, _State, _Pt);
    }

    _InIt  get_date(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt) const { 
        return do_get_date(_First, _Last, _Iosbase, _State, _Pt);
    }

    _InIt  get_weekday(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt) const { 
        return do_get_weekday(_First, _Last, _Iosbase, _State, _Pt);
    }

    _InIt  get_monthname(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt) const { 
        return do_get_monthname(_First, _Last, _Iosbase, _State, _Pt);
    }

    _InIt  get_year(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt) const { 
        return do_get_year(_First, _Last, _Iosbase, _State, _Pt);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt,
        char _Specifier, char _Modifier = '\0') const { 
        return do_get(_First, _Last, _Iosbase, _State, _Pt, _Specifier, _Modifier);
    }

    _InIt  get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt,
        const _Elem* _Fmtfirst, const _Elem* _Fmtlast) const { 
        _Adl_verify_range(_Fmtfirst, _Fmtlast);
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        _State = ios_base::goodbit;

        for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst) {
            if (_State != ios_base::goodbit) {
                
                
                break;
            } else if (_First == _Last) {
                
                _State = ios_base::eofbit | ios_base::failbit;
                break;
            } else if (_Ctype_fac.narrow(*_Fmtfirst) != '%') { 
                if (_Ctype_fac.is(_Ctype::space, *_Fmtfirst)) {
                    while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
                        ++_First;
                    }
                } else if (_Ctype_fac.tolower(*_First) != _Ctype_fac.tolower(*_Fmtfirst)) { 
                    _State |= ios_base::failbit;
                    break;
                } else {
                    ++_First;
                }
            } else if (++_Fmtfirst == _Fmtlast) {
                
                
                
                _State = ios_base::failbit;
                break;
            } else { 
                char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                char _Modifier  = '\0';

                if (_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#') {
                    if (++_Fmtfirst == _Fmtlast) { 
                        _State = ios_base::failbit;
                        break;
                    } else { 
                        _Modifier  = _Specifier;
                        _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                    }
                }

                _First = do_get(_First, _Last, _Iosbase, _State, _Pt, _Specifier, _Modifier); 
            }
        }

        return _First;
    }

    explicit  time_get(size_t _Refs = 0) : time_base(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     time_get(const _Locinfo& _Lobj, size_t _Refs = 0) : time_base(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new time_get<_Elem, _InIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 5;
    }

protected:
     ~time_get() noexcept override {
        _Tidy();
    }

     time_get(const char* _Locname, size_t _Refs = 0) : time_base(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj);
        }
    }

    template <class _Elem2>
    void  _Getvals(_Elem2, const _Locinfo& _Lobj) { 
        _Cvt = _Lobj._Getcvt();

        if (is_same_v<_Elem2, wchar_t>) {
            _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));
            _Months =
                reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
            _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));
        } else {
            _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);
            _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);
            _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);
        }
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Days   = nullptr;
        _Months = nullptr;
        _Ampm   = nullptr;

        _Tidy_guard<time_get> _Guard{this};
        _Getvals(_Elem{}, _Lobj);
        _Dateorder     = static_cast<dateorder>(_Lobj._Getdateorder());
        _Guard._Target = nullptr;
    }

    virtual dateorder  do_date_order() const {
        return _Dateorder;
    }

    virtual _InIt  do_get_time(_InIt _First, _InIt _Last, ios_base& _Iosbase,
        ios_base::iostate& _State, tm* _Pt) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        _State |= _Getint(_First, _Last, 0, 23, _Pt->tm_hour, _Ctype_fac);

        if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':') {
            _State |= ios_base::failbit; 
        } else {
            _State |= _Getint(++_First, _Last, 0, 59, _Pt->tm_min, _Ctype_fac);
        }

        if (_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':') {
            _State |= ios_base::failbit; 
        } else {
            _State |= _Getint(++_First, _Last, 0, 60, _Pt->tm_sec, _Ctype_fac);
        }

        return _First;
    }

    virtual _InIt  do_get_date(_InIt _First, _InIt _Last, ios_base& _Iosbase,
        ios_base::iostate& _State, tm* _Pt) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        dateorder _Dorder = date_order();
        if (_Dorder == no_order) {
            _Dorder = mdy;
        }

        if (_First != _Last) {
            if (!_Ctype_fac.is(_Ctype::digit, *_First)) { 
                _First  = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                _Dorder = mdy;
            } else if (_Dorder == mdy) { 
                _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
                --_Pt->tm_mon;
            } else if (_Dorder == dmy) {
                _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
            } else { 
                _First = get_year(_First, _Last, _Iosbase, _State, _Pt);
            }
        }

        while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
            ++_First; 
        }

        if (_First != _Last) { 
            char _Ch = _Ctype_fac.narrow(*_First);
            if (_Ch == ':' || _Ch == ',' || _Ch == '/') {
                ++_First;
            }
        }

        while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
            ++_First; 
        }

        if (_First != _Last) {
            if (!_Ctype_fac.is(_Ctype::digit, *_First)) {
                if (_Dorder == mdy) {
                    _State |= ios_base::failbit; 
                } else { 
                    _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                    if (_Dorder == ydm) {
                        _Dorder = ymd;
                    }
                }
            } else if (_Dorder == dmy || _Dorder == ymd) { 
                _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
                --_Pt->tm_mon;
            } else {
                _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
            }
        }

        while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
            ++_First; 
        }

        if (_First != _Last) { 
            char _Ch = _Ctype_fac.narrow(*_First);
            if (_Ch == ':' || _Ch == ',' || _Ch == '/') {
                ++_First;
            }
        }

        while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
            ++_First; 
        }

        if (_First == _Last) {
            _State |= ios_base::failbit; 
        } else if (!_Ctype_fac.is(_Ctype::digit, *_First)) {
            if (_Dorder != ydm) {
                _State |= ios_base::failbit; 
            } else {
                _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
            }
        } else if (_Dorder == ydm) { 
            _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
            --_Pt->tm_mon;
        } else if (_Dorder == ymd) {
            _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
        } else { 
            _First = get_year(_First, _Last, _Iosbase, _State, _Pt);
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    virtual _InIt  do_get_weekday(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate& _State,
        tm* _Pt) const { 
        int _Num = _Getloctxt(_First, _Last, 0, _Days, _Case_sensitive::_Nope);
        if (_Num < 0) {
            _State |= ios_base::failbit;
        } else {
            _Pt->tm_wday = _Num >> 1; 
        }

        return _First;
    }

    virtual _InIt  do_get_monthname(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate& _State,
        tm* _Pt) const { 
        int _Num = _Getloctxt(_First, _Last, 0, _Months, _Case_sensitive::_Nope);

        if (_Num < 0) {
            _State |= ios_base::failbit;
        } else {
            _Pt->tm_mon = _Num >> 1; 
        }

        return _First;
    }

    virtual _InIt  do_get_year(_InIt _First, _InIt _Last, ios_base& _Iosbase,
        ios_base::iostate& _State, tm* _Pt) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        int _Ans = 0;
        int _Digits_read;
        ios_base::iostate _Res = _Getint_v2(_First, _Last, 0, 9999, _Ans, _Digits_read, _Ctype_fac);

        _State |= _Res; 
        if (!(_Res & ios_base::failbit)) {
            if (_Digits_read <= 2) {
                if (_Ans < 69) {
                    _Pt->tm_year = _Ans + 100; 
                } else if (_Ans < 100) {
                    _Pt->tm_year = _Ans; 
                }
            } else {
                _Pt->tm_year = _Ans - 1900; 
            }
        }

        return _First;
    }

    virtual _InIt  do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State,
        tm* _Pt, char _Specifier, char = 0) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());
        int _Ans                 = 0;

        _State = ios_base::goodbit;

        switch (_Specifier) { 
        case 'a':
        case 'A':
            _First = get_weekday(_First, _Last, _Iosbase, _State, _Pt);
            break;

        case 'b':
        case 'B':
        case 'h':
            _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
            break;

        case 'c':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%b %d %H : %M : %S %Y");
            break;

        case 'C':
            _State |= _Getint(_First, _Last, 0, 99, _Ans, _Ctype_fac);
            if (!(_State & ios_base::failbit)) {
                _Pt->tm_year = _Ans * 100 - 1900; 
            }

            break;

        case 'd':
        case 'e':
            _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
            break;

        case 'D':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%m / %d / %y");
            break;

        case 'H':
            _State |= _Getint(_First, _Last, 0, 23, _Pt->tm_hour, _Ctype_fac);
            break;

        case 'I':
            _State |= _Getint(_First, _Last, 1, 12, _Ans, _Ctype_fac);
            if (!(_State & ios_base::failbit)) {
                _Pt->tm_hour = _Ans == 12 ? 0 : _Ans;
            }

            break;

        case 'j':
            _State |= _Getint(_First, _Last, 1, 366, _Pt->tm_yday, _Ctype_fac);
            break;

        case 'm':
            _State |= _Getint(_First, _Last, 1, 12, _Ans, _Ctype_fac);
            if (!(_State & ios_base::failbit)) {
                _Pt->tm_mon = _Ans - 1;
            }

            break;

        case 'M':
            _State |= _Getint(_First, _Last, 0, 59, _Pt->tm_min, _Ctype_fac);
            break;

        case 'n':
        case 't':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, " ");
            break;

        case 'p':
            _Ans = _Getloctxt(_First, _Last, 0, ":AM:am:PM:pm", _Case_sensitive::_Nope);
            if (_Ans < 0) {
                _State |= ios_base::failbit;
            } else if (1 < _Ans) {
                _Pt->tm_hour += 12;
            }

            break;

        case 'r':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%I : %M : %S %p");
            break;

        case 'R':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%H : %M");
            break;

        case 'S':
            _State |= _Getint(_First, _Last, 0, 60, _Pt->tm_sec, _Ctype_fac);
            break;

        case 'T':
        case 'X':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%H : %M : %S");
            break;

        case 'U':
            _State |= _Getint(_First, _Last, 0, 53, _Pt->tm_yday, _Ctype_fac);
            break;

        case 'w':
            _State |= _Getint(_First, _Last, 0, 6, _Pt->tm_wday, _Ctype_fac);
            break;

        case 'W':
            _State |= _Getint(_First, _Last, 0, 53, _Pt->tm_yday, _Ctype_fac);
            break;

        case 'x':
            _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%d / %m / %y");
            break;

        case 'y':
            _State |= _Getint(_First, _Last, 0, 99, _Ans, _Ctype_fac);
            if (!(_State & ios_base::failbit)) {
                _Pt->tm_year = _Ans < 69 ? _Ans + 100 : _Ans;
            }

            break;

        case 'Y':
            _State |= _Getint(_First, _Last, 0, 9999, _Ans, _Ctype_fac);
            if (!(_State & ios_base::failbit)) {
                _Pt->tm_year = _Ans - 1900;
            }
            break;

        default:
            _State |= ios_base::failbit; 
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

    _InIt  _Getfmt(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt,
        const char* _Fmtfirst) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        for (; *_Fmtfirst != '\0'; ++_Fmtfirst) {
            if (_First == _Last) {
                _State |= ios_base::failbit;
                break;
            } else if (*_Fmtfirst == '%') {
                _First = do_get(_First, _Last, _Iosbase, _State, _Pt,
                    *++_Fmtfirst); 
            } else if (*_Fmtfirst == ' ') {
                while (_First != _Last && _Ctype_fac.is(_Ctype::space, *_First)) {
                    ++_First;
                }
            } else if (_Ctype_fac.narrow(*_First) != *_Fmtfirst) { 
                _State |= ios_base::failbit;
                break;
            } else {
                ++_First;
            }
        }

        if (_First == _Last) {
            _State |= ios_base::eofbit;
        }

        return _First;
    }

private:
    ios_base::iostate __cdecl _Getint(_InIt& _First, _InIt& _Last, int _Lo, int _Hi, int& _Val,
        const _Ctype& _Ctype_fac) const { 
        
        int _Digits_read;
        return _Getint_v2(_First, _Last, _Lo, _Hi, _Val, _Digits_read, _Ctype_fac);
    }

    void  _Tidy() noexcept { 
        :: free(const_cast<_Elem*>(_Days));
        :: free(const_cast<_Elem*>(_Months));
        :: free(const_cast<_Elem*>(_Ampm));
    }

    const _Elem* _Days; 
    const _Elem* _Months; 
    const _Elem* _Ampm; 
    dateorder _Dateorder;
    _Locinfo::_Cvtvec _Cvt; 
};






template <class _Elem, class _InIt>
 locale::id time_get<_Elem, _InIt>::id;





 template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
class time_get_byname : public time_get<_Elem, _InIt> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit time_get_byname(const char* _Locname, size_t _Refs = 0)
        : time_get<_Elem, _InIt>(_Locname, _Refs) {} 

    explicit time_get_byname(const string& _Str, size_t _Refs = 0)
        : time_get<_Elem, _InIt>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~time_get_byname() noexcept override {}
};

 extern "C++" template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class time_put : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type = _Elem;
    using iter_type = _OutIt;
    using _Ctype    = ctype<_Elem>;

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, const _Elem* _Fmtfirst,
        const _Elem* _Fmtlast) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst) {
            if (_Ctype_fac.narrow(*_Fmtfirst) != '%') {
                *_Dest++ = *_Fmtfirst; 
            } else if (++_Fmtfirst == _Fmtlast) { 
                *_Dest++ = _Fmtfirst[-1];
                break;
            } else { 
                char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                char _Modifier  = '\0';
                _Elem _Percent  = _Fmtfirst[-1];

                if (_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#') {
                    if (++_Fmtfirst == _Fmtlast) { 
                        *_Dest++ = _Percent;
                        *_Dest++ = _Specifier;
                        break;
                    }

                    
                    _Modifier  = _Specifier;
                    _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                }

                _Dest = do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier); 
            }
        }

        return _Dest;
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, char _Specifier,
        char _Modifier = '\0') const { 
        return do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
    }

     static locale::id id; 

    explicit  time_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     time_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 5;
    }

protected:
     ~time_put() noexcept override {}

    void  _Init(const _Locinfo& _Lobj) { 
        _Tnames = _Lobj._Gettnames();
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem, const tm* _Pt, char _Specifier,
        char _Modifier = '\0') const { 
        char _Fmt[5] = "!%x\0"; 
        size_t _Count;
        size_t _Num;
        string _Str;

        if (_Modifier == '\0') {
            _Fmt[2] = _Specifier;
        } else { 
            _Fmt[2] = _Modifier;
            _Fmt[3] = _Specifier;
        }

        int& _Errno_ref      = (*_errno()); 
        const int _Old_errno = _Errno_ref;

        for (_Num = 16;; _Num *= 2) { 
            _Str.append(_Num, '\0');
            _Count = _Strftime(&_Str[0], _Str.size(), _Fmt, _Pt, _Tnames._Getptr());
            if (0 < _Count) {
                break;
            } else if (_Errno_ref == 22) {
                _Iosbase.setstate(ios_base::badbit);
                return _Dest;
            }
        }

        _Errno_ref = _Old_errno;
        return ::std:: copy(&_Str[1], &_Str[_Count], _Dest);
    }

private:
    _Locinfo::_Timevec _Tnames; 
};






template <class _Elem, class _OutIt>
 locale::id time_put<_Elem, _OutIt>::id;





extern "C++" template <class _OutIt>
class time_put<wchar_t, _OutIt> : public locale::facet { 
public:
    using _Elem     = wchar_t;
    using char_type = _Elem;
    using iter_type = _OutIt;
    using _Ctype    = ctype<_Elem>;

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, const _Elem* _Fmtfirst,
        const _Elem* _Fmtlast) const { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Iosbase.getloc());

        for (; _Fmtfirst != _Fmtlast; ++_Fmtfirst) {
            if (_Ctype_fac.narrow(*_Fmtfirst) != '%') {
                *_Dest++ = *_Fmtfirst; 
            } else if (++_Fmtfirst == _Fmtlast) { 
                *_Dest++ = _Fmtfirst[-1];
                break;
            } else { 
                _Elem _Raw      = *_Fmtfirst;
                char _Specifier = _Ctype_fac.narrow(_Raw);
                char _Modifier  = '\0';
                _Elem _Percent  = _Fmtfirst[-1];

                if (_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#') {
                    if (++_Fmtfirst == _Fmtlast) { 
                        *_Dest++ = _Percent;
                        *_Dest++ = _Raw;
                        break;
                    }

                    
                    _Modifier  = _Specifier;
                    _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                }

                _Dest = do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier); 
            }
        }

        return _Dest;
    }

    _OutIt  put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, char _Specifier,
        char _Modifier = '\0') const { 
        return do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
    }

     static locale::id id; 

    explicit  time_put(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

     time_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        
        if (_Ppf && !*_Ppf) {
            *_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));
        }

        return 5;
    }

protected:
     ~time_put() noexcept override {}

     time_put(const char* _Locname, size_t _Refs = 0) : locale::facet(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj);
        }
    }

    void  _Init(const _Locinfo& _Lobj) { 
        _Tnames = _Lobj._W_Gettnames();
    }

    virtual _OutIt  do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem, const tm* _Pt, char _Specifier,
        char _Modifier = '\0') const { 
        wchar_t _Fmt[5] = L"!%x\0"; 
        size_t _Count;
        size_t _Num;
        wstring _Str;

        if (_Modifier == '\0') {
            _Fmt[2] = static_cast<_Elem>(_Specifier); 
        } else { 
            _Fmt[2] = static_cast<_Elem>(_Modifier);
            _Fmt[3] = static_cast<_Elem>(_Specifier);
        }

        int& _Errno_ref      = (*_errno()); 
        const int _Old_errno = _Errno_ref;

        for (_Num = 16;; _Num *= 2) { 
            _Str.append(_Num, '\0');
            _Count = _Wcsftime(&_Str[0], _Str.size(), _Fmt, _Pt, _Tnames._Getptr());
            if (0 < _Count) {
                break;
            } else if (_Errno_ref == 22) {
                _Iosbase.setstate(ios_base::badbit);
                return _Dest;
            }
        }

        _Errno_ref = _Old_errno;
        return ::std:: copy(&_Str[1], &_Str[_Count], _Dest);
    }

private:
    _Locinfo::_Timevec _Tnames; 
};






template <class _OutIt>
 locale::id time_put<wchar_t, _OutIt>::id;








































































































































#line 1039 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"

 template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
class time_put_byname : public time_put<_Elem, _OutIt> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit time_put_byname(const char* _Locname, size_t _Refs = 0)
        : time_put<_Elem, _OutIt>(_Locname, _Refs) {} 

    explicit time_put_byname(const string& _Str, size_t _Refs = 0)
        : time_put<_Elem, _OutIt>(_Str.c_str(), _Refs) {} 

protected:
     ~time_put_byname() noexcept override {}
};




template class __declspec(dllimport) time_get<char, istreambuf_iterator<char, char_traits<char>>>;
template class __declspec(dllimport) time_put<char, ostreambuf_iterator<char, char_traits<char>>>;
template  void  time_get<char, istreambuf_iterator<char, char_traits<char>>>::_Getvals(
    wchar_t, const _Locinfo&);

template class __declspec(dllimport) time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template class __declspec(dllimport) time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
template  void 
    time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>::_Getvals(wchar_t, const _Locinfo&);
#line 1068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"










#line 1079 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"
}



#pragma warning(pop)
#pragma pack(pop)
#line 1086 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"
#line 1087 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xloctime"
#pragma external_header(pop)
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 template <class _Elem>
class collate : public locale::facet { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    using char_type   = _Elem;
    using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

    [[nodiscard]] int compare(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2) const {
        
        return do_compare(_First1, _Last1, _First2, _Last2);
    }

    [[nodiscard]] string_type transform(const _Elem* _First, const _Elem* _Last) const {
        
        return do_transform(_First, _Last);
    }

    [[nodiscard]] long hash(const _Elem* _First, const _Elem* _Last) const { 
        return do_hash(_First, _Last);
    }

     __declspec(dllimport) static locale::id id; 

    explicit collate(size_t _Refs = 0) : locale::facet(_Refs) { 
        { _Locinfo _Lobj;
        _Init(_Lobj);
        }
    }

    collate(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {
        _Init(_Lobj);
    }

    static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {
        if (_Ppf && !*_Ppf) {
            *_Ppf = new collate<_Elem>(_Locinfo(_Ploc->name().c_str()));
        }

        return 1;
    }

protected:
     ~collate() noexcept override {
        :: free(_Coll._LocaleName);
    }

    collate(const char* _Locname, size_t _Refs = 0) : locale::facet(_Refs) {
        { _Locinfo _Lobj(_Locname);
        _Init(_Lobj);
        }
    }

    void _Init(const _Locinfo& _Lobj) { 
        _Coll = _Lobj._Getcoll();
    }

    [[nodiscard]] virtual int  do_compare(
        const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2) const {
        
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);
        return _Ans < 0 ? -1 : _Ans == 0 ? 0 : +1;
    }

    [[nodiscard]] virtual string_type  do_transform(const _Elem* _First, const _Elem* _Last) const {
        
        _Adl_verify_range(_First, _Last);
        size_t _Count;
        string_type _Str;

        for (_Count = static_cast<size_t>(_Last - _First); 0 < _Count;) {
            
            _Str.resize(_Count);
            if ((_Count = _LStrxfrm(&_Str[0], &_Str[0] + _Str.size(), _First, _Last, &_Coll)) <= _Str.size()) {
                break;
            }
        }
        _Str.resize(_Count);
        return _Str;
    }

    [[nodiscard]] virtual long  do_hash(const _Elem* _First, const _Elem* _Last) const {
        
        _Adl_verify_range(_First, _Last);
        return static_cast<long>(_Hash_array_representation(_First, static_cast<size_t>(_Last - _First)));
    }

private:
    _Locinfo::_Collvec _Coll; 
};






template <class _Elem>
 locale::id collate<_Elem>::id;




template  locale::id collate<char>::id;
template  locale::id collate<wchar_t>::id;
#line 132 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"




#line 137 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"





 template <class _Elem>
class collate_byname : public collate<_Elem> { 
public:
    static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>, "Unsupported facet specialization; see N4950 [locale.category]. " "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 " "to suppress this error.");

    explicit collate_byname(const char* _Locname, size_t _Refs = 0)
        : collate<_Elem>(_Locname, _Refs) {} 

    explicit collate_byname(const string& _Str, size_t _Refs = 0)
        : collate<_Elem>(_Locinfo(_Str.c_str()), _Refs) {} 

protected:
     ~collate_byname() noexcept override {}
};

 template <class _Facet>
[[nodiscard]] bool has_facet(const locale& _Loc) noexcept {
    { ::std:: _Lockit _Lock(0); 
    size_t _Id = _Facet::id;
    return _Loc._Getfacet(_Id) || _Facet::_Getcat() != static_cast<size_t>(-1);
    }
}

 template <class _Elem>
[[nodiscard]] bool isalnum(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alnum, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isalpha(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alpha, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isblank(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::blank, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool iscntrl(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::cntrl, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isdigit(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::digit, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isgraph(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::graph, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool islower(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::lower, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isprint(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::print, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool ispunct(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::punct, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isspace(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::space, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isupper(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::upper, _Ch);
}

 template <class _Elem>
[[nodiscard]] bool isxdigit(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).is(ctype_base::xdigit, _Ch);
}

 template <class _Elem>
[[nodiscard]] _Elem tolower(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).tolower(_Ch);
}

 template <class _Elem>
[[nodiscard]] _Elem toupper(_Elem _Ch, const locale& _Loc) {
    return ::std:: use_facet<ctype<_Elem>>(_Loc).toupper(_Ch);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"
#line 241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\locale"
#pragma external_header(pop)
#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"






#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




extern "C" [[nodiscard]] __std_win_error __stdcall __std_get_cvt(__std_code_page _Codepage, _Cvtvec* _Pcvt) noexcept;

namespace std {







#line 78 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

template <class _CharT>
[[nodiscard]] constexpr const _CharT* _Choose_literal(const char* const _Str, const wchar_t* const _WStr) noexcept {
    if constexpr (is_same_v<_CharT, char>) {
        return _Str;
    } else {
        return _WStr;
    }
}





 template <class, class>
class vector;

 class format_error : public runtime_error {
    using runtime_error::runtime_error;
};

[[noreturn]] inline void _Throw_format_error(const char* const _Message) {
    throw format_error{_Message};
}

enum class _Fmt_align : uint8_t { _None, _Left, _Right, _Center };

enum class _Fmt_sign : uint8_t { _None, _Plus, _Minus, _Space };

enum class _Basic_format_arg_type : uint8_t {
    _None,
    _Int_type,
    _UInt_type,
    _Long_long_type,
    _ULong_long_type,
    _Bool_type,
    _Char_type,
    _Float_type,
    _Double_type,
    _Long_double_type,
    _Pointer_type,
    _CString_type,
    _String_type,
    _Custom_type,
};
static_assert(static_cast<int>(_Basic_format_arg_type::_Custom_type) < 16, "must fit in 4-bit bitfield");

[[nodiscard]] constexpr bool _Is_integral_fmt_type(_Basic_format_arg_type _Ty) {
    return _Ty > _Basic_format_arg_type::_None && _Ty <= _Basic_format_arg_type::_Char_type;
}
[[nodiscard]] constexpr bool _Is_arithmetic_fmt_type(_Basic_format_arg_type _Ty) {
    return _Ty > _Basic_format_arg_type::_None && _Ty <= _Basic_format_arg_type::_Long_double_type;
}

struct _Auto_id_tag {
    explicit _Auto_id_tag() = default;
};


template <class _Ty, class _CharT>
concept _Parse_arg_id_callbacks = requires(_Ty _At) {
    { _At._On_auto_id() } -> same_as<void>;
    { _At._On_manual_id(size_t{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Parse_replacement_field_callbacks = requires(_Ty _At, const _CharT* _First, const _CharT* _Last) {
    { _At._Parse_context };
    { _At._On_text(_First, _Last) } -> same_as<void>;
    { _At._On_replacement_field(size_t{}, static_cast<const _CharT*>(nullptr)) } -> same_as<void>;
    { _At._On_format_specs(size_t{}, _First, _Last) } -> same_as<const _CharT*>;
};

template <class _Ty, class _CharT>
concept _Parse_align_callbacks = requires(_Ty _At, basic_string_view<_CharT> _Sv, _Fmt_align _Aln) {
    { _At._On_fill(_Sv) } -> same_as<void>;
    { _At._On_align(_Aln) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Parse_width_callbacks = requires(_Ty _At) {
    { _At._On_width(int{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Parse_precision_callbacks = requires(_Ty _At) {
    { _At._On_precision(int{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Width_adapter_callbacks = requires(_Ty _At) {
    { _At._On_dynamic_width(_Auto_id_tag{}) } -> same_as<void>;
    { _At._On_dynamic_width(size_t{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Precision_adapter_callbacks = requires(_Ty _At) {
    { _At._On_dynamic_precision(_Auto_id_tag{}) } -> same_as<void>;
    { _At._On_dynamic_precision(size_t{}) } -> same_as<void>;
};

template <class _Ty, class _CharT>
concept _Parse_spec_callbacks = _Parse_align_callbacks<_Ty, _CharT>
                                && _Parse_width_callbacks<_Ty, _CharT>
                                && _Parse_precision_callbacks<_Ty, _CharT>
                                && _Width_adapter_callbacks<_Ty, _CharT>
                                && _Precision_adapter_callbacks<_Ty, _CharT>
                                && requires(_Ty _At, _Fmt_sign _Sgn) {
                                    { _At._On_sign(_Sgn) } -> same_as<void>;
                                    { _At._On_hash() } -> same_as<void>;
                                    { _At._On_zero() } -> same_as<void>;
                                    { _At._On_localized() } -> same_as<void>;
                                    { _At._On_type(_CharT{}) } -> same_as<void>;
};


template <class _CharT>
struct _Decode_result {
    const _CharT* _Next_ptr;
    bool _Is_unicode_scalar_value; 
    
    
};


[[nodiscard]] constexpr _Decode_result<wchar_t> _Decode_utf(
    const wchar_t* _First, const wchar_t* _Last, char32_t& _Val) noexcept {
    ;
    _Val = static_cast<char32_t>(*_First);
    if (_Val < 0xD800) {
        return {_First + 1, true};
    } else if (_Val <= 0xDBFF) {
        
        if (_First + 1 == _Last) {
            _Val = 0xFFFD;
            return {_Last, false};
        }

        if (_First[1] < 0xDC00 || _First[1] > 0xDFFF) {
            
            _Val = 0xFFFD;
            return {_First + 1, false};
        }

        _Val = (_Val - 0xD800) << 10;
        _Val += _First[1] - 0xDC00;
        _Val += 0x10000;
        return {_First + 2, true};
    } else if (_Val <= 0xDFFF) {
        
        _Val = 0xFFFD;
        return {_First + 1, false};
    }

    return {_First + 1, true};
}

[[nodiscard]] constexpr _Decode_result<char> _Decode_utf(const char* _First, const char* _Last, char32_t& _Val) noexcept {
    ;
    
    
    
    
    
    
    _Val = static_cast<char32_t>(static_cast<unsigned char>(*_First));

    
    
    
    
    
    int _Num_bytes;
    if (_Val <= 0x7F) {
        return {_First + 1, true};
    } else if (_Val >= 0xC2 && _Val <= 0xDF) {
        _Num_bytes = 2;
    } else if (_Val >= 0xE0 && _Val <= 0xEF) {
        _Num_bytes = 3;
    } else if (_Val >= 0xF0 && _Val <= 0xF4) {
        _Num_bytes = 4;
    } else {
        
        _Val = 0xFFFD;
        return {_First + 1, false};
    }

    if (_First + 1 == _Last) {
        
        
        
        
        _Val = 0xFFFD;
        return {_Last, false};
    }

    switch (_Val) {
    case 0xE0:
        
        
        if (static_cast<unsigned char>(_First[1]) < 0xA0) {
            
            
            
            
            _Val = 0xFFFD;
            return {_First + 1, false};
        }
        break;
    case 0xED:
        if (static_cast<unsigned char>(_First[1]) > 0x9F) {
            _Val = 0xFFFD;
            return {_First + 1, false};
        }
        break;
    case 0xF0:
        if (static_cast<unsigned char>(_First[1]) < 0x90) {
            _Val = 0xFFFD;
            return {_First + 1, false};
        }
        break;
    case 0xF4:
        if (static_cast<unsigned char>(_First[1]) > 0x8F) {
            _Val = 0xFFFD;
            return {_First + 1, false};
        }
        break;
    }

    
    
    
    
    switch (_Num_bytes) {
    case 2:
        _Val &= 0b1'1111u;
        break;
    case 3:
        _Val &= 0b1111u;
        break;
    case 4:
        _Val &= 0b111u;
        break;
    }

    for (int _Idx = 1; _Idx < _Num_bytes; ++_Idx) {
        if (_First + _Idx >= _Last || static_cast<unsigned char>(_First[_Idx]) < 0x80
            || static_cast<unsigned char>(_First[_Idx]) > 0xBF) {
            
            _Val = 0xFFFD;
            return {_First + _Idx, false};
        }
        
        _Val = (_Val << 6) | (static_cast<unsigned char>(_First[_Idx]) & 0b11'1111u);
    }
    return {_First + _Num_bytes, true};
}

[[nodiscard]] constexpr _Decode_result<char32_t> _Decode_utf(
    const char32_t* _First, const char32_t* _Last, char32_t& _Val) noexcept {
    ;
    (void) _Last;
    _Val               = *_First;
    const bool _Is_usv = _Val < 0xD800 || (_Val > 0xDFFF && _Val <= 0x10FFFF);
    return {_First + 1, _Is_usv};
}

template <class _CharT>
class _Unicode_codepoint_iterator {
private:
    const _CharT* _First = nullptr;
    const _CharT* _Last  = nullptr;
    const _CharT* _Next  = nullptr;
    char32_t _Val        = 0;

public:
    using value_type      = char32_t;
    using difference_type = ptrdiff_t;

    constexpr _Unicode_codepoint_iterator(const _CharT* _First_val, const _CharT* _Last_val) noexcept
        : _First(_First_val), _Last(_Last_val) {
        _Next = _Decode_utf(_First, _Last, _Val)._Next_ptr;
    }

    constexpr _Unicode_codepoint_iterator() = default;

    constexpr _Unicode_codepoint_iterator& operator++() noexcept {
        _First = _Next;
        if (_First != _Last) {
            _Next = _Decode_utf(_First, _Last, _Val)._Next_ptr;
        }

        return *this;
    }
    constexpr _Unicode_codepoint_iterator operator++(int) noexcept {
        auto _Old = *this;
        ++*this;
        return _Old;
    }

    [[nodiscard]] constexpr value_type operator*() const noexcept {
        return _Val;
    }

    [[nodiscard]] constexpr const _CharT* _Position() const noexcept {
        return _First;
    }

    [[nodiscard]] constexpr bool operator==(default_sentinel_t) const noexcept {
        return _First == _Last;
    }
    [[nodiscard]] constexpr bool operator==(const _Unicode_codepoint_iterator& _Other) const noexcept {
        ;
        return _First == _Other._First && _Last == _Other._Last;
    }
};












class _GB11_LeftHand_regex {
private:
    enum _State_t : bool { _Start, _ExtPic };

    _State_t _State = _Start;

public:
    [[nodiscard]] constexpr bool operator==(const _GB11_LeftHand_regex&) const noexcept = default;

    [[nodiscard]] constexpr bool _Match(
        const _Grapheme_Break_property_values _Left_gbp, _Extended_Pictographic_property_values _Left_ExtPic) noexcept {
        switch (_State) {
        case _Start:
            if (_Left_ExtPic == _Extended_Pictographic_property_values::_Extended_Pictographic_value) {
                _State = _ExtPic;
            }
            return false;
        case _ExtPic:
            if (_Left_gbp == _Grapheme_Break_property_values::_ZWJ_value) {
                _State = _Start;
                return true;
            } else if (_Left_gbp != _Grapheme_Break_property_values::_Extend_value) {
                _State = _Start;
                return false;
            }
            return false;
        default:
            ;
            return false;
        }
    }
};

template <class _CharT>
class _Grapheme_break_property_iterator {
private:
    using _Wrapped_iter_type = _Unicode_codepoint_iterator<_CharT>;

    _Wrapped_iter_type _WrappedIter;
    _GB11_LeftHand_regex _GB11_rx;

public:
    [[nodiscard]] constexpr bool operator==(default_sentinel_t) const noexcept {
        return _WrappedIter == default_sentinel;
    }

    [[nodiscard]] constexpr bool operator==(const _Grapheme_break_property_iterator&) const noexcept = default;

    using difference_type = ptrdiff_t;
    using value_type      = iter_value_t<_Wrapped_iter_type>;

    constexpr _Grapheme_break_property_iterator(const _CharT* _First, const _CharT* _Last)
        : _WrappedIter(_First, _Last) {}

    constexpr _Grapheme_break_property_iterator() = default;

    constexpr _Grapheme_break_property_iterator& operator++() noexcept {
        auto _Left_gbp     = _Grapheme_Break_property_data._Get_property_for_codepoint(*_WrappedIter);
        auto _Left_ExtPic  = _Extended_Pictographic_property_data._Get_property_for_codepoint(*_WrappedIter);
        auto _Right_gbp    = _Grapheme_Break_property_values::_No_value;
        auto _Right_ExtPic = _Extended_Pictographic_property_values::_No_value;
        size_t _Num_RIs    = 0;
        for (;; _Left_gbp = _Right_gbp, _Left_ExtPic = _Right_ExtPic) {
            ++_WrappedIter;
            if (_WrappedIter == default_sentinel) {
                return *this; 
            }
            _Right_gbp    = _Grapheme_Break_property_data._Get_property_for_codepoint(*_WrappedIter);
            _Right_ExtPic = _Extended_Pictographic_property_data._Get_property_for_codepoint(*_WrappedIter);
            
            
            const bool _GB11_Match = _GB11_rx._Match(_Left_gbp, _Left_ExtPic);
            
            if (_Left_gbp == _Grapheme_Break_property_values::_Regional_Indicator_value) {
                ++_Num_RIs;
            } else {
                _Num_RIs = 0;
            }

            if (_Left_gbp == _Grapheme_Break_property_values::_CR_value
                && _Right_gbp == _Grapheme_Break_property_values::_LF_value) {
                continue; 
            }

            if (_Left_gbp == _Grapheme_Break_property_values::_Control_value
                || _Left_gbp == _Grapheme_Break_property_values::_CR_value
                || _Left_gbp == _Grapheme_Break_property_values::_LF_value) {
                return *this; 
            }

            if (_Right_gbp == _Grapheme_Break_property_values::_Control_value
                || _Right_gbp == _Grapheme_Break_property_values::_CR_value
                || _Right_gbp == _Grapheme_Break_property_values::_LF_value) {
                return *this; 
            }

            if (_Left_gbp == _Grapheme_Break_property_values::_L_value
                && (_Right_gbp == _Grapheme_Break_property_values::_L_value
                    || _Right_gbp == _Grapheme_Break_property_values::_V_value
                    || _Right_gbp == _Grapheme_Break_property_values::_LV_value
                    || _Right_gbp == _Grapheme_Break_property_values::_LVT_value)) {
                continue; 
            }

            if ((_Left_gbp == _Grapheme_Break_property_values::_LV_value
                    || _Left_gbp == _Grapheme_Break_property_values::_V_value)
                && (_Right_gbp == _Grapheme_Break_property_values::_V_value
                    || _Right_gbp == _Grapheme_Break_property_values::_T_value)) {
                continue; 
            }

            if ((_Left_gbp == _Grapheme_Break_property_values::_LVT_value
                    || _Left_gbp == _Grapheme_Break_property_values::_T_value)
                && _Right_gbp == _Grapheme_Break_property_values::_T_value) {
                continue; 
            }

            if (_Right_gbp == _Grapheme_Break_property_values::_Extend_value
                || _Right_gbp == _Grapheme_Break_property_values::_ZWJ_value) {
                continue; 
            }

            if (_Right_gbp == _Grapheme_Break_property_values::_SpacingMark_value) {
                continue; 
            }

            if (_Left_gbp == _Grapheme_Break_property_values::_Prepend_value) {
                continue; 
            }

            if (_GB11_Match && _Right_ExtPic == _Extended_Pictographic_property_values::_Extended_Pictographic_value) {
                continue; 
            }

            if (_Left_gbp == _Grapheme_Break_property_values::_Regional_Indicator_value
                && _Right_gbp == _Grapheme_Break_property_values::_Regional_Indicator_value && _Num_RIs % 2 != 0) {
                continue; 
                          
            }
            return *this;
        }
    }
    constexpr _Grapheme_break_property_iterator operator++(int) noexcept {
        auto _Old = *this;
        ++*this;
        return _Old;
    }

    [[nodiscard]] constexpr const _CharT* _Position() const noexcept {
        return _WrappedIter._Position();
    }

    [[nodiscard]] constexpr value_type operator*() const noexcept {
        return *_WrappedIter;
    }
};

template <class _Ty, class _CharT>
concept _CharT_or_bool = same_as<_Ty, _CharT> || same_as<_Ty, bool>;

template <class _CharT>
concept _Format_supported_charT = _Is_any_of_v<_CharT, char, wchar_t>;

 template <class _Ty, class _CharT = char>
struct formatter;

inline void _You_see_this_error_because_arg_id_is_out_of_range() noexcept {}

 template <class _CharT>
class basic_format_parse_context {
public:
    using char_type      = _CharT;
    using const_iterator = basic_string_view<_CharT>::const_iterator;
    using iterator       = const_iterator;

    constexpr explicit basic_format_parse_context(
        const basic_string_view<_CharT> _Fmt, const size_t _Num_args_ = 0) noexcept
        : _Format_string(_Fmt), _Num_args(_Num_args_) {}

    basic_format_parse_context(const basic_format_parse_context&)            = delete;
    basic_format_parse_context& operator=(const basic_format_parse_context&) = delete;

    [[nodiscard]] constexpr const_iterator begin() const noexcept {
        return _Format_string.begin();
    }
    [[nodiscard]] constexpr const_iterator end() const noexcept {
        return _Format_string.end();
    }
    [[nodiscard]] constexpr const _CharT* _Unchecked_begin() const noexcept {
        return _Format_string._Unchecked_begin();
    }
    [[nodiscard]] constexpr const _CharT* _Unchecked_end() const noexcept {
        return _Format_string._Unchecked_end();
    }

    constexpr void advance_to(const const_iterator _It) {
        _Adl_verify_range(_It, _Format_string.end());
        _Adl_verify_range(_Format_string.begin(), _It);
        const auto _Diff = static_cast<size_t>(_It._Unwrapped() - _Format_string._Unchecked_begin());
        _Format_string.remove_prefix(_Diff);
    }

    
    
    
    
    
    [[nodiscard]] constexpr size_t next_arg_id() {
        if (_Next_arg_id < 0) {
            _Throw_format_error("Can not switch from manual to automatic indexing");
        }

        if (::std:: is_constant_evaluated()) {
            if (static_cast<size_t>(_Next_arg_id) >= _Num_args) {
                _You_see_this_error_because_arg_id_is_out_of_range();
            }
        }

        return static_cast<size_t>(_Next_arg_id++);
    }

    constexpr void check_arg_id(const size_t _Id) {
        if (::std:: is_constant_evaluated()) {
            if (_Id >= _Num_args) {
                _You_see_this_error_because_arg_id_is_out_of_range();
            }
        }

        if (_Next_arg_id > 0) {
            _Throw_format_error("Can not switch from automatic to manual indexing");
        }
        _Next_arg_id = -1;
    }

private:
    basic_string_view<_CharT> _Format_string;
    size_t _Num_args;
    
    
    
    ptrdiff_t _Next_arg_id = 0;
};

 using format_parse_context  = basic_format_parse_context<char>;
 using wformat_parse_context = basic_format_parse_context<wchar_t>;

template <class _Ty, class _Context, class _Formatter = _Context::template formatter_type<remove_const_t<_Ty>>>
concept _Formattable_with = semiregular<_Formatter>
                         && requires(_Formatter& __f, const _Formatter& __cf, _Ty&& __t, _Context __fc,
                             basic_format_parse_context<typename _Context::char_type> __pc) {
                                { __f.parse(__pc) } -> same_as<typename decltype(__pc)::iterator>;
                                { __cf.format(__t, __fc) } -> same_as<typename _Context::iterator>;
                            };

template <class _Ty, class _CharT>
inline constexpr bool _Is_basic_string_like_for = false;

template <class _CharT, class _Traits, class _Alloc>
inline constexpr bool _Is_basic_string_like_for<basic_string<_CharT, _Traits, _Alloc>, _CharT> = true;

template <class _CharT, class _Traits>
inline constexpr bool _Is_basic_string_like_for<basic_string_view<_CharT, _Traits>, _CharT> = true;

template <class _Context>
struct _Format_arg_traits {
    using _Char_type = _Context::char_type;

    
    
    template <_Formattable_with<_Context> _Ty>
    static auto _Type_eraser();

    template <class _Ty>
    using _Storage_type = decltype(_Type_eraser<remove_reference_t<_Ty>>());

    template <class _Ty>
    static constexpr size_t _Storage_size = sizeof(_Storage_type<_Ty>);
};

 template <class _Context>
class basic_format_args;

inline namespace __p2286 {
template <class _CharT>
struct _Format_handler;
}

 template <class _Context>
class basic_format_arg {
public:
    using _CharType = _Context::char_type;

    class handle {
    private:
        const void* _Ptr;
        void(__cdecl* _Format)(basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx, const void*);
        friend basic_format_arg;

    public:
        template <class _Ty>
        explicit handle(_Ty& _Val) noexcept
            : _Ptr(::std:: addressof(_Val)),
              _Format([](basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx, const void* _Ptr) {
                  using _Td = remove_const_t<_Ty>;
                  
                  using _Tq = conditional_t<_Formattable_with<const _Ty, _Context>, const _Ty, _Ty>;
                  typename _Context::template formatter_type<_Td> _Formatter;
                  _Parse_ctx.advance_to(_Formatter.parse(_Parse_ctx));
                  _Format_ctx.advance_to(
                      _Formatter.format(*const_cast<_Tq*>(static_cast<const _Td*>(_Ptr)), _Format_ctx));
              }) {
            
            using _Tq = conditional_t<_Formattable_with<const _Ty, _Context>, const _Ty, _Ty>;
            static_assert(_Formattable_with<_Tq, _Context>);
        }

        void format(basic_format_parse_context<_CharType>& _Parse_ctx, _Context& _Format_ctx) const {
            _Format(_Parse_ctx, _Format_ctx, _Ptr);
        }
    };

    
    basic_format_arg() noexcept : _Active_state(_Basic_format_arg_type::_None), _No_state() {}

    explicit operator bool() const noexcept {
        return _Active_state != _Basic_format_arg_type::_None;
    }

    
    
    template <_Formattable_with<_Context> _Ty>
    static basic_format_arg _Make_from(_Ty& _Val) noexcept {
        using _Erased_type = _Format_arg_traits<_Context>::template _Storage_type<_Ty>;




#line 744 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
        {
            return basic_format_arg(static_cast<_Erased_type>(_Val));
        }
    }

    template <class _Visitor>
    decltype(auto) _Visit(_Visitor&& _Vis) {
        switch (_Active_state) {
        case _Basic_format_arg_type::_None:
            return ::std:: forward<_Visitor>(_Vis)(_No_state);
        case _Basic_format_arg_type::_Int_type:
            return ::std:: forward<_Visitor>(_Vis)(_Int_state);
        case _Basic_format_arg_type::_UInt_type:
            return ::std:: forward<_Visitor>(_Vis)(_UInt_state);
        case _Basic_format_arg_type::_Long_long_type:
            return ::std:: forward<_Visitor>(_Vis)(_Long_long_state);
        case _Basic_format_arg_type::_ULong_long_type:
            return ::std:: forward<_Visitor>(_Vis)(_ULong_long_state);
        case _Basic_format_arg_type::_Bool_type:
            return ::std:: forward<_Visitor>(_Vis)(_Bool_state);
        case _Basic_format_arg_type::_Char_type:
            return ::std:: forward<_Visitor>(_Vis)(_Char_state);
        case _Basic_format_arg_type::_Float_type:
            return ::std:: forward<_Visitor>(_Vis)(_Float_state);
        case _Basic_format_arg_type::_Double_type:
            return ::std:: forward<_Visitor>(_Vis)(_Double_state);
        case _Basic_format_arg_type::_Long_double_type:
            return ::std:: forward<_Visitor>(_Vis)(_Long_double_state);
        case _Basic_format_arg_type::_Pointer_type:
            return ::std:: forward<_Visitor>(_Vis)(_Pointer_state);
        case _Basic_format_arg_type::_CString_type:
            return ::std:: forward<_Visitor>(_Vis)(_CString_state);
        case _Basic_format_arg_type::_String_type:
            return ::std:: forward<_Visitor>(_Vis)(_String_state);
        case _Basic_format_arg_type::_Custom_type:
            return ::std:: forward<_Visitor>(_Vis)(_Custom_state);
        default:
            do { if (false) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
            int _Dummy{};
            return ::std:: forward<_Visitor>(_Vis)(_Dummy);
        }
    }

private:
    friend basic_format_args<_Context>;
    friend _Format_handler<_CharType>;
    friend _Format_arg_traits<_Context>;

    explicit basic_format_arg(const int _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Int_type), _Int_state(_Val) {}
    explicit basic_format_arg(const unsigned int _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_UInt_type), _UInt_state(_Val) {}
    explicit basic_format_arg(const long long _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Long_long_type), _Long_long_state(_Val) {}
    explicit basic_format_arg(const unsigned long long _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_ULong_long_type), _ULong_long_state(_Val) {}
    explicit basic_format_arg(const bool _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Bool_type), _Bool_state(_Val) {}
    explicit basic_format_arg(const _CharType _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Char_type), _Char_state(_Val) {}
    explicit basic_format_arg(const float _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Float_type), _Float_state(_Val) {}
    explicit basic_format_arg(const double _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Double_type), _Double_state(_Val) {}
    explicit basic_format_arg(const long double _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Long_double_type), _Long_double_state(_Val) {}
    explicit basic_format_arg(const void* _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Pointer_type), _Pointer_state(_Val) {}
    explicit basic_format_arg(const _CharType* _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_CString_type), _CString_state(_Val) {}
    explicit basic_format_arg(const basic_string_view<_CharType> _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_String_type), _String_state(_Val) {}
    explicit basic_format_arg(const handle _Val) noexcept
        : _Active_state(_Basic_format_arg_type::_Custom_type), _Custom_state(_Val) {}

    _Basic_format_arg_type _Active_state = _Basic_format_arg_type::_None;
    union {
        monostate _No_state = monostate{};
        int _Int_state;
        unsigned int _UInt_state;
        long long _Long_long_state;
        unsigned long long _ULong_long_state;
        bool _Bool_state;
        _CharType _Char_state;
        float _Float_state;
        double _Double_state;
        long double _Long_double_state;
        const void* _Pointer_state;
        const _CharType* _CString_state;
        basic_string_view<_CharType> _String_state;
        handle _Custom_state;
    };
};

template <class _Context>
template <_Formattable_with<_Context> _Ty>
auto _Format_arg_traits<_Context>::_Type_eraser() {
    using _Td = remove_const_t<_Ty>;
    
    if constexpr (is_same_v<_Td, bool>) {
        return bool{};
    } else if constexpr (is_same_v<_Td, _Char_type>) {
        return _Char_type{};
    } else if constexpr (is_same_v<_Td, char> && is_same_v<_Char_type, wchar_t>) {
        return _Char_type{};
    } else if constexpr (signed_integral<_Td> && sizeof(_Td) <= sizeof(int)) {
        return int{};
    } else if constexpr (unsigned_integral<_Td> && sizeof(_Td) <= sizeof(unsigned int)) {
        return static_cast<unsigned int>(42);
    } else if constexpr (signed_integral<_Td> && sizeof(_Td) <= sizeof(long long)) {
        return static_cast<long long>(42);
    } else if constexpr (unsigned_integral<_Td> && sizeof(_Td) <= sizeof(unsigned long long)) {
        return static_cast<unsigned long long>(42);
    } else if constexpr (is_same_v<_Td, float>) {
        return float{};
    } else if constexpr (is_same_v<_Td, double>) {
        return double{};
    } else if constexpr (is_same_v<_Td, long double>) {
        return static_cast<long double>(42);
    } else if constexpr (_Is_basic_string_like_for<_Td, _Char_type>) {
        return basic_string_view<_Char_type>{};
    } else if constexpr (_Is_any_of_v<decay_t<_Td>, _Char_type*, const _Char_type*>) {
        return static_cast<const _Char_type*>(nullptr);
    } else if constexpr (is_void_v<remove_pointer_t<_Td>> || is_same_v<_Td, nullptr_t>) {
        return static_cast<const void*>(nullptr);
    } else {
        int _Dummy{};
        return typename basic_format_arg<_Context>::handle{_Dummy};
    }
}

 template <class _Visitor, class _Context>
decltype(auto) visit_format_arg(_Visitor&& _Vis, basic_format_arg<_Context> _Arg) {
    return _Arg._Visit(::std:: forward<_Visitor>(_Vis));
}


template <class _CharT>
[[nodiscard]] constexpr const _CharT* _Parse_nonnegative_integer(
    const _CharT* _First, const _CharT* _Last, unsigned int& _Value) {
    ;

    constexpr auto _Max_int = static_cast<unsigned int>((numeric_limits<int>::max)());
    constexpr auto _Big_int = _Max_int / 10u;

    _Value = 0;

    do {
        if (_Value > _Big_int) {
            _Value = _Max_int + 1;
            break;
        }
        _Value = _Value * 10 + static_cast<unsigned int>(*_First - '0');
        ++_First;
    } while (_First != _Last && '0' <= *_First && *_First <= '9');

    if (_Value > _Max_int) {
        _Throw_format_error("Number is too big");
    }

    return _First;
}

template <class _CharT>
[[nodiscard]] constexpr const _CharT* _Parse_nonnegative_integer(const _CharT* _First, const _CharT* _Last, int& _Value) {
    unsigned int _Val_unsigned = 0;

    _First = _Parse_nonnegative_integer(_First, _Last, _Val_unsigned);
    
    _Value = static_cast<int>(_Val_unsigned);
    return _First;
}

template <class _CharT, _Parse_arg_id_callbacks<_CharT> _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_arg_id(
    const _CharT* _First, const _CharT* _Last, _Callbacks_type&& _Callbacks) {
    ;
    _CharT _Ch = *_First;
    
    if (_Ch == '}' || _Ch == ':') {
        _Callbacks._On_auto_id();
        return _First;
    }

    if (_Ch >= '0' && _Ch <= '9') {
        unsigned int _Index = 0;
        
        
        
        
        if (_Ch == '0') {
            ++_First;
        } else {
            _First = _Parse_nonnegative_integer(_First, _Last, _Index);
        }

        
        
        
        if (_First == _Last || (*_First != '}' && *_First != ':')) {
            _Throw_format_error("Invalid format string.");
        }

        _Callbacks._On_manual_id(_Index);
        return _First;
    }
    
    _Throw_format_error("Invalid format string.");
}

[[nodiscard]] constexpr bool _Is_execution_charset_self_synchronizing() {

    
    
    
    
    switch (1252) {
    
    case 874: 
    case 1250: 
    case 1251: 
    case 1252: 
    case 1253: 
    case 1254: 
    case 1255: 
    case 1256: 
    case 1257: 
    case 1258: 
    case 65001: 
        return true;
    default:
        return false;
    }


#line 980 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
}



inline constexpr char32_t _Width_estimate_intervals_v2[] = { 
    0x1100u, 0x1160u, 0x231Au, 0x231Cu, 0x2329u, 0x232Bu, 0x23E9u, 0x23EDu, 0x23F0u, 0x23F1u, 0x23F3u, 0x23F4u, 0x25FDu,
    0x25FFu, 0x2614u, 0x2616u, 0x2648u, 0x2654u, 0x267Fu, 0x2680u, 0x2693u, 0x2694u, 0x26A1u, 0x26A2u, 0x26AAu, 0x26ACu,
    0x26BDu, 0x26BFu, 0x26C4u, 0x26C6u, 0x26CEu, 0x26CFu, 0x26D4u, 0x26D5u, 0x26EAu, 0x26EBu, 0x26F2u, 0x26F4u, 0x26F5u,
    0x26F6u, 0x26FAu, 0x26FBu, 0x26FDu, 0x26FEu, 0x2705u, 0x2706u, 0x270Au, 0x270Cu, 0x2728u, 0x2729u, 0x274Cu, 0x274Du,
    0x274Eu, 0x274Fu, 0x2753u, 0x2756u, 0x2757u, 0x2758u, 0x2795u, 0x2798u, 0x27B0u, 0x27B1u, 0x27BFu, 0x27C0u, 0x2B1Bu,
    0x2B1Du, 0x2B50u, 0x2B51u, 0x2B55u, 0x2B56u, 0x2E80u, 0x2E9Au, 0x2E9Bu, 0x2EF4u, 0x2F00u, 0x2FD6u, 0x2FF0u, 0x2FFCu,
    0x3000u, 0x303Fu, 0x3041u, 0x3097u, 0x3099u, 0x3100u, 0x3105u, 0x3130u, 0x3131u, 0x318Fu, 0x3190u, 0x31E4u, 0x31F0u,
    0x321Fu, 0x3220u, 0x3248u, 0x3250u, 0xA48Du, 0xA490u, 0xA4C7u, 0xA960u, 0xA97Du, 0xAC00u, 0xD7A4u, 0xF900u, 0xFB00u,
    0xFE10u, 0xFE1Au, 0xFE30u, 0xFE53u, 0xFE54u, 0xFE67u, 0xFE68u, 0xFE6Cu, 0xFF01u, 0xFF61u, 0xFFE0u, 0xFFE7u,
    0x16FE0u, 0x16FE5u, 0x16FF0u, 0x16FF2u, 0x17000u, 0x187F8u, 0x18800u, 0x18CD6u, 0x18D00u, 0x18D09u, 0x1AFF0u,
    0x1AFF4u, 0x1AFF5u, 0x1AFFCu, 0x1AFFDu, 0x1AFFFu, 0x1B000u, 0x1B123u, 0x1B132u, 0x1B133u, 0x1B150u, 0x1B153u,
    0x1B155u, 0x1B156u, 0x1B164u, 0x1B168u, 0x1B170u, 0x1B2FCu, 0x1F004u, 0x1F005u, 0x1F0CFu, 0x1F0D0u, 0x1F18Eu,
    0x1F18Fu, 0x1F191u, 0x1F19Bu, 0x1F200u, 0x1F203u, 0x1F210u, 0x1F23Cu, 0x1F240u, 0x1F249u, 0x1F250u, 0x1F252u,
    0x1F260u, 0x1F266u, 0x1F300u, 0x1F650u, 0x1F680u, 0x1F6C6u, 0x1F6CCu, 0x1F6CDu, 0x1F6D0u, 0x1F6D3u, 0x1F6D5u,
    0x1F6D8u, 0x1F6DCu, 0x1F6E0u, 0x1F6EBu, 0x1F6EDu, 0x1F6F4u, 0x1F6FDu, 0x1F7E0u, 0x1F7ECu, 0x1F7F0u, 0x1F7F1u,
    0x1F900u, 0x1FA00u, 0x1FA70u, 0x1FA7Du, 0x1FA80u, 0x1FA89u, 0x1FA90u, 0x1FABEu, 0x1FABFu, 0x1FAC6u, 0x1FACEu,
    0x1FADCu, 0x1FAE0u, 0x1FAE9u, 0x1FAF0u, 0x1FAF9u, 0x20000u, 0x2FFFEu, 0x30000u, 0x3FFFEu};

[[nodiscard]] constexpr int _Unicode_width_estimate(const char32_t _Ch) noexcept {
    
    
    constexpr char32_t _Linear_search_threshold = _Width_estimate_intervals_v2[12];
    if (_Ch < _Linear_search_threshold) {
        int _Result = 1;
        for (const auto& _Bound : _Width_estimate_intervals_v2) {
            if (_Ch < _Bound) {
                return _Result;
            }
            _Result ^= 0b11u; 
        }
        return 1;
    } else {
        const ptrdiff_t _Upper_bound_index =
            ::std:: upper_bound(_Width_estimate_intervals_v2, ::std:: end(_Width_estimate_intervals_v2), _Ch)
            - _Width_estimate_intervals_v2;
        return 1 + (_Upper_bound_index & 1);
    }
}

template <class _CharT, bool _Statically_Utf8 = _Is_execution_charset_self_synchronizing()>
class _Fmt_codec;

template <bool _Statically_Utf8>
class _Fmt_codec_base {};

template <>
class _Fmt_codec_base<false> {
protected:
    _Cvtvec _Cvt;

    [[nodiscard]] int _Double_byte_encoding_code_units_in_next_character(
        const char* const _First, const char* const _Last) const {
        
        
        wchar_t _Wide;
        mbstate_t _St{};
        const auto _Len   = static_cast<size_t>(_Last - _First);
        const int _Result = _Mbrtowc(&_Wide, _First, _Len, &_St, &_Cvt);
        if (_Result > 0) {
            return _Result;
        } else if (_Result < 0) { 
            return -1;
        } else { 
            return 1;
        }
    }

    _Fmt_codec_base() {

        constexpr __std_code_page _Format_codepage{1252};



#line 1059 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
        [[maybe_unused]] const __std_win_error _Result = __std_get_cvt(_Format_codepage, &_Cvt);
        ;
    }
};

template <bool _Statically_Utf8>
class _Fmt_codec<char, _Statically_Utf8> : private _Fmt_codec_base<_Statically_Utf8> {
private:
    [[nodiscard]] static constexpr int _Utf8_code_units_in_next_character(
        const char* const _First, const char* const _Last) noexcept {
        char32_t _Ch;
        const auto [_Next, _Is_usv] = _Decode_utf(_First, _Last, _Ch);
        ;
        return _Is_usv ? static_cast<int>(_Next - _First) : -1;
    }

public:
    [[nodiscard]] constexpr const char* _Find_encoded(const char* _First, const char* const _Last, const char _Val) const {
        
        
        if constexpr (_Statically_Utf8) {
            return ::std:: _Find_unchecked(_First, _Last, _Val);
        } else {
            if (this->_Cvt._Mbcurmax == 1 || this->_Cvt._Mbcurmax == 4) {
                
                return ::std:: _Find_unchecked(_First, _Last, _Val);
            }

            while (_First != _Last && *_First != _Val) {
                const int _Units = this->_Double_byte_encoding_code_units_in_next_character(_First, _Last);
                if (_Units < 0) {
                    _Throw_format_error("Invalid encoded character in format string.");
                }
                _First += _Units;
            }

            return _First;
        }
    }

    [[nodiscard]] constexpr int _Units_in_next_character(
        const char* const _First, const char* const _Last) const noexcept {
        
        
        
        ;

        if constexpr (_Statically_Utf8) {
            return _Utf8_code_units_in_next_character(_First, _Last);
        } else {
            switch (this->_Cvt._Mbcurmax) {
            default:
                ;
                [[fallthrough]];
            case 1:
                return 1; 

            case 2:
                return this->_Double_byte_encoding_code_units_in_next_character(_First, _Last);

            case 4: 
                return _Utf8_code_units_in_next_character(_First, _Last);
            }
        }
    }


    [[nodiscard]] _Decode_result<char> _Decode(const char* const _First, const char* const _Last, char32_t& _Val) const {
        ;

        if constexpr (_Is_ordinary_literal_encoding_utf8()) {
            return _Decode_utf(_First, _Last, _Val);
        } else if constexpr (_Is_execution_charset_self_synchronizing()) {
            wchar_t _Wide;
            const auto _Res =
                __std_fs_convert_narrow_to_wide(__std_code_page{1252}, _First, 1, &_Wide, 1);
            _Val = _Wide;
            return {_First + 1, _Res._Len != 0};
        } else {
            if (*_First == '\0') {
                _Val = U'\0';
                return {_First + 1, true};
            }

            wchar_t _Wide;
            mbstate_t _St{};
            const auto _Len   = static_cast<size_t>(_Last - _First);
            const int _Result = _Mbrtowc(&_Wide, _First, _Len, &_St, &this->_Cvt);
            if (_Result < 0) {
                return {_First + 1, false};
            } else {
                _Val = _Wide;
                return {_First + _Result, true};
            }
        }
    }
#line 1156 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
};

template <bool _Statically_Utf8>
class _Fmt_codec<wchar_t, _Statically_Utf8> {
public:
    [[nodiscard]] constexpr const wchar_t* _Find_encoded(
        const wchar_t* const _First, const wchar_t* const _Last, const wchar_t _Val) const {
        return ::std:: _Find_unchecked(_First, _Last, _Val);
    }

    [[nodiscard]] constexpr int _Units_in_next_character(
        const wchar_t* _First, const wchar_t* const _Last) const noexcept {
        char32_t _Ch;
        const auto [_Next, _Is_usv] = _Decode_utf(_First, _Last, _Ch);
        ;
        return _Is_usv ? static_cast<int>(_Next - _First) : -1;
    }


    [[nodiscard]] constexpr _Decode_result<wchar_t> _Decode(
        const wchar_t* const _First, const wchar_t* const _Last, char32_t& _Val) const noexcept {
        return _Decode_utf(_First, _Last, _Val);
    }
#line 1180 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
};

template <class _CharT>
[[nodiscard]] constexpr _Fmt_codec<_CharT> _Get_fmt_codec() {
    return {};
}

template <class _CharT>
    requires (is_same_v<_CharT, char> && !_Is_execution_charset_self_synchronizing())
[[nodiscard]] const _Fmt_codec<_CharT>& _Get_fmt_codec() {
    using _CodecType = _Fmt_codec<_CharT>;

    static once_flag _Flag;
    alignas(_CodecType) static unsigned char _Storage[sizeof(_CodecType)];

    ::std:: call_once(_Flag, [] { ::std:: construct_at(reinterpret_cast<_CodecType*>(&_Storage)); });

    return *::std:: launder(reinterpret_cast<const _CodecType*>(&_Storage));
}

template <class _CharT, _Parse_align_callbacks<_CharT> _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_align(
    const _CharT* _First, const _CharT* _Last, _Callbacks_type&& _Callbacks) {
    
    ;
    auto _Parsed_align = _Fmt_align::_None;

    const int _Units = _Get_fmt_codec<_CharT>()._Units_in_next_character(_First, _Last);
    if (_Units < 0) { 
        _Throw_format_error("Invalid format string.");
    }
    auto _Align_pt = _First + _Units;

    if (_Align_pt == _Last) {
        _Align_pt = _First;
    }

    for (;;) {
        switch (*_Align_pt) {
        case '<':
            _Parsed_align = _Fmt_align::_Left;
            break;
        case '>':
            _Parsed_align = _Fmt_align::_Right;
            break;
        case '^':
            _Parsed_align = _Fmt_align::_Center;
            break;
        }

        if (_Parsed_align != _Fmt_align::_None) {
            if (_Align_pt != _First) {
                if (*_First == '{') {
                    _Throw_format_error("invalid fill character '{'");
                }
                _Callbacks._On_fill({_First, static_cast<size_t>(_Align_pt - _First)});
                _First = _Align_pt + 1;
            } else {
                ++_First;
            }
            _Callbacks._On_align(_Parsed_align);
            break;
        } else if (_Align_pt == _First) {
            break;
        }
        _Align_pt = _First;
    }

    return _First;
}



template <class _CharT, _Width_adapter_callbacks<_CharT> _Callbacks_type>
struct _Width_adapter {
    _Callbacks_type& _Callbacks;

    constexpr explicit _Width_adapter(_Callbacks_type& _Handler) : _Callbacks(_Handler) {}

    constexpr void _On_auto_id() {
        _Callbacks._On_dynamic_width(_Auto_id_tag{});
    }
    constexpr void _On_manual_id(const size_t _Id) {
        _Callbacks._On_dynamic_width(_Id);
    }
};



template <class _CharT, _Precision_adapter_callbacks<_CharT> _Callbacks_type>
struct _Precision_adapter {
    _Callbacks_type& _Callbacks;

    constexpr explicit _Precision_adapter(_Callbacks_type& _Handler) : _Callbacks(_Handler) {}

    constexpr void _On_auto_id() {
        _Callbacks._On_dynamic_precision(_Auto_id_tag{});
    }
    constexpr void _On_manual_id(const size_t _Id) {
        _Callbacks._On_dynamic_precision(_Id);
    }
};





template <class _CharT>
struct _Id_adapter {
    basic_format_parse_context<_CharT>& _Parse_context;
    size_t _Arg_id = static_cast<size_t>(-1);

    constexpr void _On_auto_id() {
        _Arg_id = _Parse_context.next_arg_id();
        ;
    }
    constexpr void _On_manual_id(const size_t _Id) {
        _Parse_context.check_arg_id(_Id);
        _Arg_id = _Id;
        ;
    }
};

template <class _CharT, _Parse_width_callbacks<_CharT> _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_width(
    const _CharT* _First, const _CharT* _Last, _Callbacks_type&& _Callbacks) {
    ;
    if ('1' <= *_First && *_First <= '9') {
        int _Value = 0;
        _First     = _Parse_nonnegative_integer(_First, _Last, _Value);
        _Callbacks._On_width(_Value);
    } else if (*_First == '{') {
        ++_First;
        if (_First != _Last) {
            _First = _Parse_arg_id(_First, _Last, _Width_adapter<_CharT, _Callbacks_type>{_Callbacks});
        }

        if (_First == _Last || *_First != '}') {
            _Throw_format_error("Invalid format string.");
        }
        ++_First;
    }
    return _First;
}

template <class _CharT, _Parse_precision_callbacks<_CharT> _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_precision(
    const _CharT* _First, const _CharT* _Last, _Callbacks_type&& _Callbacks) {
    ++_First;
    _CharT _Ch = '\0';
    if (_First != _Last) {
        _Ch = *_First;
    }

    if ('0' <= _Ch && _Ch <= '9') {
        int _Precision = 0;
        _First         = _Parse_nonnegative_integer(_First, _Last, _Precision);
        _Callbacks._On_precision(_Precision);
    } else if (_Ch == '{') {
        ++_First;
        if (_First != _Last) {
            _First = _Parse_arg_id(_First, _Last, _Precision_adapter<_CharT, _Callbacks_type>{_Callbacks});
        }

        if (_First == _Last || *_First != '}') {
            _Throw_format_error("Invalid format string.");
        }
        ++_First;
    } else {
        _Throw_format_error("Missing precision specifier.");
    }

    return _First;
}

template <class _CharT, _Parse_spec_callbacks<_CharT> _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_format_specs(
    const _CharT* _First, const _CharT* _Last, _Callbacks_type&& _Callbacks) {
    if (_First == _Last || *_First == '}') {
        return _First;
    }

    _First = _Parse_align(_First, _Last, _Callbacks);
    if (_First == _Last) {
        return _First;
    }

    switch (*_First) {
    case '+':
        _Callbacks._On_sign(_Fmt_sign::_Plus);
        ++_First;
        break;
    case '-':
        _Callbacks._On_sign(_Fmt_sign::_Minus);
        ++_First;
        break;
    case ' ':
        _Callbacks._On_sign(_Fmt_sign::_Space);
        ++_First;
        break;
    default:
        break;
    }

    if (_First == _Last) {
        return _First;
    }

    if (*_First == '#') {
        _Callbacks._On_hash();
        if (++_First == _Last) {
            return _First;
        }
    }

    if (*_First == '0') {
        _Callbacks._On_zero();
        if (++_First == _Last) {
            return _First;
        }
    }

    _First = _Parse_width(_First, _Last, _Callbacks);
    if (_First == _Last) {
        return _First;
    }

    if (*_First == '.') {
        _First = _Parse_precision(_First, _Last, _Callbacks);
        if (_First == _Last) {
            return _First;
        }
    }

    if (*_First == 'L') {
        _Callbacks._On_localized();
        if (++_First == _Last) {
            return _First;
        }
    }

    
    if (*_First != '}') {
        _Callbacks._On_type(*_First);
        ++_First;
    } else {
        
        
        
        _Callbacks._On_type(static_cast<_CharT>('\0'));
    }

    return _First;
}

template <class _CharT, _Parse_replacement_field_callbacks<_CharT> _HandlerT>
[[nodiscard]] constexpr const _CharT* _Parse_replacement_field(
    const _CharT* _First, const _CharT* _Last, _HandlerT&& _Handler) {
    ++_First;
    if (_First == _Last) {
        _Throw_format_error("Invalid format string.");
    }

    if (*_First == '}') {
        
        _Handler._On_replacement_field(_Handler._Parse_context.next_arg_id(), _First);
    } else if (*_First == '{') {
        
        _Handler._On_text(_First, _First + 1);
    } else {
        _Id_adapter<_CharT> _Adapter{_Handler._Parse_context};
        _First = _Parse_arg_id(_First, _Last, _Adapter);
        _CharT _Ch{};
        if (_First != _Last) {
            _Ch = *_First;
        }

        if (_Ch == '}') {
            _Handler._On_replacement_field(_Adapter._Arg_id, _First);
        } else if (_Ch == ':') {
            _First = _Handler._On_format_specs(_Adapter._Arg_id, _First + 1, _Last);
            if (_First == _Last || *_First != '}') {
                _Throw_format_error("Unknown format specifier.");
            }
        } else {
            _Throw_format_error("Missing '}' in format string.");
        }
    }

    return _First + 1;
}

template <class _CharT, _Parse_replacement_field_callbacks<_CharT> _HandlerT>
constexpr void _Parse_format_string(basic_string_view<_CharT> _Format_str, _HandlerT&& _Handler) {
    auto _First        = _Format_str.data();
    auto _Last         = _First + _Format_str.size();
    const auto& _Codec = _Get_fmt_codec<_CharT>();

    while (_First != _Last) {
        const _CharT* _OpeningCurl = _First;
        if (*_First != '{') {
            _OpeningCurl = _Codec._Find_encoded(_First, _Last, _CharT{'{'});

            for (;;) {
                const _CharT* _ClosingCurl = _Codec._Find_encoded(_First, _OpeningCurl, _CharT{'}'});

                
                
                if (_ClosingCurl == _OpeningCurl) {
                    _Handler._On_text(_First, _OpeningCurl);
                    break;
                }
                
                
                ++_ClosingCurl;
                if (_ClosingCurl == _OpeningCurl || *_ClosingCurl != '}') {
                    _Throw_format_error("Unmatched '}' in format string.");
                }
                
                _Handler._On_text(_First, _ClosingCurl);

                
                _First = _ClosingCurl + 1;
            }

            
            if (_OpeningCurl == _Last) {
                return;
            }
        }
        
        _First = _Parse_replacement_field(_OpeningCurl, _Last, _Handler);
    }
}

template <class _CharT>
struct _Basic_format_specs {
    int _Width            = 0;
    int _Precision        = -1;
    char _Type            = '\0';
    _Fmt_align _Alignment = _Fmt_align::_None;
    _Fmt_sign _Sgn        = _Fmt_sign::_None;
    bool _Alt             = false;
    bool _Localized       = false;
    bool _Leading_zero    = false;
    uint8_t _Fill_length  = 1;
    
    _CharT _Fill[4 / sizeof(_CharT)] = {_CharT{' '}};
};




template <class _CharT>
struct _Dynamic_format_specs : _Basic_format_specs<_CharT> {
    int _Dynamic_width_index     = -1;
    int _Dynamic_precision_index = -1;
};


template <class _CharT>
class _Specs_setter {
public:
    constexpr explicit _Specs_setter(_Basic_format_specs<_CharT>& _Specs_) : _Specs(_Specs_) {}

    constexpr void _On_align(const _Fmt_align _Aln) {
        _Specs._Alignment = _Aln;
    }

    constexpr void _On_fill(const basic_string_view<_CharT> _Sv) {
        if (_Sv.size() > ::std:: size(_Specs._Fill)) {
            _Throw_format_error("Invalid fill (too long).");
        }

        const auto _Pos = ::std:: _Copy_unchecked(_Sv._Unchecked_begin(), _Sv._Unchecked_end(), _Specs._Fill);
        ::std:: fill(_Pos, ::std:: end(_Specs._Fill), _CharT{});
        _Specs._Fill_length = static_cast<uint8_t>(_Sv.size());
    }

    constexpr void _On_sign(const _Fmt_sign _Sgn) {
        _Specs._Sgn = _Sgn;
    }

    constexpr void _On_hash() {
        _Specs._Alt = true;
    }

    constexpr void _On_zero() {
        _Specs._Leading_zero = true;
    }

    constexpr void _On_width(const int _Width) {
        _Specs._Width = _Width;
    }

    constexpr void _On_precision(const int _Precision) {
        _Specs._Precision = _Precision;
    }

    constexpr void _On_localized() {
        _Specs._Localized = true;
    }

    constexpr void _On_type(const _CharT _Type) {
        _Specs._Type = static_cast<char>(_Type);
    }

protected:
    _Basic_format_specs<_CharT>& _Specs;
};

template <class _Context>
[[nodiscard]] constexpr basic_format_arg<_Context> _Get_arg(const _Context& _Ctx, const size_t _Arg_id) {
    
    
    
    auto _Arg = _Ctx.arg(_Arg_id);
    if (!_Arg) {
        _Throw_format_error("Argument not found.");
    }

    return _Arg;
}

template <class _Ty>
inline constexpr bool _Is_signed_or_unsigned_large_integer_t =
    _Is_any_of_v<remove_cv_t<_Ty>, int, unsigned int, long, unsigned long, long long, unsigned long long>;



class _Width_checker {
public:
    template <class _Ty>
    [[nodiscard]] constexpr unsigned long long operator()(const _Ty _Value) const {
        if constexpr (_Is_signed_or_unsigned_large_integer_t<_Ty>) {
            if constexpr (is_signed_v<_Ty>) {
                if (_Value < 0) {
                    _Throw_format_error("Negative width.");
                }
            }
            return static_cast<unsigned long long>(_Value);
        } else {
            _Throw_format_error("Width is not an integer.");
        }
    }
};



class _Precision_checker {
public:
    template <class _Ty>
    [[nodiscard]] constexpr unsigned long long operator()(const _Ty _Value) const {
        if constexpr (_Is_signed_or_unsigned_large_integer_t<_Ty>) {
            if constexpr (is_signed_v<_Ty>) {
                if (_Value < 0) {
                    _Throw_format_error("Negative precision.");
                }
            }
            return static_cast<unsigned long long>(_Value);
        } else {
            _Throw_format_error("Precision is not an integer.");
        }
    }
};




template <class _Handler, class _FormatArg>
[[nodiscard]] constexpr int _Get_dynamic_specs(const _FormatArg _Arg) {
    ;
    const unsigned long long _Val = ::std:: visit_format_arg(_Handler{}, _Arg);
    if (_Val > static_cast<unsigned long long>((numeric_limits<int>::max)())) {
        _Throw_format_error("Number is too big.");
    }

    return static_cast<int>(_Val);
}





template <class _ParseContext, class _Context>
class _Specs_handler : public _Specs_setter<typename _Context::char_type> {
public:
    using _CharT = _Context::char_type;

    constexpr _Specs_handler(_Basic_format_specs<_CharT>& _Specs_, _ParseContext& _Parse_ctx_, _Context& _Ctx_)
        : _Specs_setter<_CharT>(_Specs_), _Parse_ctx(_Parse_ctx_), _Ctx(_Ctx_) {}

    template <class _Id>
    constexpr void _On_dynamic_width(const _Id _Arg_id) {
        this->_Specs._Width = _Get_dynamic_specs<_Width_checker>(_Get_arg(_Arg_id));
    }

    template <class _Id>
    constexpr void _On_dynamic_precision(const _Id _Arg_id) {
        this->_Specs._Precision = _Get_dynamic_specs<_Precision_checker>(_Get_arg(_Arg_id));
    }

private:
    _ParseContext& _Parse_ctx;
    _Context& _Ctx;

    [[nodiscard]] constexpr basic_format_arg<_Context> _Get_arg(_Auto_id_tag) {
        return ::std:: _Get_arg(_Ctx, _Parse_ctx.next_arg_id());
    }

    [[nodiscard]] constexpr basic_format_arg<_Context> _Get_arg(const size_t _Arg_id) {
        _Parse_ctx.check_arg_id(_Arg_id);
        return ::std:: _Get_arg(_Ctx, _Arg_id);
    }
};

template <class _ParseContext>
class _Dynamic_specs_handler : public _Specs_setter<typename _ParseContext::char_type> {
public:
    using _CharT = _ParseContext::char_type;

    constexpr _Dynamic_specs_handler(_Dynamic_format_specs<_CharT>& _Specs_, _ParseContext& _Parse_ctx_)
        : _Specs_setter<_CharT>(_Specs_), _Dynamic_specs(_Specs_), _Parse_ctx(_Parse_ctx_) {}

    constexpr void _On_dynamic_width(const size_t _Arg_id) {
        _Parse_ctx.check_arg_id(_Arg_id);
        _Dynamic_specs._Dynamic_width_index = _Verify_dynamic_arg_index_in_range(_Arg_id);
    }

    constexpr void _On_dynamic_width(_Auto_id_tag) {
        _Dynamic_specs._Dynamic_width_index = _Verify_dynamic_arg_index_in_range(_Parse_ctx.next_arg_id());
    }

    constexpr void _On_dynamic_precision(const size_t _Arg_id) {
        _Parse_ctx.check_arg_id(_Arg_id);
        _Dynamic_specs._Dynamic_precision_index = _Verify_dynamic_arg_index_in_range(_Arg_id);
    }

    constexpr void _On_dynamic_precision(_Auto_id_tag) {
        _Dynamic_specs._Dynamic_precision_index = _Verify_dynamic_arg_index_in_range(_Parse_ctx.next_arg_id());
    }

private:
    _Dynamic_format_specs<_CharT>& _Dynamic_specs;
    _ParseContext& _Parse_ctx;

    [[nodiscard]] static constexpr int _Verify_dynamic_arg_index_in_range(const size_t _Idx) {
        if (_Idx > static_cast<size_t>((numeric_limits<int>::max)())) {
            _Throw_format_error("Dynamic width or precision index too large.");
        }

        return static_cast<int>(_Idx);
    }
};





template <class _Handler>
class _Specs_checker : public _Handler {
private:
    _Basic_format_arg_type _Arg_type;
    
    
    bool _Need_arithmetic_presentation_type = false;

public:
    constexpr explicit _Specs_checker(const _Handler& _Handler_inst, const _Basic_format_arg_type _Arg_type_)
        : _Handler(_Handler_inst), _Arg_type(_Arg_type_) {}

    constexpr void _Require_numeric_argument() const {
        if (!_Is_arithmetic_fmt_type(_Arg_type)) {
            _Throw_format_error("Format specifier requires numeric argument.");
        }
    }

    constexpr void _Check_precision() const {
        if (_Is_integral_fmt_type(_Arg_type) || _Arg_type == _Basic_format_arg_type::_Pointer_type) {
            _Throw_format_error("Precision not allowed for this argument type.");
        }
    }

    

    constexpr void _On_localized() {
        _Require_numeric_argument();
        _Handler::_On_localized();
    }

    constexpr void _On_hash() {
        _Need_arithmetic_presentation_type = true;
        _Require_numeric_argument();
        _Handler::_On_hash();
    }

    constexpr void _On_sign(_Fmt_sign _Sgn) {
        _Need_arithmetic_presentation_type = true;
        _Require_numeric_argument();
        _Handler::_On_sign(_Sgn);
    }

    constexpr void _On_zero() {
        _Need_arithmetic_presentation_type = true;
        _Require_numeric_argument();
        _Handler::_On_zero();
    }

    constexpr void _On_precision(int _Precision) {
        _Check_precision();
        _Handler::_On_precision(_Precision);
    }

    template <class _Ty>
    constexpr void _On_dynamic_precision(const _Ty _Val) {
        _Check_precision();
        _Handler::_On_dynamic_precision(_Val);
    }

    template <class _CharT>
    constexpr void _On_type(_CharT _Type) {
        if (_Type < 0 || _Type > (numeric_limits<signed char>::max)()) {
            _Throw_format_error("Invalid type specification.");
        }
        const char _Narrow_type = static_cast<char>(_Type);
        enum class _Presentation_type_category {
            _Default,
            _Integer,
            _Floating,
            _String,
            _Pointer,
            _Char,

            _Escape,
#line 1815 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
        };
        auto _Cat = _Presentation_type_category::_Default;
        switch (_Narrow_type) {
        case '\0':
            break;

        case '?':
            _Cat = _Presentation_type_category::_Escape;
            break;
#line 1825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
        case 's':
            _Cat = _Presentation_type_category::_String;
            break;
        case 'c':
            _Cat = _Presentation_type_category::_Char;
            break;
        case 'd':
        case 'B':
        case 'b':
        case 'X':
        case 'x':
        case 'o':
            _Cat = _Presentation_type_category::_Integer;
            break;
        case 'A':
        case 'a':
        case 'E':
        case 'e':
        case 'F':
        case 'f':
        case 'G':
        case 'g':
            _Cat = _Presentation_type_category::_Floating;
            break;
        case 'p':
            _Cat = _Presentation_type_category::_Pointer;
            break;
        default:
            _Throw_format_error("Invalid presentation type specifier");
        }

        switch (_Arg_type) {
        case _Basic_format_arg_type::_None:
            ;
            break;
        case _Basic_format_arg_type::_Bool_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_String;
            }
            
            if (_Cat != _Presentation_type_category::_String && _Cat != _Presentation_type_category::_Integer) {
                _Throw_format_error("Invalid presentation type for bool");
            }
            break;
        case _Basic_format_arg_type::_Char_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_Char;
            }

            if (_Cat != _Presentation_type_category::_Char && _Cat != _Presentation_type_category::_Integer

                && _Cat != _Presentation_type_category::_Escape
#line 1878 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
            ) {
                if constexpr (is_same_v<_CharT, char>) {
                    _Throw_format_error("Invalid presentation type for char");
                } else {
                    _Throw_format_error("Invalid presentation type for wchar_t");
                }
            }
            break;
        case _Basic_format_arg_type::_Int_type:
        case _Basic_format_arg_type::_UInt_type:
        case _Basic_format_arg_type::_Long_long_type:
        case _Basic_format_arg_type::_ULong_long_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_Integer;
            }

            if (_Cat != _Presentation_type_category::_Integer && _Cat != _Presentation_type_category::_Char) {
                _Throw_format_error("Invalid presentation type for integer");
            }
            break;
        case _Basic_format_arg_type::_Float_type:
        case _Basic_format_arg_type::_Double_type:
        case _Basic_format_arg_type::_Long_double_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_Floating;
            }

            if (_Cat != _Presentation_type_category::_Floating) {
                _Throw_format_error("Invalid presentation type for floating-point");
            }
            break;
        case _Basic_format_arg_type::_CString_type:
        case _Basic_format_arg_type::_String_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_String;
            }

            if (_Cat != _Presentation_type_category::_String

                && _Cat != _Presentation_type_category::_Escape
#line 1919 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
            ) {
                _Throw_format_error("Invalid presentation type for string");
            }
            break;
        case _Basic_format_arg_type::_Pointer_type:
            if (_Cat == _Presentation_type_category::_Default) {
                _Cat = _Presentation_type_category::_Pointer;
            }

            if (_Cat != _Presentation_type_category::_Pointer) {
                _Throw_format_error("Invalid presentation type for pointer");
            }
            break;
        case _Basic_format_arg_type::_Custom_type:
            
            
            
            break;
        }

        if (_Need_arithmetic_presentation_type && _Cat != _Presentation_type_category::_Integer
            && _Cat != _Presentation_type_category::_Floating) {
            _Throw_format_error("Modifier requires an integer presentation type for bool");
        }
        _Handler::_On_type(_Type);
    }
};

struct _Format_arg_index {
    

    constexpr _Format_arg_index() = default;
    constexpr explicit _Format_arg_index(const size_t _Index_) noexcept : _Index(_Index_) {
        _Type(_Basic_format_arg_type::_None);
    }

    [[nodiscard]] constexpr _Basic_format_arg_type _Type() const noexcept {
        return static_cast<_Basic_format_arg_type>(_Type_);
    }

    constexpr void _Type(_Basic_format_arg_type _Val) noexcept {
        _Type_ = static_cast<size_t>(_Val);
    }

    size_t _Index : (sizeof(size_t) * 8 - 4){};
    size_t _Type_ : 4 {};
};

template <class _Context, class... _Args>
class _Format_arg_store {
private:
    using _CharType = _Context::char_type;
    using _Traits   = _Format_arg_traits<_Context>;

    friend basic_format_args<_Context>;

    static constexpr size_t _Num_args       = sizeof...(_Args);
    static constexpr size_t _Storage_length = (_Traits::template _Storage_size<_Args> + ...);

    
    
    
    
    _Format_arg_index _Index_array[_Num_args];
    unsigned char _Storage[_Storage_length];

#pragma warning(push)
#pragma warning(disable : 6386) 
    template <class _Ty>
    void _Store_impl(
        const size_t _Arg_index, const _Basic_format_arg_type _Arg_type, const type_identity_t<_Ty>& _Val) noexcept {
        ;

        const auto _Store_index = _Index_array[_Arg_index]._Index;

        :: memcpy(_Storage + _Store_index, ::std:: addressof(_Val), sizeof(_Ty));
        _Index_array[_Arg_index]._Type(_Arg_type);
        if (_Arg_index + 1 < _Num_args) {
            
            _Index_array[_Arg_index + 1] = _Format_arg_index{_Store_index + sizeof(_Ty)};
        }
    }
#pragma warning(pop)

    template <class _Ty>
    void _Store(const size_t _Arg_index, _Ty&& _Val) noexcept {
        using _Erased_type = _Traits::template _Storage_type<_Ty>;

        _Basic_format_arg_type _Arg_type;
        if constexpr (is_same_v<_Erased_type, bool>) {
            _Arg_type = _Basic_format_arg_type::_Bool_type;
        } else if constexpr (is_same_v<_Erased_type, _CharType>) {
            _Arg_type = _Basic_format_arg_type::_Char_type;
        } else if constexpr (is_same_v<_Erased_type, int>) {
            _Arg_type = _Basic_format_arg_type::_Int_type;
        } else if constexpr (is_same_v<_Erased_type, unsigned int>) {
            _Arg_type = _Basic_format_arg_type::_UInt_type;
        } else if constexpr (is_same_v<_Erased_type, long long>) {
            _Arg_type = _Basic_format_arg_type::_Long_long_type;
        } else if constexpr (is_same_v<_Erased_type, unsigned long long>) {
            _Arg_type = _Basic_format_arg_type::_ULong_long_type;
        } else if constexpr (is_same_v<_Erased_type, float>) {
            _Arg_type = _Basic_format_arg_type::_Float_type;
        } else if constexpr (is_same_v<_Erased_type, double>) {
            _Arg_type = _Basic_format_arg_type::_Double_type;
        } else if constexpr (is_same_v<_Erased_type, long double>) {
            _Arg_type = _Basic_format_arg_type::_Long_double_type;
        } else if constexpr (is_same_v<_Erased_type, const void*>) {
            _Arg_type = _Basic_format_arg_type::_Pointer_type;
        } else if constexpr (is_same_v<_Erased_type, const _CharType*>) {
            _Arg_type = _Basic_format_arg_type::_CString_type;
        } else if constexpr (is_same_v<_Erased_type, basic_string_view<_CharType>>) {
            _Arg_type = _Basic_format_arg_type::_String_type;
        } else {
            ;
            _Arg_type = _Basic_format_arg_type::_Custom_type;
        }






#line 2043 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
        {
            _Store_impl<_Erased_type>(_Arg_index, _Arg_type, static_cast<_Erased_type>(_Val));
        }
    }

public:
    _Format_arg_store(_Args&... _Vals) noexcept {
        _Index_array[0]   = {};
        size_t _Arg_index = 0;
        (_Store(_Arg_index++, _Vals), ...);
    }
};

template <class _Context>
class _Format_arg_store<_Context> {};

 template <class _Context>
class basic_format_args {
public:
    basic_format_args() noexcept = default;

    basic_format_args(const _Format_arg_store<_Context>&) noexcept {}

    template <class... _Args>
    basic_format_args(const _Format_arg_store<_Context, _Args...>& _Store) noexcept
        : _Num_args(sizeof...(_Args)), _Index_array(_Store._Index_array) {}

    [[nodiscard]] basic_format_arg<_Context> get(const size_t _Index) const noexcept {
        if (_Index >= _Num_args) {
            return basic_format_arg<_Context>{};
        }

        using _CharType = _Context::char_type;
        
        const auto _Packed_index = _Index_array[_Index];
        const auto _Arg_storage =
            reinterpret_cast<const unsigned char*>(_Index_array + _Num_args) + _Packed_index._Index;

        switch (_Packed_index._Type()) {
        case _Basic_format_arg_type::_None:
        default:
            ;
            return basic_format_arg<_Context>{};
        case _Basic_format_arg_type::_Int_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<int>(_Arg_storage)};
        case _Basic_format_arg_type::_UInt_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<unsigned int>(_Arg_storage)};
        case _Basic_format_arg_type::_Long_long_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<long long>(_Arg_storage)};
        case _Basic_format_arg_type::_ULong_long_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<unsigned long long>(_Arg_storage)};
        case _Basic_format_arg_type::_Bool_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<bool>(_Arg_storage)};
        case _Basic_format_arg_type::_Char_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<_CharType>(_Arg_storage)};
        case _Basic_format_arg_type::_Float_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<float>(_Arg_storage)};
        case _Basic_format_arg_type::_Double_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<double>(_Arg_storage)};
        case _Basic_format_arg_type::_Long_double_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<long double>(_Arg_storage)};
        case _Basic_format_arg_type::_Pointer_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<const void*>(_Arg_storage)};
        case _Basic_format_arg_type::_CString_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<const _CharType*>(_Arg_storage)};
        case _Basic_format_arg_type::_String_type:
            return basic_format_arg<_Context>{_Get_value_from_memory<basic_string_view<_CharType>>(_Arg_storage)};
        case _Basic_format_arg_type::_Custom_type:
            return basic_format_arg<_Context>{
                _Get_value_from_memory<typename basic_format_arg<_Context>::handle>(_Arg_storage)};
        }
    }

    [[nodiscard]] size_t _Estimate_required_capacity() const noexcept {
        using _CharType = _Context::char_type;
        size_t _Result  = 0;

        for (size_t _Idx = 0; _Idx < _Num_args; ++_Idx) {
            const auto _Packed_index = _Index_array[_Idx];
            const auto _Arg_type     = _Packed_index._Type();
            if (_Arg_type == _Basic_format_arg_type::_String_type) {
                const auto _Arg_storage =
                    reinterpret_cast<const unsigned char*>(_Index_array + _Num_args) + _Packed_index._Index;
                const auto _View = _Get_value_from_memory<basic_string_view<_CharType>>(_Arg_storage);
                _Result += _View.size();
            } else if (_Arg_type == _Basic_format_arg_type::_CString_type) {
                _Result += 32; 
            } else {
                _Result += 8; 
            }
        }
        return _Result;
    }

private:
    template <class _Ty>
    [[nodiscard]] static auto _Get_value_from_memory(const unsigned char* const _Val) noexcept {
        auto& _Temp = *reinterpret_cast<const unsigned char(*)[sizeof(_Ty)]>(_Val);
        return ::std:: bit_cast<_Ty>(_Temp);
    }

    size_t _Num_args                      = 0;
    const _Format_arg_index* _Index_array = nullptr;
};

template <class _Context, class... _Args>
basic_format_args(_Format_arg_store<_Context, _Args...>) -> basic_format_args<_Context>;






class _Lazy_locale {
private:
    const locale* _Loc = nullptr;

public:
    _Lazy_locale() = default;

    explicit _Lazy_locale(const locale& _Loc_) : _Loc(&_Loc_) {}

    explicit _Lazy_locale(const locale&&) = delete;

    [[nodiscard]] locale _Get() const {
        if (_Loc) {
            return *_Loc;
        } else {
            return locale{};
        }
    }
};

 template <class _Out, class _CharT>
    requires output_iterator<_Out, const _CharT&>
class basic_format_context {
private:
    _Out _OutputIt;
    basic_format_args<basic_format_context> _Args;
    _Lazy_locale _Loc;

public:
    using iterator  = _Out;
    using char_type = _CharT;

    template <class _Ty>
    using formatter_type = formatter<_Ty, _CharT>;

    constexpr basic_format_context(_Out _OutputIt_, basic_format_args<basic_format_context> _Ctx_args)
        : _OutputIt(::std:: move(_OutputIt_)), _Args(_Ctx_args) {}

    constexpr basic_format_context(
        _Out _OutputIt_, basic_format_args<basic_format_context> _Ctx_args, const _Lazy_locale& _Loc_)
        : _OutputIt(::std:: move(_OutputIt_)), _Args(_Ctx_args), _Loc(_Loc_) {}

    [[nodiscard]] basic_format_arg<basic_format_context> arg(size_t _Id) const noexcept {
        return _Args.get(_Id);
    }
    [[nodiscard]] locale locale() {
        return _Loc._Get();
    }
    [[nodiscard]] iterator out() {
        return ::std:: move(_OutputIt);
    }
    void advance_to(iterator _It) {
        _OutputIt = ::std:: move(_It);
    }

    [[nodiscard]] const basic_format_args<basic_format_context>& _Get_args() const noexcept {
        return _Args;
    }
    [[nodiscard]] _Lazy_locale _Get_lazy_locale() const {
        return _Loc;
    }
};

template <class _Ty>
class _Fmt_buffer {
private:
    _Ty* _Ptr_        = nullptr;
    size_t _Size_     = 0;
    size_t _Capacity_ = 0;

protected:
    explicit _Fmt_buffer(const size_t _Size) noexcept : _Size_(_Size), _Capacity_(_Size) {}

    ~_Fmt_buffer() = default;

    _Fmt_buffer(_Ty* _Data, const size_t _Size, const size_t _Capacity) noexcept
        : _Ptr_(_Data), _Size_(_Size), _Capacity_(_Capacity) {}

    void _Set(_Ty* _Buf_data, const size_t _Buf_capacity) noexcept {
        _Ptr_      = _Buf_data;
        _Capacity_ = _Buf_capacity;
    }

    virtual void _Grow(size_t _Capacity) = 0;

public:
    using value_type = _Ty;

    _Fmt_buffer(const _Fmt_buffer&)    = delete;
    void operator=(const _Fmt_buffer&) = delete;

    [[nodiscard]] _Ty* begin() noexcept {
        return _Ptr_;
    }

    [[nodiscard]] _Ty* end() noexcept {
        return _Ptr_ + _Size_;
    }

    [[nodiscard]] size_t _Size() const noexcept {
        return _Size_;
    }

    [[nodiscard]] size_t _Capacity() const noexcept {
        return _Capacity_;
    }

    void _Clear() noexcept {
        _Size_ = 0;
    }

    void _Try_reserve(const size_t _New_capacity) {
        if (_New_capacity > _Capacity_) {
            _Grow(_New_capacity);
        }
    }

    void push_back(const _Ty _Value) {
        _Try_reserve(_Size_ + 1);
        _Ptr_[_Size_++] = _Value;
    }
};

struct _Fmt_buffer_traits {
    explicit _Fmt_buffer_traits(ptrdiff_t) {}

    [[nodiscard]] size_t _Count() const noexcept {
        return 0;
    }

    [[nodiscard]] size_t _Limit(const size_t _Size) noexcept {
        return _Size;
    }
};

class _Fmt_fixed_buffer_traits {
private:
    ptrdiff_t _Count_ = 0;
    ptrdiff_t _Limit_;

public:
    explicit _Fmt_fixed_buffer_traits(const ptrdiff_t _Limit) noexcept : _Limit_(_Limit) {}

    [[nodiscard]] size_t _Count() const noexcept {
        return static_cast<size_t>(_Count_);
    }

    [[nodiscard]] size_t _Limit(const size_t _Size) noexcept {
        size_t _Avail = static_cast<size_t>(_Limit_ > _Count_ ? _Limit_ - _Count_ : 0);
        _Count_ += _Size;
        return _Size < _Avail ? _Size : _Avail;
    }
};

inline constexpr size_t _Fmt_buffer_size = 256;

template <class _Iterator>
struct _Back_insert_iterator_container_type {
    using type = void;
};

template <class _Container>
struct _Back_insert_iterator_container_type<back_insert_iterator<_Container>> {
    using type = _Container;
};

template <class _Container>
struct _Back_insert_iterator_container_access : back_insert_iterator<_Container> {
    explicit _Back_insert_iterator_container_access(back_insert_iterator<_Container> _Iter)
        : back_insert_iterator<_Container>(_Iter) {}

    using back_insert_iterator<_Container>::container;
};

template <class _OutputIt, class _Ty, class _Traits = _Fmt_buffer_traits>
class _Fmt_iterator_buffer final : public _Traits, public _Fmt_buffer<_Ty> {
private:
    _OutputIt _Output;
    _Ty _Data[_Fmt_buffer_size];

    void _Grow(size_t) final {
        if (this->_Size() == _Fmt_buffer_size) {
            _Flush();
        }
    }

    void _Flush() {
        auto _Size = this->_Size();
        this->_Clear();
        const auto _End = _Data + this->_Limit(_Size);

        
        using _Container = _Back_insert_iterator_container_type<_OutputIt>::type;
        if constexpr (_Is_specialization_v<_Container, basic_string> || _Is_specialization_v<_Container, vector>) {
            auto& _Cont = *_Back_insert_iterator_container_access<_Container>{_Output}.container;
            _Cont.insert(_Cont.end(), _Data, _End);
        } else {
            _Output = ::std:: _Copy_unchecked(_Data, _End, ::std:: move(_Output));
        }
    }

public:
    explicit _Fmt_iterator_buffer(_OutputIt _Out, ptrdiff_t _Size = _Fmt_buffer_size)
        : _Traits(_Size), _Fmt_buffer<_Ty>(_Data, 0, _Fmt_buffer_size), _Output(::std:: move(_Out)) {}

    ~_Fmt_iterator_buffer() {
        if (this->_Size() != 0) {
            _Flush();
        }
    }

    [[nodiscard]] _OutputIt _Out() {
        _Flush();
        return ::std:: move(_Output);
    }

    [[nodiscard]] ptrdiff_t _Count() const noexcept {
        return static_cast<ptrdiff_t>(_Traits::_Count() + this->_Size());
    }
};

template <class _Ty>
class _Fmt_iterator_buffer<_Ty*, _Ty> final : public _Fmt_buffer<_Ty> {
private:
    void _Grow(size_t) final {}

public:
    explicit _Fmt_iterator_buffer(_Ty* _Out, ptrdiff_t = 0) : _Fmt_buffer<_Ty>(_Out, 0, ~size_t{}) {}

    [[nodiscard]] _Ty* _Out() noexcept {
        return this->end();
    }
};

template <class _Ty>
class _Fmt_counting_buffer final : public _Fmt_buffer<_Ty> {
private:
    _Ty _Data[_Fmt_buffer_size];
    size_t _Count_ = 0;

    void _Grow(size_t) final {
        if (this->_Size() != _Fmt_buffer_size) {
            return;
        }
        _Count_ += this->_Size();
        this->_Clear();
    }

public:
    _Fmt_counting_buffer() : _Fmt_buffer<_Ty>(_Data, 0, _Fmt_buffer_size) {}

    [[nodiscard]] size_t _Count() const noexcept {
        return _Count_ + this->_Size();
    }
};

using _Fmt_it  = back_insert_iterator<_Fmt_buffer<char>>;
using _Fmt_wit = back_insert_iterator<_Fmt_buffer<wchar_t>>;

 using format_context  = basic_format_context<_Fmt_it, char>;
 using wformat_context = basic_format_context<_Fmt_wit, wchar_t>;

inline namespace __p2286 {
template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, monostate) {
    ;
    return _Out;
}











inline constexpr size_t _Format_min_buffer_length = 24;

template <class _CharT, class _OutputIt, class _Arithmetic>
    requires (is_arithmetic_v<_Arithmetic> && !_CharT_or_bool<_Arithmetic, _CharT>)
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, _Arithmetic _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, bool _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, _CharT _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const void* _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const _CharT* _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, basic_string_view<_CharT> _Value);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Widen_and_copy(const char* _First, const char* const _Last, _OutputIt _Out) {
    for (; _First != _Last; ++_First, (void) ++_Out) {
        *_Out = static_cast<_CharT>(*_First);
    }

    return _Out;
}

template <class _CharT, class _OutputIt, class _Arithmetic>
    requires (is_arithmetic_v<_Arithmetic> && !_CharT_or_bool<_Arithmetic, _CharT>)
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const _Arithmetic _Value) {
    
    char _Buffer[_Format_min_buffer_length];
    char* _End = _Buffer;

    if constexpr (is_floating_point_v<_Arithmetic>) {
        if ((::std:: isnan)(_Value)) {
            if ((::std:: signbit)(_Value)) {
                *_End++ = '-';
            }

            :: memcpy(_End, "nan", 3);
            _End += 3;
        }
    }

    if (_End == _Buffer) {
        const to_chars_result _Result = ::std:: to_chars(_Buffer, ::std:: end(_Buffer), _Value);
        ;
        _End = _Result.ptr;
    }

    return _Widen_and_copy<_CharT>(_Buffer, _End, ::std:: move(_Out));
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const bool _Value) {
    if constexpr (is_same_v<_CharT, wchar_t>) {
        return _Fmt_write(::std:: move(_Out), _Value ? L"true" : L"false");
    } else {
        return _Fmt_write(::std:: move(_Out), _Value ? "true" : "false");
    }
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const _CharT _Value) {
    *_Out++ = _Value;
    return _Out;
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const void* const _Value) {
    
    char _Buffer[_Format_min_buffer_length];
    const auto [_End, _Ec] = ::std:: to_chars(_Buffer, ::std:: end(_Buffer), reinterpret_cast<uintptr_t>(_Value), 16);
    ;
    *_Out++ = '0';
    *_Out++ = 'x';
    return _Widen_and_copy<_CharT>(_Buffer, _End, ::std:: move(_Out));
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const _CharT* _Value) {
    if (!_Value) {
        _Throw_format_error("String pointer is null.");
    }

    while (*_Value) {
        *_Out++ = *_Value++;
    }

    return _Out;
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, const basic_string_view<_CharT> _Value) {
    return ::std::ranges:: copy(_Value, ::std:: move(_Out)).out;
}

template <class _OutputIt, class _Specs_type, class _Func>
[[nodiscard]] _OutputIt _Write_aligned(
    _OutputIt _Out, const int _Width, const _Specs_type& _Specs, const _Fmt_align _Default_align, _Func&& _Fn) {
    int _Fill_left  = 0;
    int _Fill_right = 0;
    auto _Alignment = _Specs._Alignment;

    if (_Alignment == _Fmt_align::_None) {
        _Alignment = _Default_align;
    }

    if (_Width < _Specs._Width) {
        switch (_Alignment) {
        case _Fmt_align::_Left:
            _Fill_right = _Specs._Width - _Width;
            break;
        case _Fmt_align::_Right:
            _Fill_left = _Specs._Width - _Width;
            break;
        case _Fmt_align::_Center:
            _Fill_left  = (_Specs._Width - _Width) / 2;
            _Fill_right = _Specs._Width - _Width - _Fill_left;
            break;
        case _Fmt_align::_None:
            ;
            break;
        }
    }

    const basic_string_view _Fill_char{_Specs._Fill, _Specs._Fill_length};
    for (; _Fill_left > 0; --_Fill_left) {
        _Out = ::std::ranges:: copy(_Fill_char, ::std:: move(_Out)).out;
    }

    _Out = _Fn(::std:: move(_Out));

    for (; _Fill_right > 0; --_Fill_right) {
        _Out = ::std::ranges:: copy(_Fill_char, ::std:: move(_Out)).out;
    }

    return _Out;
}

template <integral _Integral>
[[nodiscard]] constexpr string_view _Get_integral_prefix(const char _Type, const _Integral _Value) noexcept {
    switch (_Type) {
    case 'b':
        return "0b"sv;
    case 'B':
        return "0B"sv;
    case 'x':
        return "0x"sv;
    case 'X':
        return "0X"sv;
    case 'o':
        if (_Value != _Integral{0}) {
            return "0"sv;
        }
        return {};
    default:
        return {};
    }
}

template <class _OutputIt>
[[nodiscard]] _OutputIt _Write_sign(_OutputIt _Out, const _Fmt_sign _Sgn, const bool _Is_negative) {
    if (_Is_negative) {
        *_Out++ = '-';
    } else {
        switch (_Sgn) {
        case _Fmt_sign::_Plus:
            *_Out++ = '+';
            break;
        case _Fmt_sign::_Space:
            *_Out++ = ' ';
            break;
        case _Fmt_sign::_None:
        case _Fmt_sign::_Minus:
            break;
        }
    }
    return _Out;
}

inline void _Buffer_to_uppercase(char* _First, const char* _Last) noexcept {
    for (; _First != _Last; ++_First) {
        if (*_First >= 'a' && *_First <= 'z') {
            *_First -= 'a' - 'A';
        }
    }
}

template <class _Ty>
using _Make_standard_integer = conditional_t<is_signed_v<_Ty>, make_signed_t<_Ty>, make_unsigned_t<_Ty>>;

template <class _CharT, integral _Ty>
[[nodiscard]] constexpr bool _In_bounds(const _Ty _Value) {
    return ::std:: in_range<_Make_standard_integer<_CharT>>(static_cast<_Make_standard_integer<_Ty>>(_Value));
}

[[nodiscard]] inline int _Count_separators(size_t _Digits, const string_view _Groups) {
    if (_Groups.empty()) {
        return 0;
    }

    
    int _Separators = 0;
    auto _Group_it  = _Groups.begin();
    while (_Digits > static_cast<size_t>(*_Group_it)) {
        _Digits -= static_cast<size_t>(*_Group_it);
        ++_Separators;
        if (_Group_it + 1 != _Groups.end()) {
            ++_Group_it;
        }
    }

    return _Separators;
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Write_separated_integer(const char* _First, const char* const _Last, const string_view _Groups,
    const _CharT _Separator, int _Separators, _OutputIt _Out) {
    auto _Group_it = _Groups.begin();
    auto _Repeats  = 0;
    auto _Grouped  = 0;

    for (int _Section = 0; _Section < _Separators; ++_Section) {
        _Grouped += *_Group_it;
        if (_Group_it + 1 != _Groups.end()) {
            ++_Group_it;
        } else {
            ++_Repeats;
        }
    }
    _Out   = _Widen_and_copy<_CharT>(_First, _Last - _Grouped, ::std:: move(_Out));
    _First = _Last - _Grouped;

    for (; _Separators > 0; --_Separators) {
        if (_Repeats > 0) {
            --_Repeats;
        } else {
            --_Group_it;
        }

        *_Out++ = _Separator;
        _Out    = _Widen_and_copy<_CharT>(_First, _First + *_Group_it, ::std:: move(_Out));
        _First += *_Group_it;
    }
    ;
    return _Out;
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, monostate, const _Basic_format_specs<_CharT>&, _Lazy_locale) {
    ;
    return _Out;
}

template <class _CharT, class _OutputIt, integral _Integral>
[[nodiscard]] _OutputIt _Write_integral(
    _OutputIt _Out, _Integral _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale);


template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Write_escaped(
    _OutputIt _Out, basic_string_view<_CharT> _Value, _Basic_format_specs<_CharT> _Specs, char _Delim);
#line 2703 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

template <class _CharT, class _OutputIt, integral _Integral>
    requires (!_CharT_or_bool<_Integral, _CharT>)
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, _Integral _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(_OutputIt _Out, bool _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, _CharT _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale);

template <class _CharT, class _OutputIt, floating_point _Float>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, _Float _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const void* _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const _CharT* _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale);

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, basic_string_view<_CharT> _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale);

#pragma warning(push)
#pragma warning(disable : 4296) 
template <class _CharT, class _OutputIt, integral _Integral>
[[nodiscard]] _OutputIt _Write_integral(
    _OutputIt _Out, const _Integral _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale) {
    if (_Specs._Type == 'c') {
        if (!_In_bounds<_CharT>(_Value)) {
            if constexpr (is_same_v<_CharT, char>) {
                _Throw_format_error("integral cannot be stored in char");
            } else {
                _Throw_format_error("integral cannot be stored in wchar_t");
            }
        }
        _Specs._Alt = false;
        return _Fmt_write(::std:: move(_Out), static_cast<_CharT>(_Value), _Specs, _Locale);
    }

    ;

    if (_Specs._Sgn == _Fmt_sign::_None) {
        _Specs._Sgn = _Fmt_sign::_Minus;
    }

    int _Base = 10;

    switch (_Specs._Type) {
    case 'B':
    case 'b':
        _Base = 2;
        break;
    case 'X':
    case 'x':
        _Base = 16;
        break;
    case 'o':
        _Base = 8;
        break;
    }

    
    char _Buffer[65];
    const auto [_End, _Ec] = ::std:: to_chars(_Buffer, ::std:: end(_Buffer), _Value, _Base);
    ;

    auto _Buffer_start = _Buffer;
    auto _Width        = static_cast<int>(_End - _Buffer_start);

    if (_Value >= _Integral{0}) {
        if (_Specs._Sgn != _Fmt_sign::_Minus) {
            _Width += 1;
        }
    } else {
        
        _Buffer_start += 1;
    }

    if (_Specs._Type == 'X') {
        _Buffer_to_uppercase(_Buffer_start, _End);
    }

    string_view _Prefix;
    if (_Specs._Alt) {
        _Prefix = _Get_integral_prefix(_Specs._Type, _Value);
        _Width += static_cast<int>(_Prefix.size());
    }

    auto _Separators = 0;
    string _Groups;
    if (_Specs._Localized) {
        _Groups     = ::std:: use_facet<numpunct<_CharT>>(_Locale._Get()).grouping();
        _Separators = _Count_separators(static_cast<size_t>(_End - _Buffer_start), _Groups);
        
        _Width += _Separators;
    }

    const bool _Write_leading_zeroes = _Specs._Leading_zero && _Specs._Alignment == _Fmt_align::_None;
    auto _Writer                     = [&, _End = _End](_OutputIt _Out) {
        _Out = _Write_sign(::std:: move(_Out), _Specs._Sgn, _Value < _Integral{0});
        _Out = _Widen_and_copy<_CharT>(_Prefix.data(), _Prefix.data() + _Prefix.size(), ::std:: move(_Out));
        if (_Write_leading_zeroes && _Width < _Specs._Width) {
            _Out = ::std::ranges:: fill_n(::std:: move(_Out), _Specs._Width - _Width, _CharT{'0'});
        }

        if (_Separators > 0) {
            return _Write_separated_integer(_Buffer_start, _End, _Groups,
                                    ::std:: use_facet<numpunct<_CharT>>(_Locale._Get()).thousands_sep(), 
                                    _Separators, ::std:: move(_Out));
        }
        return _Widen_and_copy<_CharT>(_Buffer_start, _End, ::std:: move(_Out));
    };

    if (_Write_leading_zeroes) {
        return _Writer(::std:: move(_Out));
    }

    return _Write_aligned(::std:: move(_Out), _Width, _Specs, _Fmt_align::_Right, _Writer);
}
#pragma warning(pop)

template <class _CharT, class _OutputIt, integral _Integral>
    requires (!_CharT_or_bool<_Integral, _CharT>)
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const _Integral _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale) {
    return _Write_integral(::std:: move(_Out), _Value, _Specs, _Locale);
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const bool _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 's') {
        return _Write_integral(::std:: move(_Out), static_cast<unsigned char>(_Value), _Specs, _Locale);
    }

    ;

    if (_Specs._Localized) {
        _Specs._Localized  = false;
        const auto& _Facet = ::std:: use_facet<numpunct<_CharT>>(_Locale._Get());
        return _Fmt_write(::std:: move(_Out),
            _Value ? static_cast<basic_string_view<_CharT>>(_Facet.truename())
                   : static_cast<basic_string_view<_CharT>>(_Facet.falsename()),
            _Specs, _Locale);
    }

    if constexpr (is_same_v<_CharT, wchar_t>) {
        return _Fmt_write(::std:: move(_Out), _Value ? L"true" : L"false", _Specs, _Locale);
    } else {
        return _Fmt_write(::std:: move(_Out), _Value ? "true" : "false", _Specs, _Locale);
    }
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const _CharT _Value, _Basic_format_specs<_CharT> _Specs, _Lazy_locale _Locale) {
    if (_Specs._Type != '\0' && _Specs._Type != 'c'

        && _Specs._Type != '?'
#line 2870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
    ) {
        return _Write_integral(::std:: move(_Out), _Value, _Specs, _Locale);
    }

    ;


    if (_Specs._Type == '?') {
        return _Write_escaped(::std:: move(_Out), basic_string_view<_CharT>{&_Value, 1}, _Specs, '\'');
    }
#line 2881 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

    return _Fmt_write(::std:: move(_Out), basic_string_view<_CharT>{&_Value, 1}, _Specs, _Locale);
}

template <class _CharT, class _OutputIt, floating_point _Float>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const _Float _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale) {
    auto _Sgn = _Specs._Sgn;
    if (_Sgn == _Fmt_sign::_None) {
        _Sgn = _Fmt_sign::_Minus;
    }

    auto _To_upper  = false;
    auto _Format    = chars_format::general;
    auto _Exponent  = 'e';
    auto _Precision = _Specs._Precision;

    switch (_Specs._Type) {
    case 'A':
        _To_upper = true;
        [[fallthrough]];
    case 'a':
        _Format   = chars_format::hex;
        _Exponent = 'p';
        break;
    case 'E':
        _To_upper = true;
        [[fallthrough]];
    case 'e':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format = chars_format::scientific;
        break;
    case 'F':
        _To_upper = true;
        [[fallthrough]];
    case 'f':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format = chars_format::fixed;
        break;
    case 'G':
        _To_upper = true;
        [[fallthrough]];
    case 'g':
        if (_Precision == -1) {
            _Precision = 6;
        }
        _Format = chars_format::general;
        break;
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    constexpr auto _Max_precision = 1074;
    constexpr auto _Buffer_size   = _Max_precision + 308 + 3;
    char _Buffer[_Buffer_size];
    to_chars_result _Result;

    auto _Extra_precision = 0;
    if (_Precision > _Max_precision) {
        _Extra_precision = _Precision - _Max_precision;
        _Precision       = _Max_precision;
    }

    const auto _Is_negative = (::std:: signbit)(_Value);

    if ((::std:: isnan)(_Value)) {
        _Result.ptr = _Buffer;
        if (_Is_negative) {
            ++_Result.ptr; 
        }

        :: memcpy(_Result.ptr, "nan", 3);
        _Result.ptr += 3;
    } else {
        if (_Precision == -1) {
            _Result = ::std:: to_chars(_Buffer, ::std:: end(_Buffer), _Value, _Format);
        } else {
            _Result = ::std:: to_chars(_Buffer, ::std:: end(_Buffer), _Value, _Format, _Precision);
        }

        ;
    }

    auto _Buffer_start = _Buffer;
    auto _Width        = static_cast<int>(_Result.ptr - _Buffer_start);

    if (_Is_negative) {
        
        _Buffer_start += 1;
    } else {
        if (_Sgn != _Fmt_sign::_Minus) {
            _Width += 1;
        }
    }

    ;
    if (_To_upper) {
        _Buffer_to_uppercase(_Buffer_start, _Result.ptr);
        _Exponent -= 'a' - 'A';
    }

    const auto _Is_finite = (::std:: isfinite)(_Value);

    auto _Append_decimal   = false;
    auto _Exponent_start   = _Result.ptr;
    auto _Radix_point      = _Result.ptr;
    auto _Integral_end     = _Result.ptr;
    auto _Zeroes_to_append = 0;
    auto _Separators       = 0;
    string _Groups;

    if (_Is_finite) {
        if (_Specs._Alt || _Specs._Localized) {
            for (auto _It = _Buffer_start; _It < _Result.ptr; ++_It) {
                if (*_It == '.') {
                    _Radix_point = _It;
                } else if (*_It == _Exponent) {
                    _Exponent_start = _It;
                }
            }
            _Integral_end = (::std:: min)(_Radix_point, _Exponent_start);

            if (_Specs._Alt && _Radix_point == _Result.ptr) {
                
                ++_Width;
                _Append_decimal = true;
            }

            if (_Specs._Localized) {
                _Groups     = ::std:: use_facet<numpunct<_CharT>>(_Locale._Get()).grouping();
                _Separators = _Count_separators(static_cast<size_t>(_Integral_end - _Buffer_start), _Groups);
            }
        }

        switch (_Format) {
        case chars_format::hex:
        case chars_format::scientific:
            if (_Extra_precision != 0) {
                
                while (*--_Exponent_start != _Exponent) {
                }
            }
            [[fallthrough]];
        case chars_format::fixed:
            _Zeroes_to_append = _Extra_precision;
            break;
        case chars_format::general:
            if (_Specs._Alt && (_Specs._Type == 'g' || _Specs._Type == 'G')) {
                auto _Digits = static_cast<int>(_Exponent_start - _Buffer_start);

                if (!_Append_decimal) {
                    --_Digits;
                }

                _Zeroes_to_append = _Extra_precision + _Precision - _Digits;

                
                if (_Exponent_start == _Result.ptr && ::std:: abs(_Value) < 1.0 && _Value != 0.0) {
                    for (auto _It = _Buffer_start; _It < _Result.ptr; ++_It) {
                        if (*_It == '0') {
                            ++_Zeroes_to_append;
                        } else if (*_It != '.') {
                            break;
                        }
                    }
                }
            }
            break;
        default:
            __assume(false);
        }
    }

    _Width += _Zeroes_to_append;

    const bool _Write_leading_zeroes = _Specs._Leading_zero && _Specs._Alignment == _Fmt_align::_None && _Is_finite;

    auto _Writer = [&](_OutputIt _Out) {
        _Out = _Write_sign(::std:: move(_Out), _Sgn, _Is_negative);

        if (_Write_leading_zeroes && _Width < _Specs._Width) {
            _Out = ::std::ranges:: fill_n(::std:: move(_Out), _Specs._Width - _Width, _CharT{'0'});
        }

        if (_Specs._Localized) {
            const auto& _Facet = ::std:: use_facet<numpunct<_CharT>>(_Locale._Get());

            _Out = _Write_separated_integer(
                _Buffer_start, _Integral_end, _Groups, _Facet.thousands_sep(), _Separators, ::std:: move(_Out));
            if (_Radix_point != _Result.ptr || _Append_decimal) {
                *_Out++         = _Facet.decimal_point();
                _Append_decimal = false;
            }
            _Buffer_start = _Integral_end;
            if (_Radix_point != _Result.ptr) {
                ++_Buffer_start;
            }
        }

        _Out = _Widen_and_copy<_CharT>(_Buffer_start, _Exponent_start, ::std:: move(_Out));
        if (_Specs._Alt && _Append_decimal) {
            *_Out++ = '.';
        }

        for (; _Zeroes_to_append > 0; --_Zeroes_to_append) {
            *_Out++ = '0';
        }

        return _Widen_and_copy<_CharT>(_Exponent_start, _Result.ptr, ::std:: move(_Out));
    };

    if (_Write_leading_zeroes) {
        return _Writer(::std:: move(_Out));
    }

    return _Write_aligned(::std:: move(_Out), _Width, _Specs, _Fmt_align::_Right, _Writer);
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const void* const _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale) {
    ;
    ;
    ;
    ;
    ;
    ;

    
    int _Width = 3;
    if (_Value != nullptr) {
        
        
        
        
        _Width = 2 + (::std:: bit_width(reinterpret_cast<uintptr_t>(_Value)) + 3) / 4;
    }

    return _Write_aligned(::std:: move(_Out), _Width, _Specs, _Fmt_align::_Right,
        [=](_OutputIt _Out) { return _Fmt_write<_CharT>(::std:: move(_Out), _Value); });
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const _CharT* _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale _Locale) {
    return _Fmt_write(::std:: move(_Out), basic_string_view<_CharT>{_Value}, _Specs, _Locale);
}


template <class _CharT>
class _Measure_string_prefix_iterator_utf {
private:
    _Grapheme_break_property_iterator<_CharT> _WrappedIter;

public:
    [[nodiscard]] constexpr bool operator==(const _Measure_string_prefix_iterator_utf&) const noexcept = default;

    [[nodiscard]] constexpr bool operator==(default_sentinel_t) const noexcept {
        return _WrappedIter == default_sentinel;
    }

    using difference_type = ptrdiff_t;
    using value_type      = int;

    constexpr _Measure_string_prefix_iterator_utf(const _CharT* _First, const _CharT* _Last)
        : _WrappedIter(_First, _Last) {}

    constexpr _Measure_string_prefix_iterator_utf() = default;

    [[nodiscard]] constexpr value_type operator*() const {
        return _Unicode_width_estimate(*_WrappedIter);
    }

    constexpr _Measure_string_prefix_iterator_utf& operator++() noexcept {
        ++_WrappedIter;
        return *this;
    }

    constexpr _Measure_string_prefix_iterator_utf operator++(int) noexcept {
        auto _Old = *this;
        ++*this;
        return _Old;
    }

    [[nodiscard]] constexpr const _CharT* _Position() const {
        return _WrappedIter._Position();
    }
};

class _Measure_string_prefix_iterator_legacy {
private:
    _Fmt_codec<char> _Codec = _Get_fmt_codec<char>();
    const char* _First      = nullptr;
    const char* _Last       = nullptr;
    int _Units              = 0;

    void _Update_units() {
        if (_First < _Last) {
            _Units = _Codec._Units_in_next_character(_First, _Last);
        } else {
            _Units = -1;
        }
    }

public:
    [[nodiscard]] bool operator==(default_sentinel_t) const noexcept {
        return _First == _Last;
    }
    [[nodiscard]] bool operator==(const _Measure_string_prefix_iterator_legacy& _Rhs) const noexcept {
        return _First == _Rhs._First && _Last == _Rhs._Last;
    }

    using difference_type = ptrdiff_t;
    using value_type      = int;

    _Measure_string_prefix_iterator_legacy(const char* _First_val, const char* _Last_val)
        : _First(_First_val), _Last(_Last_val) {
        _Update_units();
    }

    _Measure_string_prefix_iterator_legacy() = default;

    _Measure_string_prefix_iterator_legacy& operator++() noexcept {
        _First += _Units;
        _Update_units();
        return *this;
    }
    _Measure_string_prefix_iterator_legacy operator++(int) noexcept {
        auto _Old = *this;
        ++*this;
        return _Old;
    }
    [[nodiscard]] value_type operator*() const noexcept {
        return _Units;
    }

    [[nodiscard]] const char* _Position() const noexcept {
        return _First;
    }
};

template <class _CharT>
using _Measure_string_prefix_iterator =
    conditional_t<is_same_v<_CharT, char> && !_Is_execution_charset_self_synchronizing(),
        _Measure_string_prefix_iterator_legacy, _Measure_string_prefix_iterator_utf<_CharT>>;

template <class _CharT>
[[nodiscard]] const _CharT* _Measure_string_prefix(const basic_string_view<_CharT> _Value, int& _Width) {
    
    
    const int _Max_width = _Width;
    const auto _First    = _Value.data();
    const auto _Last     = _First + _Value.size();
    _Measure_string_prefix_iterator<_CharT> _Pfx_iter(_First, _Last);
    int _Estimated_width = 0; 

    constexpr auto _Max_int = (numeric_limits<int>::max)();

    while (_Pfx_iter != default_sentinel) {
        if (_Estimated_width == _Max_width && _Max_width >= 0) {
            
            break;
        }

        const int _Character_width = *_Pfx_iter;

        if (_Max_int - _Character_width < _Estimated_width) { 
            
            if (_Max_width < 0) { 
                _Width = _Max_int;
                return _Last;
            }
            break;
        }

        _Estimated_width += _Character_width;
        if (_Estimated_width > _Max_width && _Max_width >= 0) {
            
            _Estimated_width -= _Character_width;
            break;
        }
        ++_Pfx_iter;
    }

    _Width = _Estimated_width;
    return _Pfx_iter._Position();
}


[[nodiscard]] constexpr bool _Is_printable(char32_t _Val) {
    return __printable_property_data._Get_property_for_codepoint(_Val) == __printable_property_values::_Yes_value;
}

[[nodiscard]] constexpr bool _Is_grapheme_extend(char32_t _Val) {
    
    
    return _Grapheme_Extend_property_data._Get_property_for_codepoint(_Val)
        == _Grapheme_Extend_property_values::_Grapheme_Extend_value;
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Write_escaped(_OutputIt _Out, basic_string_view<_CharT> _Value, char _Delim) {
    auto _First        = _Value.data();
    const auto _Last   = _First + _Value.size();
    const auto& _Codec = _Get_fmt_codec<_CharT>();

    ;
    *_Out++ = static_cast<_CharT>(_Delim);

    bool _Escape_grapheme_extend = true;

    char _Buffer[8];

    while (_First != _Last) {
        const auto _Ch = *_First;

        if (_Ch == static_cast<_CharT>('\t')) {
            _Out                    = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\t)", LR"(\t)")));
            _Escape_grapheme_extend = true;
            ++_First;
        } else if (_Ch == static_cast<_CharT>('\n')) {
            _Out                    = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\n)", LR"(\n)")));
            _Escape_grapheme_extend = true;
            ++_First;
        } else if (_Ch == static_cast<_CharT>('\r')) {
            _Out                    = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\r)", LR"(\r)")));
            _Escape_grapheme_extend = true;
            ++_First;
        } else if (_Ch == static_cast<_CharT>(_Delim)) {
            *_Out++                 = static_cast<_CharT>('\\');
            *_Out++                 = static_cast<_CharT>(_Delim);
            _Escape_grapheme_extend = true;
            ++_First;
        } else if (_Ch == static_cast<_CharT>('\\')) {
            _Out                    = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\\)", LR"(\\)")));
            _Escape_grapheme_extend = true;
            ++_First;
        } else {
            char32_t _Decoded_ch;
            const auto [_Next, _Is_usv] = _Codec._Decode(_First, _Last, _Decoded_ch);

            if (_Is_usv) {
                const bool _Needs_escape =
                    !_Is_printable(_Decoded_ch) || (_Escape_grapheme_extend && _Is_grapheme_extend(_Decoded_ch));

                if (_Needs_escape) {
                    _Out = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\u{)", LR"(\u{)")));

                    const auto [_End, _Ec] =
                        ::std:: to_chars(_Buffer, ::std:: end(_Buffer), static_cast<uint32_t>(_Decoded_ch), 16);
                    ;

                    _Out = _Widen_and_copy<_CharT>(_Buffer, _End, ::std:: move(_Out));

                    *_Out++                 = static_cast<_CharT>('}');
                    _Escape_grapheme_extend = true;
                } else {
                    _Out                    = ::std:: _Copy_unchecked(_First, _Next, ::std:: move(_Out));
                    _Escape_grapheme_extend = false;
                }

                _First = _Next;
            } else {
                for (; _First != _Next; ++_First) {
                    _Out = _Fmt_write(::std:: move(_Out), (_Choose_literal<_CharT>(R"(\x{)", LR"(\x{)")));

                    const auto [_End, _Ec] =
                        ::std:: to_chars(_Buffer, ::std:: end(_Buffer), static_cast<make_unsigned_t<_CharT>>(*_First), 16);
                    ;

                    _Out = _Widen_and_copy<_CharT>(_Buffer, _End, ::std:: move(_Out));

                    *_Out++ = static_cast<_CharT>('}');
                }
                _Escape_grapheme_extend = true;
            }
        }
    }

    *_Out++ = static_cast<_CharT>(_Delim);

    return ::std:: move(_Out);
}

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Write_escaped(
    _OutputIt _Out, basic_string_view<_CharT> _Value, _Basic_format_specs<_CharT> _Specs, char _Delim) {
    if (_Specs._Precision < 0 && _Specs._Width <= 0) {
        return _Write_escaped(::std:: move(_Out), _Value, _Delim);
    }

    basic_string<_CharT> _Temp;
    {
        _Fmt_iterator_buffer<back_insert_iterator<basic_string<_CharT>>, _CharT> _Buf(back_insert_iterator{_Temp});
        (void) _Write_escaped(back_insert_iterator<_Fmt_buffer<_CharT>>{_Buf}, _Value, _Delim);
    }

    int _Width          = _Specs._Precision;
    const _CharT* _Last = _Measure_string_prefix<_CharT>(_Temp, _Width);

    return _Write_aligned(::std:: move(_Out), _Width, _Specs, _Fmt_align::_Left, [&_Temp, _Last](_OutputIt _Out) {
        return _Fmt_write(::std:: move(_Out), basic_string_view<_CharT>{_Temp.data(), _Last});
    });
}
#line 3403 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

template <class _CharT, class _OutputIt>
[[nodiscard]] _OutputIt _Fmt_write(
    _OutputIt _Out, const basic_string_view<_CharT> _Value, const _Basic_format_specs<_CharT>& _Specs, _Lazy_locale) {
    ;
    ;
    ;
    ;


    if (_Specs._Type == '?') {
        return _Write_escaped(::std:: move(_Out), _Value, _Specs, '"');
    }
#line 3417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"

    if (_Specs._Precision < 0 && _Specs._Width <= 0) {
        return _Fmt_write(::std:: move(_Out), _Value);
    }

    int _Width          = _Specs._Precision;
    const _CharT* _Last = _Measure_string_prefix(_Value, _Width);

    return _Write_aligned(::std:: move(_Out), _Width, _Specs, _Fmt_align::_Left, [=](_OutputIt _Out) {
        return _Fmt_write(::std:: move(_Out), basic_string_view<_CharT>{_Value.data(), _Last});
    });
}





template <class _OutputIt, class _CharT>
struct _Default_arg_formatter {
    using _Context = basic_format_context<_OutputIt, _CharT>;

    _OutputIt _Out;
    basic_format_args<_Context> _Args;
    _Lazy_locale _Loc;

    template <class _Ty>
    _OutputIt operator()(_Ty _Val) && {
        return _Fmt_write<_CharT>(::std:: move(_Out), _Val);
    }

    _OutputIt operator()(basic_format_arg<_Context>::handle _Handle) && {
        basic_format_parse_context<_CharT> _Parse_ctx({});
        basic_format_context<_OutputIt, _CharT> _Format_ctx(::std:: move(_Out), _Args, _Loc);
        _Handle.format(_Parse_ctx, _Format_ctx);
        return _Format_ctx.out();
    }
};


template <class _OutputIt, class _CharT>
struct _Arg_formatter {
    using _Context = basic_format_context<_OutputIt, _CharT>;

    _Context* _Ctx                      = nullptr;
    _Basic_format_specs<_CharT>* _Specs = nullptr;

    _OutputIt operator()(basic_format_arg<_Context>::handle) {
        do { if (false) { } else { do { ; ::_invalid_parameter_noinfo_noreturn(); } while (false); } ; } while (false);
        ;
        return _Ctx->out();
    }

    template <class _Ty>
    _OutputIt operator()(_Ty _Val) {
        ;
        ;
        return _Fmt_write(_Ctx->out(), _Val, *_Specs, _Ctx->_Get_lazy_locale());
    }
};





template <class _Ty, class _ParseContext>
consteval _ParseContext::iterator _Compile_time_parse_format_specs(_ParseContext& _Pc) {
    using _CharT                = _ParseContext::char_type;
    using _Context              = basic_format_context<back_insert_iterator<_Fmt_buffer<_CharT>>, _CharT>;
    using _ArgTraits            = _Format_arg_traits<_Context>;
    using _FormattedTypeMapping = _ArgTraits::template _Storage_type<_Ty>;
    
    
    
    using _FormattedType = conditional_t<is_same_v<_FormattedTypeMapping, typename basic_format_arg<_Context>::handle>,
        _Ty, _FormattedTypeMapping>;
    formatter<_FormattedType, _CharT> _Formatter{};
    return _Formatter.parse(_Pc);
}


template <class _CharT, class... _Args>
struct _Format_checker {
    using _ParseContext = basic_format_parse_context<_CharT>;
    using _ParseFunc    = _ParseContext::iterator (*)(_ParseContext&);

    static constexpr size_t _Num_args = sizeof...(_Args);
    _ParseContext _Parse_context;
    _ParseFunc _Parse_funcs[_Num_args > 0 ? _Num_args : 1];

    consteval explicit _Format_checker(basic_string_view<_CharT> _Fmt) noexcept
        : _Parse_context(_Fmt, _Num_args), _Parse_funcs{&_Compile_time_parse_format_specs<_Args, _ParseContext>...} {}
    constexpr void _On_text(const _CharT*, const _CharT*) const noexcept {}
    constexpr void _On_replacement_field(size_t, const _CharT*) const noexcept {}
    constexpr const _CharT* _On_format_specs(const size_t _Id, const _CharT* _First, const _CharT*) {
        _Parse_context.advance_to(_Parse_context.begin() + (_First - _Parse_context.begin()._Unwrapped()));
        if (_Id < _Num_args) {
            auto _Iter = _Parse_funcs[_Id](_Parse_context); 
            return _Iter._Unwrapped();
        } else {
            return _First;
        }
    }
};


template <class _CharT>
struct _Format_handler {
    using _OutputIt = back_insert_iterator<_Fmt_buffer<_CharT>>;
    using _Context  = basic_format_context<_OutputIt, _CharT>;

    basic_format_parse_context<_CharT> _Parse_context;
    _Context _Ctx;

    explicit _Format_handler(_OutputIt _Out, basic_string_view<_CharT> _Str, basic_format_args<_Context> _Format_args)
        : _Parse_context(_Str), _Ctx(::std:: move(_Out), _Format_args) {}

    explicit _Format_handler(_OutputIt _Out, basic_string_view<_CharT> _Str, basic_format_args<_Context> _Format_args,
        const _Lazy_locale& _Loc)
        : _Parse_context(_Str), _Ctx(::std:: move(_Out), _Format_args, _Loc) {}

    void _On_text(const _CharT* _First, const _CharT* _Last) {
        _Ctx.advance_to(::std::ranges:: _Copy_unchecked(_First, _Last, _Ctx.out()).out);
    }

    void _On_replacement_field(const size_t _Id, const _CharT*) {
        auto _Arg = _Get_arg(_Ctx, _Id);
        _Ctx.advance_to(::std:: visit_format_arg(
            _Default_arg_formatter<_OutputIt, _CharT>{_Ctx.out(), _Ctx._Get_args(), _Ctx._Get_lazy_locale()}, _Arg));
    }

    const _CharT* _On_format_specs(const size_t _Id, const _CharT* _First, const _CharT* _Last) {
        _Parse_context.advance_to(_Parse_context.begin() + (_First - &*_Parse_context.begin()));
        auto _Arg = _Get_arg(_Ctx, _Id);
        if (_Arg._Active_state == _Basic_format_arg_type::_Custom_type) {
            _Arg._Custom_state.format(_Parse_context, _Ctx);
            return _Parse_context.begin()._Unwrapped();
        }

        _Basic_format_specs<_CharT> _Specs;
        _Specs_checker<_Specs_handler<basic_format_parse_context<_CharT>, _Context>> _Handler(
            _Specs_handler<basic_format_parse_context<_CharT>, _Context>{_Specs, _Parse_context, _Ctx},
            _Arg._Active_state);
        _First = _Parse_format_specs(_First, _Last, _Handler);
        if (_First == _Last || *_First != '}') {
            _Throw_format_error("Missing '}' in format string.");
        }

        _Ctx.advance_to(::std:: visit_format_arg(
            _Arg_formatter<_OutputIt, _CharT>{._Ctx = ::std:: addressof(_Ctx), ._Specs = ::std:: addressof(_Specs)}, _Arg));
        return _First;
    }
};
}



 template <class _Ty, class _CharT>
struct formatter {
    formatter()                           = delete;
    formatter(const formatter&)           = delete;
    formatter operator=(const formatter&) = delete;
};

inline namespace __p2286 {
template <class _Ty, class _CharT, _Basic_format_arg_type _ArgType>
struct _Formatter_base {
    using _Pc = basic_format_parse_context<_CharT>;

    constexpr _Pc::iterator parse(_Pc& _ParseCtx) {
        _Specs_checker<_Dynamic_specs_handler<_Pc>> _Handler(_Dynamic_specs_handler<_Pc>{_Specs, _ParseCtx}, _ArgType);
        const auto _It = _Parse_format_specs(_ParseCtx._Unchecked_begin(), _ParseCtx._Unchecked_end(), _Handler);
        if (_It != _ParseCtx._Unchecked_end() && *_It != '}') {
            _Throw_format_error("Missing '}' in format string.");
        }
        return _ParseCtx.begin() + (_It - _ParseCtx._Unchecked_begin());
    }

    template <class _FormatContext>
    _FormatContext::iterator format(const _Ty& _Val, _FormatContext& _FormatCtx) const {
        _Dynamic_format_specs<_CharT> _Format_specs = _Specs;
        if (_Specs._Dynamic_width_index >= 0) {
            _Format_specs._Width =
                _Get_dynamic_specs<_Width_checker>(_FormatCtx.arg(static_cast<size_t>(_Specs._Dynamic_width_index)));
        }

        if (_Specs._Dynamic_precision_index >= 0) {
            _Format_specs._Precision = _Get_dynamic_specs<_Precision_checker>(
                _FormatCtx.arg(static_cast<size_t>(_Specs._Dynamic_precision_index)));
        }

        return ::std:: visit_format_arg(
            _Arg_formatter<typename _FormatContext::iterator, _CharT>{
                ._Ctx = ::std:: addressof(_FormatCtx), ._Specs = ::std:: addressof(_Format_specs)},
            basic_format_arg<_FormatContext>::_Make_from(_Val));
    }

private:
    _Dynamic_format_specs<_CharT> _Specs;
};
}





template <_Format_supported_charT _CharT> struct formatter<int, _CharT> : _Formatter_base<int, _CharT, _Basic_format_arg_type::_Int_type> {};
template <_Format_supported_charT _CharT> struct formatter<unsigned int, _CharT> : _Formatter_base<unsigned int, _CharT, _Basic_format_arg_type::_UInt_type> {};
template <_Format_supported_charT _CharT> struct formatter<long long, _CharT> : _Formatter_base<long long, _CharT, _Basic_format_arg_type::_Long_long_type> {};
template <_Format_supported_charT _CharT> struct formatter<unsigned long long, _CharT> : _Formatter_base<unsigned long long, _CharT, _Basic_format_arg_type::_ULong_long_type> {};
template <_Format_supported_charT _CharT> struct formatter<bool, _CharT> : _Formatter_base<bool, _CharT, _Basic_format_arg_type::_Bool_type> {};
template <_Format_supported_charT _CharT> struct formatter<float, _CharT> : _Formatter_base<float, _CharT, _Basic_format_arg_type::_Float_type> {};
template <_Format_supported_charT _CharT> struct formatter<double, _CharT> : _Formatter_base<double, _CharT, _Basic_format_arg_type::_Double_type> {};
template <_Format_supported_charT _CharT> struct formatter<long double, _CharT> : _Formatter_base<long double, _CharT, _Basic_format_arg_type::_Long_double_type> {};
template <_Format_supported_charT _CharT> struct formatter<nullptr_t, _CharT> : _Formatter_base<nullptr_t, _CharT, _Basic_format_arg_type::_Pointer_type> {};
template <_Format_supported_charT _CharT> struct formatter<void*, _CharT> : _Formatter_base<void*, _CharT, _Basic_format_arg_type::_Pointer_type> {};
template <_Format_supported_charT _CharT> struct formatter<const void*, _CharT> : _Formatter_base<const void*, _CharT, _Basic_format_arg_type::_Pointer_type> {};
template <_Format_supported_charT _CharT> struct formatter<short, _CharT> : _Formatter_base<short, _CharT, _Basic_format_arg_type::_Int_type> {};
template <_Format_supported_charT _CharT> struct formatter<unsigned short, _CharT> : _Formatter_base<unsigned short, _CharT, _Basic_format_arg_type::_UInt_type> {};
template <_Format_supported_charT _CharT> struct formatter<long, _CharT> : _Formatter_base<long, _CharT, _Basic_format_arg_type::_Int_type> {};
template <_Format_supported_charT _CharT> struct formatter<unsigned long, _CharT> : _Formatter_base<unsigned long, _CharT, _Basic_format_arg_type::_UInt_type> {};
template <_Format_supported_charT _CharT> struct formatter<char, _CharT> : _Formatter_base<char, _CharT, _Basic_format_arg_type::_Char_type> {};
template <_Format_supported_charT _CharT> struct formatter<signed char, _CharT> : _Formatter_base<signed char, _CharT, _Basic_format_arg_type::_Int_type> {};
template <_Format_supported_charT _CharT> struct formatter<unsigned char, _CharT> : _Formatter_base<unsigned char, _CharT, _Basic_format_arg_type::_UInt_type> {};




template <>
struct formatter<wchar_t, wchar_t> : _Formatter_base<wchar_t, wchar_t, _Basic_format_arg_type::_Char_type> {};



template <_Format_supported_charT _CharT>
struct formatter<_CharT*, _CharT> : _Formatter_base<_CharT*, _CharT, _Basic_format_arg_type::_CString_type> {};

template <_Format_supported_charT _CharT>
struct formatter<const _CharT*, _CharT>
    : _Formatter_base<const _CharT*, _CharT, _Basic_format_arg_type::_CString_type> {};

template <_Format_supported_charT _CharT, size_t _Nx>
struct formatter<_CharT[_Nx], _CharT> : _Formatter_base<_CharT[_Nx], _CharT, _Basic_format_arg_type::_CString_type> {};

template <_Format_supported_charT _CharT, class _Traits, class _Allocator>
struct formatter<basic_string<_CharT, _Traits, _Allocator>, _CharT>
    : _Formatter_base<basic_string<_CharT, _Traits, _Allocator>, _CharT, _Basic_format_arg_type::_String_type> {};

template <_Format_supported_charT _CharT, class _Traits>
struct formatter<basic_string_view<_CharT, _Traits>, _CharT>
    : _Formatter_base<basic_string_view<_CharT, _Traits>, _CharT, _Basic_format_arg_type::_String_type> {};

 template <class _CharT, class... _Args>
struct basic_format_string {
public:
    template <class _Ty>
        requires convertible_to<const _Ty&, basic_string_view<_CharT>>
    consteval basic_format_string(const _Ty& _Str_val) : _Str(_Str_val) {
        if (_Is_execution_charset_self_synchronizing()) {
            _Parse_format_string(_Str, _Format_checker<_CharT, remove_cvref_t<_Args>...>{_Str});
        }
    }

    [[nodiscard]] constexpr basic_string_view<_CharT> get() const noexcept {
        return _Str;
    }

private:
    basic_string_view<_CharT> _Str;
};

 template <class... _Args>
using format_string = basic_format_string<char, type_identity_t<_Args>...>;

 template <class... _Args>
using wformat_string = basic_format_string<wchar_t, type_identity_t<_Args>...>;

 using format_args  = basic_format_args<format_context>;
 using wformat_args = basic_format_args<wformat_context>;

 template <class _Context = format_context, class... _Args>
[[nodiscard]] auto make_format_args(_Args&&... _Vals) {
    static_assert((_Formattable_with<remove_cvref_t<_Args>, _Context> && ...),
        "Cannot format an argument. To make type T formattable, provide a formatter<T> specialization. "
        "See N4950 [format.arg.store]/2 and [formatter.requirements].");
    return _Format_arg_store<_Context, _Args...>{_Vals...};
}

 template <class... _Args>
[[nodiscard]] auto make_wformat_args(_Args&&... _Vals) {
    static_assert((_Formattable_with<remove_cvref_t<_Args>, wformat_context> && ...),
        "Cannot format an argument. To make type T formattable, provide a formatter<T> specialization. "
        "See N4950 [format.arg.store]/2 and [formatter.requirements].");
    return _Format_arg_store<wformat_context, _Args...>{_Vals...};
}

inline namespace __p2286 {
 template <output_iterator<const char&> _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, const string_view _Fmt, const format_args _Args) {
    
    using _Dependent_char = decltype((void) _Out, char{});
    if constexpr (is_same_v<_OutputIt, _Fmt_it>) {
        _Format_handler<_Dependent_char> _Handler(_Out, _Fmt, _Args);
        _Parse_format_string(_Fmt, _Handler);
        return _Out;
    } else {
        _Fmt_iterator_buffer<_OutputIt, char> _Buf(::std:: move(_Out));
        _Format_handler<_Dependent_char> _Handler(_Fmt_it{_Buf}, _Fmt, _Args);
        _Parse_format_string(_Fmt, _Handler);
        return _Buf._Out();
    }
}

 template <output_iterator<const wchar_t&> _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, const wstring_view _Fmt, const wformat_args _Args) {
    
    using _Dependent_char = decltype((void) _Out, wchar_t{});
    if constexpr (is_same_v<_OutputIt, _Fmt_wit>) {
        _Format_handler<_Dependent_char> _Handler(_Out, _Fmt, _Args);
        _Parse_format_string(_Fmt, _Handler);
        return _Out;
    } else {
        _Fmt_iterator_buffer<_OutputIt, wchar_t> _Buf(::std:: move(_Out));
        _Format_handler<_Dependent_char> _Handler(_Fmt_wit{_Buf}, _Fmt, _Args);
        _Parse_format_string(_Fmt, _Handler);
        return _Buf._Out();
    }
}

 template <output_iterator<const char&> _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, const locale& _Loc, const string_view _Fmt, const format_args _Args) {
    
    using _Dependent_char = decltype((void) _Out, char{});
    if constexpr (is_same_v<_OutputIt, _Fmt_it>) {
        _Format_handler<_Dependent_char> _Handler(_Out, _Fmt, _Args, _Lazy_locale{_Loc});
        _Parse_format_string(_Fmt, _Handler);
        return _Out;
    } else {
        _Fmt_iterator_buffer<_OutputIt, char> _Buf(::std:: move(_Out));
        _Format_handler<_Dependent_char> _Handler(_Fmt_it{_Buf}, _Fmt, _Args, _Lazy_locale{_Loc});
        _Parse_format_string(_Fmt, _Handler);
        return _Buf._Out();
    }
}

 template <output_iterator<const wchar_t&> _OutputIt>
_OutputIt vformat_to(_OutputIt _Out, const locale& _Loc, const wstring_view _Fmt, const wformat_args _Args) {
    
    using _Dependent_char = decltype((void) _Out, wchar_t{});
    if constexpr (is_same_v<_OutputIt, _Fmt_wit>) {
        _Format_handler<_Dependent_char> _Handler(_Out, _Fmt, _Args, _Lazy_locale{_Loc});
        _Parse_format_string(_Fmt, _Handler);
        return _Out;
    } else {
        _Fmt_iterator_buffer<_OutputIt, wchar_t> _Buf(::std:: move(_Out));
        _Format_handler<_Dependent_char> _Handler(_Fmt_wit{_Buf}, _Fmt, _Args, _Lazy_locale{_Loc});
        _Parse_format_string(_Fmt, _Handler);
        return _Buf._Out();
    }
}

 template <output_iterator<const char&> _OutputIt, class... _Types>
_OutputIt format_to(_OutputIt _Out, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat_to(::std:: move(_Out), _Fmt.get(), ::std:: make_format_args(_Args...));
}

 template <output_iterator<const wchar_t&> _OutputIt, class... _Types>
_OutputIt format_to(_OutputIt _Out, const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat_to(::std:: move(_Out), _Fmt.get(), ::std:: make_wformat_args(_Args...));
}

 template <output_iterator<const char&> _OutputIt, class... _Types>
_OutputIt format_to(_OutputIt _Out, const locale& _Loc, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat_to(::std:: move(_Out), _Loc, _Fmt.get(), ::std:: make_format_args(_Args...));
}

 template <output_iterator<const wchar_t&> _OutputIt, class... _Types>
_OutputIt format_to(_OutputIt _Out, const locale& _Loc, const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat_to(::std:: move(_Out), _Loc, _Fmt.get(), ::std:: make_wformat_args(_Args...));
}

 template <int = 0> 
[[nodiscard]] string vformat(const string_view _Fmt, const format_args _Args) {
    string _Str;
    _Str.reserve(_Fmt.size() + _Args._Estimate_required_capacity());
    ::std:: vformat_to(back_insert_iterator{_Str}, _Fmt, _Args);
    return _Str;
}

 template <int = 0> 
[[nodiscard]] wstring vformat(const wstring_view _Fmt, const wformat_args _Args) {
    wstring _Str;
    _Str.reserve(_Fmt.size() + _Args._Estimate_required_capacity());
    ::std:: vformat_to(back_insert_iterator{_Str}, _Fmt, _Args);
    return _Str;
}

 template <int = 0> 
[[nodiscard]] string vformat(const locale& _Loc, const string_view _Fmt, const format_args _Args) {
    string _Str;
    _Str.reserve(_Fmt.size() + _Args._Estimate_required_capacity());
    ::std:: vformat_to(back_insert_iterator{_Str}, _Loc, _Fmt, _Args);
    return _Str;
}

 template <int = 0> 
[[nodiscard]] wstring vformat(const locale& _Loc, const wstring_view _Fmt, const wformat_args _Args) {
    wstring _Str;
    _Str.reserve(_Fmt.size() + _Args._Estimate_required_capacity());
    ::std:: vformat_to(back_insert_iterator{_Str}, _Loc, _Fmt, _Args);
    return _Str;
}

 template <class... _Types>
[[nodiscard]] string format(const format_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat(_Fmt.get(), ::std:: make_format_args(_Args...));
}

 template <class... _Types>
[[nodiscard]] wstring format(const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat(_Fmt.get(), ::std:: make_wformat_args(_Args...));
}

 template <class... _Types>
[[nodiscard]] string format(const locale& _Loc, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat(_Loc, _Fmt.get(), ::std:: make_format_args(_Args...));
}

 template <class... _Types>
[[nodiscard]] wstring format(const locale& _Loc, const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    return ::std:: vformat(_Loc, _Fmt.get(), ::std:: make_wformat_args(_Args...));
}
}

 template <class _OutputIt>
struct format_to_n_result {
    _OutputIt out;
    iter_difference_t<_OutputIt> size;
};

inline namespace __p2286 {
 template <output_iterator<const char&> _OutputIt, class... _Types>
format_to_n_result<_OutputIt> format_to_n(
    _OutputIt _Out, const iter_difference_t<_OutputIt> _Max, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_iterator_buffer<_OutputIt, char, _Fmt_fixed_buffer_traits> _Buf(::std:: move(_Out), _Max);
    ::std:: vformat_to(_Fmt_it{_Buf}, _Fmt.get(), ::std:: make_format_args(_Args...));
    return {.out = _Buf._Out(), .size = _Buf._Count()};
}

 template <output_iterator<const wchar_t&> _OutputIt, class... _Types>
format_to_n_result<_OutputIt> format_to_n(
    _OutputIt _Out, const iter_difference_t<_OutputIt> _Max, const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_iterator_buffer<_OutputIt, wchar_t, _Fmt_fixed_buffer_traits> _Buf(::std:: move(_Out), _Max);
    ::std:: vformat_to(_Fmt_wit{_Buf}, _Fmt.get(), ::std:: make_wformat_args(_Args...));
    return {.out = _Buf._Out(), .size = _Buf._Count()};
}

 template <output_iterator<const char&> _OutputIt, class... _Types>
format_to_n_result<_OutputIt> format_to_n(_OutputIt _Out, const iter_difference_t<_OutputIt> _Max, const locale& _Loc,
    const format_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_iterator_buffer<_OutputIt, char, _Fmt_fixed_buffer_traits> _Buf(::std:: move(_Out), _Max);
    ::std:: vformat_to(_Fmt_it{_Buf}, _Loc, _Fmt.get(), ::std:: make_format_args(_Args...));
    return {.out = _Buf._Out(), .size = _Buf._Count()};
}

 template <output_iterator<const wchar_t&> _OutputIt, class... _Types>
format_to_n_result<_OutputIt> format_to_n(_OutputIt _Out, const iter_difference_t<_OutputIt> _Max, const locale& _Loc,
    const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_iterator_buffer<_OutputIt, wchar_t, _Fmt_fixed_buffer_traits> _Buf(::std:: move(_Out), _Max);
    ::std:: vformat_to(_Fmt_wit{_Buf}, _Loc, _Fmt.get(), ::std:: make_wformat_args(_Args...));
    return {.out = _Buf._Out(), .size = _Buf._Count()};
}

 template <class... _Types>
[[nodiscard]] size_t formatted_size(const format_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_counting_buffer<char> _Buf;
    ::std:: vformat_to(_Fmt_it{_Buf}, _Fmt.get(), ::std:: make_format_args(_Args...));
    return _Buf._Count();
}

 template <class... _Types>
[[nodiscard]] size_t formatted_size(const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_counting_buffer<wchar_t> _Buf;
    ::std:: vformat_to(_Fmt_wit{_Buf}, _Fmt.get(), ::std:: make_wformat_args(_Args...));
    return _Buf._Count();
}

 template <class... _Types>
[[nodiscard]] size_t formatted_size(const locale& _Loc, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_counting_buffer<char> _Buf;
    ::std:: vformat_to(_Fmt_it{_Buf}, _Loc, _Fmt.get(), ::std:: make_format_args(_Args...));
    return _Buf._Count();
}

 template <class... _Types>
[[nodiscard]] size_t formatted_size(const locale& _Loc, const wformat_string<_Types...> _Fmt, _Types&&... _Args) {
    _Fmt_counting_buffer<wchar_t> _Buf;
    ::std:: vformat_to(_Fmt_wit{_Buf}, _Loc, _Fmt.get(), ::std:: make_wformat_args(_Args...));
    return _Buf._Count();
}
}


enum class _Add_newline : bool { _Nope, _Yes };

[[nodiscard]] inline string _Unescape_braces(const _Add_newline _Add_nl, const string_view _Old_str) {
    string _Unescaped_str;

    if (_Old_str.empty()) {
        if (_Add_nl == _Add_newline::_Yes) {
            _Unescaped_str.push_back('\n');
        }

        return _Unescaped_str;
    }

    size_t _Unescaped_str_expected_size = _Old_str.size();

    if (_Add_nl == _Add_newline::_Yes) {
        ++_Unescaped_str_expected_size;
    }

    _Unescaped_str.resize_and_overwrite(_Unescaped_str_expected_size, [_Add_nl, _Old_str](char* _Dest_ptr, size_t) {
        char _Prev_char           = _Old_str.front();
        size_t _Num_chars_written = 1;
        *_Dest_ptr++              = _Prev_char;

        for (const auto _Curr_char : _Old_str.substr(1)) {
            if ((_Curr_char == '{' && _Prev_char == '{') || (_Curr_char == '}' && _Prev_char == '}')) {
                _Prev_char = '\0';
            } else {
                *_Dest_ptr++ = _Curr_char;
                ++_Num_chars_written;

                _Prev_char = _Curr_char;
            }
        }

        if (_Add_nl == _Add_newline::_Yes) {
            *_Dest_ptr = '\n';
            ++_Num_chars_written;
        }

        return _Num_chars_written;
    });

    return _Unescaped_str;
}

template <class _CharT>
struct _Fill_align_and_width_specs { 
    int _Width               = -1;
    int _Dynamic_width_index = -1;
    _Fmt_align _Alignment    = _Fmt_align::_None;
    uint8_t _Fill_length     = 1;
    
    _CharT _Fill[4 / sizeof(_CharT)] = {' '};
};

template <class _CharT>
class _Fill_align_and_width_specs_setter {
public:
    constexpr explicit _Fill_align_and_width_specs_setter(
        _Fill_align_and_width_specs<_CharT>& _Specs_, basic_format_parse_context<_CharT>& _Parse_ctx_)
        : _Specs(_Specs_), _Parse_ctx(_Parse_ctx_) {}

    constexpr void _On_align(const _Fmt_align _Aln) {
        _Specs._Alignment = _Aln;
    }

    constexpr void _On_fill(const basic_string_view<_CharT> _Sv) {
        if (_Sv.size() > ::std:: size(_Specs._Fill)) {
            _Throw_format_error("Invalid fill (too long).");
        }

        const auto _Pos = ::std:: _Copy_unchecked(_Sv._Unchecked_begin(), _Sv._Unchecked_end(), _Specs._Fill);
        ::std:: fill(_Pos, ::std:: end(_Specs._Fill), _CharT{});
        _Specs._Fill_length = static_cast<uint8_t>(_Sv.size());
    }

    constexpr void _On_width(const int _Width) {
        _Specs._Width = _Width;
    }

    constexpr void _On_dynamic_width(const size_t _Arg_id) {
        _Parse_ctx.check_arg_id(_Arg_id);
        _Specs._Dynamic_width_index = _Verify_dynamic_arg_index_in_range(_Arg_id);
    }

    constexpr void _On_dynamic_width(_Auto_id_tag) {
        _Specs._Dynamic_width_index = _Verify_dynamic_arg_index_in_range(_Parse_ctx.next_arg_id());
    }

private:
    _Fill_align_and_width_specs<_CharT>& _Specs;
    basic_format_parse_context<_CharT>& _Parse_ctx;

    [[nodiscard]] static constexpr int _Verify_dynamic_arg_index_in_range(const size_t _Idx) {
        if (!::std:: in_range<int>(_Idx)) {
            _Throw_format_error("Dynamic width index is too large.");
        }

        return static_cast<int>(_Idx);
    }
};

template <class _CharT, class _Callbacks_type>
[[nodiscard]] constexpr const _CharT* _Parse_fill_align_and_width_specs(
    const _CharT* _Begin, const _CharT* _End, _Callbacks_type&& _Callbacks) {
    if (_Begin == _End || *_Begin == '}') {
        return _Begin;
    }

    _Begin = _Parse_align(_Begin, _End, _Callbacks);
    if (_Begin == _End) {
        return _Begin;
    }

    return _Parse_width(_Begin, _End, _Callbacks);
}

template <class _CharT>
struct _Fill_align_and_width_formatter {
public:
    [[nodiscard]] constexpr auto parse(basic_format_parse_context<_CharT>& _Parse_ctx) {
        _Fill_align_and_width_specs_setter<_CharT> _Callback{_Specs, _Parse_ctx};
        const auto _It =
            _Parse_fill_align_and_width_specs(_Parse_ctx._Unchecked_begin(), _Parse_ctx._Unchecked_end(), _Callback);
        if (_It != _Parse_ctx._Unchecked_end() && *_It != '}') {
            _Throw_format_error("Missing '}' in format string.");
        }

        return _Parse_ctx.begin() + (_It - _Parse_ctx._Unchecked_begin());
    }

    template <class _FormatContext, class _Func>
    [[nodiscard]] constexpr auto _Format(
        _FormatContext& _Format_ctx, const int _Width, _Fmt_align _Default_align, _Func&& _Fn) const {
        _Fill_align_and_width_specs _Format_specs = _Specs;
        if (_Specs._Dynamic_width_index >= 0) {
            _Format_specs._Width =
                _Get_dynamic_specs<_Width_checker>(_Format_ctx.arg(static_cast<size_t>(_Specs._Dynamic_width_index)));
        }

        return _Write_aligned(_Format_ctx.out(), _Width, _Format_specs, _Default_align, ::std:: forward<_Func>(_Fn));
    }

private:
    _Fill_align_and_width_specs<_CharT> _Specs;
};
#line 4066 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"




}



#pragma warning(pop)
#pragma pack(pop)

#line 4078 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
#line 4079 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
#line 4080 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\format"
#pragma external_header(pop)
#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
#pragma vtordisp(push, 2) 

 extern "C++" template <class _Elem, class _Traits>
class basic_ostream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = ostreambuf_iterator<_Elem, _Traits>;
    using _Nput  = num_put<_Elem, _Iter>;

    explicit  basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_ostream(_Uninitialized, bool _Addit = true) {
        if (_Addit) {
            this->_Addstd(this); 
        }
    }

protected:
     basic_ostream(basic_ostream&& _Right) noexcept(false) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_ostream&  operator=(basic_ostream&& _Right) noexcept  {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_ostream& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_ostream(const basic_ostream&)            = delete;
    basic_ostream&  operator=(const basic_ostream&) = delete;

     ~basic_ostream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base { 
    public:
         _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept { 
            const auto _Rdbuf = _Myostr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_ostream& _Myostr; 

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {
            if (!_Ostr.good()) {
                _Ok = false;
                return;
            }

            const auto _Tied = _Ostr.tie();
            if (!_Tied || _Tied == &_Ostr) {
                _Ok = true;
                return;
            }

            _Tied->flush();
            _Ok = _Ostr.good(); 
        }

        __pragma(warning(push)) __pragma(warning(disable : 4996))
         ~sentry() noexcept {


#line 117 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

#line 119 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
            const bool _Zero_uncaught_exceptions = ::std:: uncaught_exceptions() == 0;
#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

            if (_Zero_uncaught_exceptions) {
                this->_Myostr._Osfx();
            }
        }
        __pragma(warning(pop))

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&)            = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    
    bool  opfx() { 
        if (!this->good()) {
            return false;
        }

        const auto _Tied = _Myios::tie();
        if (!_Tied || _Myios::tie() == this) {
            return true;
        }

        _Tied->flush();
        return this->good();
    }

    
    void  osfx() noexcept { 
        _Osfx();
    }

    void  _Osfx() noexcept { 
        try {
        if (this->good() && this->flags() & ios_base::unitbuf) {
            if (_Myios::rdbuf()->pubsync() == -1) { 
                _Myios::setstate(ios_base::badbit);
            }
        }
        } catch (...) {
        }
    }




















    basic_ostream&  operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) {
        
        return _Pfn(*this);
    }

    basic_ostream&  operator<<(_Myios&(__cdecl* _Pfn)(_Myios&) ) {
        
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(ios_base&(__cdecl* _Pfn)(ios_base&) ) {
        
        _Pfn(*this);
        return *this;
    }

    basic_ostream&  operator<<(bool _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    
    
    
    

    
    

    basic_ostream&  operator<<(unsigned short _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac  = ::std:: use_facet<_Nput>(this->getloc());
            ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

            long _Tmp;
            if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {
                _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
            } else {
                _Tmp = static_cast<long>(_Val);
            }

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned int _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val))
                    .failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(unsigned long long _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(float _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(long double _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  operator<<(const void* _Val) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            const _Nput& _Nput_fac = ::std:: use_facet<_Nput>(this->getloc());

            try {
            if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }


    template <class = void> 
    basic_ostream& operator<<(const volatile void* _Val) {
        return *this << const_cast<const void*>(_Val);
    }
#line 472 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"


    template <class = void> 
    basic_ostream& operator<<(nullptr_t) { 
        return *this << "nullptr";
    }
#line 479 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

    basic_ostream&  operator<<(_Mysb* _Strbuf) { 
        ios_base::iostate _State = ios_base::goodbit;
        bool _Copied             = false;
        const sentry _Ok(*this);

        if (_Ok && _Strbuf) {
            for (int_type _Meta = _Traits::eof();; _Copied = true) { 
                try {
                _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                } catch (...) {
                _Myios::setstate(ios_base::failbit);
                throw;
                }

                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                    break; 
                }

                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta)))) {
                    _State |= ios_base::badbit; 
                    break;
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            }
        }

        this->width(0);
        int _Setstate_with;
        if (_Strbuf) {
            if (_Copied) {
                _Setstate_with = _State;
            } else {
                _Setstate_with = _State | ios_base::failbit;
            }
        } else {
            _Setstate_with = ios_base::badbit;
        }

        _Myios::setstate(_Setstate_with);
        return *this;
    }

    basic_ostream&  put(_Elem _Ch) { 
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  write(const _Elem* _Str, streamsize _Count) {
        
        ios_base::iostate _State = ios_base::goodbit;
        const sentry _Ok(*this);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else if (0 < _Count) { 
            try {
            if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count) {
                _State |= ios_base::badbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_ostream&  flush() { 
        const auto _Rdbuf = _Myios::rdbuf();
        if (_Rdbuf) { 
            const sentry _Ok(*this);

            if (_Ok) {
                ios_base::iostate _State = ios_base::goodbit;
                try {
                if (_Rdbuf->pubsync() == -1) {
                    _State |= ios_base::badbit; 
                }
                } catch (...) { _Myios::setstate(ios_base::badbit, true); }
                _Myios::setstate(_State);
            }
        }
        return *this;
    }

    basic_ostream&  seekp(pos_type _Pos) { 
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1) {
                _State |= ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            _Myios::setstate(_State);
        }

        return *this;
    }

    basic_ostream&  seekp(off_type _Off, ios_base::seekdir _Way) {
        
        const sentry _Ok(*this);

        if (!this->fail()) {
            ios_base::iostate _State = ios_base::goodbit;
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1) {
                _State |= ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
            _Myios::setstate(_State);
        }

        return *this;
    }

    pos_type  tellp() {
        const sentry _Ok(*this);

        if (!this->fail()) {
            try {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        return pos_type{off_type{-1}};
    }
};

#pragma vtordisp(pop) 



















































template class __declspec(dllimport) basic_ostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t>>;
#line 679 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"




#line 684 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val) { 
    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(:: strlen(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val) {
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val)))) {
                _State |= ios_base::badbit;
            }
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch) { 
    ios_base::iostate _State = ios_base::goodbit;
    const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

    if (_Ok) { 
        const ctype<_Elem>& _Ctype_fac = ::std:: use_facet<ctype<_Elem>>(_Ostr.getloc());
        streamsize _Pad                = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit
            && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch)))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {
    
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, char _Ch) {
    
    using _Elem = char;
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));
    streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
    const typename _Myos::sentry _Ok(_Ostr);

    if (!_Ok) {
        _State |= ios_base::badbit;
    } else { 
        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {
            _State |= ios_base::badbit;
        }

        if (_State == ios_base::goodbit) {
            for (; 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit; 
                    break;
                }
            }
        }

        _Ostr.width(0);
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch) { 
    using _Myos = basic_ostream<_Elem, _Traits>;

    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myos::sentry _Ok(_Ostr);

    if (_Ok) { 
        streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

        try {
        if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
            for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
                if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                    _State |= ios_base::badbit;
                }
            }
        }

        if (_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch))) {
            _State |= ios_base::badbit;
        }

        for (; _State == ios_base::goodbit && 0 < _Pad; --_Pad) { 
            if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                _State |= ios_base::badbit;
            }
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    }

    _Ostr.width(0);
    _Ostr.setstate(_State);
    return _Ostr;
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const signed char* _Val) {
    
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch) { 
    return _Ostr << static_cast<char>(_Ch);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val) {
    
    return _Ostr << reinterpret_cast<const char*>(_Val);
}

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch) {
    
    return _Ostr << static_cast<char>(_Ch);
}



 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char8_t*) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char8_t*) = delete;


 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char8_t) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char8_t) = delete;
#line 963 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"



 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, wchar_t) = delete;

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const wchar_t*) = delete;
#line 972 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char16_t) = delete;
 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, char32_t) = delete;

 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char16_t) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, char32_t) = delete;

 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char16_t*) = delete;
 template <class _Traits>
basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>&, const char32_t*) = delete;

 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char16_t*) = delete;
 template <class _Traits>
basic_ostream<wchar_t, _Traits>& operator<<(basic_ostream<wchar_t, _Traits>&, const char32_t*) = delete;
#line 993 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

template <class _Ostr, class _Ty, class = void>
struct _Can_stream_out : false_type {};

template <class _Ostr, class _Ty>
struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std:: declval<_Ostr&>() << ::std:: declval<const _Ty&>())>> : true_type {
};

 template <class _Ostr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Ostr*, ios_base*>, _Can_stream_out<_Ostr, _Ty>>, int> = 0>
_Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val) { 
    _Os << _Val;
    return ::std:: move(_Os);
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl endl(
    basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Ostr.widen('\n'));
    _Ostr.flush();
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.put(_Elem());
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr) { 
    _Ostr.flush();
    return _Ostr;
}



 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& emit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(true);
    }
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& noemit_on_flush(basic_ostream<_Elem, _Traits>& _Ostr) {
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        _Sync_buf_ptr->set_emit_on_sync(false);
    }
    return _Ostr;
}

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& flush_emit(basic_ostream<_Elem, _Traits>& _Ostr) {
    _Ostr.flush();
    const auto _Sync_buf_ptr = dynamic_cast<_Basic_syncbuf_impl<_Elem, _Traits>*>(_Ostr.rdbuf());
    if (_Sync_buf_ptr) {
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);
        if (!_Ok) {
            _State |= ios_base::badbit;
        } else {
            try {
            const bool _Emit_failed = !_Sync_buf_ptr->_Do_emit();
            if (_Emit_failed) {
                _State |= ios_base::badbit;
            }
            } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
        }
        _Ostr.setstate(_State);
    }
    return _Ostr;
}







#line 1077 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#line 1078 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

 template <class _Elem, class _Traits>
basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const error_code& _Errcode) {
    
    return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
}



template <int = 0>
ios_base::iostate _Print_noformat_nonunicode(ostream& _Ostr, const string_view _Str) {
    
    
    
    
    ios_base::iostate _State = ios_base::goodbit;

    try {
    const auto _Characters_written       = _Ostr.rdbuf()->sputn(_Str.data(), static_cast<streamsize>(_Str.size()));
    const bool _Was_insertion_successful = static_cast<size_t>(_Characters_written) == _Str.size();
    if (!_Was_insertion_successful) [[unlikely]] {
        _State |= ios_base::badbit;
    }
    } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }

    return _State;
}

template <int = 0>
void _Vprint_nonunicode_impl(
    const _Add_newline _Add_nl, ostream& _Ostr, const string_view _Fmt_str, const format_args _Fmt_args) {
    const ostream::sentry _Ok(_Ostr);
    ios_base::iostate _State = ios_base::goodbit;

    if (!_Ok) [[unlikely]] {
        _State |= ios_base::badbit;
    } else [[likely]] {
        
        
        string _Output_str = ::std:: vformat(_Ostr.getloc(), _Fmt_str, _Fmt_args);
        if (_Add_nl == _Add_newline::_Yes) {
            _Output_str.push_back('\n');
        }

        _State |= ::std:: _Print_noformat_nonunicode(_Ostr, _Output_str);
    }

    _Ostr.setstate(_State);
}

  template <class _Filebuf_type = filebuf>
ios_base::iostate _Print_noformat_unicode(ostream& _Ostr, const string_view _Str) {
    
    
    
    
    ios_base::iostate _State = ios_base::goodbit;

    
    
    
    
    
    
    streambuf* const _Streambuf = _Ostr.rdbuf();
    const auto _Filebuf         = dynamic_cast<_Filebuf_type*>(_Streambuf);

    
    if (_Filebuf == nullptr) {
        _State |= ::std:: _Print_noformat_nonunicode(_Ostr, _Str);
        return _State;
    }

    FILE* const _File_stream = _Filebuf->_Myfile;
    const __std_unicode_console_retrieval_result _Unicode_console_retrieval_result{
        __std_get_unicode_console_handle_from_file_stream(_File_stream)};

    
    bool _Is_unicode_console;

#pragma warning(push)
#pragma warning(disable : 4061) 
    switch (_Unicode_console_retrieval_result._Error) {
    case __std_win_error::_Success:
        _Is_unicode_console = true;
        break;

    case __std_win_error::_File_not_found:
        _Is_unicode_console = false;
        break;

    case __std_win_error::_Not_supported:
        [[unlikely]] return _State;

    default:
        [[unlikely]] return ios_base::failbit;
    }
#pragma warning(pop)

    if (_Is_unicode_console) {
        try {
        const bool _Was_flush_successful = _Ostr.rdbuf()->pubsync() != -1;
        if (!_Was_flush_successful) [[unlikely]] {
            _State |= ios_base::badbit;
            return _State;
        }

        const __std_win_error _Unicode_console_print_result =
            __std_print_to_unicode_console(_Unicode_console_retrieval_result._Console_handle, _Str.data(), _Str.size());
        if (_Unicode_console_print_result != __std_win_error::_Success) [[unlikely]] {
            _State |= ios_base::badbit;
        }
        } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
    } else {
        _State |= ::std:: _Print_noformat_nonunicode(_Ostr, _Str);
    }

    return _State;
}

template <int = 0>
void _Vprint_unicode_impl(
    const _Add_newline _Add_nl, ostream& _Ostr, const string_view _Fmt_str, const format_args _Fmt_args) {
    const ostream::sentry _Ok(_Ostr);
    ios_base::iostate _State = ios_base::goodbit;

    if (!_Ok) [[unlikely]] {
        _State |= ios_base::badbit;
    } else [[likely]] {
        
        
        string _Output_str = ::std:: vformat(_Ostr.getloc(), _Fmt_str, _Fmt_args);
        if (_Add_nl == _Add_newline::_Yes) {
            _Output_str.push_back('\n');
        }

        _State |= ::std:: _Print_noformat_unicode(_Ostr, _Output_str);
    }

    _Ostr.setstate(_State);
}

template <int = 0>
void _Print_noformat(ostream& _Ostr, const string_view _Str) {
    const ostream::sentry _Ok(_Ostr);
    ios_base::iostate _State = ios_base::goodbit;

    if (!_Ok) [[unlikely]] {
        _State |= ios_base::badbit;
    } else [[likely]] {
        if constexpr (::std:: _Is_ordinary_literal_encoding_utf8()) {
            _State |= ::std:: _Print_noformat_unicode(_Ostr, _Str);
        } else {
            _State |= ::std:: _Print_noformat_nonunicode(_Ostr, _Str);
        }
    }

    _Ostr.setstate(_State);
}

template <class... _Types>
void _Print_impl(const _Add_newline _Add_nl, ostream& _Ostr, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    constexpr bool _Has_format_args = sizeof...(_Types) > 0;

    
    

    if constexpr (_Has_format_args) {
        if constexpr (::std:: _Is_ordinary_literal_encoding_utf8()) {
            ::std:: _Vprint_unicode_impl(
                _Add_nl, _Ostr, _Fmt.get(), ::std:: make_format_args(::std:: forward<_Types>(_Args)...));
        } else {
            ::std:: _Vprint_nonunicode_impl(
                _Add_nl, _Ostr, _Fmt.get(), ::std:: make_format_args(::std:: forward<_Types>(_Args)...));
        }
    } else {
        const string _Unescaped_str{_Unescape_braces(_Add_nl, _Fmt.get())};
        ::std:: _Print_noformat(_Ostr, _Unescaped_str);
    }
}

 template <class... _Types>
void print(ostream& _Ostr, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    ::std:: _Print_impl(_Add_newline::_Nope, _Ostr, _Fmt, ::std:: forward<_Types>(_Args)...);
}

 template <class... _Types>
void println(ostream& _Ostr, const format_string<_Types...> _Fmt, _Types&&... _Args) {
    ::std:: _Print_impl(_Add_newline::_Yes, _Ostr, _Fmt, ::std:: forward<_Types>(_Args)...);
}

 template <int = 0> 
void vprint_unicode(ostream& _Ostr, const string_view _Fmt_str, const format_args _Fmt_args) {
    ::std:: _Vprint_unicode_impl(_Add_newline::_Nope, _Ostr, _Fmt_str, _Fmt_args);
}

 template <int = 0> 
void vprint_nonunicode(ostream& _Ostr, const string_view _Fmt_str, const format_args _Fmt_args) {
    ::std:: _Vprint_nonunicode_impl(_Add_newline::_Nope, _Ostr, _Fmt_str, _Fmt_args);
}









#line 1288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#line 1289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"

}



#pragma warning(pop)
#pragma pack(pop)
#line 1297 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#line 1298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\ostream"
#pragma external_header(pop)
#line 57 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"















#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Myvec>
class _Vector_const_iterator : public _Iterator_base {
public:

    using iterator_concept = contiguous_iterator_tag;
#line 32 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&;

    using _Tptr = typename _Myvec::pointer;

    constexpr _Vector_const_iterator() noexcept : _Ptr() {}

    constexpr _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this->_Adopt(_Pvector);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {






#line 54 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *_Ptr;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {






#line 66 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _Ptr;
    }

    constexpr _Vector_const_iterator& operator++() noexcept {





#line 77 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        ++_Ptr;
        return *this;
    }

    constexpr _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    constexpr _Vector_const_iterator& operator--() noexcept {





#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        --_Ptr;
        return *this;
    }

    constexpr _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    constexpr void _Verify_offset(const difference_type _Off) const noexcept {

        (void) _Off;











#line 121 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }

    constexpr _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    [[nodiscard]] constexpr _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _Vector_const_iterator operator+(
        const difference_type _Off, _Vector_const_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _Vector_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _Vector_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return _Unfancy(_Ptr) <=> _Unfancy(_Right._Ptr);
    }





















#line 192 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void _Compat(const _Vector_const_iterator& _Right) const noexcept {
        

        (void) _Right;


#line 200 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }







#line 209 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    [[nodiscard]] constexpr const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    constexpr void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));
    }

    _Tptr _Ptr; 
};


template <class _Myvec>
struct pointer_traits<_Vector_const_iterator<_Myvec>> {
    using pointer         = _Vector_const_iterator<_Myvec>;
    using element_type    = const typename pointer::value_type; 
    using difference_type = pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {












#line 244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return ::std:: to_address(_Iter._Ptr);
    }
};
#line 249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

template <class _Myvec>
class _Vector_iterator : public _Vector_const_iterator<_Myvec> {
public:
    using _Mybase = _Vector_const_iterator<_Myvec>;


    using iterator_concept = contiguous_iterator_tag;
#line 258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {






#line 278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return this->_Ptr;
    }

    constexpr _Vector_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    constexpr _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    constexpr _Vector_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    constexpr _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    constexpr _Vector_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] constexpr _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _Vector_iterator operator+(
        const difference_type _Off, _Vector_iterator _Next) noexcept {
        _Next += _Off;
        return _Next;
    }

    constexpr _Vector_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] constexpr _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return const_cast<reference>(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

    [[nodiscard]] constexpr value_type* _Unwrapped() const noexcept {
        return _Unfancy(this->_Ptr);
    }
};


template <class _Myvec>
struct pointer_traits<_Vector_iterator<_Myvec>> {
    using pointer         = _Vector_iterator<_Myvec>;
    using element_type    = pointer::value_type;
    using difference_type = pointer::difference_type;

    [[nodiscard]] static constexpr element_type* to_address(const pointer _Iter) noexcept {












#line 366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return ::std:: to_address(_Iter._Ptr);
    }
};
#line 371 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer>
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

struct _Value_init_tag { 
    explicit _Value_init_tag() = default;
};

template <class _Val_types>
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    constexpr _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

    constexpr _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

    constexpr void _Swap_val(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        swap(_Myfirst, _Right._Myfirst); 
        swap(_Mylast, _Right._Mylast); 
        swap(_Myend, _Right._Myend); 
    }

    constexpr void _Take_contents(_Vector_val& _Right) noexcept {
        this->_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; 
    pointer _Mylast; 
    pointer _Myend; 
};

template <class _Ptrty>
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    
    return _Ptr ? ::std:: addressof(*_Ptr) : nullptr;
}

template <class _Ty>
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { 
    return _Ptr;
}

 template <class _Ty, class _Alloc = allocator<_Ty>>
class vector { 
private:
    template <class>
    friend class _Vb_val;
    friend _Tidy_guard<vector>;

    using _Alty        = _Rebind_alloc_t<_Alloc, _Ty>;
    using _Alty_traits = allocator_traits<_Alty>;

public:
    static_assert(!1 || is_same_v<_Ty, typename _Alloc::value_type>,
        "vector<T, Allocator>" " requires that Allocator's value_type match " "T" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Ty>, "The C++ Standard forbids containers of non-object types "
                                    "because of [container.requirements].");

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&;
    using const_reference = const _Ty&;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:








































































































































#line 598 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    using _Scary_val = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>,
        _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer>>>;

public:
    using iterator               = _Vector_iterator<_Scary_val>;
    using const_iterator         = _Vector_const_iterator<_Scary_val>;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    constexpr vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
    }

    constexpr explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
    }

    constexpr explicit vector( const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count);
    }

    constexpr vector( const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Construct_n(_Count, ::std:: move(_UFirst), ::std:: move(_ULast));

        } else if constexpr (forward_iterator<_Iter>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Construct_n(_Count, ::std:: move(_UFirst), ::std:: move(_ULast));
#line 642 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        } else {
            auto&& _Alproxy = _Fake_alloc;
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard<vector> _Guard{this};

            _Append_uncounted_range(::std:: move(_UFirst), ::std:: move(_ULast));

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }

    constexpr vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());
    }


    template <_Container_compatible_range<_Ty> _Rng>
    constexpr vector(from_range_t, _Rng&& _Range, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        if constexpr (::std::ranges:: sized_range<_Rng> || ::std::ranges:: forward_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Construct_n(_Count, ::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        } else {
            auto&& _Alproxy = _Fake_alloc;
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_guard<vector> _Guard{this};

            _Append_uncounted_range(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));

            _Guard._Target = nullptr;
            _Proxy._Release();
        }
    }
#line 679 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    constexpr vector(const vector& _Right, const _Identity_t<_Alloc>& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        const auto& _Right_data = _Right._Mypair._Myval2;
        const auto _Count       = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
        _Construct_n(_Count, _Right_data._Myfirst, _Right_data._Mylast);
    }

    constexpr vector(vector&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t{}, ::std:: move(_Right._Getal()),
            ::std:: exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Mylast, nullptr),
            ::std:: exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(_Fake_alloc);
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }

    constexpr vector(vector&& _Right, const _Identity_t<_Alloc>& _Al_) noexcept(
        _Alty_traits::is_always_equal::value) 
        : _Mypair(_One_then_variadic_args_t{}, _Al_) {
        _Alty& _Al        = _Getal();
        auto&& _Alproxy   = _Fake_alloc;
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Al != _Right._Getal()) {
                const auto _Count = static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst);
                if (_Count != 0) {
                    _Buy_raw(_Count);
                    _Tidy_guard<vector> _Guard{this};
                    _My_data._Mylast =
                        _Uninitialized_move(_Right_data._Myfirst, _Right_data._Mylast, _My_data._Myfirst, _Al);

                    ;
                    _Guard._Target = nullptr;
                }
                _Proxy._Release();
                return;
            }
        }

        _My_data._Take_contents(_Right_data);
        _Proxy._Release();
    }

    constexpr vector& operator=(vector&& _Right) noexcept(
        _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        _Alty& _Al                = _Getal();
        _Alty& _Right_al          = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
        if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                _Move_assign_unequal_alloc(_Right);
                return *this;
            }
        }

        _Tidy();







#line 758 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        _Pocma(_Al, _Right_al);
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        return *this;
    }

    constexpr ~vector() noexcept {
        _Tidy();



#line 770 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }

private:
    template <class... _Valty>
    constexpr _Ty& _Emplace_one_at_back(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
        }

        return *_Emplace_reallocate(_Mylast, ::std:: forward<_Valty>(_Val)...);
    }

    template <class... _Valty>
    constexpr _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {
        
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;
        ; 
        if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
                          _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
            ;
            _Construct_in_place(*_Mylast, ::std:: forward<_Valty>(_Val)...);
        } else {
            ;
            _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), ::std:: forward<_Valty>(_Val)...);
            ;
        }

        _Orphan_range(_Mylast, _Mylast);
        _Ty& _Result = *_Mylast;
        ++_Mylast;

        return _Result;
    }

    template <class... _Valty>
    constexpr pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {
        
        _Alty& _Al        = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        ; 

        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        if (_Oldsize == max_size()) {
            _Xlength();
        }

        const size_type _Newsize = _Oldsize + 1;
        size_type _Newcapacity   = _Calculate_growth(_Newsize);

        const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;

        try {
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std:: forward<_Valty>(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;

        if (_Whereptr == _Mylast) { 
            if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
            } else {
                _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
            }
        } else { 
            _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);
            _Constructed_first = _Newvec;
            _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);
        }
        } catch (...) {
        _Destroy_range(_Constructed_first, _Constructed_last, _Al);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }

public:
    template <class... _Valty>
    constexpr decltype(auto) emplace_back(_Valty&&... _Val) {
        
        _Ty& _Result = _Emplace_one_at_back(::std:: forward<_Valty>(_Val)...);

        return _Result;


#line 868 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }

    constexpr void push_back(const _Ty& _Val) { 
        _Emplace_one_at_back(_Val);
    }

    constexpr void push_back(_Ty&& _Val) {
        
        _Emplace_one_at_back(::std:: move(_Val));
    }

private:
    template <class _Iter, class _Sent>
    constexpr void _Append_uncounted_range(_Iter _First, const _Sent _Last) {
        

        
        
        

        for (; _First != _Last; ++_First) {
            _Emplace_one_at_back(*_First);
        }
    }


    template <class _Iter>
    constexpr void _Append_counted_range(_Iter _First, const size_type _Count) {
        
        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const pointer _Constructed_last = _Newvec + _Oldsize + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Uninitialized_copy_n(::std:: move(_First), _Count, _Newvec + _Oldsize, _Al);
            _Constructed_first = _Newvec + _Oldsize;

            if (_Count == 1) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
            }
            } catch (...) {
            _Destroy_range(_Constructed_first, _Constructed_last, _Al);
            _Al.deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
                 

            ;
            _Mylast = _Uninitialized_copy_n(::std:: move(_First), _Count, _Oldlast, _Al);
            ;

            _Orphan_range(_Oldlast, _Oldlast);
        }
    }
#line 951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

public:

    template <_Container_compatible_range<_Ty> _Rng>
    constexpr void append_range(_Rng&& _Range) {
        if constexpr (::std::ranges:: forward_range<_Rng> || ::std::ranges:: sized_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Append_counted_range(::std::ranges:: _Ubegin(_Range), _Count);
        } else {
            _Append_uncounted_range(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
    }
#line 965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    template <class... _Valty>
    constexpr iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;




#line 977 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { 
                _Emplace_back_with_unused_capacity(::std:: forward<_Valty>(_Val)...);
            } else {
                auto& _Al = _Getal();
                _Alloc_temporary2<_Alty> _Obj(_Al, ::std:: forward<_Valty>(_Val)...); 
                
                _Orphan_range(_Whereptr, _Oldlast);
                ;
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), ::std:: move(_Oldlast[-1]));
                ;
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = ::std:: move(_Obj._Get_value());
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std:: forward<_Valty>(_Val)...));
    }

    constexpr iterator insert(const_iterator _Where, const _Ty& _Val) { 
        return emplace(_Where, _Val);
    }

    constexpr iterator insert(const_iterator _Where, _Ty&& _Val) { 
        return emplace(_Where, ::std:: move(_Val));
    }

    constexpr iterator insert(const_iterator _Where,  const size_type _Count, const _Ty& _Val) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;



#line 1022 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        const auto _Whereoff        = static_cast<size_type>(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 && _Whereptr == _Oldlast;
        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Uninitialized_fill_n(_Newvec + _Whereoff, _Count, _Val, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }
            } catch (...) {
            _Destroy_range(_Constructed_first, _Constructed_last, _Al);
            _Al.deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { 
            _Emplace_back_with_unused_capacity(_Val);
        } else { 
            const _Alloc_temporary2<_Alty> _Tmp_storage(_Al, _Val); 
            const auto& _Tmp              = _Tmp_storage._Get_value();
            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            ;
            if (_Count > _Affected_elements) { 
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Count - _Affected_elements, _Tmp, _Al);
                _Mylast = _Uninitialized_move(_Whereptr, _Oldlast, _Mylast, _Al);
                ::std:: fill(_Whereptr, _Oldlast, _Tmp);
            } else { 
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                ::std:: fill_n(_Whereptr, _Count, _Tmp);
            }
            ;
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template <class _Iter, class _Sent>
    constexpr void _Insert_uncounted_range(const_iterator _Where, _Iter _First, _Sent _Last) {
        
        if (_First == _Last) {
            return; 
        }

        auto& _My_data       = _Mypair._Myval2;
        pointer& _Myfirst    = _My_data._Myfirst;
        pointer& _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

        _Append_uncounted_range(::std:: move(_First), ::std:: move(_Last));

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        ::std:: rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template <class _Iter>
    constexpr void _Insert_counted_range(const_iterator _Where, _Iter _First, const size_type _Count) {
        
        const pointer _Whereptr = _Where._Ptr;

        auto& _Al        = _Getal();
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

        if (_Count == 0) { 
        } else if (_Count > _Unused_capacity) { 
            const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

            if (_Count > max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + _Count;
            size_type _Newcapacity   = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);
            const auto _Whereoff            = static_cast<size_type>(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            try {
            _Uninitialized_copy_n(::std:: move(_First), _Count, _Newvec + _Whereoff, _Al);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 && _Whereptr == _Oldlast) { 
                if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
                    _Uninitialized_move(_Oldfirst, _Oldlast, _Newvec, _Al);
                } else {
                    _Uninitialized_copy(_Oldfirst, _Oldlast, _Newvec, _Al);
                }
            } else { 
                _Uninitialized_move(_Oldfirst, _Whereptr, _Newvec, _Al);
                _Constructed_first = _Newvec;
                _Uninitialized_move(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count, _Al);
            }
            } catch (...) {
            _Destroy_range(_Constructed_first, _Constructed_last, _Al);
            _Al.deallocate(_Newvec, _Newcapacity);
            throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { 
                 
                 

            const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

            ;
            if (_Count < _Affected_elements) { 
                _Mylast = _Uninitialized_move(_Oldlast - _Count, _Oldlast, _Oldlast, _Al);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _Destroy_range(_Whereptr, _Whereptr + _Count, _Al);

                try {
                _Uninitialized_copy_n(::std:: move(_First), _Count, _Whereptr, _Al);
                } catch (...) {
                

                try {
                _Uninitialized_move(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr, _Al);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy_range(_Whereptr + _Count, _Mylast, _Al);
                _Mylast = _Whereptr;
                throw;
                }

                ::std:: _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                _Destroy_range(_Oldlast, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            } else { 
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = _Uninitialized_move(_Whereptr, _Oldlast, _Relocated, _Al);
                _Destroy_range(_Whereptr, _Oldlast, _Al);

                try {
                _Uninitialized_copy_n(::std:: move(_First), _Count, _Whereptr, _Al);
                } catch (...) {
                

                try {
                _Uninitialized_move(_Relocated, _Mylast, _Whereptr, _Al);
                } catch (...) {
                
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Whereptr;
                throw;
                }

                _Destroy_range(_Relocated, _Mylast, _Al);
                _Mylast = _Oldlast;
                throw;
                }
            }

            _Orphan_range(_Whereptr, _Oldlast);
            ;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;




#line 1233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        _Adl_verify_range(_First, _Last);
        auto _UFirst         = _Get_unwrapped(_First);
        auto _ULast          = _Get_unwrapped(_Last);
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Insert_counted_range(_Where, _UFirst, _Count);

        } else if constexpr (forward_iterator<_Iter>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Insert_counted_range(_Where, _UFirst, _Count);
#line 1248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        } else {
            _Insert_uncounted_range(_Where, _UFirst, _ULast);
        }
        return _Make_iterator_offset(_Whereoff);
    }


    template <_Container_compatible_range<_Ty> _Rng>
    constexpr iterator insert_range(const_iterator _Where, _Rng&& _Range) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;




#line 1265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);

        if constexpr (::std::ranges:: forward_range<_Rng> || ::std::ranges:: sized_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Insert_counted_range(_Where, ::std::ranges:: _Ubegin(_Range), _Count);
        } else {
            _Insert_uncounted_range(_Where, ::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
        return _Make_iterator_offset(_Whereoff);
    }
#line 1277 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist) {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;




#line 1287 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);

        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Insert_counted_range(_Where, _Ilist.begin(), _Count);
        return _Make_iterator_offset(_Whereoff);
    }

    constexpr void assign( const size_type _Newsize, const _Ty& _Val) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;










#line 1311 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        constexpr bool _Nothrow_construct =
            conjunction_v<is_nothrow_copy_constructible<_Ty>, _Uses_default_construct<_Alloc, _Ty*, const _Ty&>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) { 
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
                ;
            } else {
                ;
                _Mylast = _Uninitialized_fill_n(_Myfirst, _Newsize, _Val, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            ::std:: fill(_Myfirst, _Mylast, _Val);
            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_fill_n(_Mylast, _Newsize - _Oldsize, _Val, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: fill(_Myfirst, _Newlast, _Val);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

private:
    template <class _Iter, class _Sent>
    constexpr void _Assign_uncounted_range(_Iter _First, _Sent _Last) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;
        for (; _First != _Last && _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        
        
        
        

        
        _Destroy_range(_Next, _Mylast, _Getal());
        ; 
        _Mylast = _Next;

        _Append_uncounted_range(::std:: move(_First), ::std:: move(_Last));
    }

    template <class _Iter>
    constexpr void _Assign_counted_range(_Iter _First, const size_type _Newsize) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
            _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_copy_n(::std:: move(_First), _Newsize, _Myfirst, _Al);
                ;
            } else {
                ;
                _Mylast = _Uninitialized_copy_n(::std:: move(_First), _Newsize, _Myfirst, _Al);
            }
            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            bool _Copied = false;
            if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {

                if (!::std:: is_constant_evaluated())
#line 1411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
                {
                    _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);
                    _First += _Oldsize;
                    _Copied = true;
                }
            }

            if (!_Copied) {
                for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
                    *_Mid = *_First;
                }
            }

            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = _Uninitialized_copy_n(::std:: move(_First), _Newsize - _Oldsize, _Mylast, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_copy_n(::std:: move(_First), _Newsize - _Oldsize, _Mylast, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Copy_n_unchecked4(::std:: move(_First), _Newsize, _Myfirst);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

public:
    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr void assign(_Iter _First, _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast  = _Get_unwrapped(_Last);
        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Assign_counted_range(_UFirst, _Count);

        } else if constexpr (forward_iterator<_Iter>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Assign_counted_range(_UFirst, _Count);
#line 1457 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        } else {
            _Assign_uncounted_range(_UFirst, _ULast);
        }
    }


    template <_Container_compatible_range<_Ty> _Rng>
    constexpr void assign_range(_Rng&& _Range) {
        if constexpr (::std::ranges:: sized_range<_Rng> || ::std::ranges:: forward_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Assign_counted_range(::std::ranges:: _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
    }
#line 1474 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void assign(const initializer_list<_Ty> _Ilist) {
        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
    }

    constexpr vector& operator=(const vector& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al       = _Getal();
        auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alty>) {
            if (_Al != _Right_al) {
                _Tidy();
                _Mypair._Myval2._Reload_proxy(_Fake_alloc, _Fake_alloc);
            }
        }

        _Pocca(_Al, _Right_al);
        auto& _Right_data = _Right._Mypair._Myval2;
        _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

        return *this;
    }

    constexpr vector& operator=(initializer_list<_Ty> _Ilist) {
        const auto _Count = _Convert_size<size_type>(_Ilist.size());
        _Assign_counted_range(_Ilist.begin(), _Count);
        return *this;
    }

private:
    template <class _Ty2>
    constexpr void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {
        if (_Newsize > max_size()) {
            _Xlength();
        }

        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);
        size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Allocate_at_least_helper(_Al, _Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;

        try {
        if constexpr (is_same_v<_Ty2, _Ty>) {
            _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
        } else {
            ;
            _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);
        }

        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }
        } catch (...) {
        _Destroy_range(_Appended_first, _Appended_last, _Al);
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template <class _Ty2>
    constexpr void _Resize(const size_type _Newsize, const _Ty2& _Val) {
        
        auto& _Al           = _Getal();
        auto& _My_data      = _Mypair._Myval2;
        pointer& _Myfirst   = _My_data._Myfirst;
        pointer& _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize < _Oldsize) { 
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize > _Oldsize) { 
            const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
            if (_Newsize > _Oldcapacity) { 
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            ;
            const pointer _Oldlast = _Mylast;
            if constexpr (is_same_v<_Ty2, _Ty>) {
                _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);
            }
            ;
            _Orphan_range(_Oldlast, _Oldlast);
        }

        
    }

public:
    constexpr void resize( const size_type _Newsize) {
        
        _Resize(_Newsize, _Value_init_tag{});
    }

    constexpr void resize( const size_type _Newsize, const _Ty& _Val) {
        
        _Resize(_Newsize, _Val);
    }

private:
    enum class _Reallocation_policy { _At_least, _Exactly };

    template <_Reallocation_policy _Policy>
    constexpr void _Reallocate(size_type& _Newcapacity) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

        pointer _Newvec;
        if constexpr (_Policy == _Reallocation_policy::_At_least) {
            _Newvec = _Allocate_at_least_helper(_Al, _Newcapacity);
        } else {
            ;
            _Newvec = _Al.allocate(_Newcapacity);
        }

        try {
        if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
            _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
        } else {
            _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
        }
        } catch (...) {
        _Al.deallocate(_Newvec, _Newcapacity);
        throw;
        }

        _Change_array(_Newvec, _Size, _Newcapacity);
    }



















#line 1652 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;




#line 1664 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (_Newsize > max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    constexpr void reserve( size_type _Newcapacity) {
        
        if (_Newcapacity > capacity()) { 
            if (_Newcapacity > max_size()) {
                _Xlength();
            }

            _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
        }
    }

    constexpr void shrink_to_fit() { 
        auto& _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { 
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                size_type _Newcapacity = static_cast<size_type>(_Oldlast - _Oldfirst);
                _Reallocate<_Reallocation_policy::_Exactly>(_Newcapacity);
            }
        }
    }

    constexpr void pop_back() noexcept  {
        auto& _My_data   = _Mypair._Myval2;
        pointer& _Mylast = _My_data._Mylast;



#line 1717 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        ;
        --_Mylast;
    }

    constexpr iterator erase(const_iterator _Where) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Whereptr = _Where._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;





#line 1735 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        _Orphan_range(_Whereptr, _Mylast);
        ::std:: _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        ;
        --_Mylast;
        return iterator(_Whereptr, ::std:: addressof(_My_data));
    }

    constexpr iterator erase(const_iterator _First, const_iterator _Last) noexcept(
        is_nothrow_move_assignable_v<value_type>)  {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto& _My_data          = _Mypair._Myval2;
        pointer& _Mylast        = _My_data._Mylast;





#line 1756 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (_Firstptr != _Lastptr) { 
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = ::std:: _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy_range(_Newlast, _Mylast, _Getal());
            ; 
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, ::std:: addressof(_My_data));
    }

    constexpr void clear() noexcept { 
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        if (_Myfirst == _Mylast) { 
            
            
            
            return;
        }

        _My_data._Orphan_all();
        _Destroy_range(_Myfirst, _Mylast, _Getal());
        ; 
        _Mylast = _Myfirst;
    }

    constexpr void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    [[nodiscard]] constexpr _Ty* data() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] constexpr const _Ty* data() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    [[nodiscard]] constexpr iterator begin() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] constexpr const_iterator begin() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, ::std:: addressof(_My_data));
    }

    [[nodiscard]] constexpr iterator end() noexcept {
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, ::std:: addressof(_My_data));
    }

    [[nodiscard]] constexpr reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] constexpr reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] constexpr pointer _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] constexpr const_pointer _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    [[nodiscard]] constexpr pointer _Unchecked_end() noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard]] constexpr const_pointer _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Mylast;
    }

    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] constexpr bool empty() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        return (::std:: min)(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
    }

    [[nodiscard]] constexpr size_type capacity() const noexcept {
        auto& _My_data = _Mypair._Myval2;
        return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);
    }

    [[nodiscard]] constexpr _Ty& operator[](const size_type _Pos) noexcept  {
        auto& _My_data = _Mypair._Myval2;



#line 1896 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] constexpr const _Ty& operator[](const size_type _Pos) const noexcept  {
        auto& _My_data = _Mypair._Myval2;



#line 1906 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] constexpr _Ty& at(const size_type _Pos) {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] constexpr const _Ty& at(const size_type _Pos) const {
        auto& _My_data = _Mypair._Myval2;
        if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    [[nodiscard]] constexpr _Ty& front() noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1933 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] constexpr const _Ty& front() const noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1942 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *_My_data._Myfirst;
    }

    [[nodiscard]] constexpr _Ty& back() noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1951 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] constexpr const _Ty& back() const noexcept  {
        auto& _My_data = _Mypair._Myval2;


#line 1960 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _My_data._Mylast[-1];
    }

    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

private:
    constexpr size_type _Calculate_growth(const size_type _Newsize) const {
        
        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();

        if (_Oldcapacity > _Max - _Oldcapacity / 2) {
            return _Max; 
        }

        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

        if (_Geometric < _Newsize) {
            return _Newsize; 
        }

        return _Geometric; 
    }

    constexpr void _Buy_raw(size_type _Newcapacity) {
        
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        ; 
        ;

        const pointer _Newvec = _Allocate_at_least_helper(_Getal(), _Newcapacity);
        _Myfirst              = _Newvec;
        _Mylast               = _Newvec;
        _Myend                = _Newvec + _Newcapacity;
    }

    constexpr void _Buy_nonzero(const size_type _Newcapacity) {
        









        if (_Newcapacity > max_size()) {
            _Xlength();
        }

        _Buy_raw(_Newcapacity);
    }

    constexpr void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {
        
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
        }

        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;
        ;
    }

    constexpr void _Tidy() noexcept { 
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;
        pointer& _Myend   = _My_data._Myend;

        _My_data._Orphan_all();

        if (_Myfirst) { 
            _Destroy_range(_Myfirst, _Mylast, _Al);
            ;
            _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }
    }

    template <class... _Valty>
    constexpr void _Construct_n( const size_type _Count, _Valty&&... _Val) {
        
        
        
        
        auto& _Al       = _Getal();
        auto&& _Alproxy = _Fake_alloc;
        auto& _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard<vector> _Guard{this};
            if constexpr (sizeof...(_Val) == 0) {
                _My_data._Mylast = _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
            } else if constexpr (sizeof...(_Val) == 1) {
                ;
                _My_data._Mylast = _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
            } else if constexpr (sizeof...(_Val) == 2) {
                _My_data._Mylast = _Uninitialized_copy(::std:: forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);
            } else {
                static_assert(_Always_false<_Ty>, "Should be unreachable");
            }
            ;
            _Guard._Target = nullptr;
        }

        _Proxy._Release();
    }

    constexpr void _Move_assign_unequal_alloc(vector& _Right) {
        auto& _Al         = _Getal();
        auto& _My_data    = _Mypair._Myval2;
        auto& _Right_data = _Right._Mypair._Myval2;

        const pointer _First = _Right_data._Myfirst;
        const pointer _Last  = _Right_data._Mylast;
        const auto _Newsize  = static_cast<size_type>(_Last - _First);

        pointer& _Myfirst = _My_data._Myfirst;
        pointer& _Mylast  = _My_data._Mylast;

        constexpr bool _Nothrow_construct =
            conjunction_v<is_nothrow_move_constructible<_Ty>, _Uses_default_construct<_Alloc, _Ty*, _Ty>>;

        _My_data._Orphan_all();
        const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
        if (_Newsize > _Oldcapacity) {
            _Clear_and_reserve_geometric(_Newsize);
            if constexpr (_Nothrow_construct) {
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
                ;
            } else {
                ;
                _Mylast = _Uninitialized_move(_First, _Last, _Myfirst, _Al);
            }

            return;
        }

        const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
        if (_Newsize > _Oldsize) {
            const pointer _Mid = _First + _Oldsize;
            ::std:: _Move_unchecked(_First, _Mid, _Myfirst);

            if constexpr (_Nothrow_construct) {
                ;
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
            } else {
                ;
                _Mylast = _Uninitialized_move(_Mid, _Last, _Mylast, _Al);
                ;
            }
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            ::std:: _Move_unchecked(_First, _Last, _Myfirst);
            _Destroy_range(_Newlast, _Mylast, _Al);
            ;
            _Mylast = _Newlast;
        }
    }

    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }
































#line 2185 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    constexpr void _Orphan_range(pointer, pointer) const {}
#line 2187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    [[nodiscard]] constexpr _Alty& _Getal() noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr const _Alty& _Getal() const noexcept {
        return _Mypair._Get_first();
    }

    [[nodiscard]] constexpr iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, ::std:: addressof(_Mypair._Myval2));
    }

    [[nodiscard]] constexpr iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        
        auto& _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, ::std:: addressof(_My_data));
    }

    _Compressed_pair<_Alty, _Scary_val> _Mypair;
};


template <class _Iter, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
vector(_Iter, _Iter, _Alloc = _Alloc()) -> vector<_Iter_value_t<_Iter>, _Alloc>;
#line 2214 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"


template <::std::ranges:: input_range _Rng, class _Alloc = allocator<::std::ranges:: range_value_t<_Rng>>,
    enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
vector(from_range_t, _Rng&&, _Alloc = _Alloc()) -> vector<::std::ranges:: range_value_t<_Rng>, _Alloc>;
#line 2220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

template <class _Alloc>
class vector<bool, _Alloc>;

using _Vbase = unsigned int; 

inline constexpr int _VBITS = 8 * sizeof(_Vbase); 

 template <class _Ty, class _Alloc>
[[nodiscard]] constexpr bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v<_Ty, bool>) {
        return ::std:: equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}






#line 2248 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
















template <class _Ret>
struct _Vbase_compare_three_way {
    [[nodiscard]] constexpr _Ret operator()(const _Vbase _Left, const _Vbase _Right) const noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { 

            return strong_ordering::equal;


#line 2275 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); 
        ; 

        const _Vbase _Mask = _Vbase{1} << _Bit_index; 

        

        return (_Left & _Mask) == 0 ? strong_ordering::less : strong_ordering::greater;


#line 2288 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }
};


 template <class _Ty, class _Alloc>
[[nodiscard]] constexpr _Synth_three_way_result<_Ty> operator<=>(
    const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right) {
    if constexpr (is_same_v<_Ty, bool>) {
        
        const auto _Min_word_size = (::std:: min)(_Left._Myvec.size(), _Right._Myvec.size());
        const auto _Left_words    = _Left._Myvec._Unchecked_begin();
        const auto _Right_words   = _Right._Myvec._Unchecked_begin();

        using _Comp = _Vbase_compare_three_way<strong_ordering>;

        const strong_ordering _Word_comparison = ::std:: lexicographical_compare_three_way(
            _Left_words, _Left_words + _Min_word_size, _Right_words, _Right_words + _Min_word_size, _Comp{});

        if (_Word_comparison != 0) {
            return _Word_comparison;
        }

        return _Left.size() <=> _Right.size();
    } else {
        return ::std:: lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end(),
            _Right._Unchecked_begin(), _Right._Unchecked_end(), _Synth_three_way{});
    }
}










































#line 2359 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

 template <class _Ty, class _Alloc>
constexpr void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}


 template <class _Ty, class _Alloc, class _Uty>
constexpr vector<_Ty, _Alloc>::size_type erase(vector<_Ty, _Alloc>& _Cont, const _Uty& _Val) {
    return _Erase_remove(_Cont, _Val);
}

 template <class _Ty, class _Alloc, class _Pr>
constexpr vector<_Ty, _Alloc>::size_type erase_if(vector<_Ty, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_remove_if(_Cont, _Pass_fn(_Pred));
}
#line 2376 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

template <class _Alloc0>
struct _Wrap_alloc { 
    using _Alloc = _Alloc0;
};

template <class _Alvbase_wrapped>
class _Vb_iter_base : public _Iterator_base {
    
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits<_Alvbase>::size_type;
    using _Difference_type = typename allocator_traits<_Alvbase>::difference_type;
    using _Mycont          = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

    static constexpr _Difference_type _VBITS_DIFF = _VBITS;

    constexpr _Vb_iter_base() = default;

    constexpr _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this->_Adopt(_Mypvbool);
    }

    constexpr void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }





#line 2411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

template <class _Alvbase_wrapped>
class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped> {
    
private:
    using _Mybase          = _Vb_iter_base<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    
    constexpr _Vb_reference() = default;

public:
    constexpr _Vb_reference(const _Vb_reference&) = default;

    constexpr _Vb_reference(const _Mybase& _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    constexpr _Vb_reference& operator=(const _Vb_reference& _Right) noexcept {
        return *this = static_cast<bool>(_Right);
    }

    constexpr _Vb_reference& operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }


    constexpr const _Vb_reference& operator=(bool _Val) const noexcept {
        if (_Val) {
            *const_cast<_Vbase*>(_Getptr()) |= _Mask();
        } else {
            *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
        }

        return *this;
    }
#line 2458 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void flip() noexcept {
        *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
    }

    constexpr operator bool() const noexcept {
        return (*_Getptr() & _Mask()) != 0;
    }

    constexpr const _Vbase* _Getptr() const noexcept {





#line 2474 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return this->_Myptr;
    }

    friend constexpr void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    constexpr _Vbase _Mask() const noexcept {
        return static_cast<_Vbase>(1) << this->_Myoff;
    }
};

template <class _Alvbase_wrapped>
class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped> {
private:
    using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

public:
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;
    using _Size_type       = typename _Mybase::_Size_type;
    using _Reft            = _Vb_reference<_Alvbase_wrapped>;
    using const_reference  = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    constexpr _Vb_const_iterator() = default;

    constexpr _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    [[nodiscard]] constexpr const_reference operator*() const noexcept {





#line 2520 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _Reft(*this);
    }

    constexpr _Vb_const_iterator& operator++() noexcept {
        _Inc();
        return *this;
    }

    constexpr _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    constexpr _Vb_const_iterator& operator--() noexcept {
        _Dec();
        return *this;
    }

    constexpr _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    constexpr _Vb_const_iterator& operator+=(const difference_type _Off) noexcept {












#line 2560 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off)) { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
            this->_Myoff %= _VBITS;
        } else { 
            this->_Myoff += static_cast<_Size_type>(_Off);
            this->_Myptr += this->_Myoff / _VBITS;
            this->_Myoff %= _VBITS;
        }
        return *this;
    }

    [[nodiscard]] constexpr _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _Vb_const_iterator operator+(
        const difference_type _Off, _Vb_const_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    constexpr _Vb_const_iterator& operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    [[nodiscard]] constexpr _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr difference_type operator-(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return static_cast<difference_type>(_Mybase::_VBITS_DIFF * (this->_Myptr - _Right._Myptr))
             + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
    }

    [[nodiscard]] constexpr const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    [[nodiscard]] constexpr bool operator==(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
    }


    [[nodiscard]] constexpr strong_ordering operator<=>(const _Vb_const_iterator& _Right) const noexcept {
        _Compat(_Right);
        if (const auto _CmpResult = this->_Myptr <=> _Right._Myptr; _CmpResult != 0) {
            return _CmpResult;
        }
        return this->_Myoff <=> _Right._Myoff;
    }





















#line 2640 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void _Compat(const _Vb_const_iterator& _Right) const noexcept {
        

        (void) _Right;


#line 2648 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }








#line 2658 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void _Dec() noexcept { 




#line 2665 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (this->_Myoff != 0) {
            --this->_Myoff;
        } else { 
            this->_Myoff = _VBITS - 1;
            --this->_Myptr;
        }
    }

    constexpr void _Inc() noexcept { 





#line 2681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (this->_Myoff < _VBITS - 1) {
            ++this->_Myoff;
        } else { 
            this->_Myoff = 0;
            ++this->_Myptr;
        }
    }
};

template <class _Alvbase_wrapped>
class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped> {
public:
    using _Mybase          = _Vb_const_iterator<_Alvbase_wrapped>;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    using _Reft           = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    [[nodiscard]] constexpr reference operator*() const noexcept {





#line 2716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return _Reft(*this);
    }

    constexpr _Vb_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    constexpr _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    constexpr _Vb_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    constexpr _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    constexpr _Vb_iterator& operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    [[nodiscard]] constexpr _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off;
        return _Tmp;
    }

    [[nodiscard]] friend constexpr _Vb_iterator operator+(const difference_type _Off, _Vb_iterator _Right) noexcept {
        _Right += _Off;
        return _Right;
    }

    constexpr _Vb_iterator& operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    [[nodiscard]] constexpr _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off;
        return _Tmp;
    }

    [[nodiscard]] constexpr reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template <class _Alloc>
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t<_Alloc, _Vbase>;
    using _Alvbase_traits  = allocator_traits<_Alvbase>;
    using _Vectype         = vector<_Vbase, _Alvbase>;
    using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
    using size_type        = typename _Alvbase_traits::size_type;

    constexpr _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>) : _Myvec(), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(const _Alloc& _Al) noexcept : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std:: move(_Right._Myvec)), _Mysize(::std:: exchange(_Right._Mysize, size_type{0})) {
        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr _Vb_val(_Vb_val&& _Right, const _Alloc& _Al) noexcept(
        is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std:: move(_Right._Myvec), static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            
            _Right._Mysize = 0;
        }

        this->_Alloc_proxy(_Fake_alloc);
    }

    constexpr ~_Vb_val() noexcept {




#line 2836 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }

    constexpr _Alvbase& _Getal() noexcept {
        return _Myvec._Getal();
    }

    constexpr const _Alvbase& _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static constexpr size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    constexpr void _Emplace_back_unchecked(const _Vbase _Val) noexcept {
        ;
        _Myvec._Emplace_back_with_unused_capacity(_Val);
    }

    _Vectype _Myvec; 
    size_type _Mysize; 
};

template <class _Alloc>
class vector<bool, _Alloc> : public _Vb_val<_Alloc> {
public:
    static_assert(!1 || is_same_v<bool, typename _Alloc::value_type>,
        "vector<bool, Allocator>" " requires that Allocator's value_type match " "bool" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");

    using _Mybase          = _Vb_val<_Alloc>;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference<_Alvbase_wrapped>;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator<_Alvbase_wrapped>;
    using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    enum { _EEN_VBITS = _VBITS }; 

    constexpr vector() noexcept(is_nothrow_default_constructible_v<_Alloc>) : _Mybase(_Alloc()) {}

    constexpr explicit vector(const _Alloc& _Al) noexcept : _Mybase(_Al) {}

    constexpr explicit vector( size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    constexpr vector( size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    constexpr vector(const vector& _Right) : _Mybase(_Right) {}

    constexpr vector(const vector& _Right, const _Identity_t<_Alloc>& _Al) : _Mybase(_Right, _Al) {}

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mybase(_Al) {
        insert(begin(), _First, _Last);
    }


    template <_Container_compatible_range<bool> _Rng>
    constexpr vector(from_range_t, _Rng&& _Range, const _Alloc& _Al = _Alloc()) : _Mybase(_Al) {
        if constexpr (::std::ranges:: forward_range<_Rng> || ::std::ranges:: sized_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Assign_counted_range(::std::ranges:: _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
    }
#line 2924 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr vector(vector&& _Right) noexcept : _Mybase(::std:: move(_Right)) {
        this->_Swap_proxy_and_iterators(_Right);
    }

    constexpr vector(vector&& _Right, const _Identity_t<_Alloc>& _Al) noexcept(
        is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>) 
        : _Mybase(::std:: move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this->_Getal() != _Right._Getal()) {
                return;
            }
        }

        this->_Swap_proxy_and_iterators(_Right);
    }

    constexpr vector& operator=(vector&& _Right) noexcept(
        _Choose_pocma_v<_Alvbase> != _Pocma_values::_No_propagate_allocators) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }


        this->_Myvec  = ::std:: move(_Right._Myvec);
        this->_Mysize = ::std:: exchange(_Right._Mysize, size_type{0});




































#line 2987 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        return *this;
    }

    template <class... _Valty>
    constexpr decltype(auto) emplace_back(_Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        push_back(_Tmp);


        return back();
#line 2998 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    }

    template <class... _Valty>
    constexpr iterator emplace(const_iterator _Where, _Valty&&... _Val) {
        bool _Tmp(::std:: forward<_Valty>(_Val)...);
        return insert(_Where, _Tmp);
    }

    constexpr vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type()) : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    constexpr vector& operator=(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    constexpr void assign(initializer_list<bool> _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    constexpr iterator insert(const_iterator _Where, initializer_list<bool> _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    constexpr ~vector() noexcept {}

    constexpr vector& operator=(const vector& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }


        this->_Myvec  = _Right._Myvec;
        this->_Mysize = _Right._Mysize;




















#line 3054 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *this;
    }

    constexpr void reserve( size_type _Count) {
        this->_Myvec.reserve(this->_Nw(_Count));
    }

    [[nodiscard]] constexpr size_type capacity() const noexcept {
        return this->_Myvec.capacity() * _VBITS;
    }

    [[nodiscard]] constexpr iterator begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] constexpr const_iterator begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] constexpr iterator end() noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] constexpr const_iterator end() const noexcept {
        return begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] constexpr const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] constexpr const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] constexpr const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] constexpr const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] constexpr iterator _Unchecked_begin() noexcept {
        return iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] constexpr const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this->_Myvec.data(), this);
    }

    [[nodiscard]] constexpr iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    [[nodiscard]] constexpr const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
    }

    constexpr void shrink_to_fit() {
        if (this->_Myvec.capacity() != this->_Myvec.size()) {
            this->_Orphan_all();
            this->_Myvec.shrink_to_fit();
        }
    }

    constexpr iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 < this->_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    [[nodiscard]] constexpr reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] constexpr const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] constexpr reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] constexpr const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    constexpr void resize( size_type _Newsize, bool _Val = false) {
        if (size() < _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize < size()) {
            erase(begin() + static_cast<difference_type>(_Newsize), end());
        }
    }

    [[nodiscard]] constexpr size_type size() const noexcept {
        return this->_Mysize;
    }

    [[nodiscard]] constexpr size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast<size_type>((numeric_limits<difference_type>::max)());
        const size_type _Ints_max = this->_Myvec.max_size();
        if (_Ints_max > _Diff_max / _VBITS) { 
            return _Diff_max;
        }

        
        return _Ints_max * _VBITS;
    }

    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] constexpr bool empty() const noexcept {
        return this->_Mysize == 0;
    }

    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(this->_Myvec.get_allocator());
    }

    [[nodiscard]] constexpr const_reference at(size_type _Off) const {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] constexpr reference at(size_type _Off) {
        if (size() <= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    [[nodiscard]] constexpr const_reference operator[](size_type _Off) const noexcept  {


#line 3197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] constexpr reference operator[](size_type _Off) noexcept  {


#line 3207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    [[nodiscard]] constexpr reference front() noexcept  {


#line 3217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *begin();
    }

    [[nodiscard]] constexpr const_reference front() const noexcept  {


#line 3225 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *begin();
    }

    [[nodiscard]] constexpr reference back() noexcept  {


#line 3233 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *(end() - 1);
    }

    [[nodiscard]] constexpr const_reference back() const noexcept  {


#line 3241 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        return *(end() - 1);
    }

    constexpr void push_back(const bool& _Val) {
        insert(end(), _Val);
    }


    template <_Container_compatible_range<bool> _Rng>
    constexpr void append_range(_Rng&& _Range) {
        insert_range(end(), ::std:: forward<_Rng>(_Range));
    }
#line 3255 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void pop_back() noexcept  {
        erase(end() - 1);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }


    template <class _Iter>
    constexpr void _Assign_counted_range(_Iter _First, const size_type _Count) {
        ;
        this->_Myvec.reserve(this->_Nw(_Count));
        _Vbase _Accum = 0;
        _Vbase _Mask  = 1;
        for (size_type _Idx = 0; _Idx < _Count; ++_Idx) {
            const bool _Tmp = *_First;
            ++_First;
            _Accum |= _Tmp ? _Mask : _Vbase{0};
            if ((_Mask <<= 1) == 0) {
                this->_Emplace_back_unchecked(_Accum);
                _Accum = 0;
                _Mask  = 1;
            }
        }

        if (_Count % _VBITS != 0) {
            this->_Emplace_back_unchecked(_Accum);
        }
        this->_Mysize = _Count;
    }

    template <class _Iter, class _Sent>
    constexpr void _Assign_uncounted_range(_Iter _First, const _Sent _Last) {
        ;
        size_type _Count = 0;
        _Vbase _Accum    = 0;
        _Vbase _Mask     = 1;
        for (; _First != _Last; ++_Count) {
            const bool _Tmp = *_First;
            ++_First;
            _Accum |= _Tmp ? _Mask : _Vbase{0};
            if ((_Mask <<= 1) == 0) {
                this->_Myvec.push_back(_Accum);
                _Accum = 0;
                _Mask  = 1;
            }
        }

        if (_Count % _VBITS != 0) {
            this->_Myvec.push_back(_Accum);
        }
        this->_Mysize = _Count;
    }

    template <_Container_compatible_range<bool> _Rng>
    constexpr void assign_range(_Rng&& _Range) {
        clear();
        if constexpr (::std::ranges:: forward_range<_Rng> || ::std::ranges:: sized_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            _Assign_counted_range(::std::ranges:: _Ubegin(_Range), _Count);
        } else {
            _Assign_uncounted_range(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
        }
    }
#line 3325 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void assign( size_type _Count, const bool& _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    constexpr iterator insert(const_iterator _Where, const bool& _Val) {
        return _Insert_n(_Where, size_type{1}, _Val);
    }

    constexpr iterator insert(const_iterator _Where,  size_type _Count, const bool& _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
    constexpr iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const difference_type _Saved_offset = _Where - begin();
        _Adl_verify_range(_First, _Last);
        auto _UFirst      = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        if constexpr (_Is_cpp17_fwd_iter_v<_Iter>) {
            const auto _Length = static_cast<size_t>(::std:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            const auto _Off    = static_cast<difference_type>(_Insert_x(_Where, _Count));
            ::std:: _Copy_unchecked(_UFirst, _ULast, begin() + _Off);

        } else if constexpr (forward_iterator<_Iter>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_UFirst, _ULast));
            const auto _Count  = _Convert_size<size_type>(_Length);
            const auto _Off    = static_cast<difference_type>(_Insert_x(_Where, _Count));
            ::std:: _Copy_unchecked(_UFirst, _ULast, begin() + _Off);
#line 3358 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        } else {
            const auto _Old_size = this->_Mysize;
            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst);
            }


#line 3366 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
            ::std:: rotate(begin() + _Saved_offset, begin() + static_cast<difference_type>(_Old_size), end());
        }

        return begin() + _Saved_offset;
    }


    template <_Container_compatible_range<bool> _Rng>
    constexpr iterator insert_range(const_iterator _Where, _Rng&& _Range) {
        const difference_type _Old_off = _Where - begin();

        if constexpr (::std::ranges:: forward_range<_Rng> || ::std::ranges:: sized_range<_Rng>) {
            const auto _Length = _To_unsigned_like(::std::ranges:: distance(_Range));
            const auto _Count  = _Convert_size<size_type>(_Length);
            const auto _Off    = static_cast<difference_type>(_Insert_x(_Where, _Count));
            _Copy_n_unchecked4(::std::ranges:: _Ubegin(_Range), _Count, begin() + _Off);
        } else {
            auto _UFirst         = ::std::ranges:: _Ubegin(_Range);
            const auto _ULast    = ::std::ranges:: _Uend(_Range);
            const auto _Old_size = this->_Mysize;
            for (; _UFirst != _ULast; ++_UFirst) {
                emplace_back(*_UFirst);
            }


#line 3392 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
            ::std:: rotate(begin() + _Old_off, begin() + static_cast<difference_type>(_Old_size), end());
        }

        return begin() + _Old_off;
    }
#line 3398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr iterator erase(const_iterator _Where_arg) noexcept  {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();






#line 3409 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        ::std:: copy(_Next_iter(_Where), end(), _Where);
#line 3411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        _Trim(this->_Mysize - 1);
        return begin() + _Off;
    }

    constexpr iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
     {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { 







#line 3431 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
            iterator _Next = ::std:: copy(_Last, end(), _First);
            _Trim(static_cast<size_type>(_Next - begin()));
#line 3434 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
        }
        return begin() + _Off;
    }

    constexpr void clear() noexcept {
        this->_Orphan_all();
        this->_Myvec.clear();
        this->_Mysize = 0;
    }

    constexpr void flip() noexcept { 
        for (auto& _Elem : this->_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this->_Mysize);
    }

    constexpr void swap(vector& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            this->_Swap_proxy_and_iterators(_Right);
            this->_Myvec.swap(_Right._Myvec);
            ::std:: swap(this->_Mysize, _Right._Mysize);
        }
    }

    static constexpr void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; 
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash<vector<bool, _Alloc>>;

    constexpr iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast<difference_type>(_Off);
        ::std:: fill_n(_Result, _Count, _Val);
        return _Result;
    }

    constexpr size_type _Insert_x(const_iterator _Where, size_type _Count) {
        const difference_type _Off = _Where - begin();




#line 3482 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

        if (_Count != 0) {
            if (max_size() - size() < _Count) {
                _Xlen(); 
            }



#line 3491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
            this->_Myvec.resize(this->_Nw(size() + _Count), 0);
            if (empty()) {
                this->_Mysize += _Count;
            } else { 
                iterator _Oldend = end();
                this->_Mysize += _Count;
                ::std:: copy_backward(begin() + _Off, _Oldend, end());
            }
        }

        return static_cast<size_type>(_Off);
    }








































#line 3544 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

    constexpr void _Trim(size_type _Size) {
        if (max_size() < _Size) {
            _Xlen(); 
        }

        const size_type _Words = this->_Nw(_Size);
        if (_Words < this->_Myvec.size()) {
            this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
        }

        this->_Mysize = _Size;
        _Size %= _VBITS;
        if (0 < _Size) {
            this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
        }
    }

    [[noreturn]] static void _Xlen() {
        _Xlength_error("vector<bool> too long");
    }

    [[noreturn]] static void _Xran() {
        _Xout_of_range("invalid vector<bool> subscript");
    }
};

template <class _Alloc>
struct hash<vector<bool, _Alloc>> {
    using _Unnameable_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = vector<bool, _Alloc>;
    using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]   = size_t;

    [[nodiscard]] size_t operator()(const vector<bool, _Alloc>& _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};


namespace pmr {
     template <class _Ty>
    using vector = ::std:: vector<_Ty, polymorphic_allocator<_Ty>>;
} 
#line 3587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"

template <class _Alloc, bool _RequiresMutable>
inline constexpr bool _Is_vb_iterator<_Vb_iterator<_Alloc>, _RequiresMutable> = true;

template <class _Alloc>
inline constexpr bool _Is_vb_iterator<_Vb_const_iterator<_Alloc>, false> = true;

template <class _VbIt>
constexpr void _Fill_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast<_Vbase*>(_First._Myptr);
    _Vbase* const _VbLast = const_cast<_Vbase*>(_Last._Myptr);

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast<_Vbase>(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst & _DestMask) | (_FillVal & _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst & _FirstDestMask) | (_FillVal & _FirstSourceMask);
    ++_VbFirst;


    if (::std:: is_constant_evaluated()) {
        for (; _VbFirst != _VbLast; ++_VbFirst) {
            *_VbFirst = _FillVal;
        }
    } else
#line 3628 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
    {
        const auto _VbFirst_ch = reinterpret_cast<const char*>(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast<const char*>(_VbLast);
        const auto _Count_ch   = static_cast<size_t>(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast<unsigned char>(_Val ? -1 : 0);
        :: memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst & _LastDestMask) | (_FillVal & _LastSourceMask);
    }
}

template <class _VbIt>
[[nodiscard]] constexpr _VbIt _Find_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    
    if (_First == _Last) {
        return _First;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        const auto _Count          = _Countr_zero(_SelectVal);
        return _Count == _VBITS ? _Last : _First + static_cast<ptrdiff_t>(_Count - _First._Myoff);
    }

    const auto _FirstVal   = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
    const auto _FirstCount = _Countr_zero(_FirstVal);
    if (_FirstCount != _VBITS) {
        return _First + static_cast<ptrdiff_t>(_FirstCount - _First._Myoff);
    }
    ++_VbFirst;

    _Iter_diff_t<_VbIt> _TotalCount = static_cast<ptrdiff_t>(_VBITS - _First._Myoff);
    for (; _VbFirst != _VbLast; ++_VbFirst, _TotalCount += _VBITS) {
        const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
        const auto _Count     = _Countr_zero(_SelectVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
        const auto _Count          = _Countr_zero(_LastVal);
        if (_Count != _VBITS) {
            return _First + (_TotalCount + _Count);
        }
    }

    return _Last;
}

template <class _VbIt>
[[nodiscard]] constexpr _Iter_diff_t<_VbIt> _Count_vbool(_VbIt _First, const _VbIt _Last, const bool _Val) noexcept {
    if (_First == _Last) {
        return 0;
    }

    const _Vbase* _VbFirst      = _First._Myptr;
    const _Vbase* const _VbLast = _Last._Myptr;

    const auto _FirstSourceMask = static_cast<_Vbase>(-1) << _First._Myoff;

    if (_VbFirst == _VbLast) {
        
        const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
        const auto _SourceMask     = _FirstSourceMask & _LastSourceMask;
        const auto _SelectVal      = (_Val ? *_VbFirst : ~*_VbFirst) & _SourceMask;
        return _Popcount(_SelectVal);
    }

    return _Select_popcount_impl<_Vbase>(
        [_Last, _Val, _VbFirst, _VbLast, _FirstSourceMask](auto _Popcount_impl) mutable noexcept {
            const auto _FirstVal       = (_Val ? *_VbFirst : ~*_VbFirst) & _FirstSourceMask;
            _Iter_diff_t<_VbIt> _Count = _Popcount_impl(_FirstVal);
            ++_VbFirst;

            for (; _VbFirst != _VbLast; ++_VbFirst) {
                const auto _SelectVal = _Val ? *_VbFirst : ~*_VbFirst;
                _Count += _Popcount_impl(_SelectVal);
            }

            if (_Last._Myoff != 0) {
                const auto _LastSourceMask = static_cast<_Vbase>(-1) >> (_VBITS - _Last._Myoff);
                const auto _LastVal        = (_Val ? *_VbFirst : ~*_VbFirst) & _LastSourceMask;
                _Count += _Popcount_impl(_LastVal);
            }

            return _Count;
        });
}








}



#pragma warning(pop)
#pragma pack(pop)
#line 3747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
#line 3748 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\vector"
#pragma external_header(pop)
#line 58 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"







































#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

















































































































































































































































































#line 275 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




#line 280 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\string"















#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim) {
    
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::iostate _State = _Myis::goodbit;
    bool _Changed                  = false;
    const typename _Myis::sentry _Ok(_Istr, true);

    if (_Ok) { 
        try {
        _Str.erase();
        const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);
        typename _Traits::int_type _Meta            = _Istr.rdbuf()->sgetc();

        for (;; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= _Myis::eofbit;
                break;
            } else if (_Traits::eq_int_type(_Meta, _Metadelim)) { 
                _Changed = true;
                _Istr.rdbuf()->sbumpc();
                break;
            } else if (_Str.max_size() <= _Str.size()) { 
                _State |= _Myis::failbit;
                break;
            } else { 
                _Str += _Traits::to_char_type(_Meta);
                _Changed = true;
            }
        }
        } catch (...) { (_Istr) .setstate(_Myis::badbit, true); }
    }

    if (!_Changed) {
        _State |= _Myis::failbit;
    }

    _Istr.setstate(_State);
    return static_cast<basic_istream<_Elem, _Traits>&>(_Istr);
}

 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    
    return ::std:: getline(::std:: move(_Istr), _Str, _Istr.widen('\n'));
}

 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim) {
    
    return ::std:: getline(::std:: move(_Istr), _Str, _Delim);
}

 template <class _Elem, class _Traits, class _Alloc>
basic_istream<_Elem, _Traits>& getline(
    basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {
    
    return ::std:: getline(::std:: move(_Istr), _Str, _Istr.widen('\n'));
}

 [[nodiscard]] inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoi argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return static_cast<int>(_Ans);
}

 [[nodiscard]] inline long stol(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline unsigned long stoul(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref               = 0;
    const unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline long long stoll(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref           = 0;
    const long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline unsigned long long stoull(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref                    = 0;
    const unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline float stof(const string& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref       = 0;
    const float _Ans = :: strtof(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline double stod(const string& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref        = 0;
    const double _Ans = :: strtod(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline long double stold(const string& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref  = (*_errno()); 
    const char* _Ptr = _Str.c_str();
    char* _Eptr;
    _Errno_ref             = 0;
    const long double _Ans = :: strtold(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline int stoi(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoi argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoi argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return static_cast<int>(_Ans);
}

 [[nodiscard]] inline long stol(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref      = 0;
    const long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stol argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stol argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline unsigned long stoul(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref               = 0;
    const unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoul argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoul argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline long long stoll(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref           = 0;
    const long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoll argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoll argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline unsigned long long stoull(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref                    = 0;
    const unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stoull argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stoull argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline float stof(const wstring& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref       = 0;
    const float _Ans = :: wcstof(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stof argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stof argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline double stod(const wstring& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref        = 0;
    const double _Ans = :: wcstod(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stod argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stod argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

 [[nodiscard]] inline long double stold(const wstring& _Str, size_t* _Idx = nullptr) {
    int& _Errno_ref     = (*_errno()); 
    const wchar_t* _Ptr = _Str.c_str();
    wchar_t* _Eptr;
    _Errno_ref             = 0;
    const long double _Ans = :: wcstold(_Ptr, &_Eptr);

    if (_Ptr == _Eptr) {
        _Xinvalid_argument("invalid stold argument");
    }

    if (_Errno_ref == 34) {
        _Xout_of_range("stold argument out of range");
    }

    if (_Idx) {
        *_Idx = static_cast<size_t>(_Eptr - _Ptr);
    }

    return _Ans;
}

template <class _Elem, class _UTy>
[[nodiscard]] _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal) {
    
    static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");


    auto _UVal_trunc = _UVal;
















#line 464 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\string"

    do {
        *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
        _UVal_trunc /= 10;
    } while (_UVal_trunc != 0);
    return _RNext;
}

template <class _Elem, class _Ty>
[[nodiscard]] basic_string<_Elem> _Integral_to_string(const _Ty _Val) {
    
    static_assert(is_integral_v<_Ty>, "_Ty must be integral");
    using _UTy = make_unsigned_t<_Ty>;
    _Elem _Buff[21]; 
    _Elem* const _Buff_end = ::std:: end(_Buff);
    _Elem* _RNext          = _Buff_end;
    const auto _UVal       = static_cast<_UTy>(_Val);
    if (_Val < 0) {
        _RNext    = _UIntegral_to_buff(_RNext, 0 - _UVal);
        *--_RNext = '-';
    } else {
        _RNext = _UIntegral_to_buff(_RNext, _UVal);
    }

    return basic_string<_Elem>(_RNext, _Buff_end);
}


template <class _Elem, class _Ty>
[[nodiscard]] basic_string<_Elem> _UIntegral_to_string(const _Ty _Val) {
    
    static_assert(is_integral_v<_Ty>, "_Ty must be integral");
    static_assert(is_unsigned_v<_Ty>, "_Ty must be unsigned");
    _Elem _Buff[21]; 
    _Elem* const _Buff_end = ::std:: end(_Buff);
    _Elem* const _RNext    = _UIntegral_to_buff(_Buff_end, _Val);
    return basic_string<_Elem>(_RNext, _Buff_end);
}

 [[nodiscard]] inline string to_string(int _Val) {
    return _Integral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(unsigned int _Val) {
    return _UIntegral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(long _Val) {
    return _Integral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(unsigned long _Val) {
    return _UIntegral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(long long _Val) {
    return _Integral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(unsigned long long _Val) {
    return _UIntegral_to_string<char>(_Val);
}

 [[nodiscard]] inline string to_string(double _Val) {
    const auto _Len = static_cast<size_t>(:: _scprintf("%f", _Val));
    string _Str(_Len, '\0');
    :: sprintf_s(&_Str[0], _Len + 1, "%f", _Val);
    return _Str;
}

 [[nodiscard]] inline string to_string(float _Val) {
    return ::std:: to_string(static_cast<double>(_Val));
}

 [[nodiscard]] inline string to_string(long double _Val) {
    return ::std:: to_string(static_cast<double>(_Val));
}

 [[nodiscard]] inline wstring to_wstring(int _Val) {
    return _Integral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(unsigned int _Val) {
    return _UIntegral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(long _Val) {
    return _Integral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(unsigned long _Val) {
    return _UIntegral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(long long _Val) {
    return _Integral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(unsigned long long _Val) {
    return _UIntegral_to_string<wchar_t>(_Val);
}

 [[nodiscard]] inline wstring to_wstring(double _Val) {
    const auto _Len = static_cast<size_t>(:: _scwprintf(L"%f", _Val));
    wstring _Str(_Len, L'\0');
    :: swprintf_s(&_Str[0], _Len + 1, L"%f", _Val);
    return _Str;
}

 [[nodiscard]] inline wstring to_wstring(float _Val) {
    return ::std:: to_wstring(static_cast<double>(_Val));
}

 [[nodiscard]] inline wstring to_wstring(long double _Val) {
    return ::std:: to_wstring(static_cast<double>(_Val));
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 587 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\string"
#line 588 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\string"
#pragma external_header(pop)
#line 284 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"












#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"











#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"


#line 16 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xsmf_control.h"












#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

template <class _Base>
struct _Non_trivial_copy : _Base { 
    using _Base::_Base;

    _Non_trivial_copy() = default;
    constexpr _Non_trivial_copy(const _Non_trivial_copy& _That) noexcept(
        noexcept(_Base::_Construct_from(static_cast<const _Base&>(_That)))) {
        _Base::_Construct_from(static_cast<const _Base&>(_That));
    }
    _Non_trivial_copy(_Non_trivial_copy&&)                 = default;
    _Non_trivial_copy& operator=(const _Non_trivial_copy&) = default;
    _Non_trivial_copy& operator=(_Non_trivial_copy&&)      = default;
};

template <class _Base>
struct _Deleted_copy : _Base { 
    using _Base::_Base;

    _Deleted_copy()                                = default;
    _Deleted_copy(const _Deleted_copy&)            = delete;
    _Deleted_copy(_Deleted_copy&&)                 = default;
    _Deleted_copy& operator=(const _Deleted_copy&) = default;
    _Deleted_copy& operator=(_Deleted_copy&&)      = default;
};

template <class _Base, class... _Types>
using _SMF_control_copy = conditional_t<conjunction_v<is_trivially_copy_constructible<_Types>...>, _Base,
    conditional_t<conjunction_v<is_copy_constructible<_Types>...>, _Non_trivial_copy<_Base>, _Deleted_copy<_Base>>>;

template <class _Base, class... _Types>
struct _Non_trivial_move : _SMF_control_copy<_Base, _Types...> { 
    using _Mybase = _SMF_control_copy<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Non_trivial_move()                         = default;
    _Non_trivial_move(const _Non_trivial_move&) = default;
    constexpr _Non_trivial_move(_Non_trivial_move&& _That) noexcept(
        noexcept(_Mybase::_Construct_from(static_cast<_Base&&>(_That)))) {
        _Mybase::_Construct_from(static_cast<_Base&&>(_That));
    }
    _Non_trivial_move& operator=(const _Non_trivial_move&) = default;
    _Non_trivial_move& operator=(_Non_trivial_move&&)      = default;
};

template <class _Base, class... _Types>
struct _Deleted_move : _SMF_control_copy<_Base, _Types...> { 
    using _Mybase = _SMF_control_copy<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Deleted_move()                                = default;
    _Deleted_move(const _Deleted_move&)            = default;
    _Deleted_move(_Deleted_move&&)                 = delete;
    _Deleted_move& operator=(const _Deleted_move&) = default;
    _Deleted_move& operator=(_Deleted_move&&)      = default;
};

template <class _Base, class... _Types>
using _SMF_control_move =
    conditional_t<conjunction_v<is_trivially_move_constructible<_Types>...>, _SMF_control_copy<_Base, _Types...>,
        conditional_t<conjunction_v<is_move_constructible<_Types>...>, _Non_trivial_move<_Base, _Types...>,
            _Deleted_move<_Base, _Types...>>>;

template <class _Base, class... _Types>
struct _Non_trivial_copy_assign : _SMF_control_move<_Base, _Types...> { 
    using _Mybase = _SMF_control_move<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Non_trivial_copy_assign()                                = default;
    _Non_trivial_copy_assign(const _Non_trivial_copy_assign&) = default;
    _Non_trivial_copy_assign(_Non_trivial_copy_assign&&)      = default;

    constexpr _Non_trivial_copy_assign& operator=(const _Non_trivial_copy_assign& _That) noexcept(
        noexcept(_Mybase::_Assign_from(static_cast<const _Base&>(_That)))) {
        _Mybase::_Assign_from(static_cast<const _Base&>(_That));
        return *this;
    }
    _Non_trivial_copy_assign& operator=(_Non_trivial_copy_assign&&) = default;
};

template <class _Base, class... _Types>
struct _Deleted_copy_assign : _SMF_control_move<_Base, _Types...> { 
    using _Mybase = _SMF_control_move<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Deleted_copy_assign()                                       = default;
    _Deleted_copy_assign(const _Deleted_copy_assign&)            = default;
    _Deleted_copy_assign(_Deleted_copy_assign&&)                 = default;
    _Deleted_copy_assign& operator=(const _Deleted_copy_assign&) = delete;
    _Deleted_copy_assign& operator=(_Deleted_copy_assign&&)      = default;
};

template <class _Base, class... _Types>
using _SMF_control_copy_assign =
    conditional_t<conjunction_v<is_trivially_destructible<_Types>..., is_trivially_copy_constructible<_Types>...,
                      is_trivially_copy_assignable<_Types>...>,
        _SMF_control_move<_Base, _Types...>,
        conditional_t<conjunction_v<is_copy_constructible<_Types>..., is_copy_assignable<_Types>...>,
            _Non_trivial_copy_assign<_Base, _Types...>, _Deleted_copy_assign<_Base, _Types...>>>;

template <class _Base, class... _Types>
struct _Non_trivial_move_assign : _SMF_control_copy_assign<_Base, _Types...> { 
    using _Mybase = _SMF_control_copy_assign<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Non_trivial_move_assign()                                           = default;
    _Non_trivial_move_assign(const _Non_trivial_move_assign&)            = default;
    _Non_trivial_move_assign(_Non_trivial_move_assign&&)                 = default;
    _Non_trivial_move_assign& operator=(const _Non_trivial_move_assign&) = default;

    constexpr _Non_trivial_move_assign& operator=(_Non_trivial_move_assign&& _That) noexcept(
        noexcept(_Mybase::_Assign_from(static_cast<_Base&&>(_That)))) {
        _Mybase::_Assign_from(static_cast<_Base&&>(_That));
        return *this;
    }
};

template <class _Base, class... _Types>
struct _Deleted_move_assign : _SMF_control_copy_assign<_Base, _Types...> { 
    using _Mybase = _SMF_control_copy_assign<_Base, _Types...>;
    using _Mybase::_Mybase;

    _Deleted_move_assign()                                       = default;
    _Deleted_move_assign(const _Deleted_move_assign&)            = default;
    _Deleted_move_assign(_Deleted_move_assign&&)                 = default;
    _Deleted_move_assign& operator=(const _Deleted_move_assign&) = default;
    _Deleted_move_assign& operator=(_Deleted_move_assign&&)      = delete;
};

template <class _Base, class... _Types>
using _SMF_control_move_assign =
    conditional_t<conjunction_v<is_trivially_destructible<_Types>..., is_trivially_move_constructible<_Types>...,
                      is_trivially_move_assignable<_Types>...>,
        _SMF_control_copy_assign<_Base, _Types...>,
        conditional_t<conjunction_v<is_move_constructible<_Types>..., is_move_assignable<_Types>...>,
            _Non_trivial_move_assign<_Base, _Types...>, _Deleted_move_assign<_Base, _Types...>>>;

template <class _Base, class... _Types>
using _SMF_control = _SMF_control_move_assign<_Base, _Types...>;

}



#pragma warning(pop)
#pragma pack(pop)

#line 169 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xsmf_control.h"
#line 170 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xsmf_control.h"
#pragma external_header(pop)
#line 21 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"


#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {

 struct nullopt_t { 
    struct _Tag {};
    constexpr explicit nullopt_t(_Tag) {}
};
 inline constexpr nullopt_t nullopt{nullopt_t::_Tag{}};

 class bad_optional_access : public exception {
public:
    [[nodiscard]] const char*  what() const noexcept override {
        return "Bad optional access";
    }






#line 50 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
};

[[noreturn]] inline void _Throw_bad_optional_access() {
    throw bad_optional_access{};
}

struct _Nontrivial_dummy_type {
    constexpr _Nontrivial_dummy_type() noexcept {
        
    }
};
;


struct _Construct_from_invoke_result_tag {
    explicit _Construct_from_invoke_result_tag() = default;
};
#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

template <class _Ty, bool = is_trivially_destructible_v<_Ty>>
struct _Optional_destruct_base { 
    union {
        _Nontrivial_dummy_type _Dummy;
        remove_cv_t<_Ty> _Value;
    };
    bool _Has_value;

    constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} 

    template <class... _Types>
    constexpr explicit _Optional_destruct_base(in_place_t, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, _Types...>)
        : _Value(::std:: forward<_Types>(_Args)...), _Has_value{true} {} 


    template <class _Fn, class _Ux>
    constexpr _Optional_destruct_base(_Construct_from_invoke_result_tag, _Fn&& _Func, _Ux&& _Arg) noexcept(
        noexcept(static_cast<_Ty>(::std:: invoke(::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg)))))
        : _Value(::std:: invoke(::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg))), _Has_value{true} {}
#line 90 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

    constexpr void reset() noexcept {
        _Has_value = false;
    }
};

template <class _Ty>
struct _Optional_destruct_base<_Ty, false> { 
    union {
        _Nontrivial_dummy_type _Dummy;
        remove_cv_t<_Ty> _Value;
    };
    bool _Has_value;

    constexpr ~_Optional_destruct_base() noexcept {
        if (_Has_value) {
            _Value.~_Ty();
        }
    }

    constexpr _Optional_destruct_base() noexcept : _Dummy{}, _Has_value{false} {} 

    template <class... _Types>
    constexpr explicit _Optional_destruct_base(in_place_t, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, _Types...>)
        : _Value(::std:: forward<_Types>(_Args)...), _Has_value{true} {} 


    template <class _Fn, class _Ux>
    constexpr _Optional_destruct_base(_Construct_from_invoke_result_tag, _Fn&& _Func, _Ux&& _Arg) noexcept(
        noexcept(static_cast<_Ty>(::std:: invoke(::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg)))))
        : _Value(::std:: invoke(::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg))), _Has_value{true} {}
#line 123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

    _Optional_destruct_base(const _Optional_destruct_base&)            = default;
    _Optional_destruct_base(_Optional_destruct_base&&)                 = default;
    _Optional_destruct_base& operator=(const _Optional_destruct_base&) = default;
    _Optional_destruct_base& operator=(_Optional_destruct_base&&)      = default;

    constexpr void reset() noexcept {
        if (_Has_value) {
            _Value.~_Ty();
            _Has_value = false;
        }
    }
};

template <class _Ty>
struct _Optional_construct_base : _Optional_destruct_base<_Ty> {
    
    using _Optional_destruct_base<_Ty>::_Optional_destruct_base;

    template <class... _Types>
    constexpr _Ty& _Construct(_Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {
        
        ;
        _Construct_in_place(this->_Value, ::std:: forward<_Types>(_Args)...);
        this->_Has_value = true;
        return this->_Value;
    }

    template <class _Ty2>
    constexpr void _Assign(_Ty2&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty&, _Ty2>&& is_nothrow_constructible_v<_Ty, _Ty2>) {
        
        if (this->_Has_value) {
            static_cast<_Ty&>(this->_Value) = ::std:: forward<_Ty2>(_Right);
        } else {
            _Construct(::std:: forward<_Ty2>(_Right));
        }
    }

    template <class _Self>
    constexpr void _Construct_from(_Self&& _Right) noexcept(
        is_nothrow_constructible_v<_Ty, decltype(*::std:: forward<_Self>(_Right))>) {
        
        if (_Right._Has_value) {
            _Construct(*::std:: forward<_Self>(_Right));
        }
    }

    template <class _Self>
    constexpr void _Assign_from(_Self&& _Right) noexcept(
        is_nothrow_constructible_v<_Ty, decltype(*::std:: forward<_Self>(_Right))>&&
            is_nothrow_assignable_v<_Ty&, decltype(*::std:: forward<_Self>(_Right))>) {
        
        if (_Right._Has_value) {
            _Assign(*::std:: forward<_Self>(_Right));
        } else {
            this->reset();
        }
    }

    [[nodiscard]] constexpr _Ty& operator*() & noexcept {


#line 187 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return this->_Value;
    }

    [[nodiscard]] constexpr const _Ty& operator*() const& noexcept {


#line 194 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return this->_Value;
    }

    [[nodiscard]] constexpr _Ty&& operator*() && noexcept {


#line 201 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return ::std:: move(this->_Value);
    }

    [[nodiscard]] constexpr const _Ty&& operator*() const&& noexcept {


#line 208 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return ::std:: move(this->_Value);
    }
};

 template <class _Ty>
class optional : private _SMF_control<_Optional_construct_base<_Ty>, _Ty> {
private:
    using _Mybase = _SMF_control<_Optional_construct_base<_Ty>, _Ty>;

public:
    static_assert(!_Is_any_of_v<remove_cv_t<_Ty>, nullopt_t, in_place_t>,
        "T in optional<T> must be a type other than nullopt_t or in_place_t (N4950 [optional.optional.general]/3).");
    static_assert(is_object_v<_Ty> && is_destructible_v<_Ty> && !is_array_v<_Ty>,
        "T in optional<T> must meet the Cpp17Destructible requirements (N4950 [optional.optional.general]/3).");

    using value_type = _Ty;

    constexpr optional() noexcept {}
    constexpr optional(nullopt_t) noexcept {}

    template <class... _Types, enable_if_t<is_constructible_v<_Ty, _Types...>, int> = 0>
    constexpr explicit optional(in_place_t, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, _Types...>) 
        : _Mybase(in_place, ::std:: forward<_Types>(_Args)...) {}

    template <class _Elem, class... _Types,
        enable_if_t<is_constructible_v<_Ty, initializer_list<_Elem>&, _Types...>, int> = 0>
    constexpr explicit optional(in_place_t, initializer_list<_Elem> _Ilist, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, initializer_list<_Elem>&, _Types...>) 
        : _Mybase(in_place, _Ilist, ::std:: forward<_Types>(_Args)...) {}

    template <class _Ty2>
    using _AllowDirectConversion = bool_constant<conjunction_v<negation<is_same<_Remove_cvref_t<_Ty2>, optional>>,
        negation<is_same<_Remove_cvref_t<_Ty2>, in_place_t>>,
        negation<conjunction<is_same<remove_cv_t<_Ty>, bool>, _Is_specialization<_Remove_cvref_t<_Ty2>, optional>>>,
        is_constructible<_Ty, _Ty2>>>;

    template <class _Ty2 = _Ty, enable_if_t<_AllowDirectConversion<_Ty2>::value, int> = 0>
    constexpr explicit(!is_convertible_v<_Ty2, _Ty>)
        optional(_Ty2&& _Right) noexcept(is_nothrow_constructible_v<_Ty, _Ty2>) 
        : _Mybase(in_place, ::std:: forward<_Ty2>(_Right)) {}

    template <class _Ty2>
    struct _AllowUnwrapping
        : bool_constant<disjunction_v<is_same<remove_cv_t<_Ty>, bool>,
              negation<disjunction<is_same<_Ty, _Ty2>, is_constructible<_Ty, optional<_Ty2>&>,
                  is_constructible<_Ty, const optional<_Ty2>&>, is_constructible<_Ty, const optional<_Ty2>>,
                  is_constructible<_Ty, optional<_Ty2>>, is_convertible<optional<_Ty2>&, _Ty>,
                  is_convertible<const optional<_Ty2>&, _Ty>, is_convertible<const optional<_Ty2>, _Ty>,
                  is_convertible<optional<_Ty2>, _Ty>>>>> {};

    template <class _Ty2,
        enable_if_t<conjunction_v<_AllowUnwrapping<_Ty2>, is_constructible<_Ty, const _Ty2&>>, int> = 0>
    constexpr explicit(!is_convertible_v<const _Ty2&, _Ty>) optional(const optional<_Ty2>& _Right) noexcept(
        is_nothrow_constructible_v<_Ty, const _Ty2&>)  {
        if (_Right) {
            this->_Construct(*_Right);
        }
    }

    template <class _Ty2, enable_if_t<conjunction_v<_AllowUnwrapping<_Ty2>, is_constructible<_Ty, _Ty2>>, int> = 0>
    constexpr explicit(!is_convertible_v<_Ty2, _Ty>)
        optional(optional<_Ty2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty, _Ty2>)  {
        if (_Right) {
            this->_Construct(::std:: move(*_Right));
        }
    }


    template <class _Fn, class _Ux>
    constexpr optional(_Construct_from_invoke_result_tag _Tag, _Fn&& _Func, _Ux&& _Arg) noexcept(
        noexcept(static_cast<_Ty>(::std:: invoke(::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg)))))
        : _Mybase(_Tag, ::std:: forward<_Fn>(_Func), ::std:: forward<_Ux>(_Arg)) {}
#line 282 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

    constexpr optional& operator=(nullopt_t) noexcept {
        reset();
        return *this;
    }

    template <class _Ty2 = _Ty, enable_if_t<conjunction_v<negation<is_same<optional, _Remove_cvref_t<_Ty2>>>,
                                                negation<conjunction<is_scalar<_Ty>, is_same<_Ty, decay_t<_Ty2>>>>,
                                                is_constructible<_Ty, _Ty2>, is_assignable<_Ty&, _Ty2>>,
                                    int> = 0>
    constexpr optional& operator=(_Ty2&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty&, _Ty2>&& is_nothrow_constructible_v<_Ty, _Ty2>)  {
        this->_Assign(::std:: forward<_Ty2>(_Right));
        return *this;
    }

    template <class _Ty2>
    struct _AllowUnwrappingAssignment
        : bool_constant<!disjunction_v<is_same<_Ty, _Ty2>, is_assignable<_Ty&, optional<_Ty2>&>,
              is_assignable<_Ty&, const optional<_Ty2>&>, is_assignable<_Ty&, const optional<_Ty2>>,
              is_assignable<_Ty&, optional<_Ty2>>>> {};

    template <class _Ty2, enable_if_t<conjunction_v<_AllowUnwrappingAssignment<_Ty2>,
                                          is_constructible<_Ty, const _Ty2&>, is_assignable<_Ty&, const _Ty2&>>,
                              int> = 0>
    constexpr optional& operator=(const optional<_Ty2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty&, const _Ty2&>&& is_nothrow_constructible_v<_Ty, const _Ty2&>)  {
        if (_Right) {
            this->_Assign(*_Right);
        } else {
            reset();
        }

        return *this;
    }

    template <class _Ty2, enable_if_t<conjunction_v<_AllowUnwrappingAssignment<_Ty2>, is_constructible<_Ty, _Ty2>,
                                          is_assignable<_Ty&, _Ty2>>,
                              int> = 0>
    constexpr optional& operator=(optional<_Ty2>&& _Right) noexcept(
        is_nothrow_assignable_v<_Ty&, _Ty2>&& is_nothrow_constructible_v<_Ty, _Ty2>)  {
        if (_Right) {
            this->_Assign(::std:: move(*_Right));
        } else {
            reset();
        }

        return *this;
    }

    template <class... _Types>
    constexpr _Ty& emplace(_Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, _Types...>)  {
        reset();
        return this->_Construct(::std:: forward<_Types>(_Args)...);
    }

    template <class _Elem, class... _Types,
        enable_if_t<is_constructible_v<_Ty, initializer_list<_Elem>&, _Types...>, int> = 0>
    constexpr _Ty& emplace(initializer_list<_Elem> _Ilist, _Types&&... _Args) noexcept(
        is_nothrow_constructible_v<_Ty, initializer_list<_Elem>&, _Types...>)  {
        reset();
        return this->_Construct(_Ilist, ::std:: forward<_Types>(_Args)...);
    }

    constexpr void swap(optional& _Right) noexcept(
        is_nothrow_move_constructible_v<_Ty>&& is_nothrow_swappable_v<_Ty>) {
        static_assert(is_move_constructible_v<_Ty>,
            "optional<T>::swap requires T to be move constructible (N4950 [optional.swap]/1).");
        static_assert(!is_move_constructible_v<_Ty> || is_swappable_v<_Ty>,
            "optional<T>::swap requires T to be swappable (N4950 [optional.swap]/2).");
        using ::std:: swap;
        if constexpr (_Is_trivially_swappable_v<_Ty>) {
            using _TrivialBaseTy = _Optional_destruct_base<_Ty>;
            ::std:: swap(static_cast<_TrivialBaseTy&>(*this), static_cast<_TrivialBaseTy&>(_Right));
        } else {
            const bool _Engaged = this->_Has_value;
            if (_Engaged == _Right._Has_value) {
                if (_Engaged) {
                    swap(**this, *_Right); 
                }
            } else {
                optional& _Source = _Engaged ? *this : _Right;
                optional& _Target = _Engaged ? _Right : *this;
                _Target._Construct(::std:: move(*_Source));
                _Source.reset();
            }
        }
    }

    [[nodiscard]] constexpr const _Ty* operator->() const noexcept {


#line 376 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return ::std:: addressof(this->_Value);
    }
    [[nodiscard]] constexpr _Ty* operator->() noexcept {


#line 382 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
        return ::std:: addressof(this->_Value);
    }

    using _Mybase::operator*;

    constexpr explicit operator bool() const noexcept {
        return this->_Has_value;
    }
    [[nodiscard]] constexpr bool has_value() const noexcept {
        return this->_Has_value;
    }

    [[nodiscard]] constexpr const _Ty& value() const& {
        if (!this->_Has_value) {
            _Throw_bad_optional_access();
        }

        return this->_Value;
    }
    [[nodiscard]] constexpr _Ty& value() & {
        if (!this->_Has_value) {
            _Throw_bad_optional_access();
        }

        return this->_Value;
    }
    [[nodiscard]] constexpr _Ty&& value() && {
        if (!this->_Has_value) {
            _Throw_bad_optional_access();
        }

        return ::std:: move(this->_Value);
    }
    [[nodiscard]] constexpr const _Ty&& value() const&& {
        if (!this->_Has_value) {
            _Throw_bad_optional_access();
        }

        return ::std:: move(this->_Value);
    }

    template <class _Ty2>
    [[nodiscard]] constexpr remove_cv_t<_Ty> value_or(_Ty2&& _Right) const& {
        static_assert(is_convertible_v<const _Ty&, remove_cv_t<_Ty>>,
            "The const overload of optional<T>::value_or requires const T& to be convertible to remove_cv_t<T> "
            "(N4950 [optional.observe]/15 as modified by LWG-3424).");
        static_assert(is_convertible_v<_Ty2, _Ty>,
            "optional<T>::value_or(U) requires U to be convertible to T (N4950 [optional.observe]/15).");

        if (this->_Has_value) {
            return static_cast<const _Ty&>(this->_Value);
        }

        return static_cast<remove_cv_t<_Ty>>(::std:: forward<_Ty2>(_Right));
    }
    template <class _Ty2>
    [[nodiscard]] constexpr remove_cv_t<_Ty> value_or(_Ty2&& _Right) && {
        static_assert(is_convertible_v<_Ty, remove_cv_t<_Ty>>,
            "The rvalue overload of optional<T>::value_or requires T to be convertible to remove_cv_t<T> "
            "(N4950 [optional.observe]/17 as modified by LWG-3424).");
        static_assert(is_convertible_v<_Ty2, _Ty>,
            "optional<T>::value_or(U) requires U to be convertible to T (N4950 [optional.observe]/17).");

        if (this->_Has_value) {
            return static_cast<_Ty&&>(this->_Value);
        }

        return static_cast<remove_cv_t<_Ty>>(::std:: forward<_Ty2>(_Right));
    }


    template <class _Fn>
    constexpr auto and_then(_Fn&& _Func) & {
        using _Uty = invoke_result_t<_Fn, _Ty&>;

        static_assert(_Is_specialization_v<remove_cvref_t<_Uty>, optional>,
            "optional<T>::and_then(F) requires the return type of F to be a specialization of optional "
            "(N4950 [optional.monadic]/2).");

        if (this->_Has_value) {
            return ::std:: invoke(::std:: forward<_Fn>(_Func), static_cast<_Ty&>(this->_Value));
        } else {
            return remove_cvref_t<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto and_then(_Fn&& _Func) const& {
        using _Uty = invoke_result_t<_Fn, const _Ty&>;

        static_assert(_Is_specialization_v<remove_cvref_t<_Uty>, optional>,
            "optional<T>::and_then(F) requires the return type of F to be a specialization of optional "
            "(N4950 [optional.monadic]/2).");

        if (this->_Has_value) {
            return ::std:: invoke(::std:: forward<_Fn>(_Func), static_cast<const _Ty&>(this->_Value));
        } else {
            return remove_cvref_t<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto and_then(_Fn&& _Func) && {
        using _Uty = invoke_result_t<_Fn, _Ty>;

        static_assert(_Is_specialization_v<remove_cvref_t<_Uty>, optional>,
            "optional<T>::and_then(F) requires the return type of F to be a specialization of optional "
            "(N4950 [optional.monadic]/5).");

        if (this->_Has_value) {
            return ::std:: invoke(::std:: forward<_Fn>(_Func), static_cast<_Ty&&>(this->_Value));
        } else {
            return remove_cvref_t<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto and_then(_Fn&& _Func) const&& {
        using _Uty = invoke_result_t<_Fn, const _Ty>;

        static_assert(_Is_specialization_v<remove_cvref_t<_Uty>, optional>,
            "optional<T>::and_then(F) requires the return type of F to be a specialization of optional "
            "(N4950 [optional.monadic]/5).");

        if (this->_Has_value) {
            return ::std:: invoke(::std:: forward<_Fn>(_Func), static_cast<const _Ty&&>(this->_Value));
        } else {
            return remove_cvref_t<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto transform(_Fn&& _Func) & {
        using _Uty = remove_cv_t<invoke_result_t<_Fn, _Ty&>>;

        static_assert(!_Is_any_of_v<_Uty, nullopt_t, in_place_t>,
            "optional<T>::transform(F) requires the return type of F to be a type other than nullopt_t or in_place_t "
            "(N4950 [optional.monadic]/8).");
        static_assert(is_object_v<_Uty> && !is_array_v<_Uty>,
            "optional<T>::transform(F) requires the return type of F to be a non-array object type "
            "(N4950 [optional.monadic]/8).");

        if (this->_Has_value) {
            return optional<_Uty>{
                _Construct_from_invoke_result_tag{}, ::std:: forward<_Fn>(_Func), static_cast<_Ty&>(this->_Value)};
        } else {
            return optional<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto transform(_Fn&& _Func) const& {
        using _Uty = remove_cv_t<invoke_result_t<_Fn, const _Ty&>>;

        static_assert(!_Is_any_of_v<_Uty, nullopt_t, in_place_t>,
            "optional<T>::transform(F) requires the return type of F to be a type other than nullopt_t or in_place_t "
            "(N4950 [optional.monadic]/8).");
        static_assert(is_object_v<_Uty> && !is_array_v<_Uty>,
            "optional<T>::transform(F) requires the return type of F to be a non-array object type "
            "(N4950 [optional.monadic]/8).");

        if (this->_Has_value) {
            return optional<_Uty>{
                _Construct_from_invoke_result_tag{}, ::std:: forward<_Fn>(_Func), static_cast<const _Ty&>(this->_Value)};
        } else {
            return optional<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto transform(_Fn&& _Func) && {
        using _Uty = remove_cv_t<invoke_result_t<_Fn, _Ty>>;

        static_assert(!_Is_any_of_v<_Uty, nullopt_t, in_place_t>,
            "optional<T>::transform(F) requires the return type of F to be a type other than nullopt_t or in_place_t "
            "(N4950 [optional.monadic]/11).");
        static_assert(is_object_v<_Uty> && !is_array_v<_Uty>,
            "optional<T>::transform(F) requires the return type of F to be a non-array object type "
            "(N4950 [optional.monadic]/11).");

        if (this->_Has_value) {
            return optional<_Uty>{
                _Construct_from_invoke_result_tag{}, ::std:: forward<_Fn>(_Func), static_cast<_Ty&&>(this->_Value)};
        } else {
            return optional<_Uty>{};
        }
    }

    template <class _Fn>
    constexpr auto transform(_Fn&& _Func) const&& {
        using _Uty = remove_cv_t<invoke_result_t<_Fn, const _Ty>>;

        static_assert(!_Is_any_of_v<_Uty, nullopt_t, in_place_t>,
            "optional<T>::transform(F) requires the return type of F to be a type other than nullopt_t or in_place_t "
            "(N4950 [optional.monadic]/11).");
        static_assert(is_object_v<_Uty> && !is_array_v<_Uty>,
            "optional<T>::transform(F) requires the return type of F to be a non-array object type "
            "(N4950 [optional.monadic]/11).");

        if (this->_Has_value) {
            return optional<_Uty>{
                _Construct_from_invoke_result_tag{}, ::std:: forward<_Fn>(_Func), static_cast<const _Ty&&>(this->_Value)};
        } else {
            return optional<_Uty>{};
        }
    }


    template <invocable<> _Fn>
        requires copy_constructible<_Ty>
    constexpr optional or_else(_Fn&& _Func) const& {
        static_assert(is_same_v<remove_cvref_t<invoke_result_t<_Fn>>, optional>,
            "optional<T>::or_else(F) requires F to return an optional<T> (N4950 [optional.monadic]/14).");

        if (this->_Has_value) {
            return *this;
        } else {
            return ::std:: forward<_Fn>(_Func)();
        }
    }

    template <invocable<> _Fn>
        requires move_constructible<_Ty>
    constexpr optional or_else(_Fn&& _Func) && {
        static_assert(is_same_v<remove_cvref_t<invoke_result_t<_Fn>>, optional>,
            "optional<T>::or_else(F) requires F to return an optional<T> (N4950 [optional.monadic]/17).");

        if (this->_Has_value) {
            return ::std:: move(*this);
        } else {
            return ::std:: forward<_Fn>(_Func)();
        }
    }
#line 616 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
#line 617 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

    using _Mybase::reset;
};

template <class _Ty>
optional(_Ty) -> optional<_Ty>;

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator==(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left == *_Right))) 

    requires requires {
        { *_Left == *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 632 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left == *_Right;
    }
    return _Left_has_value == _Right_has_value;
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator!=(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left != *_Right))) 

    requires requires {
        { *_Left != *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 649 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left != *_Right;
    }
    return _Left_has_value != _Right_has_value;
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left < *_Right))) 

    requires requires {
        { *_Left < *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 666 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left < *_Right;
    }
    return _Left_has_value < _Right_has_value;
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left > *_Right))) 

    requires requires {
        { *_Left > *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 683 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left > *_Right;
    }
    return _Left_has_value > _Right_has_value;
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator<=(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left <= *_Right))) 

    requires requires(const _Ty1& _Elem1, const _Ty2& _Elem2) {
        { *_Left <= *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 700 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left <= *_Right;
    }
    return _Left_has_value <= _Right_has_value;
}

 template <class _Ty1, class _Ty2>
[[nodiscard]] constexpr bool operator>=(const optional<_Ty1>& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left >= *_Right))) 

    requires requires {
        { *_Left >= *_Right } -> _Implicitly_convertible_to<bool>;
    }
#line 717 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
{
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left >= *_Right;
    }
    return _Left_has_value >= _Right_has_value;
}


 template <class _Ty1, three_way_comparable_with<_Ty1> _Ty2>
[[nodiscard]] constexpr compare_three_way_result_t<_Ty1, _Ty2> operator<=>(const optional<_Ty1>& _Left,
    const optional<_Ty2>& _Right) noexcept(noexcept(*_Left <=> *_Right))  {
    const bool _Left_has_value  = _Left.has_value();
    const bool _Right_has_value = _Right.has_value();
    if (_Left_has_value && _Right_has_value) {
        return *_Left <=> *_Right;
    }

    return _Left_has_value <=> _Right_has_value;
}
#line 739 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

 template <class _Ty>
[[nodiscard]] constexpr bool operator==(const optional<_Ty>& _Left, nullopt_t) noexcept {
    return !_Left.has_value();
}


 template <class _Ty>
[[nodiscard]] constexpr strong_ordering operator<=>(const optional<_Ty>& _Left, nullopt_t) noexcept {
    return _Left.has_value() <=> false;
}


















































#line 801 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

template <class _Ty>
using _Enable_if_bool_convertible = enable_if_t<is_convertible_v<_Ty, bool>, int>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_equal =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() == ::std:: declval<const _Rhs&>())>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_not_equal =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() != ::std:: declval<const _Rhs&>())>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_less =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() < ::std:: declval<const _Rhs&>())>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_greater =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() > ::std:: declval<const _Rhs&>())>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_less_equal =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() <= ::std:: declval<const _Rhs&>())>;

template <class _Lhs, class _Rhs>
using _Enable_if_comparable_with_greater_equal =
    _Enable_if_bool_convertible<decltype(::std:: declval<const _Lhs&>() >= ::std:: declval<const _Rhs&>())>;

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator==(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left == _Right)))  {
    if (_Left) {
        return *_Left == _Right;
    }
    return false;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator==(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left == *_Right)))  {
    if (_Right) {
        return _Left == *_Right;
    }
    return false;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_not_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator!=(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left != _Right)))  {
    if (_Left) {
        return *_Left != _Right;
    }
    return true;
}
 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_not_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator!=(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left != *_Right)))  {
    if (_Right) {
        return _Left != *_Right;
    }
    return true;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_less<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator<(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left < _Right)))  {
    if (_Left) {
        return *_Left < _Right;
    }
    return true;
}
 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_less<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator<(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left < *_Right)))  {
    if (_Right) {
        return _Left < *_Right;
    }
    return false;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_greater<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator>(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left > _Right)))  {
    if (_Left) {
        return *_Left > _Right;
    }
    return false;
}
 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_greater<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator>(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left > *_Right)))  {
    if (_Right) {
        return _Left > *_Right;
    }
    return true;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_less_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator<=(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left <= _Right)))  {
    if (_Left) {
        return *_Left <= _Right;
    }
    return true;
}
 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_less_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator<=(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left <= *_Right)))  {
    if (_Right) {
        return _Left <= *_Right;
    }
    return false;
}

 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_greater_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator>=(const optional<_Ty1>& _Left, const _Ty2& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(*_Left >= _Right)))  {
    if (_Left) {
        return *_Left >= _Right;
    }
    return false;
}
 template <class _Ty1, class _Ty2, _Enable_if_comparable_with_greater_equal<_Ty1, _Ty2> = 0>
[[nodiscard]] constexpr bool operator>=(const _Ty1& _Left, const optional<_Ty2>& _Right) noexcept(
    noexcept(_Fake_copy_init<bool>(_Left >= *_Right)))  {
    if (_Right) {
        return _Left >= *_Right;
    }
    return true;
}



 template <class _Ty1, class _Ty2>
    requires (!_Derived_from_specialization_of<_Ty2, optional>)
        && three_way_comparable_with<_Ty1, _Ty2>
[[nodiscard]] constexpr compare_three_way_result_t<_Ty1, _Ty2>
    operator<=>(const optional<_Ty1>& _Left, const _Ty2& _Right)
        noexcept(noexcept(*_Left <=> _Right))  {
    
    if (_Left) {
        return *_Left <=> _Right;
    }

    return strong_ordering::less;
}
#line 948 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"

 template <class _Ty, enable_if_t<is_move_constructible_v<_Ty> && is_swappable_v<_Ty>, int> = 0>
constexpr void swap(optional<_Ty>& _Left, optional<_Ty>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}

 template <class _Ty, enable_if_t<is_constructible_v<decay_t<_Ty>, _Ty>, int> = 0> 
[[nodiscard]] constexpr optional<decay_t<_Ty>> make_optional(_Ty&& _Value) noexcept(
    noexcept(optional<decay_t<_Ty>>{::std:: forward<_Ty>(_Value)}))  {
    return optional<decay_t<_Ty>>{::std:: forward<_Ty>(_Value)};
}
 template <class _Ty, class... _Types, enable_if_t<is_constructible_v<_Ty, _Types...>, int> = 0>
[[nodiscard]] constexpr optional<_Ty> make_optional(_Types&&... _Args) noexcept(
    noexcept(optional<_Ty>{in_place, ::std:: forward<_Types>(_Args)...}))  {
    return optional<_Ty>{in_place, ::std:: forward<_Types>(_Args)...};
}
 template <class _Ty, class _Elem, class... _Types,
    enable_if_t<is_constructible_v<_Ty, initializer_list<_Elem>&, _Types...>, int> = 0>
[[nodiscard]] constexpr optional<_Ty> make_optional(initializer_list<_Elem> _Ilist, _Types&&... _Args) noexcept(
    noexcept(optional<_Ty>{in_place, _Ilist, ::std:: forward<_Types>(_Args)...}))  {
    return optional<_Ty>{in_place, _Ilist, ::std:: forward<_Types>(_Args)...};
}

template <class _Ty>
struct hash<optional<_Ty>>
    : _Conditionally_enabled_hash<optional<_Ty>, is_default_constructible_v<hash<remove_const_t<_Ty>>>> {
    static size_t _Do_hash(const optional<_Ty>& _Opt) noexcept(_Is_nothrow_hashable<remove_const_t<_Ty>>::value) {
        constexpr size_t _Unspecified_value = 0;
        if (_Opt) {
            return hash<remove_const_t<_Ty>>{}(*_Opt);
        }

        return _Unspecified_value;
    }
};

}



#pragma warning(pop)
#pragma pack(pop)
#line 991 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
#line 992 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
#line 993 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\optional"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )












extern "C" {
struct _Min_max_element_t {
    const void* _Min;
    const void* _Max;
};








__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_1(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_2(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_4(
    const void* _First, const void* _Last, void* _Dest) noexcept;
__declspec(noalias) void __cdecl __std_reverse_copy_trivially_copyable_8(
    const void* _First, const void* _Last, void* _Dest) noexcept;

_Min_max_element_t __stdcall __std_minmax_element_1(const void* _First, const void* _Last, bool _Signed) noexcept;
_Min_max_element_t __stdcall __std_minmax_element_2(const void* _First, const void* _Last, bool _Signed) noexcept;
_Min_max_element_t __stdcall __std_minmax_element_4(const void* _First, const void* _Last, bool _Signed) noexcept;
_Min_max_element_t __stdcall __std_minmax_element_8(const void* _First, const void* _Last, bool _Signed) noexcept;
}

template <class _Ty>
::std:: pair<_Ty*, _Ty*> __std_minmax_element(_Ty* _First, _Ty* _Last) noexcept {
    constexpr bool _Signed = ::std:: is_signed_v<_Ty>;

    _Min_max_element_t _Res;

    if constexpr (sizeof(_Ty) == 1) {
        _Res = __std_minmax_element_1(_First, _Last, _Signed);
    } else if constexpr (sizeof(_Ty) == 2) {
        _Res = __std_minmax_element_2(_First, _Last, _Signed);
    } else if constexpr (sizeof(_Ty) == 4) {
        _Res = __std_minmax_element_4(_First, _Last, _Signed);
    } else if constexpr (sizeof(_Ty) == 8) {
        _Res = __std_minmax_element_8(_First, _Last, _Signed);
    } else {
        static_assert(::std:: _Always_false<_Ty>, "Unexpected size");
    }

    return {const_cast<_Ty*>(static_cast<const _Ty*>(_Res._Min)), const_cast<_Ty*>(static_cast<const _Ty*>(_Res._Max))};
}
#line 80 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

namespace std {







inline constexpr int _ISORT_MAX = 32; 

template <class _It>
inline constexpr _Iter_diff_t<_It> _Isort_max{_ISORT_MAX};

template <class _Diff>
constexpr ptrdiff_t _Temporary_buffer_size(const _Diff _Value) noexcept {
    
    using _CT = common_type_t<ptrdiff_t, _Diff>;
    return static_cast<ptrdiff_t>((::std:: min)(static_cast<_CT>(9223372036854775807i64), static_cast<_CT>(_Value)));
}

template <class _Ty>
struct _Optimistic_temporary_buffer { 
    static constexpr size_t _Optimistic_size  = 4096; 
    static constexpr size_t _Optimistic_count = (::std:: max)(static_cast<size_t>(1), _Optimistic_size / sizeof(_Ty));

    template <class _Diff>
    explicit _Optimistic_temporary_buffer(const _Diff _Requested_size) noexcept { 
        const auto _Attempt = _Temporary_buffer_size(_Requested_size);
        
        
        if (static_cast<size_t>(_Requested_size) <= _Optimistic_count) { 
            _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
            _Capacity = static_cast<ptrdiff_t>(_Requested_size); 
            return;
        }

        const pair<_Ty*, ptrdiff_t> _Raw = _Get_temporary_buffer<_Ty>(_Attempt);
        if (static_cast<size_t>(_Raw.second) > _Optimistic_count) { 
            _Data     = _Raw.first;
            _Capacity = _Raw.second;
            return;
        }

        
        _Return_temporary_buffer(_Raw.first);
        _Data     = reinterpret_cast<_Ty*>(&_Stack_space[0]);
        _Capacity = _Optimistic_count;
    }

    _Optimistic_temporary_buffer(const _Optimistic_temporary_buffer&)            = delete;
    _Optimistic_temporary_buffer& operator=(const _Optimistic_temporary_buffer&) = delete;

    ~_Optimistic_temporary_buffer() noexcept {
        if (static_cast<size_t>(_Capacity) > _Optimistic_count) {
            _Return_temporary_buffer(_Data);
        }
    }

    _Ty* _Data; 
    ptrdiff_t _Capacity;
    _Aligned_storage_t<sizeof(_Ty), alignof(_Ty)> _Stack_space[_Optimistic_count];
};


namespace ranges {
     template <class _In, class _Fun>
    struct in_fun_result {
         _In in;
         _Fun fun;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Fun&> _FFun>
        constexpr operator in_fun_result<_IIn, _FFun>() const& {
            return {in, fun};
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Fun> _FFun>
        constexpr operator in_fun_result<_IIn, _FFun>() && {
            return {::std:: move(in), ::std:: move(fun)};
        }
    };

     template <class _In1, class _In2, class _Out>
    struct in_in_out_result {
         _In1 in1;
         _In2 in2;
         _Out out;

        template <_Convertible_from<const _In1&> _IIn1, _Convertible_from<const _In2&> _IIn2,
            _Convertible_from<const _Out&> _OOut>
        constexpr operator in_in_out_result<_IIn1, _IIn2, _OOut>() const& {
            return {in1, in2, out};
        }

        template <_Convertible_from<_In1> _IIn1, _Convertible_from<_In2> _IIn2, _Convertible_from<_Out> _OOut>
        constexpr operator in_in_out_result<_IIn1, _IIn2, _OOut>() && {
            return {::std:: move(in1), ::std:: move(in2), ::std:: move(out)};
        }
    };

     template <class _In, class _Out1, class _Out2>
    struct in_out_out_result {
         _In in;
         _Out1 out1;
         _Out2 out2;

        template <_Convertible_from<const _In&> _IIn, _Convertible_from<const _Out1&> _OOut1,
            _Convertible_from<const _Out2&> _OOut2>
        constexpr operator in_out_out_result<_IIn, _OOut1, _OOut2>() const& {
            return {in, out1, out2};
        }

        template <_Convertible_from<_In> _IIn, _Convertible_from<_Out1> _OOut1, _Convertible_from<_Out2> _OOut2>
        constexpr operator in_out_out_result<_IIn, _OOut1, _OOut2>() && {
            return {::std:: move(in), ::std:: move(out1), ::std:: move(out2)};
        }
    };

     template <class _Ty>
    struct min_max_result {
         _Ty min;
         _Ty max;

        template <_Convertible_from<const _Ty&> _Ty2>
        constexpr operator min_max_result<_Ty2>() const& {
            return {min, max};
        }

        template <_Convertible_from<_Ty> _Ty2>
        constexpr operator min_max_result<_Ty2>() && {
            return {::std:: move(min), ::std:: move(max)};
        }
    };

     template <class _In>
    struct in_found_result {
         _In in;
        bool found;

        template <_Convertible_from<const _In&> _IIn>
        constexpr operator in_found_result<_IIn>() const& {
            return {in, found};
        }

        template <_Convertible_from<_In> _IIn>
        constexpr operator in_found_result<_IIn>() && {
            return {::std:: move(in), found};
        }
    };


     template <class _In, class _Ty>
    struct in_value_result {
         _In in;
         _Ty value;

        template <class _IIn, class _TTy>
            requires convertible_to<const _In&, _IIn> && convertible_to<const _Ty&, _TTy>
        constexpr operator in_value_result<_IIn, _TTy>() const& {
            return {in, value};
        }

        template <class _IIn, class _TTy>
            requires convertible_to<_In, _IIn> && convertible_to<_Ty, _TTy>
        constexpr operator in_value_result<_IIn, _TTy>() && {
            return {::std:: move(in), ::std:: move(value)};
        }
    };
#line 249 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
} 
#line 251 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Fn>
constexpr _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        _Func(*_UFirst);
    }

    return _Func;
}


 template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
void for_each(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Fn _Func) noexcept; 

 template <class _InIt, class _Diff, class _Fn>
constexpr _InIt for_each_n(_InIt _First, const _Diff _Count_raw, _Fn _Func) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UFirst = _Get_unwrapped_n(_First, _Count);
        do {
            _Func(*_UFirst);
            --_Count;
            ++_UFirst;
        } while (0 < _Count);

        _Seek_wrapped(_First, _UFirst);
    }

    return _First;
}

 template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt for_each_n(_ExPo&& _Exec, _FwdIt _First, _Diff _Count_raw, _Fn _Func) noexcept; 
#line 289 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Fun>
    using for_each_result = in_fun_result<_In, _Fun>;

    class _For_each_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirectly_unary_invocable<projected<_It, _Pj>> _Fn>
        constexpr for_each_result<_It, _Fn> operator()(_It _First, _Se _Last, _Fn _Func, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UResult = _For_each_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Func), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.fun)};
        }

        template <input_range _Rng, class _Pj = identity,
            indirectly_unary_invocable<projected<iterator_t<_Rng>, _Pj>> _Fn>
        constexpr for_each_result<borrowed_iterator_t<_Rng>, _Fn> operator()(
            _Rng&& _Range, _Fn _Func, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);

            auto _UResult = _For_each_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), ::std:: move(_Func), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.fun)};
        }

    private:
        template <class _It, class _Se, class _Pj, class _Fn>
        [[nodiscard]] static constexpr for_each_result<_It, _Fn> _For_each_unchecked(
            _It _First, const _Se _Last, _Fn _Func, _Pj _Proj) {
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                ::std:: invoke(_Func, ::std:: invoke(_Proj, *_First));
            }

            return {::std:: move(_First), ::std:: move(_Func)};
        }
    };

     inline constexpr _For_each_fn for_each{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Fun>
    using for_each_n_result = in_fun_result<_In, _Fun>;

    class _For_each_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, class _Pj = identity, indirectly_unary_invocable<projected<_It, _Pj>> _Fn>
        constexpr for_each_n_result<_It, _Fn> operator()(
            _It _First, iter_difference_t<_It> _Count, _Fn _Func, _Pj _Proj = {}) const {
            if (0 < _Count) {
                auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
                do {
                    ::std:: invoke(_Func, ::std:: invoke(_Proj, *_UFirst));
                    --_Count;
                    ++_UFirst;
                } while (0 < _Count);

                _Seek_wrapped(_First, ::std:: move(_UFirst));
            }

            return {::std:: move(_First), ::std:: move(_Func)};
        }
    };

     inline constexpr _For_each_n_fn for_each_n{_Not_quite_object::_Construct_tag{}};
} 
#line 370 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 375 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt find_if_not(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 396 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt adjacent_find(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; _UFirst = _UNext) {
            if (_Pred(*_UFirst, *_UNext)) {
                _ULast = _UFirst;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt adjacent_find(const _FwdIt _First, const _FwdIt _Last) { 
    return ::std:: adjacent_find(_First, _Last, equal_to<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt adjacent_find(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt adjacent_find(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last) noexcept  {
    
    return ::std:: adjacent_find(::std:: forward<_ExPo>(_Exec), _First, _Last, equal_to{});
}
#line 431 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Count_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr iter_difference_t<_It> operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            return _Count_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val, _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr range_difference_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            return _Count_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Ty, class _Pj>
        [[nodiscard]] static constexpr iter_difference_t<_It> _Count_unchecked(
            _It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj) {
            ;
            ;
            ;


            if constexpr (is_same_v<_Pj, identity> && _Vector_alg_in_find_is_safe<_It, _Ty>
                          && sized_sentinel_for<_Se, _It>) {
                if (!::std:: is_constant_evaluated()) {
                    if (!::std:: _Could_compare_equal_to_value_type<_It>(_Val)) {
                        return 0;
                    }

                    const auto _First_ptr = _To_address(_First);
                    const auto _Last_ptr  = _First_ptr + (_Last - _First);

                    return static_cast<iter_difference_t<_It>>(__std_count_trivial(_First_ptr, _Last_ptr, _Val));
                }
            }
#line 476 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Proj, *_First) == _Val) {
                    ++_Count;
                }
            }

            return _Count;
        }
    };

     inline constexpr _Count_fn count{_Not_quite_object::_Construct_tag{}};
} 
#line 491 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr _Iter_diff_t<_InIt> count_if(_InIt _First, _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst               = _Get_unwrapped(_First);
    const auto _ULast          = _Get_unwrapped(_Last);
    _Iter_diff_t<_InIt> _Count = 0;
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            ++_Count;
        }
    }

    return _Count;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _Iter_diff_t<_FwdIt> count_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 512 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Count_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr iter_difference_t<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            return _Count_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr range_difference_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            return _Count_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr iter_difference_t<_It> _Count_if_unchecked(
            _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            iter_difference_t<_It> _Count = 0;
            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    ++_Count;
                }
            }

            return _Count;
        }
    };

     inline constexpr _Count_if_fn count_if{_Not_quite_object::_Construct_tag{}};
} 
#line 555 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, const _InIt1 _Last1, _InIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
    while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
        ++_UFirst1;
        ++_UFirst2;
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) noexcept; 
#line 578 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr pair<_InIt1, _InIt2> mismatch(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2) noexcept  {
    
    return ::std:: mismatch(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, equal_to{});
}
#line 593 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr pair<_InIt1, _InIt2> mismatch(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    auto _ULast1       = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_InIt1> && _Is_ranges_random_iter_v<_InIt2>) {
        using _CT         = _Common_diff_t<_InIt1, _InIt2>;
        const _CT _Count1 = _ULast1 - _UFirst1;
        const _CT _Count2 = _ULast2 - _UFirst2;
        const auto _Count = static_cast<_Iter_diff_t<_InIt1>>((::std:: min)(_Count1, _Count2));
        _ULast1           = _UFirst1 + _Count;
        while (_UFirst1 != _ULast1 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    } else {
        while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2 && _Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_First2, _UFirst2);
    _Seek_wrapped(_First1, _UFirst1);
    return {_First1, _First2};
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; 
#line 631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr pair<_InIt1, _InIt2> mismatch(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: mismatch(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt1, _FwdIt2> mismatch(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) noexcept  {
    
    return ::std:: mismatch(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 646 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    template <input_iterator _It1, input_iterator _It2, _Integer_like _Size, class _Pr, class _Pj1, class _Pj2>
        requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
    [[nodiscard]] constexpr bool _Equal_count(
        _It1 _First1, _It2 _First2, _Size _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        ;
        if constexpr (_Equal_memcmp_is_safe<_It1, _It2, _Pr> && same_as<_Pj1, identity> && same_as<_Pj2, identity>) {
            if (!::std:: is_constant_evaluated()) {
                return _Memcmp_count(_First1, _First2, static_cast<size_t>(_Count)) == 0;
            }
        }

        for (; _Count != 0; ++_First1, (void) ++_First2, --_Count) {
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                return false;
            }
        }

        return true;
    }

    class _Equal_fn : private _Not_quite_object {
    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Equal_4(
            _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;

            for (;;) {
                if (_First1 == _Last1) {
                    return _First2 == _Last2;
                } else if (_First2 == _Last2) {
                    return false;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    return false;
                }

                ++_First1;
                ++_First2;
            }
        }

    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count = _ULast1 - _UFirst1;
                if (_Count != _ULast2 - _UFirst2) {
                    return false;
                }

                return ::std::ranges:: _Equal_count(::std:: move(_UFirst1), ::std:: move(_UFirst2), _Count, _Pass_fn(_Pred),
                    _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            } else {
                return _Equal_4(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2), ::std:: move(_ULast2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                using _Size1      = _Make_unsigned_like_t<range_size_t<_Rng1>>;
                const auto _Count = static_cast<_Size1>(::std::ranges:: size(_Range1));
                using _Size2      = _Make_unsigned_like_t<range_size_t<_Rng2>>;
                if (_Count != static_cast<_Size2>(::std::ranges:: size(_Range2))) {
                    return false;
                }
                return ::std::ranges:: _Equal_count(
                    _Ubegin(_Range1), _Ubegin(_Range2), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            } else {
                return _Equal_4(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2), _Pass_fn(_Pred),
                    _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            }
        }
    };

     inline constexpr _Equal_fn equal{_Not_quite_object::_Construct_tag{}};
} 
#line 747 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));

    for (;; ++_UFirst1, (void) ++_UFirst2) { 
        if (_UFirst1 == _ULast1) { 
            return true;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) { 
            break;
        }
    }

    
    
    const auto _Dist2 = static_cast<_Iter_diff_t<_FwdIt2>>(::std:: distance(_UFirst1, _ULast1));
    return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, ::std:: next(_UFirst2, _Dist2), _Pass_fn(_Pred));
}

 template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] constexpr bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, equal_to<>{});
}

 template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr bool is_permutation(
    _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1 = _Get_unwrapped(_First1);
    auto _ULast1  = _Get_unwrapped(_Last1);
    auto _UFirst2 = _Get_unwrapped(_First2);
    auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_FwdIt1> && _Is_ranges_random_iter_v<_FwdIt2>) {
        if (_ULast1 - _UFirst1 != _ULast2 - _UFirst2) {
            return false;
        }

        for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2) { 
            if (!_Pred(*_UFirst1, *_UFirst2)) {
                
                return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred));
            }
        }

        return true;
    } else {
        static_assert(_Is_ranges_fwd_iter_v<_FwdIt1> && _Is_ranges_fwd_iter_v<_FwdIt2>,
            "Iterators must be at least forward iterators");
        for (;; ++_UFirst1, (void) ++_UFirst2) { 
            if (_UFirst1 == _ULast1) {
                return _UFirst2 == _ULast2;
            }

            if (_UFirst2 == _ULast2) {
                return false;
            }

            if (!_Pred(*_UFirst1, *_UFirst2)) { 
                break;
            }
        }

        auto _Next1 = _UFirst1;
        auto _Next2 = _UFirst2;
        for (;; ++_Next1, (void) ++_Next2) { 
            if (_Next1 == _ULast1) {
                if (_Next2 == _ULast2) {
                    return _Check_match_counts(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred));
                }

                return false; 
            }

            if (_Next2 == _ULast2) {
                return false; 
            }
        }
    }
}

 template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] constexpr bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) {
    
    return ::std:: is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


namespace ranges {
    class _Is_permutation_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pj1 = identity, class _Pj2 = identity,
            indirect_equivalence_relation<projected<_It1, _Pj1>, projected<_It2, _Pj2>> _Pr = ranges::equal_to>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if constexpr (sized_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count = _ULast1 - _UFirst1;
                if (_ULast2 - _UFirst2 != _Count) {
                    return false;
                }

                return _Is_permutation_sized(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            } else {
                return _Is_permutation_unsized(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pj1 = identity, class _Pj2 = identity,
            indirect_equivalence_relation<projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>> _Pr =
                ranges::equal_to>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (sized_range<_Rng1> && sized_range<_Rng2>) {
                const auto _Count = ::std::ranges:: distance(_Range1);
                if (::std::ranges:: distance(_Range2) != _Count) {
                    return false;
                }

                return _Is_permutation_sized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2), _Count,
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            } else {
                return _Is_permutation_unsized(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            }
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Is_permutation_sized(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            iter_difference_t<_It1> _Count, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
#line 903 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
            ;
            ;

            for (;; ++_First1, (void) ++_First2, --_Count) { 
                if (_Count == 0) { 
                    return true;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) { 
                    break;
                }
            }

            if (_Count == 1) { 
                return false;
            }
            

            if constexpr (bidirectional_iterator<_It1> && bidirectional_iterator<_It2>) {
                
                auto _Final1 = _Find_last_iterator(_First1, _Last1, _Count);
                auto _Final2 = _Find_last_iterator(_First2, _Last2, _Count);

                for (;;) { 
                    --_Final1;
                    --_Final2;
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Final1), ::std:: invoke(_Proj2, *_Final2))) { 
                        break;
                    }

                    if (--_Count == 1) {
                        return false; 
                    }
                }
                

                
                

                const auto _ProjectedPred = [&]<class _Ty1, class _Ty2>(_Ty1&& _Left, _Ty2&& _Right) -> bool {
                    return ::std:: invoke(_Pred, ::std:: invoke(_Proj1, ::std:: forward<_Ty1>(_Left)),
                        ::std:: invoke(_Proj2, ::std:: forward<_Ty2>(_Right)));
                };

                const _TrimResult _Res = _Trim_completely(_First1, _Final1, _First2, _Final2, _ProjectedPred);

                if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
                    return _Res == _TrimResult::_ReturnTrue;
                }

                ++_Final1;
                ++_Final2;
                
                

                
                
                
                
                
                

                return _Match_counts(::std:: move(_First1), ::std:: move(_Final1), ::std:: move(_First2), ::std:: move(_Final2),
                    _Pred, _Proj1, _Proj2);
            } else {
                return _Match_counts(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_First2), ::std:: move(_Last2),
                    _Pred, _Proj1, _Proj2);
            }
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Is_permutation_unsized(
            _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
#line 982 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            for (;; ++_First1, (void) ++_First2) { 
                if (_First1 == _Last1) { 
                    return _First2 == _Last2;
                } else if (_First2 == _Last2) { 
                    return false;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) { 
                    break;
                }
            }
            

            
            auto _Final1 = _First1;
            auto _Final2 = _First2;
            for (;;) {
                ++_Final1;
                ++_Final2;
                if (_Final1 == _Last1) {
                    if (_Final2 == _Last2) {
                        break; 
                    }

                    return false; 
                } else if (_Final2 == _Last2) {
                    return false; 
                }
            }
            

            if constexpr (bidirectional_iterator<_It1> && bidirectional_iterator<_It2>) {
                for (;;) { 
                    if (--_Final1 == _First1) {
                        return false; 
                    }
                    --_Final2; 

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Final1), ::std:: invoke(_Proj2, *_Final2))) { 
                        break;
                    }
                }
                
                

                
                

                const auto _ProjectedPred = [&]<class _Ty1, class _Ty2>(_Ty1&& _Left, _Ty2&& _Right) -> bool {
                    return ::std:: invoke(_Pred, ::std:: invoke(_Proj1, ::std:: forward<_Ty1>(_Left)),
                        ::std:: invoke(_Proj2, ::std:: forward<_Ty2>(_Right)));
                };

                const _TrimResult _Res = _Trim_completely(_First1, _Final1, _First2, _Final2, _ProjectedPred);

                if (_Res != _TrimResult::_HaveWorkAfterTrimming) {
                    return _Res == _TrimResult::_ReturnTrue;
                }

                ++_Final1;
                ++_Final2;
                
                

                
                
                
                
                
                
            }

            return _Match_counts(
                ::std:: move(_First1), ::std:: move(_Final1), ::std:: move(_First2), ::std:: move(_Final2), _Pred, _Proj1, _Proj2);
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Match_counts(const _It1 _First1, const _Se1 _Last1, const _It2 _First2,
            const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
#line 1068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            for (auto _Current = _First1; _Current != _Last1; ++_Current) {
                bool _Found = false;
                auto _Mid1  = _First1;
                for (; _Mid1 != _Current; ++_Mid1) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Current), ::std:: invoke(_Proj1, *_Mid1))) {
                        
                        _Found = true;
                        break;
                    }
                }

                if (_Found) {
                    continue;
                }

                
                iter_difference_t<_It1> _Occurrences = 1;
                while (++_Mid1 != _Last1) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Current), ::std:: invoke(_Proj1, *_Mid1))) {
                        ++_Occurrences;
                    }
                }

                
                for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Current), ::std:: invoke(_Proj2, *_Mid2))) {
                        if (--_Occurrences < 0) {
                            
                            return false;
                        }
                    }
                }

                if (_Occurrences != 0) {
                    
                    return false;
                }
            }

            return true;
        }
    };

     inline constexpr _Is_permutation_fn is_permutation{_Not_quite_object::_Construct_tag{}};
} 
#line 1115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool all_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 1134 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _All_of_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            return _All_of_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            return _All_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr bool _All_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    return false;
                }
            }

            return true;
        }
    };

     inline constexpr _All_of_fn all_of{_Not_quite_object::_Construct_tag{}};
} 
#line 1176 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr bool any_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return true;
        }
    }

    return false;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool any_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 1196 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Any_of_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            return _Any_of_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            return _Any_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr bool _Any_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    return true;
                }
            }

            return false;
        }
    };

     inline constexpr _Any_of_fn any_of{_Not_quite_object::_Construct_tag{}};
} 
#line 1238 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr bool none_of(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            return false;
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool none_of(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 1258 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _None_of_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            return _None_of_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            return _None_of_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr bool _None_of_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    return false;
                }
            }

            return true;
        }
    };

     inline constexpr _None_of_fn none_of{_Not_quite_object::_Construct_tag{}};


    class _Contains_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            const auto _ULast = _Unwrap_sent<_It>(::std:: move(_Last));
            const auto _UResult =
                ::std::ranges:: _Find_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _ULast, _Val, _Pass_fn(_Proj));
            return _UResult != _ULast;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            const auto _UResult = ::std::ranges:: _Find_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));
            return _UResult != _Uend(_Range);
        }
    };

     inline constexpr _Contains_fn contains{_Not_quite_object::_Construct_tag{}};

    class _Contains_subrange_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            if (_UFirst2 == _ULast2) {
                return true;
            }

            const auto _Match = ::std::ranges:: search(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_UFirst2),
                ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            return !_Match.empty();
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if (::std::ranges:: empty(_Range2)) {
                return true;
            }

            const auto _Match = ::std::ranges:: search(_Range1, _Range2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            return !_Match.empty();
        }
    };

     inline constexpr _Contains_subrange_fn contains_subrange{_Not_quite_object::_Construct_tag{}};
#line 1362 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

     template <class _In, class _Out>
    using copy_n_result = in_out_result<_In, _Out>;

    class _Copy_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr copy_n_result<_It, _Out> operator()(_It _First, iter_difference_t<_It> _Count, _Out _Result) const {
            auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
            if constexpr (_Iter_copy_cat<decltype(_UFirst), _Out>::_Bitcopy_assignable) {
                if (!::std:: is_constant_evaluated()) {
                    _Result = _Copy_memmove_n(_UFirst, static_cast<size_t>(_Count), ::std:: move(_Result));
                    _UFirst += _Count;
                    _Seek_wrapped(_First, ::std:: move(_UFirst));
                    return {::std:: move(_First), ::std:: move(_Result)};
                }
            }

            for (; _Count > 0; ++_UFirst, (void) ++_Result, --_Count) {
                *_Result = *_UFirst;
            }

            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Copy_n_fn copy_n{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Out>
    using copy_backward_result = in_out_result<_In, _Out>;

    class _Copy_backward_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It1, sentinel_for<_It1> _Se1, bidirectional_iterator _It2>
            requires indirectly_copyable<_It1, _It2>
        constexpr copy_backward_result<_It1, _It2> operator()(_It1 _First, _Se1 _Last, _It2 _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se1>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It1>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Result = _Copy_backward_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), ::std:: move(_Result));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <bidirectional_range _Rng, bidirectional_iterator _It>
            requires indirectly_copyable<iterator_t<_Rng>, _It>
        constexpr copy_backward_result<borrowed_iterator_t<_Rng>, _It> operator()(_Rng&& _Range, _It _Result) const {
            auto _ULast = _Get_final_iterator_unwrapped(_Range);
            _Result     = _Copy_backward_unchecked(_Ubegin(_Range), _ULast, ::std:: move(_Result));
            return {_Rewrap_iterator(_Range, ::std:: move(_ULast)), ::std:: move(_Result)};
        }
    };

     inline constexpr _Copy_backward_fn copy_backward{_Not_quite_object::_Construct_tag{}};
} 
#line 1424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt, class _Pr>
constexpr _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}
#line 1452 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Out>
    using copy_if_result = in_out_result<_In, _Out>;

    class _Copy_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires indirectly_copyable<_It, _Out>
        constexpr copy_if_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Copy_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result), _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Copy_if_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                ::std:: move(_Result), _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It, class _Se, class _Out, class _Pj, class _Pr>
        [[nodiscard]] static constexpr copy_if_result<_It, _Out> _Copy_if_unchecked(
            _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_Result = *_First;
                    ++_Result;
                }
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Copy_if_fn copy_if{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Out>
    using move_result = in_out_result<_In, _Out>;

    template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
        requires indirectly_movable<_It, _Out>
    constexpr move_result<_It, _Out> _Move_unchecked(_It _First, _Se _Last, _Out _Result) {
        if constexpr (_Iter_move_cat<_It, _Out>::_Bitcopy_assignable) {
            if (!::std:: is_constant_evaluated()) {
                auto _Final = ::std::ranges:: next(_First, ::std:: move(_Last));
                _Result     = _Copy_memmove(::std:: move(_First), _Final, ::std:: move(_Result));
                return {::std:: move(_Final), ::std:: move(_Result)};
            }
        }

        for (; _First != _Last; ++_First, (void) ++_Result) {
            *_Result = ::std::ranges:: iter_move(_First);
        }

        return {::std:: move(_First), ::std:: move(_Result)};
    }

    class _Move_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_movable<_It, _Out>
        constexpr move_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = ::std::ranges:: _Move_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out>
            requires indirectly_movable<iterator_t<_Rng>, _Out>
        constexpr move_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
            auto _First = ::std::ranges:: begin(_Range);
            auto _UResult =
                ::std::ranges:: _Move_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), ::std:: move(_Result));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }
    };

     inline constexpr _Move_fn move{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Out>
    using move_backward_result = in_out_result<_In, _Out>;

    
    template <bidirectional_iterator _It1, bidirectional_iterator _It2>
        requires indirectly_movable<_It1, _It2>
    constexpr _It2 _Move_backward_common(const _It1 _First, _It1 _Last, _It2 _Result) {
        if constexpr (_Iter_move_cat<_It1, _It2>::_Bitcopy_assignable) {
            if (!::std:: is_constant_evaluated()) {
                return _Copy_backward_memmove(_First, _Last, _Result);
            }
        }

        while (_First != _Last) {
            *--_Result = ::std::ranges:: iter_move(--_Last);
        }

        return _Result;
    }

    class _Move_backward_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It1, sentinel_for<_It1> _Se1, bidirectional_iterator _It2>
            requires indirectly_movable<_It1, _It2>
        constexpr move_backward_result<_It1, _It2> operator()(_It1 _First, _Se1 _Last, _It2 _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se1>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It1>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Result = ::std::ranges:: _Move_backward_common(::std:: move(_UFirst), ::std:: move(_ULast), ::std:: move(_Result));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <bidirectional_range _Rng, bidirectional_iterator _It>
            requires indirectly_movable<iterator_t<_Rng>, _It>
        constexpr move_backward_result<borrowed_iterator_t<_Rng>, _It> operator()(_Rng&& _Range, _It _Result) const {
            auto _ULast = _Get_final_iterator_unwrapped(_Range);
            _Result     = ::std::ranges:: _Move_backward_common(_Ubegin(_Range), _ULast, ::std:: move(_Result));
            return {_Rewrap_iterator(_Range, ::std:: move(_ULast)), ::std:: move(_Result)};
        }
    };

     inline constexpr _Move_backward_fn move_backward{_Not_quite_object::_Construct_tag{}};
} 
#line 1605 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt1, class _OutIt2, class _Pr>
constexpr pair<_OutIt1, _OutIt2> partition_copy(
    _InIt _First, _InIt _Last, _OutIt1 _Dest_true, _OutIt2 _Dest_false, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest_true  = _Get_unwrapped_unverified(_Dest_true);
    auto _UDest_false = _Get_unwrapped_unverified(_Dest_false);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UDest_true = *_UFirst;
            ++_UDest_true;
        } else {
            *_UDest_false = *_UFirst;
            ++_UDest_false;
        }
    }

    _Seek_wrapped(_Dest_false, _UDest_false);
    _Seek_wrapped(_Dest_true, _UDest_true);
    return {_Dest_true, _Dest_false};
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
pair<_FwdIt2, _FwdIt3> partition_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest_true, _FwdIt3 _Dest_false,
    _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: partition_copy(_First, _Last, _Dest_true, _Dest_false, _Pass_fn(_Pred));
}


namespace ranges {
     template <class _In, class _Out1, class _Out2>
    using partition_copy_result = in_out_out_result<_In, _Out1, _Out2>;

    class _Partition_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out1, weakly_incrementable _Out2,
            class _Pj = identity, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires indirectly_copyable<_It, _Out1> && indirectly_copyable<_It, _Out2>
        constexpr partition_copy_result<_It, _Out1, _Out2> operator()(
            _It _First, _Se _Last, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Partition_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Get_unwrapped_unverified(::std:: move(_Dest_true)),
                _Get_unwrapped_unverified(::std:: move(_Dest_false)), _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Dest_true, ::std:: move(_UResult.out1));
            _Seek_wrapped(_Dest_false, ::std:: move(_UResult.out2));
            return {::std:: move(_First), ::std:: move(_Dest_true), ::std:: move(_Dest_false)};
        }

        template <input_range _Rng, weakly_incrementable _Out1, weakly_incrementable _Out2, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires indirectly_copyable<iterator_t<_Rng>, _Out1> && indirectly_copyable<iterator_t<_Rng>, _Out2>
        constexpr partition_copy_result<borrowed_iterator_t<_Rng>, _Out1, _Out2> operator()(
            _Rng&& _Range, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Partition_copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                _Get_unwrapped_unverified(::std:: move(_Dest_true)), _Get_unwrapped_unverified(::std:: move(_Dest_false)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Dest_true, ::std:: move(_UResult.out1));
            _Seek_wrapped(_Dest_false, ::std:: move(_UResult.out2));
            return {::std:: move(_First), ::std:: move(_Dest_true), ::std:: move(_Dest_false)};
        }

    private:
        template <class _It, class _Se, class _Out1, class _Out2, class _Pr, class _Pj>
        [[nodiscard]] static constexpr partition_copy_result<_It, _Out1, _Out2> _Partition_copy_unchecked(
            _It _First, const _Se _Last, _Out1 _Dest_true, _Out2 _Dest_false, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_Dest_true = *_First;
                    ++_Dest_true;
                } else {
                    *_Dest_false = *_First;
                    ++_Dest_false;
                }
            }

            return {::std:: move(_First), ::std:: move(_Dest_true), ::std:: move(_Dest_false)};
        }
    };

     inline constexpr _Partition_copy_fn partition_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 1710 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 1711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _Pr>
[[nodiscard]] constexpr bool is_partitioned(const _InIt _First, const _InIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    for (;; ++_UFirst) { 
        if (_UFirst == _ULast) {
            return true;
        }

        if (!_Pred(*_UFirst)) {
            break;
        }
    }

    while (++_UFirst != _ULast) { 
        if (_Pred(*_UFirst)) {
            return false; 
        }
    }

    return true;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool is_partitioned(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 1742 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Is_partitioned_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            return _Is_partitioned_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            return _Is_partitioned_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
        }

    private:
        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr bool _Is_partitioned_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            for (;; ++_First) { 
                if (_First == _Last) {
                    return true;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    break;
                }
            }

            while (++_First != _Last) { 
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    return false; 
                }
            }

            return true;
        }
    };

     inline constexpr _Is_partitioned_fn is_partitioned{_Not_quite_object::_Construct_tag{}};
} 
#line 1794 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _Count       = ::std:: distance(_UFirst, _ULast);
    while (0 < _Count) { 
        const auto _Count2 = static_cast<_Iter_diff_t<_FwdIt>>(_Count / 2);
        const auto _UMid   = ::std:: next(_UFirst, _Count2);

        if (_Pred(*_UMid)) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2;
            --_Count;
        } else {
            _Count = _Count2;
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


namespace ranges {
    class _Partition_point_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            if constexpr (sized_sentinel_for<_Se, _It>) {
                const auto _Length = _Unwrap_sent<_It>(::std:: move(_Last)) - _UFirst;
                _UFirst = _Partition_point_n_unchecked(::std:: move(_UFirst), _Length, _Pass_fn(_Pred), _Pass_fn(_Proj));
            } else {
                _UFirst = _Partition_point_unchecked(
                    ::std:: move(_UFirst), _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
            }

            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            if constexpr (sized_range<_Rng>) {
                const auto _Length = ::std::ranges:: distance(_Range);
                auto _UFirst = _Partition_point_n_unchecked(_Ubegin(_Range), _Length, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_UFirst));
            } else {
                auto _UFirst =
                    _Partition_point_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_UFirst));
            }
        }

    private:
        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static constexpr _It _Partition_point_n_unchecked(
            _It _First, iter_difference_t<_It> _Length, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            while (_Length > 0) {
                const auto _Half = static_cast<iter_difference_t<_It>>(_Length / 2);
                auto _Mid        = ::std::ranges:: next(_First, _Half);
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid))) { 
                    _First = ::std:: move(_Mid);
                    ++_First;
                    _Length -= _Half;
                    --_Length;
                } else { 
                    _Length = _Half;
                }
            }

            return _First;
        }

        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr _It _Partition_point_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            
            
            iter_difference_t<_It> _Skip = 2;
            for (;;) {
                auto _Mid = _First;
                _Skip -= ::std::ranges:: advance(_Mid, _Skip, _Last);
                if (_Mid == _Last) { 
                    break;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid))) { 
                    break;
                }

                _First = ::std:: move(_Mid);
                ++_First;

                using _Uty = _Make_unsigned_like_t<iter_difference_t<_It>>;
                if (static_cast<_Uty>(_Skip) <= (static_cast<_Uty>(-1) >> 1)) {
                    _Skip <<= 1;
                }
            }

            return _Partition_point_n_unchecked(::std:: move(_First), _Skip, _Pred, _Proj);
        }
    };

     inline constexpr _Partition_point_fn partition_point{_Not_quite_object::_Construct_tag{}};
} 
#line 1916 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool _Equal_rev_pred_unchecked(_InIt1 _First1, _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred) {
    
    if constexpr (_Equal_memcmp_is_safe<_InIt1, _InIt2, _Pr>) {

        if (!::std:: is_constant_evaluated())
#line 1924 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
        {
            return _Memcmp_ranges(_First2, _Last2, _First1) == 0;
        }
    }

    for (; _First2 != _Last2; ++_First1, (void) ++_First2) {
        if (!_Pred(*_First1, *_First2)) {
            return false;
        }
    }

    return true;
}

 template <class _FwdItHaystack, class _FwdItPat, class _Pr>
[[nodiscard]] constexpr _FwdItHaystack search(_FwdItHaystack _First1, _FwdItHaystack _Last1, const _FwdItPat _First2,
    const _FwdItPat _Last2, _Pr _Pred) { 
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_FwdItHaystack> && _Is_ranges_random_iter_v<_FwdItPat>) {
        const _Iter_diff_t<_FwdItPat> _Count2 = _ULast2 - _UFirst2;
        if (_ULast1 - _UFirst1 >= _Count2) {
            const auto _Last_possible = _ULast1 - static_cast<_Iter_diff_t<_FwdItHaystack>>(_Count2);
            for (;; ++_UFirst1) {
                if (_Equal_rev_pred_unchecked(_UFirst1, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    break;
                }

                if (_UFirst1 == _Last_possible) {
                    break;
                }
            }
        }
    } else {
        for (;; ++_UFirst1) { 
            auto _UMid1 = _UFirst1;
            for (auto _UMid2 = _UFirst2;; ++_UMid1, (void) ++_UMid2) {
                if (_UMid2 == _ULast2) {
                    _Seek_wrapped(_Last1, _UFirst1);
                    return _Last1;
                } else if (_UMid1 == _ULast1) {
                    return _Last1;
                } else if (!_Pred(*_UMid1, *_UMid2)) {
                    break;
                }
            }
        }
    }

    return _Last1;
}


 template <class _ExPo, class _FwdItHaystack, class _FwdItPat, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdItHaystack search(_ExPo&& _Exec, _FwdItHaystack _First1, _FwdItHaystack _Last1, _FwdItPat _First2,
    _FwdItPat _Last2, _Pr _Pred) noexcept; 
#line 1987 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdItHaystack, class _FwdItPat>
[[nodiscard]] constexpr _FwdItHaystack search(
    const _FwdItHaystack _First1, const _FwdItHaystack _Last1, const _FwdItPat _First2, const _FwdItPat _Last2) {
    
    return ::std:: search(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdItHaystack, class _FwdItPat, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdItHaystack search(_ExPo&& _Exec, const _FwdItHaystack _First1, const _FwdItHaystack _Last1,
    const _FwdItPat _First2, const _FwdItPat _Last2) noexcept  {
    
    return ::std:: search(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 2003 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdItHaystack, class _Searcher>
[[nodiscard]] constexpr _FwdItHaystack search(
    const _FwdItHaystack _First, const _FwdItHaystack _Last, const _Searcher& _Search) {
    
    return _Search(_First, _Last).first;
}

 template <class _FwdIt, class _Diff, class _Ty, class _Pr>
[[nodiscard]] constexpr _FwdIt search_n(
    const _FwdIt _First, _FwdIt _Last, const _Diff _Count_raw, const _Ty& _Val, _Pr _Pred) {
    
    const _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (_Count <= 0) {
        return _First;
    }

    if (static_cast<uintmax_t>(_Count) > static_cast<uintmax_t>((numeric_limits<_Iter_diff_t<_FwdIt>>::max)())) {
        
        return _Last;
    }

    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Is_ranges_random_iter_v<_FwdIt>) {
        const auto _Count_diff = static_cast<_Iter_diff_t<_FwdIt>>(_Count);
        auto _UOld_first       = _UFirst;
        for (_Iter_diff_t<_FwdIt> _Inc = 0; _Count_diff <= _ULast - _UOld_first;) { 
            _UFirst = _UOld_first + _Inc;
            if (_Pred(*_UFirst, _Val)) { 
                _Iter_diff_t<_FwdIt> _Count1 = _Count_diff;
                auto _UMid                   = _UFirst;

                while (_UOld_first != _UFirst && _Pred(*_Prev_iter(_UFirst), _Val)) { 
                    --_Count1;
                    --_UFirst;
                }

                if (_Count1 <= _ULast - _UMid) {
                    for (;;) { 
                        if (--_Count1 == 0) {
                            _Seek_wrapped(_Last, _UFirst); 
                            return _Last;
                        } else if (!_Pred(*++_UMid, _Val)) { 
                            break;
                        }
                    }
                }
                _UOld_first = ++_UMid; 
                _Inc        = 0;
            } else { 
                _UOld_first = _Next_iter(_UFirst);
                _Inc        = _Count_diff - 1;
            }
        }
    } else {
        for (; _UFirst != _ULast; ++_UFirst) {
            if (_Pred(*_UFirst, _Val)) { 
                auto _UMid = _UFirst;

                for (_Algorithm_int_t<_Diff> _Count1 = _Count;;) {
                    if (--_Count1 == 0) {
                        _Seek_wrapped(_Last, _UFirst); 
                        return _Last;
                    } else if (++_UMid == _ULast) {
                        return _Last; 
                    } else if (!_Pred(*_UMid, _Val)) { 
                        break;
                    }
                }

                _UFirst = _UMid; 
            }
        }
    }

    return _Last;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Ty, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt search_n(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Diff _Count_raw, const _Ty& _Val,
    _Pr _Pred) noexcept; 
#line 2089 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Diff, class _Ty>
[[nodiscard]] constexpr _FwdIt search_n(const _FwdIt _First, const _FwdIt _Last, const _Diff _Count, const _Ty& _Val) {
    
    return ::std:: search_n(_First, _Last, _Count, _Val, equal_to<>{});
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt search_n(_ExPo&& _Exec, const _FwdIt _First, const _FwdIt _Last, const _Diff _Count,
    const _Ty& _Val) noexcept  { 
    return ::std:: search_n(::std:: forward<_ExPo>(_Exec), _First, _Last, _Count, _Val, equal_to{});
}
#line 2103 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Search_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pr = ranges::equal_to,
            class _Pj = identity>
            requires indirectly_comparable<_It, const _Ty*, _Pr, _Pj>
        [[nodiscard]] constexpr subrange<_It> operator()(_It _First, _Se _Last, const iter_difference_t<_It> _Count,
            const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            if (_Count <= 0) {
                return {_First, _First};
            }

            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Unwrap_sent<_It>(::std:: move(_Last));

            if constexpr (sized_sentinel_for<_Se, _It>) {
                const auto _Dist = _ULast - _UFirst;
                auto _UResult =
                    _Search_n_sized(::std:: move(_UFirst), _Dist, _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_n_unsized(
                    ::std:: move(_UFirst), ::std:: move(_ULast), _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng, class _Ty, class _Pr = ranges::equal_to, class _Pj = identity>
            requires indirectly_comparable<iterator_t<_Rng>, const _Ty*, _Pr, _Pj>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, const range_difference_t<_Rng> _Count,
            const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);

            if (_Count <= 0) {
                return {_First, _First};
            }

            if constexpr (sized_range<_Rng>) {
                const auto _Dist = ::std::ranges:: distance(_Range);

                auto _UResult =
                    _Search_n_sized(_Get_unwrapped(_First), _Dist, _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_First, ::std:: move(_UResult));
            } else {
                auto _UResult = _Search_n_unsized(
                    _Unwrap_range_iter<_Rng>(_First), _Uend(_Range), _Val, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_First, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It, class _Ty, class _Pr, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Search_n_sized(_It _First, iter_difference_t<_It> _Dist,
            const _Ty& _Val, const iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;
            

            if constexpr (bidirectional_iterator<_It>) {
                if (_Dist < _Count) {
                    ::std::ranges:: advance(_First, _Dist);
                    return {_First, _First};
                }

                auto _Last = ::std::ranges:: next(_First, _Count);
                auto _Mid1 = _First;
                auto _Mid2 = _Last;
                for (;;) {
                    
                    
                    
                    

                    --_Mid2;
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid2), _Val)) { 
                        ++_Mid2;
                        const auto _Delta = ::std::ranges:: distance(_First, _Mid2);

                        if (_Dist - _Delta < _Count) { 
                            _First = ::std:: move(_Last);
                            _Dist -= _Count;
                            break;
                        }

                        _First = ::std:: move(_Mid2);
                        _Dist -= _Delta;
                        _Mid1 = _Last;
                        ::std::ranges:: advance(_Last, _Delta);
                        _Mid2 = _Last;
                        continue;
                    }

                    if (_Mid2 == _Mid1) { 
                        return {::std:: move(_First), ::std:: move(_Last)};
                    }
                }
            } else {
                for (; _Dist >= _Count; ++_First, (void) --_Dist) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), _Val)) {
                        auto _Saved = _First;
                        for (iter_difference_t<_It> _Len = 0;;) {
                            ++_First;
                            if (++_Len == _Count) { 
                                return {::std:: move(_Saved), ::std:: move(_First)};
                            }

                            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), _Val)) { 
                                _Dist -= _Len;
                                break;
                            }
                        }
                    }
                }
            }

            ::std::ranges:: advance(_First, _Dist);
            return {_First, _First};
        }

        template <class _It, class _Se, class _Ty, class _Pr, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Search_n_unsized(
            _It _First, const _Se _Last, const _Ty& _Val, const iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), _Val)) {
                    auto _Saved = _First;
                    for (auto _Len = _Count;;) {
                        ++_First;
                        if (--_Len == 0) { 
                            return {::std:: move(_Saved), ::std:: move(_First)};
                        }

                        if (_First == _Last) { 
                            return {_First, _First};
                        }

                        if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), _Val)) { 
                            break;
                        }
                    }
                }
            }

            return {_First, _First};
        }
    };

     inline constexpr _Search_n_fn search_n{_Not_quite_object::_Construct_tag{}};


    class _Starts_with_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            auto _UFirst1      = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1       = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2      = _Unwrap_iter<_Se2>(::std:: move(_First2));
            const auto _ULast2 = _Unwrap_sent<_It2>(::std:: move(_Last2));
            if constexpr (_Sized_or_unreachable_sentinel_for<_Se1, _It1> && sized_sentinel_for<_Se2, _It2>) {
                const iter_difference_t<_It2> _Count2 = _ULast2 - _UFirst2;
                if constexpr (sized_sentinel_for<_Se1, _It1>) {
                    if (_Count2 > _ULast1 - _UFirst1) {
                        return false;
                    }
                }

                return ::std::ranges:: _Equal_count(::std:: move(_UFirst1), ::std:: move(_UFirst2),
                    static_cast<iter_difference_t<_It1>>(_Count2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            } else {
                const auto _Result = ::std::ranges:: _Mismatch_4(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    _ULast2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Result.in2 == _ULast2;
            }
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (_Sized_or_infinite_range<_Rng1> && sized_range<_Rng2>) {
                const range_difference_t<_Rng2> _Count2 = ::std::ranges:: distance(_Range2);
                if constexpr (sized_range<_Rng1>) {
                    if (_Count2 > ::std::ranges:: distance(_Range1)) {
                        return false;
                    }
                }

                return ::std::ranges:: _Equal_count(_Ubegin(_Range1), _Ubegin(_Range2),
                    static_cast<range_difference_t<_Rng1>>(_Count2), _Pass_fn(_Pred), _Pass_fn(_Proj1),
                    _Pass_fn(_Proj2));
            } else {
                const auto _ULast2 = _Uend(_Range2);
                const auto _Result = ::std::ranges:: _Mismatch_4(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _ULast2,
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Result.in2 == _ULast2;
            }
        }
    };

     inline constexpr _Starts_with_fn starts_with{_Not_quite_object::_Construct_tag{}};

    class _Ends_with_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires (forward_iterator<_It1> || sized_sentinel_for<_Se1, _It1>)
                  && (forward_iterator<_It2> || sized_sentinel_for<_Se2, _It2>)
                  && indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(::std:: move(_First1));
            auto _ULast1  = _Unwrap_sent<_It1>(::std:: move(_Last1));
            auto _UFirst2 = _Unwrap_iter<_Se2>(::std:: move(_First2));
            auto _ULast2  = _Unwrap_sent<_It2>(::std:: move(_Last2));

            const auto _Count1 = _Distance_helper(_UFirst1, _ULast1);
            const auto _Count2 = _Distance_helper(_UFirst2, _ULast2);

            return _Ends_with_impl(::std:: move(_UFirst1), ::std:: move(_ULast1), _Count1, ::std:: move(_UFirst2),
                ::std:: move(_ULast2), _Count2, _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

        template <input_range _Rng1, input_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires (forward_range<_Rng1> || sized_range<_Rng1>) && (forward_range<_Rng2> || sized_range<_Rng2>)
                  && indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            const auto _Count1 = _Distance_helper(_Range1);
            const auto _Count2 = _Distance_helper(_Range2);

            return _Ends_with_impl(_Ubegin(_Range1), _Uend(_Range1), _Count1, _Ubegin(_Range2), _Uend(_Range2), _Count2,
                _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

    private:
        struct _Not_a_difference {};

        template <class _It, class _Se>
        [[nodiscard]] static constexpr auto _Distance_helper(const _It& _First, const _Se& _Last) {
            ;
            if constexpr (sized_sentinel_for<_Se, _It>) {
                return _Last - _First;
            } else {
                return _Not_a_difference{};
            }
        }

        template <class _Rng>
        [[nodiscard]] static constexpr auto _Distance_helper(_Rng&& _Range) {
            ;
            if constexpr (sized_range<_Rng>) {
                return ::std::ranges:: distance(_Range);
            } else {
                return _Not_a_difference{};
            }
        }

        template <class _Ty, class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Match_backwards(
            const _Ty _First1, _It1 _Last1, const _It2 _First2, _It2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;

            for (;;) {
                if (_First2 == _Last2) { 
                    return true;
                }

                if (_First1 == _Last1) { 
                    return false;
                }

                --_Last1;
                --_Last2;
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Last1), ::std:: invoke(_Proj2, *_Last2))) {
                    return false; 
                }
            }
        }

        template <class _It1, class _Se1, class _Diff1, class _It2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Ends_with_sized_needle(_It1 _First1, _Se1 _Last1, _Diff1 _Count1,
            _It2 _First2, iter_difference_t<_It2> _Count2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;

            constexpr bool _Sized1 = !same_as<_Diff1, _Not_a_difference>;

            if constexpr (random_access_iterator<_It1> && _Sized1) {
                _First1 += static_cast<iter_difference_t<_It1>>(_Count1 - _Count2);
            } else if constexpr (_Bidi_common<_It1, _Se1>) {
                if constexpr (_Sized1) {
                    if ((_Count1 >> 1) >= _Count2) { 
                        ::std::ranges:: advance(_Last1, static_cast<iter_difference_t<_It1>>(-_Count2));
                        _First1 = ::std:: move(_Last1);
                    } else { 
                        ::std::ranges:: advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
                    }
                } else { 
                    if (::std::ranges:: advance(_Last1, static_cast<iter_difference_t<_It1>>(-_Count2), _First1) != 0) {
                        
                        return false;
                    }
                    _First1 = ::std:: move(_Last1);
                }
            } else if constexpr (forward_iterator<_It1>) {
                auto _Mid1  = _First1;
                auto _Count = _Count2;
                do {
                    if (_Mid1 == _Last1) { 
                        return false;
                    }

                    ++_Mid1;
                } while (--_Count != 0);

                
                while (_Mid1 != _Last1) {
                    ++_First1;
                    ++_Mid1;
                }
            } else {
                ::std::ranges:: advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
            }

            return ::std::ranges:: _Equal_count(::std:: move(_First1), ::std:: move(_First2),
                static_cast<iter_difference_t<_It1>>(_Count2), _Pred, _Proj1, _Proj2);
        }

        template <class _It1, class _Se1, class _Diff1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Ends_with_unsized_needle(
            _It1 _First1, _Se1 _Last1, _Diff1 _Count1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;

            constexpr bool _Sized1 = !same_as<_Diff1, _Not_a_difference>;

            iter_difference_t<_It2> _Count2 = 0;

            if constexpr (_Sized1) {
                for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2, (void) ++_Count2) {
                    if (_Count2 == _Count1) { 
                        return false;
                    }
                }

                ::std::ranges:: advance(_First1, static_cast<iter_difference_t<_It1>>(_Count1 - _Count2));
            } else { 
                auto _Mid1 = _First1;
                for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid1, (void) ++_Mid2, ++_Count2) {
                    if (_Mid1 == _Last1) { 
                        return false;
                    }
                }

                
                while (_Mid1 != _Last1) {
                    ++_First1;
                    ++_Mid1;
                }
            }

            return ::std::ranges:: _Equal_count(::std:: move(_First1), ::std:: move(_First2),
                static_cast<iter_difference_t<_It1>>(_Count2), _Pred, _Proj1, _Proj2);
        }

        template <class _It1, class _Se1, class _Diff1, class _It2, class _Se2, class _Diff2, class _Pr, class _Pj1,
            class _Pj2>
        [[nodiscard]] static constexpr bool _Ends_with_impl(_It1 _First1, _Se1 _Last1, _Diff1 _Count1, _It2 _First2,
            _Se2 _Last2, _Diff2 _Count2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            constexpr bool _Sized1           = !same_as<_Diff1, _Not_a_difference>;
            constexpr bool _Sized2           = !same_as<_Diff2, _Not_a_difference>;
            constexpr bool _Both_sized       = _Sized1 && _Sized2;
            constexpr bool _Both_bidi_common = _Bidi_common<_It1, _Se1> && _Bidi_common<_It2, _Se2>;

            if constexpr (_Both_sized) {
                if (_Count2 > _Count1) {
                    return false;
                }
            }

            if constexpr (_Sized2) {
                if (_Count2 == 0) {
                    return true;
                }
            }

            if constexpr (_Both_bidi_common && !(random_access_iterator<_It1> && _Both_sized)) {
                if constexpr (_Both_sized) {
                    return _Match_backwards(unreachable_sentinel, ::std:: move(_Last1), ::std:: move(_First2),
                        ::std:: move(_Last2), _Pred, _Proj1, _Proj2);
                } else {
                    return _Match_backwards(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_First2),
                        ::std:: move(_Last2), _Pred, _Proj1, _Proj2);
                }
            } else if constexpr (_Sized2) {
                return _Ends_with_sized_needle(
                    ::std:: move(_First1), ::std:: move(_Last1), _Count1, ::std:: move(_First2), _Count2, _Pred, _Proj1, _Proj2);
            } else {
                return _Ends_with_unsized_needle(::std:: move(_First1), ::std:: move(_Last1), _Count1, ::std:: move(_First2),
                    ::std:: move(_Last2), _Pred, _Proj1, _Proj2);
            }
        }
    };

     inline constexpr _Ends_with_fn ends_with{_Not_quite_object::_Construct_tag{}};

    template <class _Fn>
    class _Flipped {
    private:
        _Fn _Func;

    public:
        template <class _Ty, class _Uty>
            requires invocable<_Fn&, _Uty, _Ty>
        invoke_result_t<_Fn&, _Uty, _Ty> operator()(_Ty&&, _Uty&&);
    };

    template <class _Fn, class _Ty, class _It, class _Uty>
    concept _Indirectly_binary_left_foldable_impl =
        movable<_Ty> && movable<_Uty> && convertible_to<_Ty, _Uty> && invocable<_Fn&, _Uty, iter_reference_t<_It>>
        && assignable_from<_Uty&, invoke_result_t<_Fn&, _Uty, iter_reference_t<_It>>>;

    template <class _Fn, class _Ty, class _It>
    concept _Indirectly_binary_left_foldable =
        copy_constructible<_Fn> && indirectly_readable<_It> && invocable<_Fn&, _Ty, iter_reference_t<_It>>
        && convertible_to<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>,
            decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>>
        && _Indirectly_binary_left_foldable_impl<_Fn, _Ty, _It,
            decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>>;

    template <class _Fn, class _Ty, class _It>
    concept _Indirectly_binary_right_foldable = _Indirectly_binary_left_foldable<_Flipped<_Fn>, _Ty, _It>;

     template <class _It, class _Ty>
    using fold_left_with_iter_result = in_value_result<_It, _Ty>;

     template <class _It, class _Ty>
    using fold_left_first_with_iter_result = in_value_result<_It, _Ty>;

    class _Fold_left_with_iter_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, _Indirectly_binary_left_foldable<_Ty, _It> _Fn>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
            _Adl_verify_range(_First, _Last);
            return _Fold_left_with_iter_impl<_It>(
                ::std:: move(_First), ::std:: move(_Last), ::std:: move(_Init), _Pass_fn(_Func));
        }

        template <input_range _Rng, class _Ty, _Indirectly_binary_left_foldable<_Ty, iterator_t<_Rng>> _Fn>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
            return _Fold_left_with_iter_impl<borrowed_iterator_t<_Rng>>(
                ::std::ranges:: begin(_Range), ::std::ranges:: end(_Range), ::std:: move(_Init), _Pass_fn(_Func));
        }

    private:
        template <class _RetIt, class _It, class _Se, class _Ty, class _Fn>
        [[nodiscard]] constexpr auto _Fold_left_with_iter_impl(_It&& _First, _Se&& _Last, _Ty&& _Init, _Fn _Func) const {
            ;
            ;
            ;

            using _Uty         = decay_t<invoke_result_t<_Fn&, _Ty, iter_reference_t<_It>>>;
            using _Return_type = fold_left_with_iter_result<_RetIt, _Uty>;

            if (_First == _Last) {
                return _Return_type{::std:: move(_First), static_cast<_Uty>(::std:: move(_Init))};
            } else {
                auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
                auto _ULast  = _Unwrap_sent<_It>(::std:: move(_Last));

                _Uty _Accum = ::std:: invoke(_Func, ::std:: move(_Init), *_UFirst);
                for (++_UFirst; _UFirst != _ULast; ++_UFirst) {
                    _Accum = ::std:: invoke(_Func, ::std:: move(_Accum), *_UFirst);
                }

                _Seek_wrapped(_First, ::std:: move(_UFirst));
                return _Return_type{::std:: move(_First), ::std:: move(_Accum)};
            }
        }
    };

     inline constexpr _Fold_left_with_iter_fn fold_left_with_iter{_Not_quite_object::_Construct_tag{}};

    class _Fold_left_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, _Indirectly_binary_left_foldable<_Ty, _It> _Fn>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
            return ::std::ranges:: fold_left_with_iter(::std:: move(_First), _Last, ::std:: move(_Init), _Pass_fn(_Func)).value;
        }

        template <input_range _Rng, class _Ty, _Indirectly_binary_left_foldable<_Ty, iterator_t<_Rng>> _Fn>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
            return ::std::ranges:: fold_left_with_iter(::std:: forward<_Rng>(_Range), ::std:: move(_Init), _Pass_fn(_Func)).value;
        }
    };

     inline constexpr _Fold_left_fn fold_left{_Not_quite_object::_Construct_tag{}};

    class _Fold_left_first_with_iter_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se,
            _Indirectly_binary_left_foldable<iter_value_t<_It>, _It> _Fn>
            requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
            _Adl_verify_range(_First, _Last);
            return _Fold_left_first_with_iter_impl<_It>(::std:: move(_First), ::std:: move(_Last), _Pass_fn(_Func));
        }

        template <input_range _Rng, _Indirectly_binary_left_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
            requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
            return _Fold_left_first_with_iter_impl<borrowed_iterator_t<_Rng>>(
                ::std::ranges:: begin(_Range), ::std::ranges:: end(_Range), _Pass_fn(_Func));
        }

    private:
        template <class _RetIt, class _It, class _Se, class _Fn>
        [[nodiscard]] constexpr auto _Fold_left_first_with_iter_impl(_It&& _First, _Se&& _Last, _Fn _Func) const {
            ;
            ;
            ;
            ;

            using _Uty =
                decltype(::std::ranges:: fold_left(::std:: move(_First), _Last, static_cast<iter_value_t<_It>>(*_First), _Func));
            using _Return_type = fold_left_first_with_iter_result<_RetIt, optional<_Uty>>;
            if (_First == _Last) {
                return _Return_type{::std:: move(_First), optional<_Uty>{}};
            } else {
                auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
                auto _ULast  = _Unwrap_sent<_It>(::std:: move(_Last));

                optional<_Uty> _Init{in_place, *_UFirst};
                _Uty& _Init_ref = *_Init;
                for (++_UFirst; _UFirst != _ULast; ++_UFirst) {
                    _Init_ref = ::std:: invoke(_Func, ::std:: move(_Init_ref), *_UFirst);
                }

                _Seek_wrapped(_First, ::std:: move(_UFirst));
                return _Return_type{::std:: move(_First), ::std:: move(_Init)};
            }
        }
    };

     inline constexpr _Fold_left_first_with_iter_fn fold_left_first_with_iter{
        _Not_quite_object::_Construct_tag{}};

    class _Fold_left_first_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se,
            _Indirectly_binary_left_foldable<iter_value_t<_It>, _It> _Fn>
            requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
            return ::std::ranges:: fold_left_first_with_iter(::std:: move(_First), ::std:: move(_Last), _Pass_fn(_Func)).value;
        }

        template <input_range _Rng, _Indirectly_binary_left_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
            requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
            return ::std::ranges:: fold_left_first_with_iter(::std:: forward<_Rng>(_Range), _Pass_fn(_Func)).value;
        }
    };

     inline constexpr _Fold_left_first_fn fold_left_first{_Not_quite_object::_Construct_tag{}};

    template <class _It, class _Se, class _Ty, class _Fn>
    [[nodiscard]] constexpr auto _Fold_right_unchecked(_It _First, _Se _Last, _Ty _Init, _Fn _Func) {
        ;
        ;
        ;

        using _Uty = decay_t<invoke_result_t<_Fn&, iter_reference_t<_It>, _Ty>>;
        if (_First == _Last) {
            return static_cast<_Uty>(::std:: move(_Init));
        } else {
            _It _Tail   = ::std::ranges:: next(_First, _Last);
            _Uty _Accum = ::std:: invoke(_Func, *--_Tail, ::std:: move(_Init));
            while (_First != _Tail) {
                _Accum = ::std:: invoke(_Func, *--_Tail, ::std:: move(_Accum));
            }
            return _Accum;
        }
    }

    class _Fold_right_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Ty,
            _Indirectly_binary_right_foldable<_Ty, _It> _Fn>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Ty _Init, _Fn _Func) const {
            _Adl_verify_range(_First, _Last);
            return ::std::ranges:: _Fold_right_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Init), _Pass_fn(_Func));
        }

        template <bidirectional_range _Rng, class _Ty, _Indirectly_binary_right_foldable<_Ty, iterator_t<_Rng>> _Fn>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Ty _Init, _Fn _Func) const {
            return ::std::ranges:: _Fold_right_unchecked(_Ubegin(_Range), _Uend(_Range), ::std:: move(_Init), _Pass_fn(_Func));
        }
    };

     inline constexpr _Fold_right_fn fold_right{_Not_quite_object::_Construct_tag{}};

    class _Fold_right_last_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se,
            _Indirectly_binary_right_foldable<iter_value_t<_It>, _It> _Fn>
            requires constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
        [[nodiscard]] constexpr auto operator()(_It _First, _Se _Last, _Fn _Func) const {
            _Adl_verify_range(_First, _Last);
            return _Fold_right_last_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Func));
        }

        template <bidirectional_range _Rng,
            _Indirectly_binary_right_foldable<range_value_t<_Rng>, iterator_t<_Rng>> _Fn>
            requires constructible_from<range_value_t<_Rng>, range_reference_t<_Rng>>
        [[nodiscard]] constexpr auto operator()(_Rng&& _Range, _Fn _Func) const {
            return _Fold_right_last_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Func));
        }

    private:
        template <class _It, class _Se, class _Fn>
        [[nodiscard]] constexpr auto _Fold_right_last_unchecked(_It _First, _Se _Last, _Fn _Func) const {
            ;
            ;
            ;
            ;

            using _Uty = decltype(::std::ranges:: fold_right(_First, _Last, static_cast<iter_value_t<_It>>(*_First), _Func));
            if (_First == _Last) {
                return optional<_Uty>{};
            } else {
                _It _Tail = ::std::ranges:: prev(::std::ranges:: next(_First, ::std:: move(_Last)));
                return optional<_Uty>{in_place, ::std::ranges:: _Fold_right_unchecked(::std:: move(_First), _Tail,
                                                    static_cast<iter_value_t<_It>>(*_Tail), ::std:: move(_Func))};
            }
        }
    };

     inline constexpr _Fold_right_last_fn fold_right_last{_Not_quite_object::_Construct_tag{}};

    class _Find_last_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard]] constexpr subrange<_It> operator()(_It _First, _Se _Last, const _Ty& _Value, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            if constexpr (bidirectional_iterator<_It>) {
                auto _ULast   = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
                auto _UResult = _Find_last_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Value, _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            } else {
                auto _ULast   = _Unwrap_sent<_It>(::std:: move(_Last));
                auto _UResult = _Find_last_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Value, _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Value, _Pj _Proj = {}) const {
            if constexpr (bidirectional_range<_Rng>) {
                auto _UResult = _Find_last_unchecked(
                    _Ubegin(_Range), _Get_final_iterator_unwrapped(_Range), _Value, _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
            } else {
                auto _UResult = _Find_last_unchecked(_Ubegin(_Range), _Uend(_Range), _Value, _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It, class _Se, class _Ty, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Find_last_unchecked(
            _It _First, _Se _Last, const _Ty& _Value, _Pj _Proj) {
            ;
            ;
            ;

            if constexpr (_Bidi_common<_It, _Se>) {
                for (auto _Result = _Last; _Result != _First;) {
                    if (::std:: invoke(_Proj, *--_Result) == _Value) {
                        return {::std:: move(_Result), ::std:: move(_Last)};
                    }
                }
                return {_Last, _Last};
            } else if constexpr (same_as<_It, _Se>) {
                auto _Result = _Last;
                for (; _First != _Last; ++_First) {
                    if (::std:: invoke(_Proj, *_First) == _Value) {
                        _Result = _First;
                    }
                }
                return {::std:: move(_Result), ::std:: move(_Last)};
            } else {
                auto _Result = _First;
                bool _Found  = false;
                for (;; ++_First) {
                    if (_First == _Last) {
                        if (!_Found) {
                            _Result = _First;
                        }
                        break;
                    }

                    if (::std:: invoke(_Proj, *_First) == _Value) {
                        _Result = _First;
                        _Found  = true;
                    }
                }
                return {::std:: move(_Result), ::std:: move(_First)};
            }
        }
    };

     inline constexpr _Find_last_fn find_last{_Not_quite_object::_Construct_tag{}};

    template <bool _Search_for>
    class _Find_last_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard]] constexpr subrange<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);

            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            if constexpr (bidirectional_iterator<_It>) {
                auto _ULast = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
                auto _UResult =
                    _Find_last_if_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            } else {
                auto _ULast = _Unwrap_sent<_It>(::std:: move(_Last));
                auto _UResult =
                    _Find_last_if_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            if constexpr (bidirectional_range<_Rng>) {
                auto _UResult = _Find_last_if_unchecked(
                    _Ubegin(_Range), _Get_final_iterator_unwrapped(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
            } else {
                auto _UResult =
                    _Find_last_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
            }
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr subrange<_It> _Find_last_if_unchecked(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            if constexpr (_Bidi_common<_It, _Se>) {
                for (auto _Result = _Last; _Result != _First;) {
                    if (::std:: invoke_r<bool>(_Pred, ::std:: invoke(_Proj, *--_Result)) == _Search_for) {
                        return {::std:: move(_Result), ::std:: move(_Last)};
                    }
                }
                return {_Last, _Last};
            } else if constexpr (same_as<_It, _Se>) {
                auto _Result = _Last;
                for (; _First != _Last; ++_First) {
                    if (::std:: invoke_r<bool>(_Pred, ::std:: invoke(_Proj, *_First)) == _Search_for) {
                        _Result = _First;
                    }
                }
                return {::std:: move(_Result), ::std:: move(_Last)};
            } else {
                auto _Result = _First;
                bool _Found  = false;
                for (;; ++_First) {
                    if (_First == _Last) {
                        if (!_Found) {
                            _Result = _First;
                        }
                        break;
                    }

                    if (::std:: invoke_r<bool>(_Pred, ::std:: invoke(_Proj, *_First)) == _Search_for) {
                        _Result = _First;
                        _Found  = true;
                    }
                }
                return {::std:: move(_Result), ::std:: move(_First)};
            }
        }
    };

     inline constexpr _Find_last_if_fn<true> find_last_if{_Not_quite_object::_Construct_tag{}};
     inline constexpr _Find_last_if_fn<false> find_last_if_not{_Not_quite_object::_Construct_tag{}};
#line 2959 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
} 
#line 2961 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr _FwdIt1 find_end(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    if constexpr (_Is_ranges_random_iter_v<_FwdIt1> && _Is_ranges_random_iter_v<_FwdIt2>) {
        const _Iter_diff_t<_FwdIt2> _Count2 = _ULast2 - _UFirst2;
        if (_Count2 > 0 && _Count2 <= _ULast1 - _UFirst1) {
            for (auto _UCandidate = _ULast1 - static_cast<_Iter_diff_t<_FwdIt1>>(_Count2);; --_UCandidate) {
                if (_Equal_rev_pred_unchecked(_UCandidate, _UFirst2, _ULast2, _Pass_fn(_Pred))) {
                    _Seek_wrapped(_First1, _UCandidate);
                    return _First1;
                }

                if (_UCandidate == _UFirst1) {
                    break;
                }
            }
        }

        return _Last1;
    } else if constexpr (_Is_ranges_bidi_iter_v<_FwdIt1> && _Is_ranges_bidi_iter_v<_FwdIt2>) {
        for (auto _UCandidate = _ULast1;; --_UCandidate) { 
            auto _UNext1 = _UCandidate;
            auto _UNext2 = _ULast2;
            for (;;) { 
                if (_UFirst2 == _UNext2) { 
                    _Seek_wrapped(_First1, _UNext1);
                    return _First1;
                }

                if (_UFirst1 == _UNext1) {
                    
                    return _Last1;
                }

                --_UNext1;
                --_UNext2;
                if (!_Pred(*_UNext1, *_UNext2)) { 
                    break;
                }
            }
        }
    } else {
        auto _UResult = _ULast1;
        for (;;) { 
            auto _UNext1 = _UFirst1;
            auto _UNext2 = _UFirst2;
            for (;;) { 
                const bool _End_of_needle = static_cast<bool>(_UNext2 == _ULast2);
                if (_End_of_needle) { 
                    _UResult = _UFirst1;
                }

                if (_UNext1 == _ULast1) {
                    
                    _Seek_wrapped(_First1, _UResult);
                    return _First1;
                }

                if (_End_of_needle || !_Pred(*_UNext1, *_UNext2)) {
                    break; 
                }

                ++_UNext1;
                ++_UNext2;
            }

            ++_UFirst1;
        }

        _Seek_wrapped(_First1, _UResult);
        return _First1;
    }
}

 template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] constexpr _FwdIt1 find_end(
    _FwdIt1 const _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2) {
    
    return ::std:: find_end(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt1 find_end(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt1 find_end(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) noexcept
 { 
    return ::std:: find_end(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 3061 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Find_end_fn : private _Not_quite_object {
    private:
        template <class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Random_access_sized_ranges(_It1 _First1,
            const iter_difference_t<_It1> _Count1, _It2 _First2, const iter_difference_t<_It2> _Count2, _Pr _Pred,
            _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            
            

            if (_Count2 > 0 && _Count2 <= _Count1) {
                const auto _Count2_as1 = static_cast<iter_difference_t<_It1>>(_Count2);

                for (auto _Candidate = _First1 + (_Count1 - _Count2_as1);; --_Candidate) {
                    auto [_Match, _Mid1] =
                        ::std::ranges:: _Equal_rev_pred(_Candidate, _First2, _First2 + _Count2, _Pred, _Proj1, _Proj2);
                    if (_Match) {
                        return {::std:: move(_Candidate), ::std:: move(_Mid1)};
                    }

                    if (_Candidate == _First1) {
                        break;
                    }
                }
            }

            _First1 += _Count1;
            return {_First1, _First1};
        }

        template <class _It1, class _It2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Bidi_common_ranges(
            _It1 _First1, _It1 _Last1, _It2 _First2, const _It2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;

            for (auto _Candidate = _Last1;; --_Candidate) { 
                auto _Next1 = _Candidate;
                auto _Next2 = _Last2;
                for (;;) { 
                    if (_First2 == _Next2) { 
                        return {::std:: move(_Next1), ::std:: move(_Candidate)};
                    }

                    if (_First1 == _Next1) {
                        
                        return {_Last1, _Last1};
                    }

                    --_Next1;
                    --_Next2;
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Next1), ::std:: invoke(_Proj2, *_Next2))) {
                        break; 
                    }
                }
            }
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr subrange<_It1> _Forward_ranges(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            subrange<_It1> _Match{};
            bool _Found = false;

            for (;; ++_First1) { 
                auto _Next1 = _First1;
                auto _Next2 = _First2;
                for (;; ++_Next1, (void) ++_Next2) { 
                    const bool _End_of_needle = _Next2 == _Last2;
                    if (_End_of_needle) { 
                        _Match = subrange{_First1, _Next1};
                        _Found = true;
                    }

                    if (_Next1 == _Last1) { 
                        if (!_Found) {
                            _Match = subrange{_Next1, _Next1};
                        }

                        return _Match;
                    }

                    if (_End_of_needle) {
                        break; 
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Next1), ::std:: invoke(_Proj2, *_Next2))) {
                        break; 
                    }
                }
            }
        }

    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr subrange<_It1> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UFirst1 = _Unwrap_iter<_Se1>(_First1);
            auto _ULast1  = _Unwrap_sent<_It1>(_Last1);
            auto _UFirst2 = _Unwrap_iter<_Se2>(_First2);
            auto _ULast2  = _Unwrap_sent<_It2>(_Last2);

            if constexpr (random_access_iterator<_It1> && sized_sentinel_for<_Se1, _It1> && random_access_iterator<_It2>
                          && sized_sentinel_for<_Se2, _It2>) {
                const auto _Count1 = _ULast1 - _UFirst1;
                const auto _Count2 = _ULast2 - _UFirst2;
                auto _UResult = _Random_access_sized_ranges(::std:: move(_UFirst1), _Count1, ::std:: move(_UFirst2), _Count2,
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            } else if constexpr (_Bidi_common<_It1, _Se1> && _Bidi_common<_It2, _Se2>) {
                auto _UResult = _Bidi_common_ranges(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Forward_ranges(::std:: move(_UFirst1), ::std:: move(_ULast1), ::std:: move(_UFirst2),
                    ::std:: move(_ULast2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<subrange<_It1>>(_First1, ::std:: move(_UResult));
            }
        }

        template <forward_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            if constexpr (random_access_range<_Rng1> && sized_range<_Rng1> && random_access_range<_Rng2>
                          && sized_range<_Rng2>) {
                auto _UResult = _Random_access_sized_ranges(_Ubegin(_Range1), ::std::ranges:: distance(_Range1),
                    _Ubegin(_Range2), ::std::ranges:: distance(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            } else if constexpr (_Bidi_common_range<_Rng1> && _Bidi_common_range<_Rng2>) {
                auto _UResult = _Bidi_common_ranges(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            } else {
                auto _UResult = _Forward_ranges(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
                return _Rewrap_subrange<borrowed_subrange_t<_Rng1>>(_Range1, ::std:: move(_UResult));
            }
        }
    };

     inline constexpr _Find_end_fn find_end{_Not_quite_object::_Construct_tag{}};
} 
#line 3224 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt1, class _FwdIt2, class _Pr>
[[nodiscard]] constexpr _FwdIt1 find_first_of(
    _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2, const _FwdIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1       = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped(_First2);
    const auto _ULast2  = _Get_unwrapped(_Last2);
    for (; _UFirst1 != _ULast1; ++_UFirst1) {
        for (auto _UMid2 = _UFirst2; _UMid2 != _ULast2; ++_UMid2) {
            if (_Pred(*_UFirst1, *_UMid2)) {
                _Seek_wrapped(_First1, _UFirst1);
                return _First1;
            }
        }
    }

    _Seek_wrapped(_First1, _UFirst1);
    return _First1;
}

 template <class _FwdIt1, class _FwdIt2>
[[nodiscard]] constexpr _FwdIt1 find_first_of(const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) { 
    return ::std:: find_first_of(_First1, _Last1, _First2, _Last2, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt1 find_first_of(
    _ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt1 find_first_of(_ExPo&& _Exec, const _FwdIt1 _First1, const _FwdIt1 _Last1, const _FwdIt2 _First2,
    const _FwdIt2 _Last2) noexcept  { 
    return ::std:: find_first_of(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, equal_to{});
}
#line 3265 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Find_first_of_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, forward_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::equal_to, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_comparable<_It1, _It2, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr _It1 operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            auto _UResult = _Find_first_of_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));

            _Seek_wrapped(_First1, ::std:: move(_UResult));
            return _First1;
        }

        template <input_range _Rng1, forward_range _Rng2, class _Pr = ranges::equal_to, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_comparable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Pr, _Pj1, _Pj2>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng1> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1 = ::std::ranges:: begin(_Range1);

            auto _UResult = _Find_first_of_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Ubegin(_Range2), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));

            _Seek_wrapped(_First1, ::std:: move(_UResult));
            return _First1;
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr _It1 _Find_first_of_unchecked(_It1 _First1, const _Se1 _Last1, const _It2 _First2,
            const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            for (; _First1 != _Last1; ++_First1) {
                for (auto _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_Mid2))) {
                        return _First1;
                    }
                }
            }

            return _First1;
        }
    };

     inline constexpr _Find_first_of_fn find_first_of{_Not_quite_object::_Construct_tag{}};

     template <class _In1, class _In2>
    using swap_ranges_result = in_in_result<_In1, _In2>;

    class _Swap_ranges_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2>
            requires indirectly_swappable<_It1, _It2>
        constexpr swap_ranges_result<_It1, _It2> operator()(
            _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            auto _UResult =
                _Swap_ranges_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)), _Unwrap_sent<_It1>(::std:: move(_Last1)),
                    _Unwrap_iter<_Se2>(::std:: move(_First2)), _Unwrap_sent<_It2>(::std:: move(_Last2)));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, input_range _Rng2>
            requires indirectly_swappable<iterator_t<_Rng1>, iterator_t<_Rng2>>
        constexpr swap_ranges_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2) const {
            auto _First1 = ::std::ranges:: begin(_Range1);
            auto _First2 = ::std::ranges:: begin(_Range2);

            auto _UResult = _Swap_ranges_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2>
        [[nodiscard]] static constexpr swap_ranges_result<_It1, _It2> _Swap_ranges_unchecked(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2) {
            ;
            ;
            ;
            ;
            ;


            using _Elem1 = remove_reference_t<iter_reference_t<_It1>>;
            using _Elem2 = remove_reference_t<iter_reference_t<_It2>>;
            if constexpr (same_as<_Elem1, _Elem2> && _Is_trivially_swappable_v<_Elem1> 
                          && contiguous_iterator<_It1> && _Sized_or_unreachable_sentinel_for<_Se1, _It1> 
                          && contiguous_iterator<_It2> && _Sized_or_unreachable_sentinel_for<_Se2, _It2>) {
                if (!::std:: is_constant_evaluated()) {
                    constexpr bool _Is_sized1 = sized_sentinel_for<_Se1, _It1>;
                    constexpr bool _Is_sized2 = sized_sentinel_for<_Se2, _It2>;
                    const auto _First1_addr   = ::std:: to_address(_First1);
                    const auto _First2_addr   = ::std:: to_address(_First2);
                    if constexpr (_Is_sized1 && _Is_sized2) {
                        const size_t _Count =
                            (::std:: min)(static_cast<size_t>(_Last1 - _First1), static_cast<size_t>(_Last2 - _First2));
                        const auto _Last1_addr = _First1_addr + _Count;
                        __std_swap_ranges_trivially_swappable_noalias(_First1_addr, _Last1_addr, _First2_addr);
                        return {_First1 + _Count, _First2 + _Count};
                    } else if constexpr (_Is_sized1) {
                        const auto _Final1     = ::std::ranges:: next(_First1, _Last1);
                        const auto _Last1_addr = ::std:: to_address(_Final1);
                        __std_swap_ranges_trivially_swappable_noalias(_First1_addr, _Last1_addr, _First2_addr);
                        return {_Final1, _First2 + (_Last1 - _First1)};
                    } else if constexpr (_Is_sized2) {
                        const auto _Final2     = ::std::ranges:: next(_First2, _Last2);
                        const auto _Last2_addr = ::std:: to_address(_Final2);
                        __std_swap_ranges_trivially_swappable_noalias(_First2_addr, _Last2_addr, _First1_addr);
                        return {_First1 + (_Last2 - _First2), _Final2};
                    } else {
                        ;
                    }
                }
            }
#line 3407 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2) {
                ::std::ranges:: iter_swap(_First1, _First2);
            }

            return {::std:: move(_First1), ::std:: move(_First2)};
        }
    };

     inline constexpr _Swap_ranges_fn swap_ranges{_Not_quite_object::_Construct_tag{}};
} 
#line 3419 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt1, class _FwdIt2>
constexpr _FwdIt2 swap_ranges(const _FwdIt1 _First1, const _FwdIt1 _Last1, _FwdIt2 _First2) {
    
    _Adl_verify_range(_First1, _Last1);
    const auto _UFirst1 = _Get_unwrapped(_First1);
    const auto _ULast1  = _Get_unwrapped(_Last1);
    const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
    _Verify_ranges_do_not_overlap(_UFirst1, _ULast1, _UFirst2);
    _Seek_wrapped(_First2, _Swap_ranges_unchecked(_UFirst1, _ULast1, _UFirst2));
    return _First2;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 swap_ranges(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt1>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: swap_ranges(_First1, _Last1, _Dest);
}
#line 3442 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt1, class _FwdIt2>
constexpr void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right) { 
    swap(*_Left, *_Right); 
}

 template <class _InIt, class _OutIt, class _Fn>
constexpr _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        *_UDest = _Func(*_UFirst);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 transform(_ExPo&& _Exec, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Fn _Func) noexcept; 
#line 3467 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _OutIt, class _Fn>
constexpr _OutIt transform(
    const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _OutIt _Dest, _Fn _Func) {
    
    _Adl_verify_range(_First1, _Last1);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    const auto _Count  = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    auto _UFirst2      = _Get_unwrapped_n(_First2, _Count);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Count);
    for (; _UFirst1 != _ULast1; ++_UFirst1, (void) ++_UFirst2, ++_UDest) {
        *_UDest = _Func(*_UFirst1, *_UFirst2);
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Fn,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 transform(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt3 _Dest,
    _Fn _Func) noexcept; 
#line 3492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Out>
    using unary_transform_result = in_out_result<_In, _Out>;

     template <class _In1, class _In2, class _Out>
    using binary_transform_result = in_in_out_result<_In1, _In2, _Out>;

    class _Transform_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, copy_constructible _Fn,
            class _Pj = identity>
            requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It, _Pj>>>
        constexpr unary_transform_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, _Fn _Func, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Transform_unary_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, weakly_incrementable _Out, copy_constructible _Fn, class _Pj = identity>
            requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<iterator_t<_Rng>, _Pj>>>
        constexpr unary_transform_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, _Fn _Func, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Transform_unary_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                ::std:: move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, copy_constructible _Fn, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_writable<_Out, indirect_result_t<_Fn&, projected<_It1, _Pj1>, projected<_It2, _Pj2>>>
        constexpr binary_transform_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2,
            _Se2 _Last2, _Out _Result, _Fn _Func, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Transform_binary_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), ::std:: move(_Result), _Pass_fn(_Func), _Pass_fn(_Proj1),
                _Pass_fn(_Proj2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, copy_constructible _Fn,
            class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_writable<_Out,
                indirect_result_t<_Fn&, projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>>>
        constexpr binary_transform_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Fn _Func, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _First2  = ::std::ranges:: begin(_Range2);
            auto _UResult = _Transform_binary_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2), ::std:: move(_Result), _Pass_fn(_Func),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It, class _Se, class _Out, class _Fn, class _Pj>
        [[nodiscard]] static constexpr unary_transform_result<_It, _Out> _Transform_unary_unchecked(
            _It _First, const _Se _Last, _Out _Result, _Fn _Func, _Pj _Proj) {
            
            ;
            ;
            ;

            for (; _First != _Last; ++_First, (void) ++_Result) {
                *_Result = ::std:: invoke(_Func, ::std:: invoke(_Proj, *_First));
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Fn, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr binary_transform_result<_It1, _It2, _Out> _Transform_binary_unchecked(_It1 _First1,
            const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Out _Result, _Fn _Func, _Pj1 _Proj1, _Pj2 _Proj2) {
            
            ;
            ;
            ;
            ;
#line 3589 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void) ++_First2, ++_Result) {
                *_Result = ::std:: invoke(_Func, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2));
            }

            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }
    };

     inline constexpr _Transform_fn transform{_Not_quite_object::_Construct_tag{}};
} 
#line 3601 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Ty>
constexpr void replace(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (*_UFirst == _Oldval) {
            *_UFirst = _Newval;
        }
    }
}


 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void replace(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Oldval,
    const _Ty& _Newval) noexcept; 
#line 3620 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Replace_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty1, class _Ty2, class _Pj = identity>
            requires indirectly_writable<_It, const _Ty2&>
                  && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty1*>
        constexpr _It operator()(
            _It _First, _Se _Last, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Replace_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Oldval, _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty1, class _Ty2, class _Pj = identity>
            requires indirectly_writable<iterator_t<_Rng>, const _Ty2&>
                  && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty1*>
        constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Replace_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Oldval, _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Ty1, class _Ty2, class _Pj>
        [[nodiscard]] static constexpr _It _Replace_unchecked(
            _It _First, const _Se _Last, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj) {
            
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Proj, *_First) == _Oldval) {
                    *_First = _Newval;
                }
            }

            return _First;
        }
    };

     inline constexpr _Replace_fn replace{_Not_quite_object::_Construct_tag{}};
} 
#line 3676 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr, class _Ty>
constexpr void replace_if(const _FwdIt _First, const _FwdIt _Last, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (_Pred(*_UFirst)) {
            *_UFirst = _Val;
        }
    }
}


 template <class _ExPo, class _FwdIt, class _Pr, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
void replace_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val) noexcept; 
#line 3694 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Replace_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires indirectly_writable<_It, const _Ty&>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Replace_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <input_range _Rng, class _Ty, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires indirectly_writable<iterator_t<_Rng>, const _Ty&>
        constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Replace_if_unchecked(
                _Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

    private:
        template <class _It, class _Se, class _Ty, class _Pj, class _Pr>
        [[nodiscard]] static constexpr _It _Replace_if_unchecked(
            _It _First, const _Se _Last, _Pr _Pred, const _Ty& _Newval, _Pj _Proj) {
            
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_First = _Newval;
                }
            }

            return _First;
        }
    };

     inline constexpr _Replace_if_fn replace_if{_Not_quite_object::_Construct_tag{}};
} 
#line 3749 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt, class _Ty>
constexpr _OutIt replace_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (*_UFirst == _Oldval) {
            *_UDest = _Newval;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 replace_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, const _Ty& _Oldval,
    const _Ty& _Newval) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: replace_copy(_First, _Last, _Dest, _Oldval, _Newval);
}
#line 3780 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Out>
    using replace_copy_result = in_out_result<_In, _Out>;

    class _Replace_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty1, class _Ty2, output_iterator<const _Ty2&> _Out,
            class _Pj = identity>
            requires indirectly_copyable<_It, _Out>
                  && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty1*>
        constexpr replace_copy_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Replace_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result), _Oldval, _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, class _Ty1, class _Ty2, output_iterator<const _Ty2&> _Out, class _Pj = identity>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
                  && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty1*>
        constexpr replace_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Replace_copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                ::std:: move(_Result), _Oldval, _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It, class _Se, class _Ty1, class _Ty2, class _Out, class _Pj>
        [[nodiscard]] static constexpr replace_copy_result<_It, _Out> _Replace_copy_unchecked(
            _It _First, const _Se _Last, _Out _Result, const _Ty1& _Oldval, const _Ty2& _Newval, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First, (void) ++_Result) {
                if (::std:: invoke(_Proj, *_First) == _Oldval) {
                    *_Result = _Newval;
                } else {
                    *_Result = *_First;
                }
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Replace_copy_fn replace_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 3843 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt, class _Pr, class _Ty>
constexpr _OutIt replace_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
    for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {
        if (_Pred(*_UFirst)) {
            *_UDest = _Val;
        } else {
            *_UDest = *_UFirst;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, class _Ty,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 replace_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred, const _Ty& _Val) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: replace_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred), _Val);
}
#line 3875 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Out>
    using replace_copy_if_result = in_out_result<_In, _Out>;

    class _Replace_copy_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, class _Ty, output_iterator<const _Ty&> _Out,
            class _Pj = identity, indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires indirectly_copyable<_It, _Out>
        constexpr replace_copy_if_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Replace_copy_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng, class _Ty, output_iterator<const _Ty&> _Out, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr replace_copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Replace_copy_if_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                ::std:: move(_Result), _Pass_fn(_Pred), _Newval, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It, class _Se, class _Ty, class _Out, class _Pj, class _Pr>
        [[nodiscard]] static constexpr replace_copy_if_result<_It, _Out> _Replace_copy_if_unchecked(
            _It _First, const _Se _Last, _Out _Result, _Pr _Pred, const _Ty& _Newval, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First, (void) ++_Result) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_Result = _Newval;
                } else {
                    *_Result = *_First;
                }
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Replace_copy_if_fn replace_copy_if{_Not_quite_object::_Construct_tag{}};

    class _Fill_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, output_iterator<const _Ty&> _It, sentinel_for<_It> _Se>
        constexpr _It operator()(_It _First, _Se _Last, const _Ty& _Value) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _ULast = _Unwrap_sent<_It>(::std:: move(_Last));
            if (!::std:: is_constant_evaluated()) {
                if constexpr (sized_sentinel_for<decltype(_ULast), decltype(_UFirst)>) {
                    if constexpr (_Fill_memset_is_safe<decltype(_UFirst), _Ty>) {
                        const auto _Distance = static_cast<size_t>(_ULast - _UFirst);
                        _Fill_memset(_UFirst, _Value, _Distance);
                        _Seek_wrapped(_First, _UFirst + _Distance);
                        return _First;
                    } else if constexpr (_Fill_zero_memset_is_safe<decltype(_UFirst), _Ty>) {
                        if (_Is_all_bits_zero(_Value)) {
                            const auto _Distance = static_cast<size_t>(_ULast - _UFirst);
                            _Fill_zero_memset(_UFirst, _Distance);
                            _Seek_wrapped(_First, _UFirst + _Distance);
                            return _First;
                        }
                    }
                }
            }

            for (; _UFirst != _ULast; ++_UFirst) {
                *_UFirst = _Value;
            }

            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }

        template <class _Ty, output_range<const _Ty&> _Rng>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, const _Ty& _Value) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First, (*this)(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Value));
            return _First;
        }
    };

     inline constexpr _Fill_fn fill{_Not_quite_object::_Construct_tag{}};

    class _Generate_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _Out, sentinel_for<_Out> _Se, copy_constructible _Fn>
            requires invocable<_Fn&> && indirectly_writable<_Out, invoke_result_t<_Fn&>>
        constexpr _Out operator()(_Out _First, _Se _Last, _Fn _Gen) const {
            _Adl_verify_range(_First, _Last);
            _Seek_wrapped(_First, _Generate_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                                      _Unwrap_sent<_Out>(::std:: move(_Last)), _Pass_fn(_Gen)));
            return _First;
        }

        template <class _Rng, copy_constructible _Fn>
            requires invocable<_Fn&> && output_range<_Rng, invoke_result_t<_Fn&>>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Fn _Gen) const {
            auto _First = ::std::ranges:: begin(_Range);
            _Seek_wrapped(_First,
                _Generate_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range), _Pass_fn(_Gen)));
            return _First;
        }

    private:
        template <class _Out, class _Se, class _Fn>
        [[nodiscard]] static constexpr _Out _Generate_unchecked(_Out _First, const _Se _Last, _Fn _Gen) {
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                *_First = _Gen();
            }

            return _First;
        }
    };

     inline constexpr _Generate_fn generate{_Not_quite_object::_Construct_tag{}};

    class _Generate_n_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_or_output_iterator _Out, copy_constructible _Fn>
            requires invocable<_Fn&> && indirectly_writable<_Out, invoke_result_t<_Fn&>>
        constexpr _Out operator()(_Out _First, iter_difference_t<_Out> _Count, _Fn _Gen) const {
            if (_Count > 0) {
                auto _UFirst = _Get_unwrapped_n(::std:: move(_First), _Count);
                do {
                    *_UFirst = _Gen();
                    ++_UFirst;
                } while (--_Count > 0);

                _Seek_wrapped(_First, ::std:: move(_UFirst));
            }

            return _First;
        }
    };

     inline constexpr _Generate_n_fn generate_n{_Not_quite_object::_Construct_tag{}};
} 
#line 4046 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Fn>
constexpr void generate(_FwdIt _First, _FwdIt _Last, _Fn _Func) { 
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    for (; _UFirst != _ULast; ++_UFirst) {
        *_UFirst = _Func();
    }
}


 template <class _ExPo, class _FwdIt, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
void generate(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Fn _Func) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: generate(_First, _Last, _Pass_fn(_Func));
}
#line 4066 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _OutIt, class _Diff, class _Fn>
constexpr _OutIt generate_n(_OutIt _Dest, const _Diff _Count_raw, _Fn _Func) {
    
    _Algorithm_int_t<_Diff> _Count = _Count_raw;
    if (0 < _Count) {
        auto _UDest = _Get_unwrapped_n(_Dest, _Count);
        do {
            *_UDest = _Func();
            --_Count;
            ++_UDest;
        } while (0 < _Count);

        _Seek_wrapped(_Dest, _UDest);
    }

    return _Dest;
}


 template <class _ExPo, class _FwdIt, class _Diff, class _Fn, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt generate_n(_ExPo&&, const _FwdIt _Dest, const _Diff _Count_raw, _Fn _Func) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: generate_n(_Dest, _Count_raw, _Pass_fn(_Func));
}
#line 4094 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt, class _Ty>
constexpr _OutIt remove_copy(_InIt _First, _InIt _Last, _OutIt _Dest, const _Ty& _Val) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!(*_UFirst == _Val)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 remove_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, const _Ty& _Val) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: remove_copy(_First, _Last, _Dest, _Val);
}
#line 4123 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _OutIt, class _Pr>
constexpr _OutIt remove_copy_if(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst != _ULast; ++_UFirst) {
        if (!_Pred(*_UFirst)) {
            *_UDest = *_UFirst;
            ++_UDest;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 remove_copy_if(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: remove_copy_if(_First, _Last, _Dest, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, class _Ty, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] _FwdIt remove(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, const _Ty& _Val) noexcept; 

 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] _FwdIt remove_if(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 
#line 4158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Remove_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity>
            requires indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        [[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr subrange<_It> operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Remove_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _Val, _Pass_fn(_Proj));

            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity>
            requires permutable<iterator_t<_Rng>>
                  && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        [[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr borrowed_subrange_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pj _Proj = {}) const {
            auto _UResult = _Remove_unchecked(_Ubegin(_Range), _Uend(_Range), _Val, _Pass_fn(_Proj));

            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Ty, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Remove_unchecked(
            _It _First, const _Se _Last, const _Ty& _Val, _Pj _Proj) {
            
            ;
            ;
            ;

            _First     = ::std::ranges:: _Find_unchecked(::std:: move(_First), _Last, _Val, _Proj);
            auto _Next = _First;
            if (_First == _Last) {
                return {::std:: move(_Next), ::std:: move(_First)};
            }

            while (++_First != _Last) {
                if (::std:: invoke(_Proj, *_First) != _Val) {
                    *_Next = ::std::ranges:: iter_move(_First);
                    ++_Next;
                }
            }

            return {::std:: move(_Next), ::std:: move(_First)};
        }
    };

     inline constexpr _Remove_fn remove{_Not_quite_object::_Construct_tag{}};

    class _Remove_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        [[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr subrange<_It> operator()(
            _It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Remove_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires permutable<iterator_t<_Rng>>
        [[nodiscard("The 'remove' and 'remove_if' algorithms return the iterator past the last element " "that should be kept. You need to call container.erase(result, container.end()) afterwards. " "In C++20, 'std::erase' and 'std::erase_if' are simpler replacements for these two steps.")]] constexpr borrowed_subrange_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _UResult = _Remove_if_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Remove_if_unchecked(
            _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            _First     = ::std::ranges:: _Find_if_unchecked(::std:: move(_First), _Last, _Pred, _Proj);
            auto _Next = _First;
            if (_First == _Last) {
                return {::std:: move(_Next), ::std:: move(_First)};
            }

            while (++_First != _Last) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_Next = ::std::ranges:: iter_move(_First);
                    ++_Next;
                }
            }

            return {::std:: move(_Next), ::std:: move(_First)};
        }
    };

     inline constexpr _Remove_if_fn remove_if{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Out>
    using remove_copy_result = in_out_result<_In, _Out>;

    class _Remove_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Ty, class _Pj = identity>
            requires indirectly_copyable<_It, _Out>
                  && indirect_binary_predicate<ranges::equal_to, projected<_It, _Pj>, const _Ty*>
        constexpr remove_copy_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, const _Ty& _Val, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult =
                _Remove_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                    _Get_unwrapped_unverified(::std:: move(_Result)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <input_range _Rng, weakly_incrementable _Out, class _Ty, class _Pj = identity>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
                  && indirect_binary_predicate<ranges::equal_to, projected<iterator_t<_Rng>, _Pj>, const _Ty*>
        constexpr remove_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, const _Ty& _Val, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Remove_copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Val, _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

    private:
        template <class _It, class _Se, class _Out, class _Ty, class _Pj>
        [[nodiscard]] static constexpr remove_copy_result<_It, _Out> _Remove_copy_unchecked(
            _It _First, const _Se _Last, _Out _Result, const _Ty& _Val, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (::std:: invoke(_Proj, *_First) != _Val) {
                    *_Result = *_First;
                    ++_Result;
                }
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Remove_copy_fn remove_copy{_Not_quite_object::_Construct_tag{}};

     template <class _In, class _Out>
    using remove_copy_if_result = in_out_result<_In, _Out>;

    class _Remove_copy_if_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires indirectly_copyable<_It, _Out>
        constexpr remove_copy_if_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult =
                _Remove_copy_if_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                    _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr remove_copy_if_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, _Pr _Pred, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Remove_copy_if_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

    private:
        template <class _It, class _Se, class _Out, class _Pr, class _Pj>
        [[nodiscard]] static constexpr remove_copy_if_result<_It, _Out> _Remove_copy_if_unchecked(
            _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            for (; _First != _Last; ++_First) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    *_Result = *_First;
                    ++_Result;
                }
            }

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Remove_copy_if_fn remove_copy_if{_Not_quite_object::_Construct_tag{}};
} 
#line 4388 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr>
[[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] constexpr _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UFirstb = _UFirst; ++_UFirst != _ULast; _UFirstb = _UFirst) {
            if (_Pred(*_UFirstb, *_UFirst)) { 
                while (++_UFirst != _ULast) {
                    if (!_Pred(*_UFirstb, *_UFirst)) {
                        *++_UFirstb = ::std:: move(*_UFirst);
                    }
                }

                _Seek_wrapped(_Last, ++_UFirstb);
                return _Last;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

 template <class _FwdIt>
[[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] constexpr _FwdIt unique(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: unique(_First, _Last, equal_to<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] _FwdIt unique(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: unique(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] _FwdIt unique(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: unique(_First, _Last);
}
#line 4436 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Unique_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_equivalence_relation<projected<_It, _Pj>> _Pr = ranges::equal_to>
        [[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] constexpr subrange<_It> operator()(
            _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Unique_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_equivalence_relation<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::equal_to>
            requires permutable<iterator_t<_Rng>>
        [[nodiscard("The 'unique' algorithm returns the iterator past the last element that should be kept. " "You need to call container.erase(result, container.end()) afterwards.")]] constexpr borrowed_subrange_t<_Rng> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Unique_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));

            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pj, class _Pr>
        [[nodiscard]] static constexpr subrange<_It> _Unique_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            auto _Current = _First;
            if (_First == _Last) {
                return {::std:: move(_Current), ::std:: move(_First)};
            }

            for (;; ++_Current) {
                if (++_First == _Last) {
                    ++_Current;
                    return {::std:: move(_Current), ::std:: move(_First)};
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Current), ::std:: invoke(_Proj, *_First))) {
                    break;
                }
            }

            while (++_First != _Last) {
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Current), ::std:: invoke(_Proj, *_First))) {
                    ++_Current;
                    *_Current = ::std::ranges:: iter_move(_First);
                }
            }
            ++_Current;

            return {::std:: move(_Current), ::std:: move(_First)};
        }
    };

     inline constexpr _Unique_fn unique{_Not_quite_object::_Construct_tag{}};
} 
#line 4503 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _InIt, class _OutIt>

concept


#line 4510 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
    _Can_reread_dest = _Is_cpp17_fwd_iter_v<_OutIt> && is_same_v<_Iter_value_t<_InIt>, _Iter_value_t<_OutIt>>;

 template <class _InIt, class _OutIt, class _Pr>
constexpr _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);

    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _ULast) {
        return _Dest;
    }

    auto _UDest = _Get_unwrapped_unverified(_Dest);

    if constexpr (_Is_ranges_fwd_iter_v<_InIt>) { 
        auto _Firstb = _UFirst;

        *_UDest = *_Firstb;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_Firstb, *_UFirst))) { 
                _Firstb = _UFirst;
                *_UDest = *_Firstb;
                ++_UDest;
            }
        }
    } else if constexpr (_Can_reread_dest<_InIt, _OutIt>) { 
        *_UDest = *_UFirst;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(*_UDest, *_UFirst))) {
                *++_UDest = *_UFirst;
            }
        }

        ++_UDest;
    } else { 
        _Iter_value_t<_InIt> _Val = *_UFirst;

        *_UDest = _Val;
        ++_UDest;

        while (++_UFirst != _ULast) {
            if (!static_cast<bool>(_Pred(_Val, *_UFirst))) { 
                _Val    = *_UFirst;
                *_UDest = _Val;
                ++_UDest;
            }
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

 template <class _InIt, class _OutIt>
constexpr _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest) { 
    return ::std:: unique_copy(_First, _Last, _Dest, equal_to<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 unique_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: unique_copy(_First, _Last, _Dest);
}
#line 4592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
     template <class _In, class _Out>
    using unique_copy_result = in_out_result<_In, _Out>;

    template <class _It, class _Ty>
    concept _Is_input_with_value_type = input_iterator<_It> && same_as<iter_value_t<_It>, _Ty>;

    template <class _It, class _Out>
    concept _Can_reread_or_store = forward_iterator<_It> || _Is_input_with_value_type<_Out, iter_value_t<_It>>
                                || indirectly_copyable_storable<_It, _Out>;

    class _Unique_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Pj = identity,
            indirect_equivalence_relation<projected<_It, _Pj>> _Pr = ranges::equal_to>
            requires indirectly_copyable<_It, _Out> && _Can_reread_or_store<_It, _Out>
        constexpr unique_copy_result<_It, _Out> operator()(
            _It _First, _Se _Last, _Out _Result, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult =
                _Unique_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)),
                    _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <input_range _Rng, weakly_incrementable _Out, class _Pj = identity,
            indirect_equivalence_relation<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::equal_to>
            requires indirectly_copyable<iterator_t<_Rng>, _Out> && _Can_reread_or_store<iterator_t<_Rng>, _Out>
        constexpr unique_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, _Out _Result, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First   = ::std::ranges:: begin(_Range);
            auto _UResult = _Unique_copy_unchecked(_Unwrap_range_iter<_Rng>(::std:: move(_First)), _Uend(_Range),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

    private:
        template <class _It, class _Se, class _Out, class _Pj, class _Pr>
        [[nodiscard]] static constexpr unique_copy_result<_It, _Out> _Unique_copy_unchecked(
            _It _First, const _Se _Last, _Out _Result, _Pr _Pred, _Pj _Proj) {
            
            
            ;
            ;
            ;
            ;
            ;
            ;

            if (_First == _Last) {
                return {::std:: move(_First), ::std:: move(_Result)};
            }

            if constexpr (_Is_input_with_value_type<_Out, iter_value_t<_It>>) {
                
                *_Result = *_First;

                while (++_First != _Last) {
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Result), ::std:: invoke(_Proj, *_First))) {
                        ++_Result;
                        *_Result = *_First;
                    }
                }
            } else if constexpr (forward_iterator<_It>) {
                
                auto _Current = _First;
                *_Result      = *_First;

                while (++_First != _Last) {
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Current), ::std:: invoke(_Proj, *_First))) {
                        _Current = _First;
                        ++_Result;
                        *_Result = *_First;
                    }
                }
            } else {
                
                iter_value_t<_It> _Val = *_First;

                while (++_First != _Last) {
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, _Val), ::std:: invoke(_Proj, *_First))) {
                        *_Result = ::std:: move(_Val);
                        ++_Result;
                        _Val = *_First;
                    }
                }
                *_Result = ::std:: move(_Val);
            }
            ++_Result;

            return {::std:: move(_First), ::std:: move(_Result)};
        }
    };

     inline constexpr _Unique_copy_fn unique_copy{_Not_quite_object::_Construct_tag{}};

    
    template <bidirectional_iterator _It>
        requires permutable<_It>
    constexpr void _Reverse_common(_It _First, _It _Last) {

        if constexpr (contiguous_iterator<_It>) {
            using _Elem          = remove_reference_t<iter_reference_t<_It>>;
            constexpr size_t _Nx = sizeof(_Elem);
            constexpr bool _Allow_vectorization =
                conjunction_v<_Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;

            if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
                if (!::std:: is_constant_evaluated()) {
                    _Elem* const _First_addr = ::std:: to_address(_First);
                    _Elem* const _Last_addr  = ::std:: to_address(_Last);
                    if constexpr (_Nx == 1) {
                        __std_reverse_trivially_swappable_1(_First_addr, _Last_addr);
                    } else if constexpr (_Nx == 2) {
                        __std_reverse_trivially_swappable_2(_First_addr, _Last_addr);
                    } else if constexpr (_Nx == 4) {
                        __std_reverse_trivially_swappable_4(_First_addr, _Last_addr);
                    } else {
                        __std_reverse_trivially_swappable_8(_First_addr, _Last_addr);
                    }

                    return;
                }
            }
        }
#line 4728 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

        for (; _First != _Last && _First != --_Last; ++_First) {
            ::std::ranges:: iter_swap(_First, _Last);
        }
    }

    class _Reverse_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se>
            requires permutable<_It>
        constexpr _It operator()(_It _First, _Se _Last) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Reverse_common(::std:: move(_UFirst), ::std:: move(_ULast));
            return _First;
        }

        template <bidirectional_range _Rng>
            requires permutable<iterator_t<_Rng>>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range) const {
            auto _ULast = _Get_final_iterator_unwrapped(_Range);
            _Reverse_common(_Ubegin(_Range), _ULast);
            return _Rewrap_iterator(_Range, ::std:: move(_ULast));
        }
    };

     inline constexpr _Reverse_fn reverse{_Not_quite_object::_Construct_tag{}};
} 
#line 4761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _BidIt, class _OutIt>
constexpr _OutIt reverse_copy(_BidIt _First, _BidIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_BidIt>(_UFirst, _ULast));


    using _Elem                         = remove_reference_t<_Iter_ref_t<remove_const_t<decltype(_UFirst)>>>;
    using _DestElem                     = remove_reference_t<_Iter_ref_t<decltype(_UDest)>>;
    constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
        bool_constant<_Iterators_are_contiguous<decltype(_ULast), decltype(_UDest)>>, is_trivially_copyable<_Elem>,
        negation<is_volatile<_Elem>>>;
    constexpr size_t _Nx                = sizeof(_Elem);

    if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {

        if (!::std:: is_constant_evaluated())
#line 4782 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
        {
            if constexpr (_Nx == 1) {
                __std_reverse_copy_trivially_copyable_1(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 2) {
                __std_reverse_copy_trivially_copyable_2(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else if constexpr (_Nx == 4) {
                __std_reverse_copy_trivially_copyable_4(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            } else {
                __std_reverse_copy_trivially_copyable_8(_To_address(_UFirst), _To_address(_ULast), _To_address(_UDest));
            }

            _UDest += _ULast - _UFirst;
            _Seek_wrapped(_Dest, _UDest);
            return _Dest;
        }
    }
#line 4799 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

    for (; _UFirst != _ULast; ++_UDest) {
        *_UDest = *--_ULast;
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}


 template <class _ExPo, class _BidIt, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt reverse_copy(_ExPo&&, _BidIt _First, _BidIt _Last, _FwdIt _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_bidi_iter_v<_BidIt>, "This algorithm requires bidirectional iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: reverse_copy(_First, _Last, _Dest);
}


namespace ranges {
     template <class _In, class _Out>
    using reverse_copy_result = in_out_result<_In, _Out>;

    class _Reverse_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr reverse_copy_result<_It, _Out> operator()(_It _First, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Result = _Reverse_copy_common(::std:: move(_UFirst), ::std:: move(_ULast), ::std:: move(_Result));
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <bidirectional_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr reverse_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(_Rng&& _Range, _Out _Result) const {
            if constexpr (common_range<_Rng>) {
                _Result = _Reverse_copy_common(_Ubegin(_Range), _Uend(_Range), ::std:: move(_Result));
                return {::std::ranges:: end(_Range), ::std:: move(_Result)};
            } else {
                auto _ULast = _Get_final_iterator_unwrapped(_Range);
                _Result     = _Reverse_copy_common(_Ubegin(_Range), _ULast, ::std:: move(_Result));
                return {_Rewrap_iterator(_Range, ::std:: move(_ULast)), ::std:: move(_Result)};
            }
        }

    private:
        template <class _It, class _Out>
        [[nodiscard]] static constexpr _Out _Reverse_copy_common(const _It _First, _It _Last, _Out _Result) {
            ;
            ;
            ;


            if constexpr (contiguous_iterator<_It> && contiguous_iterator<_Out>) {
                using _Elem                         = remove_reference_t<iter_reference_t<_It>>;
                using _DestElem                     = remove_reference_t<iter_reference_t<_Out>>;
                constexpr bool _Allow_vectorization = conjunction_v<is_same<remove_const_t<_Elem>, _DestElem>,
                    is_trivially_copyable<_Elem>, negation<is_volatile<_Elem>>>;
                constexpr size_t _Nx                = sizeof(_Elem);

                if constexpr (_Allow_vectorization && _Nx <= 8 && (_Nx & (_Nx - 1)) == 0) {
                    if (!::std:: is_constant_evaluated()) {
                        _Elem* const _First_addr      = ::std:: to_address(_First);
                        _Elem* const _Last_addr       = ::std:: to_address(_Last);
                        _DestElem* const _Result_addr = ::std:: to_address(_Result);
                        if constexpr (_Nx == 1) {
                            __std_reverse_copy_trivially_copyable_1(_First_addr, _Last_addr, _Result_addr);
                        } else if constexpr (_Nx == 2) {
                            __std_reverse_copy_trivially_copyable_2(_First_addr, _Last_addr, _Result_addr);
                        } else if constexpr (_Nx == 4) {
                            __std_reverse_copy_trivially_copyable_4(_First_addr, _Last_addr, _Result_addr);
                        } else {
                            __std_reverse_copy_trivially_copyable_8(_First_addr, _Last_addr, _Result_addr);
                        }

                        _Result += _Last - _First;
                        return _Result;
                    }
                }
            }
#line 4887 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            for (; _First != _Last; ++_Result) {
                *_Result = *--_Last;
            }

            return _Result;
        }
    };

     inline constexpr _Reverse_copy_fn reverse_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 4899 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 4900 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    template <permutable _It>
    [[nodiscard]] constexpr subrange<_It> _Reverse_until_mid_unchecked(_It _First, const _It _Mid, _It _Last) {
        
        ;
        ;

        do {
            ::std::ranges:: iter_swap(_First, --_Last);
        } while (++_First != _Mid && _Last != _Mid);

        return {::std:: move(_First), ::std:: move(_Last)};
    }

    template <permutable _It, sentinel_for<_It> _Se>
    [[nodiscard]] constexpr subrange<_It> _Rotate_unchecked(_It _First, _It _Mid, _Se _Last) {
        
        

        if (_First == _Mid) {
            auto _Final = _Get_final_iterator_unwrapped<_It>(_Mid, ::std:: move(_Last));
            return {_Final, _Final};
        }

        if (_Mid == _Last) {
            return {::std:: move(_First), ::std:: move(_Mid)};
        }

        if constexpr (bidirectional_iterator<_It>) {
            _Reverse_common(_First, _Mid);
            auto _Final = _Get_final_iterator_unwrapped<_It>(_Mid, ::std:: move(_Last));
            _Reverse_common(_Mid, _Final);

            if constexpr (random_access_iterator<_It>) {
                _Reverse_common(_First, _Final);
                _First += _Final - _Mid;

                return {::std:: move(_First), ::std:: move(_Final)};
            } else {
                const auto _Result = ::std::ranges:: _Reverse_until_mid_unchecked(::std:: move(_First), _Mid, _Final);
                auto _Mid_first    = _Result.begin();
                auto _Mid_last     = _Result.end();
                _Reverse_common(_Mid_first, _Mid_last);

                if (_Mid_first == _Mid) {
                    return {::std:: move(_Mid_last), ::std:: move(_Final)};
                } else {
                    return {::std:: move(_Mid_first), ::std:: move(_Final)};
                }
            }
        } else {
            auto _Next = _Mid;
            do { 
                ::std::ranges:: iter_swap(_First, _Next);
                ++_First;
                ++_Next;
                if (_First == _Mid) {
                    _Mid = _Next;
                }
            } while (_Next != _Last);

            auto _Begin = _First;

            while (_Mid != _Last) { 
                _Next = _Mid;
                do {
                    ::std::ranges:: iter_swap(_First, _Next);
                    ++_First;
                    ++_Next;
                    if (_First == _Mid) {
                        _Mid = _Next;
                    }
                } while (_Next != _Last);
            }
            return {::std:: move(_Begin), ::std:: move(_Mid)};
        }
    }

    class _Rotate_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se>
        constexpr subrange<_It> operator()(_It _First, _It _Mid, _Se _Last) const {
            _Adl_verify_range(_First, _Mid);
            _Adl_verify_range(_Mid, _Last);
            auto _UResult = ::std::ranges:: _Rotate_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_iter<_Se>(::std:: move(_Mid)), _Unwrap_sent<_It>(::std:: move(_Last)));

            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng>
            requires permutable<iterator_t<_Rng>>
        constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, iterator_t<_Rng> _Mid) const {
            _Adl_verify_range(::std::ranges:: begin(_Range), _Mid);
            _Adl_verify_range(_Mid, ::std::ranges:: end(_Range));
            auto _UResult =
                ::std::ranges:: _Rotate_unchecked(_Ubegin(_Range), _Unwrap_range_iter<_Rng>(::std:: move(_Mid)), _Uend(_Range));

            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Mid, ::std:: move(_UResult));
        }
    };

     inline constexpr _Rotate_fn rotate{_Not_quite_object::_Construct_tag{}};
} 
#line 5009 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _OutIt>
constexpr _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last, _OutIt _Dest) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _UMid   = _Get_unwrapped(_Mid);
    const auto _ULast  = _Get_unwrapped(_Last);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_distance<_FwdIt>(_UFirst, _ULast));
    _UDest             = ::std:: _Copy_unchecked(_UMid, _ULast, _UDest);
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst, _UMid, _UDest));
    return _Dest;
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt2 rotate_copy(_ExPo&&, _FwdIt1 _First, _FwdIt1 _Mid, _FwdIt1 _Last, _FwdIt2 _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt2>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: rotate_copy(_First, _Mid, _Last, _Dest);
}


namespace ranges {
     template <class _In, class _Out>
    using rotate_copy_result = in_out_result<_In, _Out>;

    class _Rotate_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out>
            requires indirectly_copyable<_It, _Out>
        constexpr rotate_copy_result<_It, _Out> operator()(_It _First, _It _Mid, _Se _Last, _Out _Result) const {
            _Adl_verify_range(_First, _Mid);
            _Adl_verify_range(_Mid, _Last);
            auto _UResult = _Rotate_copy_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_iter<_Se>(::std:: move(_Mid)), _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), ::std:: move(_UResult.out)};
        }

        template <forward_range _Rng, weakly_incrementable _Out>
            requires indirectly_copyable<iterator_t<_Rng>, _Out>
        constexpr rotate_copy_result<borrowed_iterator_t<_Rng>, _Out> operator()(
            _Rng&& _Range, iterator_t<_Rng> _Mid, _Out _Result) const {
            _Adl_verify_range(::std::ranges:: begin(_Range), _Mid);
            _Adl_verify_range(_Mid, ::std::ranges:: end(_Range));
            auto _UResult = _Rotate_copy_unchecked(
                _Ubegin(_Range), _Unwrap_range_iter<_Rng>(::std:: move(_Mid)), _Uend(_Range), ::std:: move(_Result));

            return {_Rewrap_iterator(_Range, ::std:: move(_UResult.in)), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It, class _Se, class _Out>
        [[nodiscard]] static constexpr rotate_copy_result<_It, _Out> _Rotate_copy_unchecked(
            _It _First, _It _Mid, _Se _Last, _Out _Result) {
            
            ;
            ;
            ;
            ;

            auto _UResult1 = ::std::ranges:: _Copy_unchecked(_Mid, ::std:: move(_Last), ::std:: move(_Result));
            auto _UResult2 = ::std::ranges:: _Copy_unchecked(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_UResult1.out));
            return {::std:: move(_UResult1.in), ::std:: move(_UResult2.out)};
        }
    };

     inline constexpr _Rotate_copy_fn rotate_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 5086 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 5087 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _Diff, class _Urng>
class _Rng_from_urng { 
public:
    using _Ty0 = make_unsigned_t<_Diff>;
    using _Ty1 = _Invoke_result_t<_Urng&>;

    using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;

    explicit _Rng_from_urng(_Urng& _Func)
        : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(static_cast<_Udiff>(-1)) {
        for (; static_cast<_Udiff>((_Urng::max)() - (_Urng::min)()) < _Bmask; _Bmask >>= 1) {
            --_Bits;
        }
    }

    _Diff operator()(_Diff _Index) { 
        for (;;) { 
            _Udiff _Ret  = 0; 
            _Udiff _Mask = 0; 

            while (_Mask < static_cast<_Udiff>(_Index - 1)) { 
                _Ret <<= _Bits - 1; 
                _Ret <<= 1;
                _Ret |= _Get_bits();
                _Mask <<= _Bits - 1; 
                _Mask <<= 1;
                _Mask |= _Bmask;
            }

            
            if (_Ret / _Index < _Mask / _Index || _Mask % _Index == static_cast<_Udiff>(_Index - 1)) {
                return static_cast<_Diff>(_Ret % _Index);
            }
        }
    }

    _Udiff _Get_all_bits() {
        _Udiff _Ret = 0;

        for (size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits) { 
            _Ret <<= _Bits - 1; 
            _Ret <<= 1;
            _Ret |= _Get_bits();
        }

        return _Ret;
    }

    _Rng_from_urng(const _Rng_from_urng&)            = delete;
    _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
    _Udiff _Get_bits() { 
        for (;;) { 
            const _Udiff _Val = static_cast<_Udiff>(_Ref() - (_Urng::min)());

            if (_Val <= _Bmask) {
                return _Val;
            }
        }
    }

    _Urng& _Ref; 
    size_t _Bits; 
    _Udiff _Bmask; 
};


template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
_SampleIt _Sample_reservoir_unchecked(
    _PopIt _First, const _PopIt _Last, const _SampleIt _Dest, const _Diff _Count, _RngFn& _RngFunc) {
    
    
    using _Diff_sample = _Iter_diff_t<_SampleIt>;
    const auto _SCount = static_cast<_Diff_sample>(_Count);
    _Iter_diff_t<_PopIt> _Pop_size{};
    for (; _Pop_size < _SCount; ++_Pop_size, (void) ++_First) {
        
        
        
        const auto _Sample_pop = static_cast<_Diff_sample>(_Pop_size);
        if (_First == _Last) {
            return _Dest + _Sample_pop;
        }

        *(_Dest + _Sample_pop) = *_First;
    }
    for (; _First != _Last; ++_First) {
        const auto _Idx = _RngFunc(++_Pop_size);
        if (_Idx < _SCount) {
            *(_Dest + static_cast<_Diff_sample>(_Idx)) = *_First; 
        }
    }
    return _Dest + _SCount;
}

template <class _PopIt, class _SampleIt, class _Diff, class _RngFn>
_SampleIt _Sample_selection_unchecked(
    _PopIt _First, _Iter_diff_t<_PopIt> _Pop_size, _SampleIt _Dest, _Diff _Count, _RngFn& _RngFunc) {
    
    
    using _CT = common_type_t<_Iter_diff_t<_PopIt>, _Diff>;
    for (; _Pop_size > 0; ++_First, (void) --_Pop_size) {
        if (static_cast<_CT>(_RngFunc(_Pop_size)) < static_cast<_CT>(_Count)) {
            --_Count;
            *_Dest = *_First;
            ++_Dest;
        }
    }
    return _Dest;
}

 template <class _PopIt, class _SampleIt, class _Diff, class _Urng>
_SampleIt sample(_PopIt _First, _PopIt _Last, _SampleIt _Dest, _Diff _Count, _Urng&& _Func) {
    
    static_assert(_Is_ranges_fwd_iter_v<_PopIt> || _Is_cpp17_random_iter_v<_SampleIt>,
        "If the source range is not forward, the destination range must be a Cpp17RandomAccessIterator.");

    static_assert(is_integral_v<_Diff>, "The sample size must have an integer type.");
    _Adl_verify_range(_First, _Last);
    if (0 < _Count) {
        auto _UFirst   = _Get_unwrapped(_First);
        auto _ULast    = _Get_unwrapped(_Last);
        using _PopDiff = _Iter_diff_t<_PopIt>;
        _Rng_from_urng<_PopDiff, remove_reference_t<_Urng>> _RngFunc(_Func);
        if constexpr (_Is_ranges_fwd_iter_v<_PopIt>) {
            
            using _CT            = common_type_t<_Diff, _PopDiff>;
            const auto _Pop_size = ::std:: distance(_UFirst, _ULast);
            if (static_cast<_CT>(_Count) > static_cast<_CT>(_Pop_size)) {
                _Count = static_cast<_Diff>(_Pop_size); 
            }

            _Seek_wrapped(_Dest,
                _Sample_selection_unchecked(_UFirst, _Pop_size, _Get_unwrapped_n(_Dest, _Count), _Count, _RngFunc));
        } else {
            static_assert(_Is_ranges_input_iter_v<_PopIt>, "Source iterators must be at least input iterators");
            
            _Seek_wrapped(_Dest,
                _Sample_reservoir_unchecked(_UFirst, _ULast, _Get_unwrapped_unverified(_Dest), _Count, _RngFunc));
        }
    }

    return _Dest;
}



 template <class _Ty>
concept uniform_random_bit_generator = invocable<_Ty&>
    && unsigned_integral<invoke_result_t<_Ty&>>
    && requires {
        { (_Ty::min)() } -> same_as<invoke_result_t<_Ty&>>;
        { (_Ty::max)() } -> same_as<invoke_result_t<_Ty&>>;
        requires bool_constant<(_Ty::min)() < (_Ty::max)()>::value;
    };


namespace ranges {
    class _Sample_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It, sentinel_for<_It> _Se, weakly_incrementable _Out, class _Urng>
            requires (forward_iterator<_It> || random_access_iterator<_Out>)
                  && indirectly_copyable<_It, _Out> && uniform_random_bit_generator<remove_reference_t<_Urng>>
        _Out operator()(_It _First, _Se _Last, _Out _Result, iter_difference_t<_It> _Count, _Urng&& _Func) const {
            _Adl_verify_range(_First, _Last);
            if (_Count <= 0) {
                return _Result;
            }

            _Rng_from_urng<iter_difference_t<_It>, remove_reference_t<_Urng>> _RngFunc(_Func);
            if constexpr (forward_iterator<_It>) {
                auto _UFirst   = _Unwrap_iter<_Se>(::std:: move(_First));
                auto _Pop_size = ::std::ranges:: distance(_UFirst, _Unwrap_sent<_It>(::std:: move(_Last)));
                return _Sample_selection_unchecked(::std:: move(_UFirst), _Pop_size, ::std:: move(_Result), _Count, _RngFunc);
            } else {
                return _Sample_reservoir_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                    _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: move(_Result), _Count, _RngFunc);
            }
        }

        template <input_range _Rng, weakly_incrementable _Out, class _Urng>
            requires (forward_range<_Rng> || random_access_iterator<_Out>)
                  && indirectly_copyable<iterator_t<_Rng>, _Out>
                  && uniform_random_bit_generator<remove_reference_t<_Urng>>
        _Out operator()(_Rng&& _Range, _Out _Result, range_difference_t<_Rng> _Count, _Urng&& _Func) const {
            if (_Count <= 0) {
                return _Result;
            }

            _Rng_from_urng<range_difference_t<_Rng>, remove_reference_t<_Urng>> _RngFunc(_Func);
            if constexpr (forward_range<_Rng>) {
                auto _UFirst   = _Ubegin(_Range);
                auto _Pop_size = ::std::ranges:: distance(_UFirst, _Uend(_Range));
                return _Sample_selection_unchecked(::std:: move(_UFirst), _Pop_size, ::std:: move(_Result), _Count, _RngFunc);
            } else {
                return _Sample_reservoir_unchecked(
                    _Ubegin(_Range), _Uend(_Range), ::std:: move(_Result), _Count, _RngFunc);
            }
        }

    private:
        template <class _It, class _Out, class _Rng>
        [[nodiscard]] static _Out _Sample_selection_unchecked(
            _It _First, iter_difference_t<_It> _Pop_size, _Out _Result, iter_difference_t<_It> _Count, _Rng& _RngFunc) {
            
            ;
            ;
            ;

            if (_Count > _Pop_size) {
                _Count = _Pop_size;
            }

            for (; _Pop_size > 0; ++_First, (void) --_Pop_size) {
                if (_RngFunc(_Pop_size) < _Count) {
                    *_Result = *_First;
                    ++_Result;
                    if (--_Count == 0) {
                        break;
                    }
                }
            }

            return _Result;
        }

        template <class _It, class _Se, class _Out, class _Rng>
        [[nodiscard]] static _Out _Sample_reservoir_unchecked(
            _It _First, const _Se _Last, _Out _Result, const iter_difference_t<_It> _Count, _Rng& _RngFunc) {
            
            ;
            ;
            ;
            ;

            iter_difference_t<_It> _Pop_size{};
            for (; _Pop_size < _Count; ++_Pop_size, (void) ++_First) {
                if (_First == _Last) {
                    return _Result + _Pop_size;
                }

                *(_Result + _Pop_size) = *_First;
            }
            for (; _First != _Last; ++_First) {
                const auto _Idx = _RngFunc(++_Pop_size);
                if (_Idx < _Count) {
                    *(_Result + _Idx) = *_First;
                }
            }

            return _Result + _Count;
        }
    };

     inline constexpr _Sample_fn sample{_Not_quite_object::_Construct_tag{}};
} 
#line 5348 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 5349 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _RngFn>
void _Random_shuffle1(_RanIt _First, _RanIt _Last, _RngFn& _RngFunc) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if (_UFirst == _ULast) {
        return;
    }

    using _Diff         = _Iter_diff_t<_RanIt>;
    auto _UTarget       = _UFirst;
    _Diff _Target_index = 1;
    for (; ++_UTarget != _ULast; ++_Target_index) { 
        _Diff _Off = _RngFunc(static_cast<_Diff>(_Target_index + 1));
        ;
        if (_Off != _Target_index) { 
            swap(*_UTarget, *(_UFirst + _Off)); 
        }
    }
}

 template <class _RanIt, class _Urng>
void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func) { 
    using _Urng0 = remove_reference_t<_Urng>;
    _Rng_from_urng<_Iter_diff_t<_RanIt>, _Urng0> _RngFunc(_Func);
    _Random_shuffle1(_First, _Last, _RngFunc);
}


namespace ranges {
    class _Shuffle_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Urng>
            requires permutable<_It> && uniform_random_bit_generator<remove_reference_t<_Urng>>
        _It operator()(_It _First, _Se _Last, _Urng&& _Func) const {
            _Adl_verify_range(_First, _Last);

            _Rng_from_urng<iter_difference_t<_It>, remove_reference_t<_Urng>> _RngFunc(_Func);
            auto _UResult =
                _Shuffle_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_sent<_It>(::std:: move(_Last)), _RngFunc);

            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <random_access_range _Rng, class _Urng>
            requires permutable<iterator_t<_Rng>> && uniform_random_bit_generator<remove_reference_t<_Urng>>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Urng&& _Func) const {
            _Rng_from_urng<range_difference_t<_Rng>, remove_reference_t<_Urng>> _RngFunc(_Func);

            return _Rewrap_iterator(_Range, _Shuffle_unchecked(_Ubegin(_Range), _Uend(_Range), _RngFunc));
        }

    private:
        template <class _It, class _Se, class _Rng>
        [[nodiscard]] static _It _Shuffle_unchecked(_It _First, const _Se _Last, _Rng& _Func) {
            
            ;
            ;
            ;

            if (_First == _Last) {
                return _First;
            }
            using _Diff = iter_difference_t<_It>;

            auto _Target        = _First;
            _Diff _Target_index = 1;
            for (; ++_Target != _Last; ++_Target_index) {
                
                const _Diff _Off = _Func(_Target_index + 1);
                ;
                if (_Off != _Target_index) { 
                    ::std::ranges:: iter_swap(_Target, _First + _Off);
                }
            }
            return _Target;
        }
    };

     inline constexpr _Shuffle_fn shuffle{_Not_quite_object::_Construct_tag{}};
} 
#line 5436 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"





























#line 5466 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


 template <class _FwdIt>
constexpr _FwdIt shift_left(_FwdIt _First, const _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) {
    
    
    ;

    _Adl_verify_range(_First, _Last);

    if (_Pos_to_shift == 0) {
        return _Last;
    }

    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    auto _Start_at     = _UFirst;

    if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
        if (_Pos_to_shift >= _ULast - _UFirst) {
            return _First;
        }
        _Start_at += _Pos_to_shift;
    } else {
        for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
            if (_Start_at == _ULast) {
                return _First;
            }
            ++_Start_at;
        }
    }

    _Seek_wrapped(_First, ::std:: _Move_unchecked(_Start_at, _ULast, _UFirst));
    return _First;
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt shift_left(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: shift_left(_First, _Last, _Pos_to_shift);
}

 template <class _FwdIt>
constexpr _FwdIt shift_right(_FwdIt _First, const _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) {
    
    
    ;

    _Adl_verify_range(_First, _Last);

    if (_Pos_to_shift == 0) {
        return _First;
    }

    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);

    if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        auto _UEnd_at = _ULast;
        if constexpr (_Is_cpp17_random_iter_v<_FwdIt>) {
            if (_Pos_to_shift >= _ULast - _UFirst) {
                return _Last;
            }
            _UEnd_at -= _Pos_to_shift;
        } else {
            for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
                if (_UEnd_at == _UFirst) {
                    return _Last;
                }
                --_UEnd_at;
            }
        }

        _Seek_wrapped(_First, _Move_backward_unchecked(_UFirst, _UEnd_at, _ULast));
        return _First;
    } else {
        auto _UResult = _UFirst;

        for (; 0 < _Pos_to_shift; --_Pos_to_shift) {
            if (_UResult == _ULast) {
                return _Last;
            }
            ++_UResult;
        }
        _Seek_wrapped(_First, _UResult);

        auto _Trail = _UFirst;
        auto _Lead  = _UResult;

        for (; _Trail != _UResult; ++_Trail, (void) ++_Lead) {
            if (_Lead == _ULast) {
                ::std:: _Move_unchecked(_UFirst, _Trail, _UResult);

                return _First;
            }
        }

        
        

        for (;;) {
            
            
            for (auto _Mid = _UFirst; _Mid != _UResult; ++_Mid, (void) ++_Trail, ++_Lead) {
                if (_Lead == _ULast) {
                    _Trail = ::std:: _Move_unchecked(_Mid, _UResult, _Trail);
                    ::std:: _Move_unchecked(_UFirst, _Mid, _Trail);

                    return _First;
                }
                swap(*_Mid, *_Trail); 
            }
        }
    }
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt shift_right(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Iter_diff_t<_FwdIt> _Pos_to_shift) noexcept  {
    
    
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: shift_right(_First, _Last, _Pos_to_shift);
}
#line 5592 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Shift_left_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se>
        constexpr subrange<_It> operator()(_It _First, const _Se _Last, iter_difference_t<_It> _Pos_to_shift) const {
            ;

            _Adl_verify_range(_First, _Last);
            auto _Result = _First;
            _Unwrap_iter_t<_It, _Se> _UResult;

            if (_Pos_to_shift == 0) {
                _UResult = _Get_final_iterator_unwrapped<_It>(_Unwrap_iter<_Se>(_Result), _Last);
            } else {
                _UResult = _Shift_left_impl(_Unwrap_iter<_Se>(_First), _Unwrap_sent<_It>(_Last), _Pos_to_shift);
            }
            _Seek_wrapped(_Result, _UResult);
            return {::std:: move(_First), ::std:: move(_Result)};
        }

        template <forward_range _Rng>
            requires permutable<iterator_t<_Rng>>
        constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, range_difference_t<_Rng> _Pos_to_shift) const {
            ;

            if (_Pos_to_shift == 0) {
                auto _Last = _Rewrap_iterator(_Range, _Get_final_iterator_unwrapped(_Range));
                return {::std::ranges:: begin(_Range), ::std:: move(_Last)};
            }

            if constexpr (sized_range<_Rng>) {
                auto _First = ::std::ranges:: begin(_Range);
                if (::std::ranges:: distance(_Range) <= _Pos_to_shift) {
                    return {_First, _First};
                }

                auto _UFirst   = _Unwrap_range_iter<_Rng>(_First);
                auto _Start_at = ::std::ranges:: next(_UFirst, _Pos_to_shift);
                auto _Result   = ::std::ranges:: _Move_unchecked(::std:: move(_Start_at), _Uend(_Range), _UFirst).out;
                return {::std:: move(_First), _Rewrap_iterator(_Range, ::std:: move(_Result))};
            } else {
                auto _Result = _Shift_left_impl(_Ubegin(_Range), _Uend(_Range), _Pos_to_shift);
                return {::std::ranges:: begin(_Range), _Rewrap_iterator(_Range, ::std:: move(_Result))};
            }
        }

    private:
        template <class _It, class _Se>
        [[nodiscard]] static constexpr _It _Shift_left_impl(_It _First, _Se _Last, iter_difference_t<_It> _Pos_to_shift) {
            ;
            ;
            ;

            auto _Start_at = _First;
            if (::std::ranges:: advance(_Start_at, _Pos_to_shift, _Last) != 0) {
                return _First;
            }

            return ::std::ranges:: _Move_unchecked(::std:: move(_Start_at), ::std:: move(_Last), ::std:: move(_First)).out;
        }
    };

     inline constexpr _Shift_left_fn shift_left{_Not_quite_object::_Construct_tag{}};

    class _Shift_right_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se>
        constexpr subrange<_It> operator()(_It _First, const _Se _Last, iter_difference_t<_It> _Pos_to_shift) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst     = _Unwrap_iter<_Se>(_First);
            auto _ULast      = _Unwrap_sent<_It>(_Last);
            const auto _Size = _Size_helper(_UFirst, _ULast);
            auto _Result     = _Shift_right_impl(::std:: move(_UFirst), ::std:: move(_ULast), _Pos_to_shift, _Size);
            _Seek_wrapped(_First, _Result.begin());
            auto _Final = _First;
            _Seek_wrapped(_Final, _Result.end());
            return {::std:: move(_First), ::std:: move(_Final)};
        }

        template <forward_range _Rng>
            requires permutable<iterator_t<_Rng>>
        constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, range_difference_t<_Rng> _Pos_to_shift) const {
            const auto _Size = _Size_helper(_Range);
            auto _Result     = _Shift_right_impl(_Ubegin(_Range), _Uend(_Range), _Pos_to_shift, _Size);
            auto _First      = _Rewrap_iterator(_Range, _Result.begin());
            auto _Final      = _Rewrap_iterator(_Range, _Result.end());
            return {::std:: move(_First), ::std:: move(_Final)};
        }

    private:
        struct _Unsized {};

        template <range _Rng>
        [[nodiscard]] static constexpr auto _Size_helper(_Rng&& _Range) {
            if constexpr (sized_range<_Rng>) {
                return ::std::ranges:: distance(_Range);
            } else {
                return _Unsized{};
            }
        }

        template <class _It, sentinel_for<_It> _Se>
        [[nodiscard]] static constexpr auto _Size_helper(const _It& _First, const _Se& _Last) {
            if constexpr (sized_sentinel_for<_Se, _It>) {
                return _Last - _First;
            } else {
                return _Unsized{};
            }
        }

        template <input_iterator _It, weakly_incrementable _Out>
            requires indirectly_movable<_It, _Out>
        [[nodiscard]] static constexpr _Out _Move_n_helper(_It _First, iter_difference_t<_It> _Count, _Out _Result) {
            for (; _Count > 0; ++_First, (void) --_Count, ++_Result) {
                *_Result = ::std::ranges:: iter_move(_First);
            }

            return _Result;
        }

        template <class _It, class _Se, class _SizeTy>
        [[nodiscard]] static constexpr subrange<_It> _Shift_right_impl(
            _It _First, _Se _Last, iter_difference_t<_It> _Pos_to_shift, const _SizeTy _Size) {
            ;
            ;
            ;

            if (_Pos_to_shift == 0) {
                return {_First, ::std::ranges:: next(_First, _Last)};
            }

            constexpr bool _Is_sized = !same_as<_SizeTy, _Unsized>;

            if constexpr (_Is_sized) {
                if (_Pos_to_shift >= _Size) {
                    if constexpr (same_as<_It, _Se>) {
                        return {_Last, _Last};
                    } else if constexpr (random_access_iterator<_It>) {
                        _First += _Size;
                        return {_First, _First};
                    } else {
                        ::std::ranges:: advance(_First, _Last);
                        return {_First, _First};
                    }
                }
            }

            if constexpr (_Bidi_common<_It, _Se>) {
                auto _Mid = _Last;
                if constexpr (_Is_sized) {
                    
                    ::std::ranges:: advance(_Mid, -_Pos_to_shift);
                } else {
                    if (::std::ranges:: advance(_Mid, -_Pos_to_shift, _First) != 0) {
                        return {_Last, _Last};
                    }
                }
                return {::std::ranges:: _Move_backward_common(::std:: move(_First), ::std:: move(_Mid), _Last), _Last};
            } else if constexpr (_Is_sized && random_access_iterator<_It>) {
                auto _Final = _First + _Size;
                auto _Mid   = _Final - _Pos_to_shift;
                return {::std::ranges:: _Move_backward_common(::std:: move(_First), ::std:: move(_Mid), _Final), _Final};
            } else {
                auto _Buf = _First;
                if constexpr (_Is_sized) {
                    ::std::ranges:: advance(_Buf, _Pos_to_shift);
                } else {
                    if (::std::ranges:: advance(_Buf, _Pos_to_shift, _Last) != 0) {
                        return {_Buf, _Buf};
                    }
                }

                if constexpr (_Is_sized) {
                    if (_Size < 2 * _Pos_to_shift) {
                        return {_Buf, _Move_n_helper(_First, _Size - _Pos_to_shift, _Buf)};
                    }
                }

                auto _Lead = _Buf;
                if constexpr (_Is_sized) {
                    
                    ::std::ranges:: advance(_Lead, _Pos_to_shift);
                } else {
                    if (auto _Rem = ::std::ranges:: advance(_Lead, _Pos_to_shift, _Last); _Rem != 0) {
                        return {_Buf, _Move_n_helper(_First, _Pos_to_shift - _Rem, _Buf)};
                    }
                }

                auto _Trail = _Buf;

                
                
                
                
                
                
                
                

                for (;;) {
                    for (auto _Mid = _First; _Mid != _Buf; ++_Mid, (void) ++_Trail, ++_Lead) {
                        if (_Lead == _Last) {
                            
                            
                            
                            
                            _Trail = ::std::ranges:: _Move_unchecked(_Mid, _Buf, ::std:: move(_Trail)).out;
                            _Trail = ::std::ranges:: _Move_unchecked(_First, _Mid, ::std:: move(_Trail)).out;
                            ;
                            return {::std:: move(_Buf), ::std:: move(_Trail)};
                        }

                        ::std::ranges:: iter_swap(_Mid, _Trail);
                    }
                }
            }
        }
    };

     inline constexpr _Shift_right_fn shift_right{_Not_quite_object::_Construct_tag{}};
} 
#line 5820 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr>
constexpr _FwdIt partition(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if constexpr (_Is_cpp17_bidi_iter_v<_FwdIt>) {
        for (;;) { 
            for (;;) { 
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }

                if (!_Pred(*_UFirst)) {
                    break;
                }

                ++_UFirst;
            }

            do { 
                --_ULast;
                if (_UFirst == _ULast) {
                    _Seek_wrapped(_First, _UFirst);
                    return _First;
                }
            } while (!_Pred(*_ULast));

            swap(*_UFirst, *_ULast); 
            ++_UFirst;
        }
    } else {
        for (;;) { 
            if (_UFirst == _ULast) {
                _Seek_wrapped(_First, _UFirst);
                return _First;
            }

            if (!_Pred(*_UFirst)) {
                break;
            }

            ++_UFirst;
        }

        for (auto _UNext = _UFirst; ++_UNext != _ULast;) {
            if (_Pred(*_UNext)) {
                swap(*_UFirst, *_UNext); 
                ++_UFirst;
            }
        }
    }

    _Seek_wrapped(_First, _UFirst);
    return _First;
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt partition(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 


namespace ranges {
    class _Partition_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <permutable _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
        constexpr subrange<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UResult = _Partition_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires permutable<iterator_t<_Rng>>
        constexpr borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _UResult = _Partition_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Partition_unchecked(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            if constexpr (_Bidi_common<_It, _Se>) {
                auto _Saved_last = _Last;
                for (;; ++_First) { 
                    for (;; ++_First) { 
                        if (_First == _Last) {
                            return {::std:: move(_First), ::std:: move(_Saved_last)};
                        }

                        if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                            break;
                        }
                    }

                    do { 
                        --_Last;
                        if (_First == _Last) {
                            return {::std:: move(_First), ::std:: move(_Saved_last)};
                        }
                    } while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Last)));

                    ::std::ranges:: iter_swap(_First, _Last); 
                }

                return {::std:: move(_First), ::std:: move(_Saved_last)};
            } else {
                for (;; ++_First) { 
                    if (_First == _Last) {
                        return {_First, _First};
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                        break;
                    }
                }

                auto _Next = _First;
                while (++_Next != _Last) {
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next))) {
                        ::std::ranges:: iter_swap(_First, _Next); 
                        ++_First;
                    }
                }

                return {::std:: move(_First), ::std:: move(_Next)};
            }
        }
    };

     inline constexpr _Partition_fn partition{_Not_quite_object::_Construct_tag{}};
} 
#line 5964 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 5965 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _BidIt>
_BidIt _Buffered_rotate_unchecked(const _BidIt _First, const _BidIt _Mid, const _BidIt _Last,
    const _Iter_diff_t<_BidIt> _Count1, const _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr,
    const ptrdiff_t _Capacity) { 
                                 
                                 
    if (_Count1 == 0) {
        return _Last;
    }

    if (_Count2 == 0) {
        return _First;
    }

    if (_Count1 <= _Count2 && _Count1 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, ::std:: _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
        const _BidIt _New_mid = ::std:: _Move_unchecked(_Mid, _Last, _First);
        ::std:: _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
        return _New_mid; 
    }

    if (_Count2 <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{
            _Temp_ptr, ::std:: _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
        _Move_backward_unchecked(_First, _Mid, _Last);
        return ::std:: _Move_unchecked(_Backout._First, _Backout._Last, _First); 
    }

    
    return ::std:: rotate(_First, _Mid, _Last);
}

template <class _BidIt, class _Pr>
pair<_BidIt, _Iter_diff_t<_BidIt>> _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr _Pred,
    const _Iter_diff_t<_BidIt> _Count, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity) {
    
    
    
    
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count - static_cast<_Diff>(1) <= _Capacity) { 
        _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr};
        _BidIt _Next = _First;
        _Backout._Emplace_back(::std:: move(*_First));
        while (++_First != _Last) { 
                                    
            if (_Pred(*_First)) {
                *_Next = ::std:: move(*_First);
                ++_Next;
            } else {
                _Backout._Emplace_back(::std:: move(*_First));
            }
        }

        
        *_Next = ::std:: move(*_Last);
        ++_Next;
        ::std:: _Move_unchecked(_Backout._First, _Backout._Last, _Next); 
        _Diff _True_distance = static_cast<_Diff>(_Count - static_cast<_Diff>(_Backout._Last - _Backout._First));
        return pair<_BidIt, _Diff>(_Next, _True_distance); 
    }

    const _Diff _Mid_offset = _Count / static_cast<_Diff>(2); 
    const _BidIt _Mid       = ::std:: next(_First, _Mid_offset);

    
    _BidIt _Left           = _Mid;
    _Diff _Left_true_count = _Mid_offset;
    for (;;) { 
        --_Left;
        if (_First == _Left) { 
            --_Left_true_count; 
            break;
        }

        if (_Pred(*_Left)) { 
            const pair<_BidIt, _Diff> _Low =
                _Stable_partition_unchecked1(_First, _Left, _Pred, _Left_true_count, _Temp_ptr, _Capacity);
            _Left            = _Low.first;
            _Left_true_count = _Low.second;
            break;
        }

        --_Left_true_count;
    }

    
    _BidIt _Right           = _Mid;
    _Diff _Right_true_count = 0;
    for (;;) { 
        if (_Right == _Last) { 
            ++_Right; 
            ++_Right_true_count;
            break;
        }

        if (!_Pred(*_Right)) { 
            const _Diff _Right_count = _Count - _Mid_offset;
            const _Diff _Remaining   = _Right_count - _Right_true_count;
            const pair<_BidIt, _Diff> _High =
                _Stable_partition_unchecked1(_Right, _Last, _Pred, _Remaining, _Temp_ptr, _Capacity);
            _Right = _High.first;
            _Right_true_count += _High.second;
            break;
        }

        ++_Right;
        ++_Right_true_count;
    }

    
    const _BidIt _Partition_point = _Buffered_rotate_unchecked(_Left, _Mid, _Right,
        static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
    return pair<_BidIt, _Diff>(_Partition_point, static_cast<_Diff>(_Left_true_count + _Right_true_count));
}

template <class _BidIt, class _Pr>
_BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    for (;;) {
        if (_First == _Last) { 
            return _First;
        }

        if (!_Pred(*_First)) { 
            break;
        }

        ++_First;
    }

    for (;;) {
        --_Last;
        if (_First == _Last) { 
            return _First;
        }

        if (_Pred(*_Last)) { 
            break;
        }
    }

    using _Diff              = _Iter_diff_t<_BidIt>;
    const _Diff _Temp_count  = ::std:: distance(_First, _Last); 
    const _Diff _Total_count = _Temp_count + static_cast<_Diff>(1);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Temp_count};
    return _Stable_partition_unchecked1(_First, _Last, _Pred, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity).first;
}

 template <class _BidIt, class _Pr>
_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Stable_partition_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}


 template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_BidIt stable_partition(_ExPo&&, _BidIt _First, _BidIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_cpp17_bidi_iter_v<_BidIt>, "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.");
    return ::std:: stable_partition(_First, _Last, _Pass_fn(_Pred));
}
#line 6135 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    template <bidirectional_iterator _It>
    _It _Buffered_rotate_common(const _It _First, const _It _Mid, const _It _Last, const iter_difference_t<_It> _Count1,
        const iter_difference_t<_It> _Count2, iter_value_t<_It>* const _Temp_ptr, const ptrdiff_t _Capacity) {
        
        ;
        ;

        if (_Count1 == 0) {
            return _Last;
        }

        if (_Count2 == 0) {
            return _First;
        }

        if (_Count1 <= _Count2 && _Count1 <= _Capacity) { 
            _Uninitialized_backout<iter_value_t<_It>*> _Backout{
                _Temp_ptr, ::std::ranges:: _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr, _Temp_ptr + _Count1).out};
            const _It _New_mid = ::std::ranges:: _Move_unchecked(::std:: move(_Mid), ::std:: move(_Last), ::std:: move(_First)).out;
            ::std::ranges:: _Move_unchecked(_Backout._First, _Backout._Last, _New_mid);
            return _New_mid;
        }

        if (_Count2 <= _Capacity) { 
            _Uninitialized_backout<iter_value_t<_It>*> _Backout{
                _Temp_ptr, ::std::ranges:: _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr, _Temp_ptr + _Count2).out};
            ::std::ranges:: _Move_backward_common(_First, ::std:: move(_Mid), ::std:: move(_Last));
            return ::std::ranges:: _Move_unchecked(_Backout._First, _Backout._Last, ::std:: move(_First)).out;
        }

        
        return ::std::ranges:: _Rotate_unchecked(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last)).begin();
    }

    class _Stable_partition_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_unary_predicate<projected<_It, _Pj>> _Pr>
            requires permutable<_It>
        subrange<_It> operator()(_It _First, _Se _Last, _Pr _Pred, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));

            auto _UResult =
                _Stable_partition_common(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <bidirectional_range _Rng, class _Pj = identity,
            indirect_unary_predicate<projected<iterator_t<_Rng>, _Pj>> _Pr>
            requires permutable<iterator_t<_Rng>>
        borrowed_subrange_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred, _Pj _Proj = {}) const {
            auto _ULast = _Get_final_iterator_unwrapped(_Range);
            auto _UResult =
                _Stable_partition_common(_Ubegin(_Range), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Range, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static subrange<_It> _Stable_partition_common(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            
            for (;;) { 
                if (_First == _Last) { 
                    return {::std:: move(_First), ::std:: move(_Last)};
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                    break;
                }
                ++_First;
            }

            auto _Saved_last = _Last;
            do { 
                --_Last;
                if (_First == _Last) {
                    return {::std:: move(_First), ::std:: move(_Saved_last)};
                }
            } while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Last)));

            const iter_difference_t<_It> _Temp_count = ::std::ranges:: distance(_First, _Last);
            _Optimistic_temporary_buffer<iter_value_t<_It>> _Temp_buf{_Temp_count};

            
            const auto _Total_count = static_cast<iter_difference_t<_It>>(_Temp_count + 1);

            auto _Result = _Stable_partition_common_buffered(
                ::std:: move(_First), ::std:: move(_Last), _Pred, _Proj, _Total_count, _Temp_buf._Data, _Temp_buf._Capacity);
            return {::std:: move(_Result.first), ::std:: move(_Saved_last)};
        }

        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static pair<_It, iter_difference_t<_It>> _Stable_partition_common_buffered(_It _First, _It _Last,
            _Pr _Pred, _Pj _Proj, const iter_difference_t<_It> _Count, iter_value_t<_It>* const _Temp_ptr,
            const ptrdiff_t _Capacity) {
            
            
            ;
            ;
            ;
            ;
            ;
            ;

            using _Diff = iter_difference_t<_It>;
            if (_Count - 1 <= _Capacity) { 
                _Uninitialized_backout<iter_value_t<_It>*> _Backout{_Temp_ptr};
                _It _Next = _First;
                _Backout._Emplace_back(::std::ranges:: iter_move(_First));
                while (++_First != _Last) {
                    
                    
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First))) {
                        *_Next = ::std::ranges:: iter_move(_First);
                        ++_Next;
                    } else {
                        _Backout._Emplace_back(::std::ranges:: iter_move(_First));
                    }
                }

                
                *_Next = ::std::ranges:: iter_move(_Last);
                ++_Next;
                
                ::std::ranges:: _Move_unchecked(_Backout._First, _Backout._Last, _Next);
                const auto _True_distance = static_cast<_Diff>(_Count - (_Backout._Last - _Backout._First));
                return {::std:: move(_Next), _True_distance};
            }

            const _Diff _Mid_offset = _Count >> 1; 
            const _It _Mid          = ::std::ranges:: next(_First, _Mid_offset);
            
            _It _Left              = _Mid;
            _Diff _Left_true_count = _Mid_offset;
            for (;;) { 
                --_Left;
                --_Left_true_count;
                if (_First == _Left) { 
                    break;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Left))) {
                    
                    ++_Left_true_count; 
                    const auto _Low = _Stable_partition_common_buffered(
                        _First, ::std:: move(_Left), _Pred, _Proj, _Left_true_count, _Temp_ptr, _Capacity);
                    _Left            = ::std:: move(_Low.first);
                    _Left_true_count = _Low.second;
                    break;
                }
            }

            
            _It _Right              = _Mid;
            _Diff _Right_true_count = 0;
            for (;;) { 
                if (_Right == _Last) { 
                    ++_Right; 
                    ++_Right_true_count;
                    break;
                }

                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Right))) {
                    
                    const auto _Right_count = static_cast<_Diff>(_Count - _Mid_offset);
                    const auto _Remaining   = static_cast<_Diff>(_Right_count - _Right_true_count);
                    const auto _High        = _Stable_partition_common_buffered(
                        ::std:: move(_Right), _Last, _Pred, _Proj, _Remaining, _Temp_ptr, _Capacity);
                    _Right = ::std:: move(_High.first);
                    _Right_true_count += _High.second;
                    break;
                }

                ++_Right;
                ++_Right_true_count;
            }

            
            auto _Partition_point =
                ::std::ranges:: _Buffered_rotate_common(::std:: move(_Left), ::std:: move(_Mid), ::std:: move(_Right),
                    static_cast<_Diff>(_Mid_offset - _Left_true_count), _Right_true_count, _Temp_ptr, _Capacity);
            return {::std:: move(_Partition_point), static_cast<_Diff>(_Left_true_count + _Right_true_count)};
        }
    };

     inline constexpr _Stable_partition_fn stable_partition{_Not_quite_object::_Construct_tag{}};
} 
#line 6334 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _Ty, class _Pr>
constexpr void _Push_heap_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_RanIt>;
    for (_Diff _Idx                                                          = (_Hole - 1) >> 1; 
         _Top < _Hole && static_cast<bool>(_Pred(*(_First + _Idx), _Val)); _Idx = (_Hole - 1) >> 1) { 
        
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    *(_First + _Hole) = ::std:: forward<_Ty>(_Val); 
}

 template <class _RanIt, class _Pr>
constexpr void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    auto _ULast        = _Get_unwrapped(_Last);
    using _Diff        = _Iter_diff_t<_RanIt>;
    _Diff _Count       = _ULast - _UFirst;
    if (2 <= _Count) {
        _Iter_value_t<_RanIt> _Val = ::std:: move(*--_ULast);
        ::std:: _Push_heap_by_index(_UFirst, --_Count, _Diff(0), ::std:: move(_Val), _Pass_fn(_Pred));
    }
}

 template <class _RanIt>
constexpr void push_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: push_heap(_First, _Last, less<>{});
}


namespace ranges {
    template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
        requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
              && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
    constexpr void _Push_heap_by_index(const _It _First, iter_difference_t<_It> _Hole,
        const iter_difference_t<_It> _Top, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        while (_Top < _Hole) {
            const auto _Idx = static_cast<iter_difference_t<_It>>((_Hole - 1) >> 1); 
            if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *(_First + _Idx)), ::std:: invoke(_Proj2, _Val))) {
                break;
            }

            
            *(_First + _Hole) = ::std::ranges:: iter_move(_First + _Idx);
            _Hole             = _Idx;
        }

        *(_First + _Hole) = ::std:: forward<_Ty>(_Val); 
    }

    class _Push_heap_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Push_heap_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if constexpr (common_range<_Rng>) {
                _Push_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return ::std::ranges:: end(_Range);
            } else {
                auto _ULast = _Get_final_iterator_unwrapped(_Range);
                _Push_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_ULast));
            }
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static constexpr void _Push_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            const auto _Count = _Last - _First;
            if (_Count < 2) {
                return;
            }

            --_Last;
            iter_value_t<_It> _Val = ::std::ranges:: iter_move(_Last);
            
            ::std::ranges:: _Push_heap_by_index(::std:: move(_First), _Count - 1, 0, ::std:: move(_Val), _Pred, _Proj, _Proj);
        }
    };

     inline constexpr _Push_heap_fn push_heap{_Not_quite_object::_Construct_tag{}};
} 
#line 6441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _Ty, class _Pr>
constexpr void _Pop_heap_hole_by_index(
    _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {
    
    ;

    using _Diff      = _Iter_diff_t<_RanIt>;
    const _Diff _Top = _Hole;
    _Diff _Idx       = _Hole;

    
    
    const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; 
    while (_Idx < _Max_sequence_non_leaf) { 
        _Idx = 2 * _Idx + 2;
        if (static_cast<bool>(_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))) {
            --_Idx;
        }
        *(_First + _Hole) = ::std:: move(*(_First + _Idx));
        _Hole             = _Idx;
    }

    if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { 
        *(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
        _Hole             = _Bottom - 1;
    }

    ::std:: _Push_heap_by_index(_First, _Hole, _Top, ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Ty, class _Pr>
constexpr void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest, _Ty&& _Val, _Pr _Pred) {
    
    
    
    *_Dest      = ::std:: move(*_First);
    using _Diff = _Iter_diff_t<_RanIt>;
    ::std:: _Pop_heap_hole_by_index(
        _First, static_cast<_Diff>(0), static_cast<_Diff>(_Last - _First), ::std:: forward<_Ty>(_Val), _Pred);
}

template <class _RanIt, class _Pr>
constexpr void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    if (2 <= _Last - _First) {
        --_Last;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
        ::std:: _Pop_heap_hole_unchecked(_First, _Last, _Last, ::std:: move(_Val), _Pred);
    }
}

 template <class _RanIt, class _Pr>
constexpr void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    ::std:: _Pop_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

 template <class _RanIt>
constexpr void pop_heap(_RanIt _First, _RanIt _Last) {
    
    ::std:: pop_heap(_First, _Last, less<>{});
}


namespace ranges {
    template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
        requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
              && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
    constexpr void _Pop_heap_hole_by_index(_It _First, iter_difference_t<_It> _Hole,
        const iter_difference_t<_It> _Bottom, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        ;
        ;

        using _Diff      = iter_difference_t<_It>;
        const _Diff _Top = _Hole;
        _Diff _Idx       = _Hole;

        
        
        const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; 
        while (_Idx < _Max_sequence_non_leaf) { 
            _Idx      = 2 * _Idx + 2;
            auto _Mid = _First + _Idx;
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_Mid), ::std:: invoke(_Proj1, *::std::ranges:: prev(_Mid)))) {
                --_Idx;
                --_Mid;
            }
            *(_First + _Hole) = ::std::ranges:: iter_move(_Mid);
            _Hole             = _Idx;
        }

        if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { 
            *(_First + _Hole) = ::std::ranges:: iter_move(_First + (_Bottom - 1));
            _Hole             = _Bottom - 1;
        }

        ::std::ranges:: _Push_heap_by_index(::std:: move(_First), _Hole, _Top, ::std:: forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
    }

    template <random_access_iterator _It, class _Ty, class _Pr, class _Pj1, class _Pj2>
        requires sortable<_It, _Pr, _Pj1> && indirectly_writable<_It, _Ty>
              && indirect_strict_weak_order<_Pr, projected<_It, _Pj1>, projected<remove_reference_t<_Ty>*, _Pj2>>
    constexpr void _Pop_heap_hole_unchecked(
        _It _First, const _It _Last, const _It _Dest, _Ty&& _Val, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
        
        ;
        ;

        *_Dest            = ::std::ranges:: iter_move(_First);
        const auto _Count = _Last - _First;
        ::std::ranges:: _Pop_heap_hole_by_index(::std:: move(_First), 0, _Count, ::std:: forward<_Ty>(_Val), _Pred, _Proj1, _Proj2);
    }

    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr void _Pop_heap_unchecked(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        if (_Last - _First < 2) {
            return;
        }

        --_Last;
        iter_value_t<_It> _Val = ::std::ranges:: iter_move(_Last);
        
        ::std::ranges:: _Pop_heap_hole_unchecked(::std:: move(_First), _Last, _Last, ::std:: move(_Val), _Pred, _Proj, _Proj);
    }

    class _Pop_heap_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            ::std::ranges:: _Pop_heap_unchecked(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if constexpr (common_range<_Rng>) {
                ::std::ranges:: _Pop_heap_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return ::std::ranges:: end(_Range);
            } else {
                auto _ULast = _Get_final_iterator_unwrapped(_Range);
                ::std::ranges:: _Pop_heap_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_ULast));
            }
        }
    };

     inline constexpr _Pop_heap_fn pop_heap{_Not_quite_object::_Construct_tag{}};
} 
#line 6603 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _Pr>
constexpr void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff   = _Iter_diff_t<_RanIt>;
    _Diff _Bottom = _Last - _First;
    for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { 
        
        --_Hole;
        _Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
        ::std:: _Pop_heap_hole_by_index(_First, _Hole, _Bottom, ::std:: move(_Val), _Pred);
    }
}

 template <class _RanIt, class _Pr>
constexpr void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    _Make_heap_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
}

 template <class _RanIt>
constexpr void make_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: make_heap(_First, _Last, less<>{});
}


namespace ranges {
    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr void _Make_heap_common(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        using _Diff         = iter_difference_t<_It>;
        const _Diff _Bottom = _Last - _First;
        for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { 
            
            --_Hole;
            iter_value_t<_It> _Val = ::std::ranges:: iter_move(_First + _Hole);
            
            ::std::ranges:: _Pop_heap_hole_by_index(_First, _Hole, _Bottom, ::std:: move(_Val), _Pred, _Proj, _Proj);
        }
    }

    class _Make_heap_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Make_heap_common(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if constexpr (common_range<_Rng>) {
                _Make_heap_common(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return ::std::ranges:: end(_Range);
            } else {
                auto _ULast = _Get_final_iterator_unwrapped(_Range);
                _Make_heap_common(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_ULast));
            }
        }
    };

     inline constexpr _Make_heap_fn make_heap{_Not_quite_object::_Construct_tag{}};
} 
#line 6677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _Pr>
constexpr _RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    using _Diff       = _Iter_diff_t<_RanIt>;
    const _Diff _Size = _Last - _First;
    for (_Diff _Off = 1; _Off < _Size; ++_Off) {
        if (static_cast<bool>(_Pred(*(_First + ((_Off - 1) >> 1)), *(_First + _Off)))) { 
            return _First + _Off;
        }
    }

    return _Last;
}

 template <class _RanIt, class _Pr>
[[nodiscard]] constexpr _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(
        _First, ::std:: _Is_heap_until_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred)));
    return _First;
}

 template <class _RanIt, class _Pr>
[[nodiscard]] constexpr bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return ::std:: _Is_heap_until_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

 template <class _RanIt>
[[nodiscard]] constexpr _RanIt is_heap_until(_RanIt _First, _RanIt _Last) {
    
    return ::std:: is_heap_until(_First, _Last, less<>{});
}

 template <class _RanIt>
[[nodiscard]] constexpr bool is_heap(_RanIt _First, _RanIt _Last) { 
    return ::std:: is_heap(_First, _Last, less<>{});
}


 template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _RanIt is_heap_until(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept; 

 template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool is_heap(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept  {
    
    return ::std:: is_heap_until(::std:: forward<_ExPo>(_Exec), _First, _Last, _Pass_fn(_Pred)) == _Last;
}

 template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _RanIt is_heap_until(_ExPo&& _Exec, _RanIt _First, _RanIt _Last) noexcept  {
    
    return ::std:: is_heap_until(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}

 template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool is_heap(_ExPo&& _Exec, _RanIt _First, _RanIt _Last) noexcept  {
    
    return ::std:: is_heap(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}


namespace ranges {
    template <class _It, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Is_heap_until_unchecked(
        _It _First, const iter_difference_t<_It> _Size, _Pr _Pred, _Pj _Proj) {
        
        ;
        ;

        if (_Size == 0) {
            return _First;
        }

        using _Diff = iter_difference_t<_It>;
        _Diff _Off  = 1;
        for (; _Off < _Size; ++_Off) {
            const auto _Mid1 = _First + static_cast<_Diff>((_Off - 1) >> 1); 
            auto _Mid2       = _First + _Off;
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid1), ::std:: invoke(_Proj, *_Mid2))) {
                return _Mid2;
            }
        }

        return _First + _Off;
    }

    class _Is_heap_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _ULast = _Unwrap_sent<_It>(::std:: move(_Last));
            const auto _Size  = ::std::ranges:: distance(_UFirst, _ULast);
            const auto _UResult =
                ::std::ranges:: _Is_heap_until_unchecked(::std:: move(_UFirst), _Size, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UResult == _ULast;
        }

        template <random_access_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Size = ::std::ranges:: distance(_Range);
            const auto _UResult =
                ::std::ranges:: _Is_heap_until_unchecked(_Ubegin(_Range), _Size, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UResult == _Uend(_Range);
        }
    };

     inline constexpr _Is_heap_fn is_heap{_Not_quite_object::_Construct_tag{}};

    class _Is_heap_until_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst     = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _Size = ::std::ranges:: distance(_UFirst, _Unwrap_sent<_It>(::std:: move(_Last)));
            auto _UResult =
                ::std::ranges:: _Is_heap_until_unchecked(::std:: move(_UFirst), _Size, _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UResult));
            return _First;
        }

        template <random_access_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Size = ::std::ranges:: distance(_Range);
            auto _UResult = ::std::ranges:: _Is_heap_until_unchecked(_Ubegin(_Range), _Size, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Is_heap_until_fn is_heap_until{_Not_quite_object::_Construct_tag{}};
} 
#line 6825 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 6826 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _RanIt, class _Pr>
constexpr void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    for (; _Last - _First >= 2; --_Last) {
        ::std:: _Pop_heap_unchecked(_First, _Last, _Pred);
    }
}

 template <class _RanIt, class _Pr>
constexpr void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);





#line 6846 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
    _Sort_heap_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
}

 template <class _RanIt>
constexpr void sort_heap(_RanIt _First, _RanIt _Last) { 
    ::std:: sort_heap(_First, _Last, less<>{});
}


namespace ranges {
    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr void _Sort_heap_common(const _It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        for (; _Last - _First >= 2; --_Last) {
            ::std::ranges:: _Pop_heap_unchecked(_First, _Last, _Pred, _Proj);
        }
    }

    class _Sort_heap_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            _Sort_heap_common(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            if constexpr (common_range<_Rng>) {
                _Sort_heap_common(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return ::std::ranges:: end(_Range);
            } else {
                auto _ULast = _Get_final_iterator_unwrapped(_Range);
                _Sort_heap_common(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Rewrap_iterator(_Range, ::std:: move(_ULast));
            }
        }
    };

     inline constexpr _Sort_heap_fn sort_heap{_Not_quite_object::_Construct_tag{}};

    template <class _It, class _Ty, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Lower_bound_unchecked(
        _It _First, iter_difference_t<_It> _Count, const _Ty& _Val, _Pr _Pred, _Pj _Proj) {
        ;
        ;

        using _Diff = iter_difference_t<_It>;

        while (_Count > 0) { 
            const auto _Half = static_cast<_Diff>(_Count / 2);
            auto _Mid        = ::std::ranges:: next(_First, _Half);
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), _Val)) { 
                _First = ::std:: move(_Mid);
                ++_First;
                _Count -= static_cast<_Diff>(_Half + 1);
            } else { 
                _Count = _Half;
            }
        }

        return _First;
    }

    class _Lower_bound_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _Count = ::std::ranges:: distance(_UFirst, _Unwrap_sent<_It>(::std:: move(_Last)));
            _UFirst =
                ::std::ranges:: _Lower_bound_unchecked(::std:: move(_UFirst), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Count = ::std::ranges:: distance(_Range);
            auto _UResult =
                ::std::ranges:: _Lower_bound_unchecked(_Ubegin(_Range), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Lower_bound_fn lower_bound{_Not_quite_object::_Construct_tag{}};

    template <class _It, class _Ty, class _Pr, class _Pj>
    [[nodiscard]] constexpr _It _Upper_bound_unchecked(
        _It _First, iter_difference_t<_It> _Count, const _Ty& _Val, _Pr _Pred, _Pj _Proj) {
        ;
        ;

        using _Diff = iter_difference_t<_It>;

        while (_Count > 0) { 
            const auto _Half = static_cast<_Diff>(_Count / 2);
            auto _Mid        = ::std::ranges:: next(_First, _Half);
            if (::std:: invoke(_Pred, _Val, ::std:: invoke(_Proj, *_Mid))) {
                _Count = _Half;
            } else { 
                _First = ::std:: move(_Mid);
                ++_First;
                _Count -= static_cast<_Diff>(_Half + 1);
            }
        }

        return _First;
    }

    class _Upper_bound_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _Count = ::std::ranges:: distance(_UFirst, _Unwrap_sent<_It>(::std:: move(_Last)));
            _UFirst =
                ::std::ranges:: _Upper_bound_unchecked(::std:: move(_UFirst), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Count = ::std::ranges:: distance(_Range);
            auto _UResult =
                ::std::ranges:: _Upper_bound_unchecked(_Ubegin(_Range), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Upper_bound_fn upper_bound{_Not_quite_object::_Construct_tag{}};
} 
#line 7003 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);

    using _Diff  = _Iter_diff_t<_FwdIt>;
    _Diff _Count = ::std:: distance(_UFirst, _ULast);

    for (;;) { 
        if (_Count <= 0) {
            _Seek_wrapped(_Last, _UFirst); 
            _Seek_wrapped(_First, _UFirst);
            break;
        }

        _Diff _Count2    = _Count / 2;
        const auto _UMid = ::std:: next(_UFirst, _Count2);
        if (static_cast<bool>(_Pred(*_UMid, _Val))) { 
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + 1;
        } else if (_Pred(_Val, *_UMid)) {
            _Count = _Count2; 
        } else { 
            auto _UFirst2 = ::std:: lower_bound(_UFirst, _UMid, _Val, _Pass_fn(_Pred));
            ::std:: advance(_UFirst, _Count);
            auto _ULast2 = ::std:: upper_bound(_Next_iter(_UMid), _UFirst, _Val, _Pass_fn(_Pred));
            _Seek_wrapped(_Last, _ULast2);
            _Seek_wrapped(_First, _UFirst2);
            break;
        }
    }

    return {_First, _Last};
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> equal_range(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: equal_range(_First, _Last, _Val, less<>{});
}


namespace ranges {
    class _Equal_range_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr subrange<_It> operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _Count = ::std::ranges:: distance(_UFirst, _Unwrap_sent<_It>(::std:: move(_Last)));
            auto _UResult = _Equal_range_unchecked(::std:: move(_UFirst), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_subrange<subrange<_It>>(_First, ::std:: move(_UResult));
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_subrange_t<_Rng> operator()(
            _Rng&& _Range, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Count = ::std::ranges:: distance(_Range);
            auto _UResult     = _Equal_range_unchecked(_Ubegin(_Range), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            auto _Result      = ::std::ranges:: begin(_Range);
            return _Rewrap_subrange<borrowed_subrange_t<_Rng>>(_Result, ::std:: move(_UResult));
        }

    private:
        template <class _It, class _Ty, class _Pr, class _Pj>
        [[nodiscard]] static constexpr subrange<_It> _Equal_range_unchecked(
            _It _First, iter_difference_t<_It> _Count, const _Ty& _Val, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            using _Diff = iter_difference_t<_It>;

            while (_Count > 0) { 
                const auto _Half = static_cast<_Diff>(_Count / 2);
                auto _Mid        = ::std::ranges:: next(_First, _Half);

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), _Val)) { 
                    _First = ::std:: move(_Mid);
                    ++_First;
                    _Count -= static_cast<_Diff>(_Half + 1);
                } else if (::std:: invoke(_Pred, _Val, ::std:: invoke(_Proj, *_Mid))) {
                    _Count = _Half; 
                } else { 
                    _First = ::std::ranges:: _Lower_bound_unchecked(::std:: move(_First), _Half, _Val, _Pred, _Proj);
                    ++_Mid;
                    _Count -= static_cast<_Diff>(_Half + 1);
                    _Mid = ::std::ranges:: _Upper_bound_unchecked(::std:: move(_Mid), _Count, _Val, _Pred, _Proj);
                    return {::std:: move(_First), ::std:: move(_Mid)};
                }
            }

            return {_First, _First};
        }
    };

     inline constexpr _Equal_range_fn equal_range{_Not_quite_object::_Construct_tag{}};
} 
#line 7109 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Ty, class _Pr>
[[nodiscard]] constexpr bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = ::std:: lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    return _UFirst != _ULast && !_Pred(_Val, *_UFirst);
}

 template <class _FwdIt, class _Ty>
[[nodiscard]] constexpr bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {
    
    return ::std:: binary_search(_First, _Last, _Val, less<>{});
}


namespace ranges {
    class _Binary_search_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(
            _It _First, _Se _Last, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst      = _Unwrap_iter<_Se>(::std:: move(_First));
            const auto _ULast = _Unwrap_sent<_It>(::std:: move(_Last));
            const auto _Count = ::std::ranges:: distance(_UFirst, _ULast);
            _UFirst =
                ::std::ranges:: _Lower_bound_unchecked(::std:: move(_UFirst), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UFirst != _ULast && !::std:: invoke(_Pred, _Val, ::std:: invoke(_Proj, *_UFirst));
        }

        template <forward_range _Rng, class _Ty, class _Pj = identity,
            indirect_strict_weak_order<const _Ty*, projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, const _Ty& _Val, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _Count = ::std::ranges:: distance(_Range);
            const auto _UFirst =
                ::std::ranges:: _Lower_bound_unchecked(_Ubegin(_Range), _Count, _Val, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UFirst != _Uend(_Range) && !::std:: invoke(_Pred, _Val, ::std:: invoke(_Proj, *_UFirst));
        }
    };

     inline constexpr _Binary_search_fn binary_search{_Not_quite_object::_Construct_tag{}};
} 
#line 7158 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Distance_unknown) {
    return {};
}

template <class _Diff1>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Diff1, _Distance_unknown) {
    return {};
}

template <class _Diff2>
[[nodiscard]] constexpr _Distance_unknown _Idl_dist_add(_Distance_unknown, _Diff2) {
    return {};
}

template <class _Diff1, class _Diff2>
[[nodiscard]] constexpr auto _Idl_dist_add(_Diff1 _Lhs, _Diff2 _Rhs) {
    return _Lhs + _Rhs;
}

 template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
constexpr _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    const auto _Count1 = _Idl_distance<_InIt1>(_UFirst1, _ULast1);
    const auto _Count2 = _Idl_distance<_InIt2>(_UFirst2, _ULast2);
    auto _UDest        = _Get_unwrapped_n(_Dest, _Idl_dist_add(_Count1, _Count2));
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (;;) {
            if (static_cast<bool>(_Pred(*_UFirst2, *_UFirst1))) {
                *_UDest = *_UFirst2;
                ++_UDest;
                ++_UFirst2;

                if (_UFirst2 == _ULast2) {
                    break;
                }
            } else {
                *_UDest = *_UFirst1;
                ++_UDest;
                ++_UFirst1;

                if (_UFirst1 == _ULast1) {
                    break;
                }
            }
        }
    }

    _UDest = ::std:: _Copy_unchecked(_UFirst1, _ULast1, _UDest); 
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

 template <class _InIt1, class _InIt2, class _OutIt>
constexpr _OutIt merge(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 merge(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: merge(_First1, _Last1, _First2, _Last2, _Dest);
}


namespace ranges {
     template <class _In1, class _In2, class _Out>
    using merge_result = in_in_out_result<_In1, _In2, _Out>;

    class _Merge_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<_It1, _It2, _Out, _Pr, _Pj1, _Pj2>
        constexpr merge_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult =
                _Merge_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)), _Unwrap_sent<_It1>(::std:: move(_Last1)),
                    _Unwrap_iter<_Se2>(::std:: move(_First2)), _Unwrap_sent<_It2>(::std:: move(_Last2)), ::std:: move(_Result),
                    _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_UResult.out)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, class _Pr = ranges::less,
            class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Out, _Pr, _Pj1, _Pj2>
        constexpr merge_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _First2  = ::std::ranges:: begin(_Range2);
            auto _UResult = _Merge_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2), ::std:: move(_Result), _Pass_fn(_Pred),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_UResult.out)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr merge_result<_It1, _It2, _Out> _Merge_unchecked(_It1 _First1, const _Se1 _Last1,
            _It2 _First2, const _Se2 _Last2, _Out _Result, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;

            for (;; ++_Result) {
                if (_First1 == _Last1) {
                    auto _Copy_result =
                        ::std::ranges:: _Copy_unchecked(::std:: move(_First2), ::std:: move(_Last2), ::std:: move(_Result));
                    return {::std:: move(_First1), ::std:: move(_Copy_result.in), ::std:: move(_Copy_result.out)};
                }

                if (_First2 == _Last2) {
                    auto _Copy_result =
                        ::std::ranges:: _Copy_unchecked(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_Result));
                    return {::std:: move(_Copy_result.in), ::std:: move(_First2), ::std:: move(_Copy_result.out)};
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    *_Result = *_First2;
                    ++_First2;
                } else {
                    *_Result = *_First1;
                    ++_First1;
                }
            }
        }
    };

     inline constexpr _Merge_fn merge{_Not_quite_object::_Construct_tag{}};
} 
#line 7328 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 7329 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"









template <class _BidIt>
void _Rotate_one_right(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_Mid));
    _Move_backward_unchecked(_First, _Mid, _Last);
    *_First = ::std:: move(_Temp);
}

template <class _BidIt>
void _Rotate_one_left(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    
    _Iter_value_t<_BidIt> _Temp(::std:: move(*_First));
    *::std:: _Move_unchecked(_Mid, _Last, _First) = ::std:: move(_Temp);
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_left(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, ::std:: _Uninitialized_move_unchecked(_First, _Mid, _Temp_ptr)};
    _Ptr_ty _Left_first      = _Temp_ptr;
    const _Ptr_ty _Left_last = _Backout._Last - 1; 
    *_First                  = ::std:: move(*_Mid); 
    ++_First;
    ++_Mid;
    for (;;) {
        if (_Pred(*_Mid, *_Left_first)) { 
            *_First = ::std:: move(*_Mid);
            ++_First;
            ++_Mid;
            if (_Mid == _Last) {
                ::std:: _Move_unchecked(_Left_first, _Backout._Last, _First); 
                return;
            }
        } else { 
            *_First = ::std:: move(*_Left_first);
            ++_First;
            ++_Left_first;
            if (_Left_first == _Left_last) {
                
                *::std:: _Move_unchecked(_Mid, _Last, _First) = ::std:: move(*_Left_last);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Inplace_merge_buffer_right(
    _BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    using _Ptr_ty = _Iter_value_t<_BidIt>*;
    _Uninitialized_backout<_Ptr_ty> _Backout{_Temp_ptr, ::std:: _Uninitialized_move_unchecked(_Mid, _Last, _Temp_ptr)};
    *--_Last                   = ::std:: move(*--_Mid); 
    const _Ptr_ty _Right_first = _Temp_ptr;
    _Ptr_ty _Right_last        = _Backout._Last - 1;
    --_Mid;
    for (;;) {
        if (_Pred(*_Right_last, *_Mid)) { 
            *--_Last = ::std:: move(*_Mid);
            if (_First == _Mid) {
                *--_Last = ::std:: move(*_Right_last); 
                _Move_backward_unchecked(_Right_first, _Right_last, _Last); 
                return;
            }

            --_Mid;
        } else { 
            *--_Last = ::std:: move(*_Right_last);
            --_Right_last;
            if (_Right_first == _Right_last) { 
                *--_Last = ::std:: move(*_Mid); 
                _Move_backward_unchecked(_First, _Mid, _Last);
                *_First = ::std:: move(*_Right_first);
                return;
            }
        }
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* _Temp_ptr, ptrdiff_t _Capacity, _Pr _Pred);

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer2(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred,
    _BidIt _Firstn, _BidIt _Lastn, _Iter_diff_t<_BidIt> _Count1n, _Iter_diff_t<_BidIt> _Count2n) {
    
    using _Diff  = _Iter_diff_t<_BidIt>;
    _BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn, static_cast<_Diff>(_Count1 - _Count1n), _Count2n,
        _Temp_ptr, _Capacity); 
    _Buffered_inplace_merge_unchecked(
        _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred); 
    _Buffered_inplace_merge_unchecked(_Midn, _Lastn, _Last, static_cast<_Diff>(_Count1 - _Count1n),
        static_cast<_Diff>(_Count2 - _Count2n), _Temp_ptr, _Capacity, _Pred);
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_divide_and_conquer(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count1 <= _Count2) {
        const _Diff _Count1n = _Count1 >> 1; 
        const _BidIt _Firstn = ::std:: next(_First, _Count1n);
        const _BidIt _Lastn  = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
        ::std:: _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity,
            _Pred, _Firstn, _Lastn, _Count1n, ::std:: distance(_Mid, _Lastn));
    } else {
        const _Diff _Count2n = _Count2 >> 1; 
        const _BidIt _Lastn  = ::std:: next(_Mid, _Count2n);
        const _BidIt _Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
        ::std:: _Buffered_inplace_merge_divide_and_conquer2(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity,
            _Pred, _Firstn, _Lastn, ::std:: distance(_First, _Firstn), _Count2n);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked_impl(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    if (_Count1 <= _Count2 && _Count1 <= _Capacity) {
        ::std:: _Inplace_merge_buffer_left(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else if (_Count2 <= _Capacity) {
        ::std:: _Inplace_merge_buffer_right(_First, _Mid, _Last, _Temp_ptr, _Pred);
    } else {
        ::std:: _Buffered_inplace_merge_divide_and_conquer(
            _First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Buffered_inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Iter_diff_t<_BidIt> _Count1,
    _Iter_diff_t<_BidIt> _Count2, _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    
    
    if (_Mid == _Last) {
        return;
    }

    for (;;) {
        if (_First == _Mid) {
            return;
        }

        if (_Pred(*_Mid, *_First)) {
            break;
        }

        ++_First;
        --_Count1;
    }

    const auto _Highest = _Prev_iter(_Mid);
    do {
        --_Last;
        --_Count2;
        if (_Mid == _Last) {
            ::std:: _Rotate_one_right(_First, _Mid, ++_Last);
            return;
        }
    } while (!_Pred(*_Last, *_Highest));

    ++_Last;
    ++_Count2;

    if (_Count1 == 1) {
        ::std:: _Rotate_one_left(_First, _Mid, _Last);
        return;
    }

    _Buffered_inplace_merge_unchecked_impl(_First, _Mid, _Last, _Count1, _Count2, _Temp_ptr, _Capacity, _Pred);
}

 template <class _BidIt, class _Pr>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _UMid   = _Get_unwrapped(_Mid);
    auto _ULast  = _Get_unwrapped(_Last);
    ;

    
    if (_UMid == _ULast) {
        return;
    }

    for (;;) {
        if (_UFirst == _UMid) {
            return;
        }

        if (_Pred(*_UMid, *_UFirst)) { 
            break;
        }

        ++_UFirst;
    }

    const auto _Highest = _Prev_iter(_UMid);
    do {
        --_ULast;
        if (_UMid == _ULast) { 
            ::std:: _Rotate_one_right(_UFirst, _UMid, ++_ULast);
            return;
        }
    } while (!_Pred(*_ULast, *_Highest)); 

    ++_ULast;

    using _Diff         = _Iter_diff_t<_BidIt>;
    const _Diff _Count1 = ::std:: distance(_UFirst, _UMid);
    if (_Count1 == 1) { 
        ::std:: _Rotate_one_left(_UFirst, _UMid, _ULast);
        return;
    }

    const _Diff _Count2 = ::std:: distance(_UMid, _ULast);
    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{(::std:: min)(_Count1, _Count2)};
    _Buffered_inplace_merge_unchecked_impl(
        _UFirst, _UMid, _ULast, _Count1, _Count2, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}

 template <class _BidIt>
void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last) {
    
    ::std:: inplace_merge(_First, _Mid, _Last, less<>{});
}


 template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
void inplace_merge(_ExPo&&, _BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_cpp17_bidi_iter_v<_BidIt>, "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.");
    ::std:: inplace_merge(_First, _Mid, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void inplace_merge(_ExPo&&, _BidIt _First, _BidIt _Mid, _BidIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_bidi_iter_v<_BidIt>, "This algorithm requires that mutable iterators be Cpp17BidirectionalIterators or stronger.");
    ::std:: inplace_merge(_First, _Mid, _Last);
}
#line 7595 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    template <forward_iterator _It, sentinel_for<_It> _Se, class _Pr, class _Pj>
        requires indirect_strict_weak_order<_Pr, projected<_It, _Pj>>
    [[nodiscard]] constexpr _It _Is_sorted_until_unchecked(_It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
        if (_First == _Last) {
            return _First;
        }

        for (auto _Prev = _First; ++_First != _Last; ++_Prev) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Prev))) {
                break;
            }
        }

        return _First;
    }

    template <bidirectional_iterator _It>
    void _Rotate_one_right(_It _First, _It _Mid, _It _Last) {
        
        ;
        auto _Temp = ::std::ranges:: iter_move(_Mid);
        ::std::ranges:: _Move_backward_common(_First, ::std:: move(_Mid), ::std:: move(_Last));
        *_First = ::std:: move(_Temp);
    }

    template <bidirectional_iterator _It>
    void _Rotate_one_left(_It _First, _It _Mid, _It _Last) {
        
        ;
        auto _Temp   = ::std::ranges:: iter_move(_First);
        auto _Result = ::std::ranges:: _Move_unchecked(::std:: move(_Mid), ::std:: move(_Last), ::std:: move(_First));
        *_Result.out = ::std:: move(_Temp);
    }

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Inplace_merge_buffer_left(_It _First, _It _Mid, _It _Last, iter_value_t<_It>* _Left_first,
        const ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj) {
        
        
        using _Ty = iter_value_t<_It>;

        _Ty* _Left_last = ::std::ranges:: _Uninitialized_move_unchecked(_First, _Mid, _Left_first, _Left_first + _Capacity).out;
        _Uninitialized_backout<_Ty*> _Backout{_Left_first, _Left_last};

        
        --_Left_last;

        
        *_First = ::std::ranges:: iter_move(_Mid);
        ++_First;
        ++_Mid;

        for (;;) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_Left_first))) {
                *_First = ::std::ranges:: iter_move(_Mid); 
                ++_First;
                ++_Mid;
                if (_Mid == _Last) {
                    
                    ::std::ranges:: _Move_unchecked(_Left_first, _Backout._Last, _First);
                    return;
                }
            } else {
                *_First = ::std::ranges:: iter_move(_Left_first);
                ++_First;
                ++_Left_first;
                if (_Left_first == _Left_last) {
                    
                    const auto _Final = ::std::ranges:: _Move_unchecked(_Mid, _Last, _First);
                    *_Final.out       = ::std::ranges:: iter_move(_Left_first);
                    return;
                }
            }
        }
    }

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Inplace_merge_buffer_right(_It _First, _It _Mid, _It _Last, iter_value_t<_It>* _Right_first,
        const ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj) {
        
        
        using _Ty = iter_value_t<_It>;

        _Ty* _Right_last =
            ::std::ranges:: _Uninitialized_move_unchecked(_Mid, _Last, _Right_first, _Right_first + _Capacity).out;
        _Uninitialized_backout<_Ty*> _Backout{_Right_first, _Right_last};

        
        *--_Last = ::std::ranges:: iter_move(--_Mid);

        
        --_Mid;
        --_Right_last;
        for (;;) {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Right_last), ::std:: invoke(_Proj, *_Mid))) {
                *--_Last = ::std::ranges:: iter_move(_Mid); 
                if (_First == _Mid) {
                    ++_Right_last; 
                    ::std::ranges:: _Move_backward_common(_Right_first, _Right_last, ::std:: move(_Last));
                    return;
                }
                --_Mid;
            } else {
                *--_Last = ::std::ranges:: iter_move(_Right_last);
                --_Right_last;
                if (_Right_first == _Right_last) { 
                    ++_Mid; 
                    ::std::ranges:: _Move_backward_common(_First, ::std:: move(_Mid), ::std:: move(_Last));
                    *_First = ::std::ranges:: iter_move(_Right_first);
                    return;
                }
            }
        }
    }

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Buffered_inplace_merge_common(_It _First, _It _Mid, _It _Last, iter_difference_t<_It> _Count1,
        iter_difference_t<_It> _Count2, iter_value_t<_It>* _Temp_ptr, ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj);

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Buffered_inplace_merge_divide_and_conquer2(_It _First, _It _Mid, _It _Last,
        const iter_difference_t<_It> _Count1, const iter_difference_t<_It> _Count2, iter_value_t<_It>* const _Temp_ptr,
        const ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj, _It _Firstn, _It _Lastn, const iter_difference_t<_It> _Count1n,
        const iter_difference_t<_It> _Count2n) {
        
        _It _Midn = ::std::ranges:: _Buffered_rotate_common(_Firstn, _Mid, _Lastn,
            static_cast<iter_difference_t<_It>>(_Count1 - _Count1n), _Count2n, _Temp_ptr,
            _Capacity); 
        ::std::ranges:: _Buffered_inplace_merge_common(
            _First, _Firstn, _Midn, _Count1n, _Count2n, _Temp_ptr, _Capacity, _Pred, _Proj); 
        ::std::ranges:: _Buffered_inplace_merge_common(_Midn, _Lastn, _Last,
            static_cast<iter_difference_t<_It>>(_Count1 - _Count1n),
            static_cast<iter_difference_t<_It>>(_Count2 - _Count2n), _Temp_ptr, _Capacity, _Pred, _Proj);
    }

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Buffered_inplace_merge_divide_and_conquer(_It _First, _It _Mid, _It _Last,
        const iter_difference_t<_It> _Count1, const iter_difference_t<_It> _Count2, iter_value_t<_It>* const _Temp_ptr,
        const ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj) {
        
        
        if (_Count1 <= _Count2) {
            const iter_difference_t<_It> _Count1n = _Count1 >> 1; 
            _It _Firstn                           = ::std::ranges:: next(_First, _Count1n);
            _It _Lastn = ::std::ranges:: _Lower_bound_unchecked(_Mid, _Count1, ::std:: invoke(_Proj, *_Firstn), _Pred, _Proj);
            const auto _Count2n = ::std::ranges:: distance(_Mid, _Lastn);
            ::std::ranges:: _Buffered_inplace_merge_divide_and_conquer2(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                _Count1, _Count2, _Temp_ptr, _Capacity, _Pred, _Proj, ::std:: move(_Firstn), ::std:: move(_Lastn), _Count1n,
                _Count2n);
        } else {
            const iter_difference_t<_It> _Count2n = _Count2 >> 1; 
            _It _Lastn                            = ::std::ranges:: next(_Mid, _Count2n);
            _It _Firstn = ::std::ranges:: _Upper_bound_unchecked(_First, _Count2, ::std:: invoke(_Proj, *_Lastn), _Pred, _Proj);
            const auto _Count1n = ::std::ranges:: distance(_First, _Firstn);
            ::std::ranges:: _Buffered_inplace_merge_divide_and_conquer2(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                _Count1, _Count2, _Temp_ptr, _Capacity, _Pred, _Proj, ::std:: move(_Firstn), ::std:: move(_Lastn), _Count1n,
                _Count2n);
        }
    }

    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    void _Buffered_inplace_merge_common(_It _First, _It _Mid, _It _Last, iter_difference_t<_It> _Count1,
        iter_difference_t<_It> _Count2, iter_value_t<_It>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred,
        _Pj _Proj) {
        
        
        
        if (_First == _Mid || _Mid == _Last) {
            return;
        }

        
        while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_First))) {
            --_Count1;
            if (++_First == _Mid) {
                return;
            }
        }

        
        const auto _Highest = ::std::ranges:: prev(_Mid);
        do {
            
            if (_Mid == --_Last) {
                
                ::std::ranges:: _Rotate_one_right(::std:: move(_First), ::std:: move(_Mid), ::std:: move(++_Last));
                return;
            }
            --_Count2;
        } while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Last), ::std:: invoke(_Proj, *_Highest)));
        ++_Last;
        ++_Count2;

        if (_Count1 == 1) {
            ::std::ranges:: _Rotate_one_left(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last));
            return;
        }

        if (_Count1 <= _Count2 && _Count1 <= _Capacity) {
            ::std::ranges:: _Inplace_merge_buffer_left(
                ::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last), _Temp_ptr, _Capacity, _Pred, _Proj);
        } else if (_Count2 <= _Capacity) {
            ::std::ranges:: _Inplace_merge_buffer_right(
                ::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last), _Temp_ptr, _Capacity, _Pred, _Proj);
        } else {
            ::std::ranges:: _Buffered_inplace_merge_divide_and_conquer(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                _Count1, _Count2, _Temp_ptr, _Capacity, _Pred, _Proj);
        }
    }

    class _Inplace_merge_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        _It operator()(_It _First, _It _Mid, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Mid);
            _Adl_verify_range(_Mid, _Last);

            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);

            _Inplace_merge_common(::std:: move(_UFirst), _Unwrap_iter<_Se>(::std:: move(_Mid)), ::std:: move(_ULast),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <bidirectional_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, iterator_t<_Rng> _Mid, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _First = ::std::ranges:: begin(_Range);
            auto _Last  = ::std::ranges:: end(_Range);

            _Adl_verify_range(_First, _Mid);
            _Adl_verify_range(_Mid, _Last);

            auto _UFirst = _Unwrap_range_iter<_Rng>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<iterator_t<_Rng>>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);

            _Inplace_merge_common(::std:: move(_UFirst), _Unwrap_range_iter<_Rng>(::std:: move(_Mid)), ::std:: move(_ULast),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static void _Inplace_merge_common(_It _First, _It _Mid, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            if (_First == _Mid || _Mid == _Last) {
                return;
            }





#line 7867 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            
            while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_First))) {
                if (++_First == _Mid) {
                    return;
                }
            }

            
            if (_Mid == --_Last) {
                
                ::std::ranges:: _Rotate_one_right(::std:: move(_First), ::std:: move(_Mid), ::std:: move(++_Last));
                return;
            }

            
            const auto _Highest = ::std::ranges:: prev(_Mid);
            while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Last), ::std:: invoke(_Proj, *_Highest))) {
                if (_Mid == --_Last) {
                    
                    ::std::ranges:: _Rotate_one_right(::std:: move(_First), ::std:: move(_Mid), ::std:: move(++_Last));
                    return;
                }
            }
            ++_Last;

            const iter_difference_t<_It> _Count1 = ::std::ranges:: distance(_First, _Mid);
            if (_Count1 == 1) { 
                ::std::ranges:: _Rotate_one_left(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last));
                return;
            }

            const iter_difference_t<_It> _Count2 = ::std::ranges:: distance(_Mid, _Last);
            _Optimistic_temporary_buffer<iter_value_t<_It>> _Temp_buf{(::std:: min)(_Count1, _Count2)};
            if (_Count1 <= _Count2 && _Count1 <= _Temp_buf._Capacity) {
                ::std::ranges:: _Inplace_merge_buffer_left(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                    _Temp_buf._Data, _Temp_buf._Capacity, _Pred, _Proj);
            } else if (_Count2 <= _Temp_buf._Capacity) {
                ::std::ranges:: _Inplace_merge_buffer_right(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                    _Temp_buf._Data, _Temp_buf._Capacity, _Pred, _Proj);
            } else {
                ::std::ranges:: _Buffered_inplace_merge_divide_and_conquer(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                    _Count1, _Count2, _Temp_buf._Data, _Temp_buf._Capacity, _Pred, _Proj);
            }
        }
    };

     inline constexpr _Inplace_merge_fn inplace_merge{_Not_quite_object::_Construct_tag{}};
} 
#line 7917 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _BidIt, class _Pr>
constexpr _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    if (_First != _Last) {
        for (_BidIt _Mid = _First; ++_Mid != _Last;) { 
            _BidIt _Hole               = _Mid;
            _Iter_value_t<_BidIt> _Val = ::std:: move(*_Mid);

            if (static_cast<bool>(_Pred(_Val, *_First))) { 
                _Move_backward_unchecked(_First, _Mid, ++_Hole);
                *_First = ::std:: move(_Val);
            } else { 
                for (_BidIt _Prev = _Hole; static_cast<bool>(_Pred(_Val, *--_Prev)); _Hole = _Prev) {
                    *_Hole = ::std:: move(*_Prev); 
                }

                *_Hole = ::std:: move(_Val); 
            }
        }
    }

    return _Last;
}

template <class _RanIt, class _Pr>
constexpr void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    if (static_cast<bool>(_Pred(*_Mid, *_First))) {
        swap(*_Mid, *_First); 
    }

    if (static_cast<bool>(_Pred(*_Last, *_Mid))) { 
        swap(*_Last, *_Mid); 

        if (static_cast<bool>(_Pred(*_Mid, *_First))) {
            swap(*_Mid, *_First); 
        }
    }
}

template <class _RanIt, class _Pr>
constexpr void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    using _Diff        = _Iter_diff_t<_RanIt>;
    const _Diff _Count = _Last - _First;
    if (40 < _Count) { 
        const _Diff _Step     = (_Count + 1) >> 3; 
        const _Diff _Two_step = _Step << 1; 
        _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);
        _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
        _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);
        _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
    } else {
        _Med3_unchecked(_First, _Mid, _Last, _Pred);
    }
}

template <class _RanIt, class _Pr>
constexpr pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {
    
    _RanIt _Mid = _First + ((_Last - _First) >> 1); 
    _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);
    _RanIt _Pfirst = _Mid;
    _RanIt _Plast  = _Next_iter(_Pfirst);

    while (_First < _Pfirst && !static_cast<bool>(_Pred(*_Prev_iter(_Pfirst), *_Pfirst))
           && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {
        --_Pfirst;
    }

    while (_Plast < _Last && !static_cast<bool>(_Pred(*_Plast, *_Pfirst)) && !_Pred(*_Pfirst, *_Plast)) {
        ++_Plast;
    }

    _RanIt _Gfirst = _Plast;
    _RanIt _Glast  = _Pfirst;

    for (;;) { 
        for (; _Gfirst < _Last; ++_Gfirst) {
            if (static_cast<bool>(_Pred(*_Pfirst, *_Gfirst))) {
                continue;
            } else if (_Pred(*_Gfirst, *_Pfirst)) {
                break;
            } else if (_Plast != _Gfirst) {
                swap(*_Plast, *_Gfirst); 
                ++_Plast;
            } else {
                ++_Plast;
            }
        }

        for (; _First < _Glast; --_Glast) {
            const auto _Glast_prev = _Prev_iter(_Glast);
            if (static_cast<bool>(_Pred(*_Glast_prev, *_Pfirst))) {
                continue;
            } else if (_Pred(*_Pfirst, *_Glast_prev)) {
                break;
            } else if (--_Pfirst != _Glast_prev) {
                swap(*_Pfirst, *_Glast_prev); 
            }
        }

        if (_Glast == _First && _Gfirst == _Last) {
            return pair<_RanIt, _RanIt>(_Pfirst, _Plast);
        }

        if (_Glast == _First) { 
            if (_Plast != _Gfirst) {
                swap(*_Pfirst, *_Plast); 
            }

            ++_Plast;
            swap(*_Pfirst, *_Gfirst); 
            ++_Pfirst;
            ++_Gfirst;
        } else if (_Gfirst == _Last) { 
            if (--_Glast != --_Pfirst) {
                swap(*_Glast, *_Pfirst); 
            }

            swap(*_Pfirst, *--_Plast); 
        } else {
            swap(*_Gfirst, *--_Glast); 
            ++_Gfirst;
        }
    }
}

template <class _RanIt, class _Pr>
constexpr void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {
    
    for (;;) {
        if (_Last - _First <= _ISORT_MAX) { 
            _Insertion_sort_unchecked(_First, _Last, _Pred);
            return;
        }

        if (_Ideal <= 0) { 
            _Make_heap_unchecked(_First, _Last, _Pred);
            _Sort_heap_unchecked(_First, _Last, _Pred);
            return;
        }

        
        auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

        _Ideal = (_Ideal >> 1) + (_Ideal >> 2); 

        if (_Mid.first - _First < _Last - _Mid.second) { 
            _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);
            _First = _Mid.second;
        } else { 
            _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);
            _Last = _Mid.first;
        }
    }
}

 template <class _RanIt, class _Pr>
constexpr void sort(const _RanIt _First, const _RanIt _Last, _Pr _Pred) { 
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));
}

 template <class _RanIt>
constexpr void sort(const _RanIt _First, const _RanIt _Last) { 
    ::std:: sort(_First, _Last, less<>{});
}


 template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
void sort(_ExPo&& _Exec, _RanIt _First, _RanIt _Last, _Pr _Pred) noexcept; 

 template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void sort(_ExPo&& _Exec, const _RanIt _First, const _RanIt _Last) noexcept  {
    
    ::std:: sort(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
#line 8099 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    template <bidirectional_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr _It _Insertion_sort_common(const _It _First, const _It _Last, _Pr _Pred, _Pj _Proj) {
        

        if (_First == _Last) { 
            return _Last;
        }

        for (auto _Mid = _First; ++_Mid != _Last;) { 
            iter_value_t<_It> _Val = ::std::ranges:: iter_move(_Mid);
            auto _Hole             = _Mid;

            for (auto _Prev = _Hole;;) {
                --_Prev;
                if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, _Val), ::std:: invoke(_Proj, *_Prev))) {
                    break;
                }
                *_Hole = ::std::ranges:: iter_move(_Prev); 
                if (--_Hole == _First) {
                    break;
                }
            }

            *_Hole = ::std:: move(_Val); 
        }
        return _Last;
    }

    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr void _Med3_common(_It _First, _It _Mid, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_First))) {
            ::std::ranges:: iter_swap(_Mid, _First);
        }

        if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Last), ::std:: invoke(_Proj, *_Mid))) {
            return;
        }

        
        ::std::ranges:: iter_swap(_Last, _Mid);

        if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_First))) {
            ::std::ranges:: iter_swap(_Mid, _First);
        }
    }

    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    constexpr void _Guess_median_common(_It _First, _It _Mid, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        using _Diff        = iter_difference_t<_It>;
        const _Diff _Count = _Last - _First;
        if (_Count > 40) { 
            const _Diff _Step     = (_Count + 1) >> 3; 
            const _Diff _Two_step = _Step << 1; 
            _Med3_common(_First, _First + _Step, _First + _Two_step, _Pred, _Proj);
            _Med3_common(_Mid - _Step, _Mid, _Mid + _Step, _Pred, _Proj);
            _Med3_common(_Last - _Two_step, _Last - _Step, _Last, _Pred, _Proj);
            _Med3_common(_First + _Step, _Mid, _Last - _Step, _Pred, _Proj);
        } else {
            _Med3_common(_First, _Mid, _Last, _Pred, _Proj);
        }
    }

    template <random_access_iterator _It, class _Pr, class _Pj>
        requires sortable<_It, _Pr, _Pj>
    [[nodiscard]] constexpr subrange<_It> _Partition_by_median_guess_common(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
        
        

        _It _Mid = _First + ((_Last - _First) >> 1); 
        _Guess_median_common(_First, _Mid, ::std::ranges:: prev(_Last), _Pred, _Proj);
        _It _Pfirst = _Mid;
        _It _Plast  = ::std::ranges:: next(_Pfirst);

        while (_First < _Pfirst
               && !::std:: invoke(_Pred, ::std:: invoke(_Proj, *::std::ranges:: prev(_Pfirst)), ::std:: invoke(_Proj, *_Pfirst))
               && !::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Pfirst), ::std:: invoke(_Proj, *::std::ranges:: prev(_Pfirst)))) {
            --_Pfirst;
        }

        while (_Plast < _Last && !::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Plast), ::std:: invoke(_Proj, *_Pfirst))
               && !::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Pfirst), ::std:: invoke(_Proj, *_Plast))) {
            ++_Plast;
        }

        _It _Gfirst = _Plast;
        _It _Glast  = _Pfirst;

        for (;;) { 
            for (; _Gfirst < _Last; ++_Gfirst) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Pfirst), ::std:: invoke(_Proj, *_Gfirst))) {
                    continue;
                } else if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Gfirst), ::std:: invoke(_Proj, *_Pfirst))) {
                    break;
                } else if (_Plast != _Gfirst) {
                    ::std::ranges:: iter_swap(_Plast, _Gfirst);
                    ++_Plast;
                } else {
                    ++_Plast;
                }
            }

            for (; _First < _Glast; --_Glast) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *::std::ranges:: prev(_Glast)), ::std:: invoke(_Proj, *_Pfirst))) {
                    continue;
                } else if (::std:: invoke(
                               _Pred, ::std:: invoke(_Proj, *_Pfirst), ::std:: invoke(_Proj, *::std::ranges:: prev(_Glast)))) {
                    break;
                } else if (--_Pfirst != ::std::ranges:: prev(_Glast)) {
                    ::std::ranges:: iter_swap(_Pfirst, ::std::ranges:: prev(_Glast));
                }
            }

            if (_Glast == _First && _Gfirst == _Last) {
                return {::std:: move(_Pfirst), ::std:: move(_Plast)};
            }

            if (_Glast == _First) { 
                if (_Plast != _Gfirst) {
                    ::std::ranges:: iter_swap(_Pfirst, _Plast);
                }

                ++_Plast;
                ::std::ranges:: iter_swap(_Pfirst, _Gfirst);
                ++_Pfirst;
                ++_Gfirst;
            } else if (_Gfirst == _Last) { 
                if (--_Glast != --_Pfirst) {
                    ::std::ranges:: iter_swap(_Glast, _Pfirst);
                }

                ::std::ranges:: iter_swap(_Pfirst, --_Plast);
            } else {
                ::std::ranges:: iter_swap(_Gfirst, --_Glast);
                ++_Gfirst;
            }
        }
    }

    class _Sort_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            const auto _Count = _ULast - _UFirst;
            _Sort_common(::std:: move(_UFirst), ::std:: move(_ULast), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst      = _Ubegin(_Range);
            auto _ULast       = _Get_final_iterator_unwrapped(_Range);
            const auto _Count = _ULast - _UFirst;
            _Sort_common(::std:: move(_UFirst), _ULast, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_ULast));
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static constexpr void _Sort_common(_It _First, _It _Last, iter_difference_t<_It> _Ideal, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;

            for (;;) {
                if (_Last - _First <= _ISORT_MAX) { 
                    ::std::ranges:: _Insertion_sort_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
                    return;
                }

                if (_Ideal <= 0) { 
                    _Make_heap_common(_First, _Last, _Pred, _Proj);
                    _Sort_heap_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
                    return;
                }

                


#line 8294 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
                auto _Mid       = _Partition_by_median_guess_common(_First, _Last, _Pred, _Proj);
                auto _Mid_first = _Mid.begin();
                auto _Mid_last  = _Mid.end();
#line 8298 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

                _Ideal = (_Ideal >> 1) + (_Ideal >> 2); 

                if (_Mid_first - _First < _Last - _Mid_last) { 
                    _Sort_common(_First, ::std:: move(_Mid_first), _Ideal, _Pred, _Proj);
                    _First = ::std:: move(_Mid_last);
                } else { 
                    _Sort_common(::std:: move(_Mid_last), _Last, _Ideal, _Pred, _Proj);
                    _Last = ::std:: move(_Mid_first);
                }
            }
        }
    };

     inline constexpr _Sort_fn sort{_Not_quite_object::_Construct_tag{}};
} 
#line 8315 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _FwdIt, class _Ty, class _Pr>
_Ty* _Uninitialized_merge_move(_FwdIt _First, const _FwdIt _Mid, const _FwdIt _Last, _Ty* const _Dest, _Pr _Pred) {
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    _FwdIt _Next = _Mid;
    for (;;) {
        if (static_cast<bool>(_Pred(*_Next, *_First))) {
            _Backout._Emplace_back(::std:: move(*_Next));
            ++_Next;

            if (_Next == _Last) {
                _Backout._Last = ::std:: _Uninitialized_move_unchecked(_First, _Mid, _Backout._Last);
                return _Backout._Release();
            }
        } else {
            _Backout._Emplace_back(::std:: move(*_First));
            ++_First;

            if (_First == _Mid) {
                _Backout._Last = ::std:: _Uninitialized_move_unchecked(_Next, _Last, _Backout._Last);
                return _Backout._Release();
            }
        }
    }
}

template <class _InIt, class _OutIt, class _Pr>
_OutIt _Merge_move(_InIt _First, const _InIt _Mid, const _InIt _Last, _OutIt _Dest, _Pr _Pred) {
    
    
    _InIt _Next = _Mid;
    for (;;) {
        if (static_cast<bool>(_Pred(*_Next, *_First))) {
            *_Dest = ::std:: move(*_Next);
            ++_Dest;
            ++_Next;

            if (_Next == _Last) {
                return ::std:: _Move_unchecked(_First, _Mid, _Dest);
            }
        } else {
            *_Dest = ::std:: move(*_First);
            ++_Dest;
            ++_First;

            if (_First == _Mid) {
                return ::std:: _Move_unchecked(_Next, _Last, _Dest);
            }
        }
    }
}

template <class _BidIt, class _Ty, class _Pr>
void _Uninitialized_chunked_merge_unchecked2(
    _BidIt _First, const _BidIt _Last, _Ty* _Dest, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    _Uninitialized_backout<_Ty*> _Backout{_Dest};
    while (_Count > _Isort_max<_BidIt>) {
        _Count -= _Isort_max<_BidIt>;
        const _BidIt _Mid1 = ::std:: next(_First, _Isort_max<_BidIt>);
        const auto _Chunk2 = (::std:: min)(_Isort_max<_BidIt>, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Backout._Last     = _Uninitialized_merge_move(_First, _Mid1, _Mid2, _Backout._Last, _Pred);
        _First             = _Mid2;
    }

    ::std:: _Uninitialized_move_unchecked(_First, _Last, _Backout._Last); 
    _Backout._Release();
}

template <class _BidIt, class _OutIt, class _Pr>
void _Chunked_merge_unchecked(_BidIt _First, const _BidIt _Last, _OutIt _Dest, const _Iter_diff_t<_BidIt> _Chunk,
    _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    
    while (_Chunk < _Count) {
        _Count -= _Chunk;
        const _BidIt _Mid1 = ::std:: next(_First, _Chunk);
        const auto _Chunk2 = (::std:: min)(_Chunk, _Count);
        _Count -= _Chunk2;
        const _BidIt _Mid2 = ::std:: next(_Mid1, _Chunk2);
        _Dest              = _Merge_move(_First, _Mid1, _Mid2, _Dest, _Pred);
        _First             = _Mid2;
    }

    ::std:: _Move_unchecked(_First, _Last, _Dest); 
}

template <class _BidIt, class _Pr>
void _Insertion_sort_isort_max_chunks(_BidIt _First, const _BidIt _Last, _Iter_diff_t<_BidIt> _Count, _Pr _Pred) {
    
    
    for (; _Isort_max<_BidIt> < _Count; _Count -= _Isort_max<_BidIt>) { 
        _First = _Insertion_sort_unchecked(_First, ::std:: next(_First, _Isort_max<_BidIt>), _Pred);
    }

    _Insertion_sort_unchecked(_First, _Last, _Pred); 
}

template <class _BidIt, class _Pr>
void _Buffered_merge_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, _Pr _Pred) {
    
    
    
    _Insertion_sort_isort_max_chunks(_First, _Last, _Count, _Pred);
    
    if (_Count <= _Isort_max<_BidIt>) {
        return;
    }

    
    _Uninitialized_chunked_merge_unchecked2(_First, _Last, _Temp_ptr, _Count, _Pred);
    _Uninitialized_backout<_Iter_value_t<_BidIt>*> _Backout{_Temp_ptr, _Temp_ptr + _Count};
    auto _Chunk = _Isort_max<_BidIt>;
    for (;;) {
        
        _Chunk <<= 1;
        _Chunked_merge_unchecked(_Temp_ptr, _Temp_ptr + _Count, _First, static_cast<ptrdiff_t>(_Chunk),
            static_cast<ptrdiff_t>(_Count), _Pred);
        _Chunk <<= 1;
        if (_Count <= _Chunk) { 
            return;
        }

        
        _Chunked_merge_unchecked(_First, _Last, _Temp_ptr, _Chunk, _Count, _Pred);
    }
}

template <class _BidIt, class _Pr>
void _Stable_sort_unchecked(const _BidIt _First, const _BidIt _Last, const _Iter_diff_t<_BidIt> _Count,
    _Iter_value_t<_BidIt>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred) {
    
    using _Diff = _Iter_diff_t<_BidIt>;
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_First, _Last, _Pred); 
    } else { 
        const auto _Half_count      = static_cast<_Diff>(_Count >> 1); 
        const auto _Half_count_ceil = static_cast<_Diff>(_Count - _Half_count);
        const _BidIt _Mid           = ::std:: next(_First, _Half_count_ceil);
        if (_Half_count_ceil <= _Capacity) { 
            _Buffered_merge_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred);
            _Buffered_merge_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Pred);
        } else { 
            _Stable_sort_unchecked(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred);
            _Stable_sort_unchecked(_Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred);
        }

        _Buffered_inplace_merge_unchecked(
            _First, _Mid, _Last, _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred); 
    }
}

 template <class _BidIt, class _Pr>
void stable_sort(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    const auto _Count  = ::std:: distance(_UFirst, _ULast);
    if (_Count <= _ISORT_MAX) {
        _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));
        return;
    }

    _Optimistic_temporary_buffer<_Iter_value_t<_BidIt>> _Temp_buf{_Count - _Count / 2};
    _Stable_sort_unchecked(_UFirst, _ULast, _Count, _Temp_buf._Data, _Temp_buf._Capacity, _Pass_fn(_Pred));
}


 template <class _ExPo, class _BidIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
void stable_sort(_ExPo&& _Exec, _BidIt _First, _BidIt _Last, _Pr _Pred) noexcept; 
#line 8495 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _BidIt>
void stable_sort(const _BidIt _First, const _BidIt _Last) { 
    ::std:: stable_sort(_First, _Last, less<>{});
}


 template <class _ExPo, class _BidIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void stable_sort(_ExPo&& _Exec, _BidIt _First, _BidIt _Last) noexcept  {
    
    ::std:: stable_sort(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}
#line 8508 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"


namespace ranges {
    class _Stable_sort_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);

            const auto _Count = _ULast - _UFirst;
            _Stable_sort_common(::std:: move(_UFirst), ::std:: move(_ULast), _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _First;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = _Ubegin(_Range);
            auto _ULast  = _Get_final_iterator_unwrapped(_Range);

            const auto _Count = _ULast - _UFirst;
            _Stable_sort_common(::std:: move(_UFirst), _ULast, _Count, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_ULast));
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static void _Stable_sort_common(
            _It _First, _It _Last, const iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            if (_Count <= _Isort_max<_It>) {
                ::std::ranges:: _Insertion_sort_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
                return;
            }

            _Optimistic_temporary_buffer<_Iter_value_t<_It>> _Temp_buf{_Count - _Count / 2};
            _Stable_sort_common_buffered(
                ::std:: move(_First), ::std:: move(_Last), _Count, _Temp_buf._Data, _Temp_buf._Capacity, _Pred, _Proj);
        }

        template <class _It, class _Pr, class _Pj>
        static void _Stable_sort_common_buffered(_It _First, _It _Last, const iter_difference_t<_It> _Count,
            iter_value_t<_It>* const _Temp_ptr, const ptrdiff_t _Capacity, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            

            if (_Count <= _Isort_max<_It>) {
                ::std::ranges:: _Insertion_sort_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
            } else { 
                const iter_difference_t<_It> _Half_count      = _Count >> 1; 
                const iter_difference_t<_It> _Half_count_ceil = _Count - _Half_count;
                const _It _Mid                                = _First + _Half_count_ceil;
                if (_Half_count_ceil <= _Capacity) { 
                    _Buffered_merge_sort_common(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Pred, _Proj);
                    _Buffered_merge_sort_common(_Mid, _Last, _Half_count, _Temp_ptr, _Pred, _Proj);
                } else { 
                    _Stable_sort_common_buffered(_First, _Mid, _Half_count_ceil, _Temp_ptr, _Capacity, _Pred, _Proj);
                    _Stable_sort_common_buffered(_Mid, _Last, _Half_count, _Temp_ptr, _Capacity, _Pred, _Proj);
                }
                
                ::std::ranges:: _Buffered_inplace_merge_common(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Last),
                    _Half_count_ceil, _Half_count, _Temp_ptr, _Capacity, _Pred, _Proj);
            }
        }

        template <class _It, class _Pr, class _Pj>
        static void _Buffered_merge_sort_common(const _It _First, const _It _Last, const iter_difference_t<_It> _Count,
            iter_value_t<_It>* const _Temp_ptr, _Pr _Pred, _Pj _Proj) {
            
            
            ;
            ;
            ;

            _Insertion_sort_isort_max_chunks(_First, _Last, _Count, _Pred, _Proj);
            
            if (_Count <= _Isort_max<_It>) {
                return;
            }

            
            _Uninitialized_chunked_merge_common(_First, _Last, _Temp_ptr, _Count, _Pred, _Proj);
            _Uninitialized_backout<iter_value_t<_It>*> _Backout{_Temp_ptr, _Temp_ptr + _Count};
            iter_difference_t<_It> _Chunk_size = _Isort_max<_It>;
            for (;;) {
                
                _Chunk_size <<= 1;
                _Chunked_merge_common(_Temp_ptr, _Temp_ptr + _Count, _First, _Chunk_size, _Count, _Pred, _Proj);
                _Chunk_size <<= 1;
                if (_Count <= _Chunk_size) { 
                    return;
                }

                
                _Chunked_merge_common(_First, _Last, _Temp_ptr, _Chunk_size, _Count, _Pred, _Proj);
            }
        }

        template <class _It, class _Pr, class _Pj>
        static void _Insertion_sort_isort_max_chunks(
            _It _First, _It _Last, iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;

            for (; _Isort_max<_It> < _Count; _Count -= _Isort_max<_It>) { 
                _First = ::std::ranges:: _Insertion_sort_common(_First, _First + _Isort_max<_It>, _Pred, _Proj);
            }

            
            ::std::ranges:: _Insertion_sort_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
        }

        template <class _It, class _Pr, class _Pj>
        static void _Uninitialized_chunked_merge_common(_It _First, const _It _Last, iter_value_t<_It>* const _Dest,
            iter_difference_t<_It> _Count, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;

            _Uninitialized_backout<iter_value_t<_It>*> _Backout{_Dest};
            const auto _Backout_end = _Dest + _Count;
            while (_Isort_max<_It> < _Count) {
                _Count -= _Isort_max<_It>;
                const auto _Chunk2 = (::std:: min)(_Isort_max<_It>, _Count);
                _Count -= _Chunk2;

                auto _Mid1     = _First + _Isort_max<_It>;
                auto _Last1    = _Mid1 + _Chunk2;
                auto _Last2    = _Backout._Last + _Isort_max<_It> + _Chunk2;
                _Backout._Last = _Uninitialized_merge_move(
                    ::std:: move(_First), ::std:: move(_Mid1), _Last1, _Backout._Last, _Last2, _Pred, _Proj);
                _First = ::std:: move(_Last1);
            }

            
            ::std::ranges:: _Uninitialized_move_unchecked(::std:: move(_First), ::std:: move(_Last), _Backout._Last, _Backout_end);
            _Backout._Release();
        }

        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static iter_value_t<_It>* _Uninitialized_merge_move(_It _First, _It _Mid, _It _Last,
            iter_value_t<_It>* const _Dest, iter_value_t<_It>* const _Dest_last, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            _Uninitialized_backout<iter_value_t<_It>*> _Backout{_Dest};
            _It _Next = _Mid;
            for (;;) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next), ::std:: invoke(_Proj, *_First))) {
                    _Backout._Emplace_back(::std::ranges:: iter_move(_Next));
                    ++_Next;

                    if (_Next == _Last) {
                        _Backout._Last = ::std::ranges:: _Uninitialized_move_unchecked(
                            ::std:: move(_First), ::std:: move(_Mid), _Backout._Last, _Dest_last)
                                             .out;
                        return _Backout._Release();
                    }
                } else {
                    _Backout._Emplace_back(::std::ranges:: iter_move(_First));
                    ++_First;

                    if (_First == _Mid) {
                        _Backout._Last = ::std::ranges:: _Uninitialized_move_unchecked(
                            ::std:: move(_Next), ::std:: move(_Last), _Backout._Last, _Dest_last)
                                             .out;
                        return _Backout._Release();
                    }
                }
            }
        }

        template <class _InIt, class _OutIt, class _Pr, class _Pj>
        [[nodiscard]] static _OutIt _Merge_move_common(
            _InIt _First, _InIt _Mid, _InIt _Last, _OutIt _Dest, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;

            _InIt _Next = _Mid;
            for (;;) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next), ::std:: invoke(_Proj, *_First))) {
                    *_Dest = ::std::ranges:: iter_move(_Next);
                    ++_Dest;
                    ++_Next;

                    if (_Next == _Last) {
                        return ::std::ranges:: _Move_unchecked(::std:: move(_First), ::std:: move(_Mid), ::std:: move(_Dest)).out;
                    }
                } else {
                    *_Dest = ::std::ranges:: iter_move(_First);
                    ++_Dest;
                    ++_First;

                    if (_First == _Mid) {
                        return ::std::ranges:: _Move_unchecked(::std:: move(_Next), ::std:: move(_Last), ::std:: move(_Dest)).out;
                    }
                }
            }
        }

        template <class _It1, class _It2, class _Pr, class _Pj>
        static void _Chunked_merge_common(_It1 _First, const _It1 _Last, _It2 _Dest,
            const iter_difference_t<_It1> _Chunk_size, iter_difference_t<_It1> _Count, _Pr _Pred, _Pj _Proj) {
            
            ;
            ;
            ;
            ;
            ;

            while (_Chunk_size < _Count) {
                _Count -= _Chunk_size;
                const auto _Right_chunk_size = (::std:: min)(_Chunk_size, _Count);
                _Count -= _Right_chunk_size;

                auto _Mid1  = _First + _Chunk_size;
                auto _Last1 = _Mid1 + _Right_chunk_size;
                _Dest       = _Merge_move_common(::std:: move(_First), ::std:: move(_Mid1), _Last1, _Dest, _Pred, _Proj);
                _First      = ::std:: move(_Last1);
            }

            
            ::std::ranges:: _Move_unchecked(::std:: move(_First), ::std:: move(_Last), ::std:: move(_Dest));
        }
    };

     inline constexpr _Stable_sort_fn stable_sort{_Not_quite_object::_Construct_tag{}};
} 
#line 8761 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _RanIt, class _Pr>
constexpr void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Mid);
    _Adl_verify_range(_Mid, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _UMid  = _Get_unwrapped(_Mid);
    const auto _ULast = _Get_unwrapped(_Last);

    if (_UFirst == _UMid) {
        return; 
    }

    _Make_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
    for (auto _UNext = _UMid; _UNext < _ULast; ++_UNext) {
        if (static_cast<bool>(_Pred(*_UNext, *_UFirst))) { 
            _Iter_value_t<_RanIt> _Val = ::std:: move(*_UNext);
            ::std:: _Pop_heap_hole_unchecked(_UFirst, _UMid, _UNext, ::std:: move(_Val), _Pass_fn(_Pred));
        }
    }

    _Sort_heap_unchecked(_UFirst, _UMid, _Pass_fn(_Pred));
}

 template <class _RanIt>
constexpr void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last) {
    
    ::std:: partial_sort(_First, _Mid, _Last, less<>{});
}


 template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
void partial_sort(_ExPo&&, _RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_cpp17_random_iter_v<_RanIt>, "This algorithm requires that mutable iterators be Cpp17RandomAccessIterators or stronger.");
    return ::std:: partial_sort(_First, _Mid, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void partial_sort(_ExPo&&, _RanIt _First, _RanIt _Mid, _RanIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_random_iter_v<_RanIt>, "This algorithm requires that mutable iterators be Cpp17RandomAccessIterators or stronger.");
    return ::std:: partial_sort(_First, _Mid, _Last);
}


namespace ranges {
    class _Partial_sort_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _It _Mid, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Mid);
            _Adl_verify_range(_Mid, _Last);

            if constexpr (is_same_v<_It, _Se>) {
                _Partial_sort_common(_Unwrap_iter<_Se>(::std:: move(_First)), _Unwrap_iter<_Se>(::std:: move(_Mid)),
                    _Unwrap_sent<_It>(_Last), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Last;
            } else {
                auto _UMid  = _Unwrap_iter<_Se>(::std:: move(_Mid));
                auto _ULast = _Get_final_iterator_unwrapped<_It>(_UMid, ::std:: move(_Last));
                _Seek_wrapped(_Mid, _ULast);
                _Partial_sort_common(_Unwrap_iter<_Se>(::std:: move(_First)), ::std:: move(_UMid), ::std:: move(_ULast),
                    _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Mid;
            }
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, iterator_t<_Rng> _Mid, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(::std::ranges:: begin(_Range), _Mid);
            _Adl_verify_range(_Mid, ::std::ranges:: end(_Range));

            if constexpr (common_range<_Rng>) {
                _Partial_sort_common(_Ubegin(_Range), _Unwrap_range_iter<_Rng>(::std:: move(_Mid)), _Uend(_Range),
                    _Pass_fn(_Pred), _Pass_fn(_Proj));
                return ::std::ranges:: end(_Range);
            } else {
                auto _UMid  = _Unwrap_range_iter<_Rng>(::std:: move(_Mid));
                auto _ULast = _Get_final_iterator_unwrapped(_Range, _UMid);
                _Seek_wrapped(_Mid, _ULast);
                _Partial_sort_common(
                    _Ubegin(_Range), ::std:: move(_UMid), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
                return _Mid;
            }
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static constexpr void _Partial_sort_common(_It _First, _It _Mid, const _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            if (_First == _Mid) {
                return; 
            }

            _Make_heap_common(_First, _Mid, _Pred, _Proj);
            for (auto _Next = _Mid; _Next != _Last; ++_Next) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next), ::std:: invoke(_Proj, *_First))) {
                    
                    iter_value_t<_It> _Val = ::std::ranges:: iter_move(_Next);
                    ::std::ranges:: _Pop_heap_hole_unchecked(_First, _Mid, _Next, ::std:: move(_Val), _Pred, _Proj, _Proj);
                }
            }

            _Sort_heap_common(::std:: move(_First), ::std:: move(_Mid), _Pred, _Proj);
        }
    };

     inline constexpr _Partial_sort_fn partial_sort{_Not_quite_object::_Construct_tag{}};
} 
#line 8882 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 8883 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt, class _RanIt, class _Pr>
constexpr _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    auto _UMid2        = _UFirst2;
    if (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        for (; _UFirst1 != _ULast1 && _UMid2 != _ULast2; ++_UFirst1, (void) ++_UMid2) {
            *_UMid2 = *_UFirst1; 
        }

        _Make_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
        for (; _UFirst1 != _ULast1; ++_UFirst1) {
            if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) {
                
                using _Diff = _Iter_diff_t<_RanIt>;
                ::std:: _Pop_heap_hole_by_index(
                    _UFirst2, static_cast<_Diff>(0), static_cast<_Diff>(_UMid2 - _UFirst2), *_UFirst1, _Pass_fn(_Pred));
            }
        }

        _Sort_heap_unchecked(_UFirst2, _UMid2, _Pass_fn(_Pred));
    }

    _Seek_wrapped(_First2, _UMid2);
    return _First2;
}

 template <class _InIt, class _RanIt>
constexpr _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1, _RanIt _First2, _RanIt _Last2) {
    
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, less<>{});
}


 template <class _ExPo, class _FwdIt, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
_RanIt partial_sort_copy(_ExPo&&, _FwdIt _First1, _FwdIt _Last1, _RanIt _First2, _RanIt _Last2, _Pr _Pred) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_RanIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
_RanIt partial_sort_copy(_ExPo&&, _FwdIt _First1, _FwdIt _Last1, _RanIt _First2, _RanIt _Last2) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_RanIt>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2);
}


namespace ranges {
     template <class _In, class _Out>
    using partial_sort_copy_result = in_out_result<_In, _Out>;

    class _Partial_sort_copy_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, random_access_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires indirectly_copyable<_It1, _It2> && sortable<_It2, _Pr, _Pj2>
                  && indirect_strict_weak_order<_Pr, projected<_It1, _Pj1>, projected<_It2, _Pj2>>
        constexpr partial_sort_copy_result<_It1, _It2> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            auto _UResult = _Partial_sort_copy_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));

            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_First2, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2)};
        }

        template <input_range _Rng1, random_access_range _Rng2, class _Pr = ranges::less, class _Pj1 = identity,
            class _Pj2 = identity>
            requires indirectly_copyable<iterator_t<_Rng1>, iterator_t<_Rng2>> && sortable<iterator_t<_Rng2>, _Pr, _Pj2>
                  && indirect_strict_weak_order<_Pr, projected<iterator_t<_Rng1>, _Pj1>,
                      projected<iterator_t<_Rng2>, _Pj2>>
        constexpr partial_sort_copy_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First   = ::std::ranges:: begin(_Range1);
            auto _UResult = _Partial_sort_copy_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First)), _Uend(_Range1),
                _Ubegin(_Range2), _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));

            _Seek_wrapped(_First, ::std:: move(_UResult.in));
            return {::std:: move(_First), _Rewrap_iterator(_Range2, ::std:: move(_UResult.out))};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr partial_sort_copy_result<_It1, _It2> _Partial_sort_copy_unchecked(
            _It1 _First1, _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;
            ;

            if (_First1 == _Last1 || _First2 == _Last2) {
                ::std::ranges:: advance(_First1, ::std:: move(_Last1));
                return {::std:: move(_First1), ::std:: move(_First2)};
            }

            
            auto _Mid2 = _First2;
            do {
                *_Mid2 = *_First1;
                ++_First1;
                ++_Mid2;
            } while (_First1 != _Last1 && _Mid2 != _Last2);

            _Make_heap_common(_First2, _Mid2, _Pred, _Proj2); 
            for (; _First1 != _Last1; ++_First1) { 
                
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    
                    using _Diff = iter_difference_t<_It2>;
                    ::std::ranges:: _Pop_heap_hole_by_index(_First2, static_cast<_Diff>(0), static_cast<_Diff>(_Mid2 - _First2),
                        *_First1, _Pred, _Proj2, _Proj1);
                }
            }

            
            _Sort_heap_common(::std:: move(_First2), _Mid2, _Pred, _Proj2);
            return {::std:: move(_First1), ::std:: move(_Mid2)};
        }
    };

     inline constexpr _Partial_sort_copy_fn partial_sort_copy{_Not_quite_object::_Construct_tag{}};
} 
#line 9030 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9031 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _RanIt, class _Pr>
constexpr void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Nth);
    _Adl_verify_range(_Nth, _Last);
    auto _UFirst     = _Get_unwrapped(_First);
    const auto _UNth = _Get_unwrapped(_Nth);
    auto _ULast      = _Get_unwrapped(_Last);
    if (_UNth == _ULast) {
        return; 
    }

    while (_ISORT_MAX < _ULast - _UFirst) { 
        auto _UMid = _Partition_by_median_guess_unchecked(_UFirst, _ULast, _Pass_fn(_Pred));

        if (_UMid.second <= _UNth) {
            _UFirst = _UMid.second;
        } else if (_UMid.first <= _UNth) {
            return; 
        } else {
            _ULast = _UMid.first;
        }
    }

    _Insertion_sort_unchecked(_UFirst, _ULast, _Pass_fn(_Pred)); 
}

 template <class _RanIt>
constexpr void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last) { 
    ::std:: nth_element(_First, _Nth, _Last, less<>{});
}


 template <class _ExPo, class _RanIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
void nth_element(_ExPo&&, _RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_cpp17_random_iter_v<_RanIt>, "This algorithm requires that mutable iterators be Cpp17RandomAccessIterators or stronger.");
    ::std:: nth_element(_First, _Nth, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _RanIt, _Enable_if_execution_policy_t<_ExPo> = 0>
void nth_element(_ExPo&&, _RanIt _First, _RanIt _Nth, _RanIt _Last) noexcept  {
    
    
    static_assert(_Is_cpp17_random_iter_v<_RanIt>, "This algorithm requires that mutable iterators be Cpp17RandomAccessIterators or stronger.");
    ::std:: nth_element(_First, _Nth, _Last);
}


namespace ranges {
    class _Nth_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <random_access_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr _It operator()(_It _First, _It _Nth, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Nth);
            _Adl_verify_range(_Nth, _Last);
            auto _UNth   = _Unwrap_iter<_Se>(_Nth);
            auto _UFinal = _Get_final_iterator_unwrapped<_It>(_UNth, ::std:: move(_Last));
            _Seek_wrapped(_Nth, _UFinal);

            _Nth_element_common(_Unwrap_iter<_Se>(::std:: move(_First)), ::std:: move(_UNth), ::std:: move(_UFinal),
                _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Nth;
        }

        template <random_access_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr borrowed_iterator_t<_Rng> operator()(
            _Rng&& _Range, iterator_t<_Rng> _Nth, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(::std::ranges:: begin(_Range), _Nth);
            _Adl_verify_range(_Nth, ::std::ranges:: end(_Range));
            auto _UNth   = _Unwrap_range_iter<_Rng>(_Nth);
            auto _UFinal = [&] {
                if constexpr (common_range<_Rng>) {
                    return _Uend(_Range);
                } else if constexpr (sized_range<_Rng>) {
                    return ::std::ranges:: next(_Ubegin(_Range), ::std::ranges:: distance(_Range));
                } else {
                    return ::std::ranges:: next(_UNth, _Uend(_Range));
                }
            }();
            _Seek_wrapped(_Nth, _UFinal);

            _Nth_element_common(
                _Ubegin(_Range), ::std:: move(_UNth), ::std:: move(_UFinal), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Nth;
        }

    private:
        template <class _It, class _Pr, class _Pj>
        static constexpr void _Nth_element_common(_It _First, _It _Nth, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            if (_Nth == _Last) {
                return; 
            }

            while (_ISORT_MAX < _Last - _First) { 
                subrange<_It> _Mid = _Partition_by_median_guess_common(_First, _Last, _Pred, _Proj);

                if (_Mid.end() <= _Nth) {
                    _First = _Mid.end();
                } else if (_Mid.begin() <= _Nth) {
                    return; 
                } else {
                    _Last = _Mid.begin();
                }
            }

            
            ::std::ranges:: _Insertion_sort_common(::std:: move(_First), ::std:: move(_Last), _Pred, _Proj);
        }
    };

     inline constexpr _Nth_element_fn nth_element{_Not_quite_object::_Construct_tag{}};
} 
#line 9154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9155 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _Pr>
[[nodiscard]] constexpr bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UFirst1) {
        if (static_cast<bool>(_Pred(*_UFirst2, *_UFirst1))) {
            return false;
        }

        if (!_Pred(*_UFirst1, *_UFirst2)) {
            ++_UFirst2;
        }
    }

    return _UFirst2 == _ULast2;
}

 template <class _InIt1, class _InIt2>
[[nodiscard]] constexpr bool includes(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2) {
    
    return ::std:: includes(_First1, _Last1, _First2, _Last2, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool includes(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: includes(_First1, _Last1, _First2, _Last2, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool includes(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: includes(_First1, _Last1, _First2, _Last2);
}


namespace ranges {
    class _Includes_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pj1 = identity, class _Pj2 = identity,
            indirect_strict_weak_order<projected<_It1, _Pj1>, projected<_It2, _Pj2>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            return _Includes_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)), _Unwrap_sent<_It1>(::std:: move(_Last1)),
                _Unwrap_iter<_Se2>(::std:: move(_First2)), _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

        template <input_range _Rng1, input_range _Rng2, class _Pj1 = identity, class _Pj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>> _Pr =
                ranges::less>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            return _Includes_unchecked(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2), _Uend(_Range2),
                _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Includes_unchecked(
            _It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            if (_First2 == _Last2) {
                return true;
            } else if (_First1 == _Last1) {
                return false;
            }

            for (;;) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    ++_First1;
                    if (_First1 == _Last1) {
                        return false;
                    }

                    continue;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    return false;
                }

                ++_First1;
                ++_First2;
                if (_First2 == _Last2) {
                    return true;
                } else if (_First1 == _Last1) {
                    return false;
                }
            }
        }
    };

     inline constexpr _Includes_fn includes{_Not_quite_object::_Construct_tag{}};
} 
#line 9278 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9279 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
constexpr _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    for (; _UFirst1 != _ULast1 && _UFirst2 != _ULast2; ++_UDest) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UFirst2;
        } else { 
            *_UDest = *_UFirst1;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = ::std:: _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

 template <class _InIt1, class _InIt2, class _OutIt>
constexpr _OutIt set_union(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_union(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest);
}


namespace ranges {
     template <class _In1, class _In2, class _Out>
    using set_union_result = in_in_out_result<_In1, _In2, _Out>;

    class _Set_union_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<_It1, _It2, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_union_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult =
                _Set_union_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)), _Unwrap_sent<_It1>(::std:: move(_Last1)),
                    _Unwrap_iter<_Se2>(::std:: move(_First2)), _Unwrap_sent<_It2>(::std:: move(_Last2)),
                    _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, class _Pr = ranges::less,
            class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_union_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _First2  = ::std::ranges:: begin(_Range2);
            auto _UResult = _Set_union_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr set_union_result<_It1, _It2, _Out> _Set_union_unchecked(_It1 _First1,
            const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Out _Result, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;

            for (; _First1 != _Last1 && _First2 != _Last2; ++_Result) {
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    *_Result = *_First2;
                    ++_First2;
                } else {
                    *_Result = *_First1;
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                        ++_First2;
                    }
                    ++_First1;
                }
            }

            auto _UResult1 = ::std::ranges:: _Copy_unchecked(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_Result));
            auto _UResult2 = ::std::ranges:: _Copy_unchecked(::std:: move(_First2), ::std:: move(_Last2), ::std:: move(_UResult1.out));
            return {::std:: move(_UResult1.in), ::std:: move(_UResult2.in), ::std:: move(_UResult2.out)};
        }
    };

     inline constexpr _Set_union_fn set_union{_Not_quite_object::_Construct_tag{}};
} 
#line 9417 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9418 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
constexpr _OutIt set_intersection(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) {
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) {
            ++_UFirst2;
        } else {
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, _UDest);
    return _Dest;
}

 template <class _InIt1, class _InIt2, class _OutIt>
constexpr _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_intersection(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_intersection(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept  {
    
    return ::std:: set_intersection(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}


namespace ranges {
     template <class _In1, class _In2, class _Out>
    using set_intersection_result = in_in_out_result<_In1, _In2, _Out>;

    class _Set_intersection_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<_It1, _It2, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_intersection_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2,
            _Se2 _Last2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Set_intersection_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, class _Pr = ranges::less,
            class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_intersection_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _First2  = ::std::ranges:: begin(_Range2);
            auto _UResult = _Set_intersection_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr set_intersection_result<_It1, _It2, _Out> _Set_intersection_unchecked(_It1 _First1,
            const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Out _Result, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;

            for (;;) {
                if (_First1 == _Last1) {
                    ::std::ranges:: advance(_First2, _Last2);
                    break;
                } else if (_First2 == _Last2) {
                    ::std::ranges:: advance(_First1, _Last1);
                    break;
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    ++_First1;
                } else if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    ++_First2;
                } else {
                    *_Result = *_First1;
                    ++_Result;
                    ++_First1;
                    ++_First2;
                }
            }

            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }
    };

     inline constexpr _Set_intersection_fn set_intersection{_Not_quite_object::_Construct_tag{}};
} 
#line 9550 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
constexpr _OutIt set_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else {
            if (!_Pred(*_UFirst2, *_UFirst1)) {
                ++_UFirst1;
            }

            ++_UFirst2;
        }
    }

    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst1, _ULast1, _UDest));
    return _Dest;
}

 template <class _InIt1, class _InIt2, class _OutIt>
constexpr _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _FwdIt3 _Dest,
    _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_difference(_ExPo&& _Exec, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept  {
    
    return ::std:: set_difference(::std:: forward<_ExPo>(_Exec), _First1, _Last1, _First2, _Last2, _Dest, less{});
}


namespace ranges {
     template <class _In, class _Out>
    using set_difference_result = in_out_result<_In, _Out>;

    class _Set_difference_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<_It1, _It2, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_difference_result<_It1, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2,
            _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult =
                _Set_difference_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)), _Unwrap_sent<_It1>(::std:: move(_Last1)),
                    _Unwrap_iter<_Se2>(::std:: move(_First2)), _Unwrap_sent<_It2>(::std:: move(_Last2)),
                    _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_Result)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, class _Pr = ranges::less,
            class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_difference_result<borrowed_iterator_t<_Rng1>, _Out> operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _UResult = _Set_difference_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)), _Uend(_Range1),
                _Ubegin(_Range2), _Uend(_Range2), _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_Result)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr set_difference_result<_It1, _Out> _Set_difference_unchecked(_It1 _First1,
            const _Se1 _Last1, _It2 _First2, const _Se2 _Last2, _Out _Result, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;

            for (;;) {
                if (_First1 == _Last1) {
                    return {::std:: move(_First1), ::std:: move(_Result)};
                }

                if (_First2 == _Last2) {
                    return ::std::ranges:: _Copy_unchecked(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_Result));
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    *_Result = *_First1;
                    ++_Result;
                    ++_First1;
                } else {
                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                        ++_First1;
                    }

                    ++_First2;
                }
            }
        }
    };

     inline constexpr _Set_difference_fn set_difference{_Not_quite_object::_Construct_tag{}};
} 
#line 9680 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9681 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _InIt1, class _InIt2, class _OutIt, class _Pr>
constexpr _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred) {
    
    _Adl_verify_range(_First1, _Last1);
    _Adl_verify_range(_First2, _Last2);
    auto _UFirst1      = _Get_unwrapped(_First1);
    const auto _ULast1 = _Get_unwrapped(_Last1);
    auto _UFirst2      = _Get_unwrapped(_First2);
    const auto _ULast2 = _Get_unwrapped(_Last2);
    ;
    ;
    auto _UDest = _Get_unwrapped_unverified(_Dest);
    while (_UFirst1 != _ULast1 && _UFirst2 != _ULast2) {
        if (static_cast<bool>(_Pred(*_UFirst1, *_UFirst2))) { 
            *_UDest = *_UFirst1;
            ++_UDest;
            ++_UFirst1;
        } else if (_Pred(*_UFirst2, *_UFirst1)) { 
            *_UDest = *_UFirst2;
            ++_UDest;
            ++_UFirst2;
        } else { 
            ++_UFirst1;
            ++_UFirst2;
        }
    }

    _UDest = ::std:: _Copy_unchecked(_UFirst1, _ULast1, _UDest);
    _Seek_wrapped(_Dest, ::std:: _Copy_unchecked(_UFirst2, _ULast2, _UDest));
    return _Dest;
}

 template <class _InIt1, class _InIt2, class _OutIt>
constexpr _OutIt set_symmetric_difference(
    _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest) {
    
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, less<>{});
}


 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3, class _Pr,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest, _Pr _Pred) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt1, class _FwdIt2, class _FwdIt3,
    _Enable_if_execution_policy_t<_ExPo> = 0>
_FwdIt3 set_symmetric_difference(_ExPo&&, _FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2,
    _FwdIt3 _Dest) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt1>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt2>, "Parallel algorithms require forward iterators or stronger.");
    static_assert(_Is_cpp17_fwd_iter_v<_FwdIt3>, "Non-ranges algorithms require that mutable iterators be Cpp17ForwardIterators or stronger.");
    return ::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2, _Dest);
}


namespace ranges {
     template <class _In1, class _In2, class _Out>
    using set_symmetric_difference_result = in_in_out_result<_In1, _In2, _Out>;

    class _Set_symmetric_difference_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            weakly_incrementable _Out, class _Pr = ranges::less, class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<_It1, _It2, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_symmetric_difference_result<_It1, _It2, _Out> operator()(_It1 _First1, _Se1 _Last1, _It2 _First2,
            _Se2 _Last2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            auto _UResult = _Set_symmetric_difference_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred),
                _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

        template <input_range _Rng1, input_range _Rng2, weakly_incrementable _Out, class _Pr = ranges::less,
            class _Pj1 = identity, class _Pj2 = identity>
            requires mergeable<iterator_t<_Rng1>, iterator_t<_Rng2>, _Out, _Pr, _Pj1, _Pj2>
        constexpr set_symmetric_difference_result<borrowed_iterator_t<_Rng1>, borrowed_iterator_t<_Rng2>, _Out>
            operator()(_Rng1&& _Range1, _Rng2&& _Range2, _Out _Result, _Pr _Pred = {}, _Pj1 _Proj1 = {},
                _Pj2 _Proj2 = {}) const {
            auto _First1  = ::std::ranges:: begin(_Range1);
            auto _First2  = ::std::ranges:: begin(_Range2);
            auto _UResult = _Set_symmetric_difference_unchecked(_Unwrap_range_iter<_Rng1>(::std:: move(_First1)),
                _Uend(_Range1), _Unwrap_range_iter<_Rng2>(::std:: move(_First2)), _Uend(_Range2),
                _Get_unwrapped_unverified(::std:: move(_Result)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
            _Seek_wrapped(_First1, ::std:: move(_UResult.in1));
            _Seek_wrapped(_First2, ::std:: move(_UResult.in2));
            _Seek_wrapped(_Result, ::std:: move(_UResult.out));
            return {::std:: move(_First1), ::std:: move(_First2), ::std:: move(_Result)};
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Out, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr set_symmetric_difference_result<_It1, _It2, _Out>
            _Set_symmetric_difference_unchecked(_It1 _First1, const _Se1 _Last1, _It2 _First2, const _Se2 _Last2,
                _Out _Result, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;
            ;

            for (;;) {
                if (_First1 == _Last1) {
                    auto _UResult = ::std::ranges:: _Copy_unchecked(::std:: move(_First2), ::std:: move(_Last2), ::std:: move(_Result));
                    return {::std:: move(_First1), ::std:: move(_UResult.in), ::std:: move(_UResult.out)};
                }

                if (_First2 == _Last2) {
                    auto _UResult = ::std::ranges:: _Copy_unchecked(::std:: move(_First1), ::std:: move(_Last1), ::std:: move(_Result));
                    return {::std:: move(_UResult.in), ::std:: move(_First2), ::std:: move(_UResult.out)};
                }

                if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    *_Result = *_First1;
                    ++_Result;
                    ++_First1;
                } else if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    *_Result = *_First2;
                    ++_Result;
                    ++_First2;
                } else {
                    ++_First1;
                    ++_First2;
                }
            }
        }
    };

     inline constexpr _Set_symmetric_difference_fn set_symmetric_difference{
        _Not_quite_object::_Construct_tag{}};
} 
#line 9833 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 9834 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

template <class _FwdIt, class _Pr>
constexpr pair<_FwdIt, _FwdIt> _Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {

    if constexpr (_Is_min_max_optimization_safe<_FwdIt, _Pr>) {
        if (!_Is_constant_evaluated()) {
            const auto _First_ptr = _To_address(_First);
            const auto _Result    = __std_minmax_element(_First_ptr, _To_address(_Last));
            if constexpr (is_pointer_v<_FwdIt>) {
                return _Result;
            } else {
                return {_First + (_Result.first - _First_ptr), _First + (_Result.second - _First_ptr)};
            }
        }
    }
#line 9850 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

    
    pair<_FwdIt, _FwdIt> _Found(_First, _First);

    if (_First != _Last) {
        while (++_First != _Last) { 
            _FwdIt _Next = _First;
            if (++_Next == _Last) { 
                if (static_cast<bool>(_Pred(*_First, *_Found.first))) {
                    _Found.first = _First;
                } else if (!static_cast<bool>(_Pred(*_First, *_Found.second))) {
                    _Found.second = _First;
                }
            } else { 
                if (static_cast<bool>(_Pred(*_Next, *_First))) { 
                    if (static_cast<bool>(_Pred(*_Next, *_Found.first))) {
                        _Found.first = _Next;
                    }

                    if (!static_cast<bool>(_Pred(*_First, *_Found.second))) {
                        _Found.second = _First;
                    }
                } else { 
                    if (static_cast<bool>(_Pred(*_First, *_Found.first))) {
                        _Found.first = _First;
                    }

                    if (!static_cast<bool>(_Pred(*_Next, *_Found.second))) {
                        _Found.second = _Next;
                    }
                }
                _First = _Next;
            }
        }
    }

    return _Found;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _Result = ::std:: _Minmax_element_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pass_fn(_Pred));
    _Seek_wrapped(_Last, _Result.second);
    _Seek_wrapped(_First, _Result.first);
    return {_First, _Last};
}

 template <class _FwdIt>
[[nodiscard]] constexpr pair<_FwdIt, _FwdIt> minmax_element(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: minmax_element(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt, _FwdIt> minmax_element(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept
 {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: minmax_element(_First, _Last, _Pass_fn(_Pred));
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] pair<_FwdIt, _FwdIt> minmax_element(_ExPo&&, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    
    static_assert(_Is_ranges_fwd_iter_v<_FwdIt>, "Parallel algorithms require forward iterators or stronger.");
    return ::std:: minmax_element(_First, _Last);
}


namespace ranges {
     template <class _Ty>
    using minmax_element_result = min_max_result<_Ty>;

    class _Minmax_element_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr minmax_element_result<_It> operator()(
            _It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            ::std:: _Adl_verify_range(_First, _Last);
            auto _UResult = _Minmax_element_fwd_unchecked(::std::ranges:: _Unwrap_iter<_Se>(::std:: move(_First)),
                ::std::ranges:: _Unwrap_sent<_It>(::std:: move(_Last)), ::std:: _Pass_fn(_Pred), ::std:: _Pass_fn(_Proj));
            ::std:: _Seek_wrapped(_First, ::std:: move(_UResult.min));
            auto _Second = _First;
            ::std:: _Seek_wrapped(_Second, ::std:: move(_UResult.max));
            return {::std:: move(_First), ::std:: move(_Second)};
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr minmax_element_result<borrowed_iterator_t<_Rng>> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult = _Minmax_element_fwd_unchecked(
                ::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range), ::std:: _Pass_fn(_Pred), ::std:: _Pass_fn(_Proj));
            return {
                _Rewrap_iterator(_Range, ::std:: move(_UResult.min)), _Rewrap_iterator(_Range, ::std:: move(_UResult.max))};
        }

    private:
        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr min_max_result<_It> _Minmax_element_fwd_unchecked(
            _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;


            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                          && sized_sentinel_for<_Se, _It>) {
                if (!::std:: is_constant_evaluated()) {
                    const auto _First_ptr = ::std:: to_address(_First);
                    const auto _Last_ptr  = _First_ptr + (_Last - _First);
                    const auto _Result    = :: __std_minmax_element(_First_ptr, _Last_ptr);
                    if constexpr (is_pointer_v<_It>) {
                        return {_Result.first, _Result.second};
                    } else {
                        return {_First + (_Result.first - _First_ptr), _First + (_Result.second - _First_ptr)};
                    }
                }
            }
#line 9978 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            min_max_result<_It> _Found{_First, _First};

            if (_First == _Last) {
                return _Found;
            }

            while (++_First != _Last) { 
                _It _Prev = _First;
                if (++_First == _Last) { 
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found.min))) {
                        _Found.min = _Prev;
                    } else if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found.max))) {
                        _Found.max = _Prev;
                    }

                    break;
                }

                
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Prev))) {
                    
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found.min))) {
                        _Found.min = _First;
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found.max))) {
                        _Found.max = _Prev;
                    }
                } else { 
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found.min))) {
                        _Found.min = _Prev;
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found.max))) {
                        _Found.max = _First;
                    }
                }
            }

            return _Found;
        }
    };

     inline constexpr _Minmax_element_fn minmax_element{_Not_quite_object::_Construct_tag{}};
} 
#line 10025 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 10026 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left [[msvc::lifetimebound]],
    const _Ty& _Right [[msvc::lifetimebound]],
    _Pr _Pred) noexcept(noexcept(static_cast<bool>(_Pred(_Right, _Left))))  {
    
    if (static_cast<bool>(_Pred(_Right, _Left))) {
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist, _Pr _Pred) {
    
    pair<const _Ty*, const _Ty*> _Res = ::std:: _Minmax_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pass_fn(_Pred));
    return pair<_Ty, _Ty>(*_Res.first, *_Res.second);
}

 template <class _Ty>
[[nodiscard]] constexpr pair<const _Ty&, const _Ty&> minmax(const _Ty& _Left [[msvc::lifetimebound]],
    const _Ty& _Right [[msvc::lifetimebound]]) noexcept(noexcept(_Right < _Left))  {
    
    if (_Right < _Left) {
        ;
        return {_Right, _Left};
    }

    return {_Left, _Right};
}

 template <class _Ty>
[[nodiscard]] constexpr pair<_Ty, _Ty> minmax(initializer_list<_Ty> _Ilist) {
    
    return ::std:: minmax(_Ilist, less<>{});
}


namespace ranges {
     template <class _Ty>
    using minmax_result = min_max_result<_Ty>;

    class _Minmax_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr minmax_result<const _Ty&> operator()(const _Ty& _Left [[msvc::lifetimebound]],
            const _Ty& _Right [[msvc::lifetimebound]], _Pr _Pred = {}, _Pj _Proj = {}) const {
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Right), ::std:: invoke(_Proj, _Left))) {
                return {_Right, _Left};
            } else {
                return {_Left, _Right};
            }
        }

        template <copyable _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr minmax_result<_Ty> operator()(
            initializer_list<_Ty> _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _First = _Range.begin();
            const auto _Last  = _Range.end();
            ;
#line 10092 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
            return _Minmax_fwd_unchecked(_First, _Last, ::std:: _Pass_fn(_Pred), ::std:: _Pass_fn(_Proj));
        }

        template <input_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
            requires indirectly_copyable_storable<iterator_t<_Rng>, range_value_t<_Rng>*>
        [[nodiscard]] constexpr minmax_result<range_value_t<_Rng>> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UFirst = ::std::ranges:: _Ubegin(_Range);
            auto _ULast  = ::std::ranges:: _Uend(_Range);
            ;
#line 10104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
            if constexpr (forward_range<_Rng> && _Prefer_iterator_copies<iterator_t<_Rng>>) {
                return _Minmax_fwd_unchecked(
                    ::std:: move(_UFirst), ::std:: move(_ULast), ::std:: _Pass_fn(_Pred), ::std:: _Pass_fn(_Proj));
            } else {
                using _Vty = range_value_t<_Rng>;
                
                minmax_result<_Vty> _Found = {static_cast<_Vty>(*_UFirst), _Found.min};
                if (_UFirst == _ULast) {
                    return _Found;
                }

                while (++_UFirst != _ULast) { 
                    auto _Prev = *_UFirst;
                    if (++_UFirst == _ULast) { 
                        if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Prev), ::std:: invoke(_Proj, _Found.min))) {
                            _Found.min = ::std:: move(_Prev);
                        } else if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, _Prev), ::std:: invoke(_Proj, _Found.max))) {
                            _Found.max = ::std:: move(_Prev);
                        }

                        break;
                    }

                    
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Prev))) {
                        
                        if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Found.min))) {
                            _Found.min = *_UFirst;
                        }

                        if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, _Prev), ::std:: invoke(_Proj, _Found.max))) {
                            _Found.max = ::std:: move(_Prev);
                        }
                    } else { 
                        if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Prev), ::std:: invoke(_Proj, _Found.min))) {
                            _Found.min = ::std:: move(_Prev);
                        }

                        if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_UFirst), ::std:: invoke(_Proj, _Found.max))) {
                            _Found.max = *_UFirst;
                        }
                    }
                }

                return _Found;
            }
        }

    private:
        template <class _It, class _Se, class _Pr, class _Pj>
        [[nodiscard]] static constexpr minmax_result<iter_value_t<_It>> _Minmax_fwd_unchecked(
            _It _First, const _Se _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;
            ;

            ;

            using _Vty = iter_value_t<_It>;

            if constexpr (is_same_v<_Pj, identity> && _Is_min_max_optimization_safe<_It, _Pr>
                          && sized_sentinel_for<_Se, _It>) {
                if (!::std:: is_constant_evaluated()) {
                    const auto _First_ptr = ::std:: to_address(_First);
                    const auto _Last_ptr  = _First_ptr + (_Last - _First);
                    const auto _Result    = :: __std_minmax_element(_First_ptr, _Last_ptr);
                    return {static_cast<_Vty>(*_Result.first), static_cast<_Vty>(*_Result.second)};
                }
            }
#line 10174 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            auto _Found_min = _First;
            if (++_First == _Last) {
                
                minmax_result<_Vty> _Result = {static_cast<_Vty>(*_Found_min), _Result.min};
                return _Result;
            }

            auto _Found_max = _First;
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Found_max), ::std:: invoke(_Proj, *_Found_min))) {
                ::std::ranges:: swap(_Found_min, _Found_max);
            }

            while (++_First != _Last) { 
                _It _Prev = _First;
                if (++_First == _Last) { 
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found_min))) {
                        _Found_min = _Prev;
                    } else if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found_max))) {
                        _Found_max = _Prev;
                    }

                    break;
                }

                
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Prev))) {
                    
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found_min))) {
                        _Found_min = _First;
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found_max))) {
                        _Found_max = _Prev;
                    }
                } else { 
                    if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Prev), ::std:: invoke(_Proj, *_Found_min))) {
                        _Found_min = _Prev;
                    }

                    if (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_First), ::std:: invoke(_Proj, *_Found_max))) {
                        _Found_max = _First;
                    }
                }
            }

            return {static_cast<_Vty>(*_Found_min), static_cast<_Vty>(*_Found_max)};
        }
    };

     inline constexpr _Minmax_fn minmax{_Not_quite_object::_Construct_tag{}};
} 
#line 10227 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _BidIt, class _Pr>
constexpr bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (static_cast<bool>(_Pred(*--_UNext, *_UNext1))) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!static_cast<bool>(_Pred(*_UNext, *_UMid)));

            swap(*_UNext, *_UMid); 
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

 template <class _BidIt>
constexpr bool next_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: next_permutation(_First, _Last, less<>{});
}


namespace ranges {
     template <class _In>
    using next_permutation_result = in_found_result<_In>;

    class _Next_permutation_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr next_permutation_result<_It> operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            const bool _Found =
                _Next_permutation_common(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return {::std:: move(_First), _Found};
        }

        template <bidirectional_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr next_permutation_result<borrowed_iterator_t<_Rng>> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _ULast       = _Get_final_iterator_unwrapped(_Range);
            const bool _Found = _Next_permutation_common(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return {_Rewrap_iterator(_Range, ::std:: move(_ULast)), _Found};
        }

    private:
        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static constexpr bool _Next_permutation_common(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            auto _Next = _Last;
            if (_First == _Last || _First == --_Next) {
                return false;
            }

            for (;;) { 
                auto _Next1 = _Next;
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *--_Next), ::std:: invoke(_Proj, *_Next1))) {
                    
                    auto _Mid = _Last;
                    do {
                        --_Mid;
                    } while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next), ::std:: invoke(_Proj, *_Mid)));

                    ::std::ranges:: iter_swap(_Next, _Mid);
                    _Reverse_common(::std:: move(_Next1), ::std:: move(_Last));
                    return true;
                }

                if (_Next == _First) { 
                    _Reverse_common(::std:: move(_First), ::std:: move(_Last));
                    return false;
                }
            }
        }
    };

     inline constexpr _Next_permutation_fn next_permutation{_Not_quite_object::_Construct_tag{}};
} 
#line 10331 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _BidIt, class _Pr>
constexpr bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UNext       = _ULast;
    if (_UFirst == _ULast || _UFirst == --_UNext) {
        return false;
    }

    for (;;) { 
        auto _UNext1 = _UNext;
        if (static_cast<bool>(_Pred(*_UNext1, *--_UNext))) { 
            auto _UMid = _ULast;
            do {
                --_UMid;
            } while (!static_cast<bool>(_Pred(*_UMid, *_UNext)));

            swap(*_UNext, *_UMid); 
            ::std:: reverse(_UNext1, _ULast);
            return true;
        }

        if (_UNext == _UFirst) { 
            ::std:: reverse(_UFirst, _ULast);
            return false;
        }
    }
}

 template <class _BidIt>
constexpr bool prev_permutation(_BidIt _First, _BidIt _Last) {
    
    return ::std:: prev_permutation(_First, _Last, less<>{});
}


namespace ranges {
     template <class _In>
    using prev_permutation_result = in_found_result<_In>;

    class _Prev_permutation_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <bidirectional_iterator _It, sentinel_for<_It> _Se, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<_It, _Pr, _Pj>
        constexpr prev_permutation_result<_It> operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Unwrap_iter<_Se>(::std:: move(_First));
            auto _ULast  = _Get_final_iterator_unwrapped<_It>(_UFirst, ::std:: move(_Last));
            _Seek_wrapped(_First, _ULast);
            const bool _Found =
                _Prev_permutation_common(::std:: move(_UFirst), ::std:: move(_ULast), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return {::std:: move(_First), _Found};
        }

        template <bidirectional_range _Rng, class _Pr = ranges::less, class _Pj = identity>
            requires sortable<iterator_t<_Rng>, _Pr, _Pj>
        constexpr prev_permutation_result<borrowed_iterator_t<_Rng>> operator()(
            _Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _ULast       = _Get_final_iterator_unwrapped(_Range);
            const bool _Found = _Prev_permutation_common(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return {_Rewrap_iterator(_Range, ::std:: move(_ULast)), _Found};
        }

    private:
        template <class _It, class _Pr, class _Pj>
        [[nodiscard]] static constexpr bool _Prev_permutation_common(_It _First, _It _Last, _Pr _Pred, _Pj _Proj) {
            ;
            ;

            auto _Next = _Last;
            if (_First == _Last || _First == --_Next) {
                return false;
            }

            for (;;) { 
                auto _Next1 = _Next;
                if (::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Next1), ::std:: invoke(_Proj, *--_Next))) {
                    
                    auto _Mid = _Last;
                    do {
                        --_Mid;
                    } while (!::std:: invoke(_Pred, ::std:: invoke(_Proj, *_Mid), ::std:: invoke(_Proj, *_Next)));

                    ::std::ranges:: iter_swap(_Next, _Mid);
                    _Reverse_common(::std:: move(_Next1), ::std:: move(_Last));
                    return true;
                }

                if (_Next == _First) { 
                    _Reverse_common(::std:: move(_First), ::std:: move(_Last));
                    return false;
                }
            }
        }
    };

     inline constexpr _Prev_permutation_fn prev_permutation{_Not_quite_object::_Construct_tag{}};
} 
#line 10435 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr _FwdIt is_sorted_until(const _FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    auto _UFirst = _Get_unwrapped(_First);
    auto _ULast  = _Get_unwrapped(_Last);
    if (_UFirst != _ULast) {
        for (auto _UNext = _UFirst; ++_UNext != _ULast; ++_UFirst) {
            if (static_cast<bool>(_Pred(*_UNext, *_UFirst))) {
                _ULast = _UNext;
                break;
            }
        }
    }

    _Seek_wrapped(_Last, _ULast);
    return _Last;
}

 template <class _FwdIt, class _Pr>
[[nodiscard]] constexpr bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred) {
    
    _Adl_verify_range(_First, _Last);
    const auto _UFirst = _Get_unwrapped(_First);
    const auto _ULast  = _Get_unwrapped(_Last);
    return ::std:: is_sorted_until(_UFirst, _ULast, _Pass_fn(_Pred)) == _ULast;
}

 template <class _FwdIt>
[[nodiscard]] constexpr _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last) {
    
    return ::std:: is_sorted_until(_First, _Last, less<>{});
}

 template <class _FwdIt>
[[nodiscard]] constexpr bool is_sorted(_FwdIt _First, _FwdIt _Last) { 
    return ::std:: is_sorted(_First, _Last, less<>{});
}


 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt is_sorted_until(_ExPo&&, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept; 

 template <class _ExPo, class _FwdIt, class _Pr, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool is_sorted(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last, _Pr _Pred) noexcept  {
    
    return ::std:: is_sorted_until(::std:: forward<_ExPo>(_Exec), _First, _Last, _Pass_fn(_Pred)) == _Last;
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] _FwdIt is_sorted_until(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    return ::std:: is_sorted_until(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}

 template <class _ExPo, class _FwdIt, _Enable_if_execution_policy_t<_ExPo> = 0>
[[nodiscard]] bool is_sorted(_ExPo&& _Exec, _FwdIt _First, _FwdIt _Last) noexcept  {
    
    return ::std:: is_sorted(::std:: forward<_ExPo>(_Exec), _First, _Last, less{});
}


namespace ranges {
    class _Is_sorted_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            const auto _ULast  = _Unwrap_sent<_It>(::std:: move(_Last));
            const auto _UFirst = ::std::ranges:: _Is_sorted_until_unchecked(
                _Unwrap_iter<_Se>(::std:: move(_First)), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UFirst == _ULast;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            const auto _ULast = _Uend(_Range);
            const auto _UFirst =
                ::std::ranges:: _Is_sorted_until_unchecked(_Ubegin(_Range), _ULast, _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _UFirst == _ULast;
        }
    };

     inline constexpr _Is_sorted_fn is_sorted{_Not_quite_object::_Construct_tag{}};

    class _Is_sorted_until_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <forward_iterator _It, sentinel_for<_It> _Se, class _Pj = identity,
            indirect_strict_weak_order<projected<_It, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr _It operator()(_It _First, _Se _Last, _Pr _Pred = {}, _Pj _Proj = {}) const {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = ::std::ranges:: _Is_sorted_until_unchecked(_Unwrap_iter<_Se>(::std:: move(_First)),
                _Unwrap_sent<_It>(::std:: move(_Last)), _Pass_fn(_Pred), _Pass_fn(_Proj));
            _Seek_wrapped(_First, ::std:: move(_UFirst));
            return _First;
        }

        template <forward_range _Rng, class _Pj = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng>, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr borrowed_iterator_t<_Rng> operator()(_Rng&& _Range, _Pr _Pred = {}, _Pj _Proj = {}) const {
            auto _UResult =
                ::std::ranges:: _Is_sorted_until_unchecked(_Ubegin(_Range), _Uend(_Range), _Pass_fn(_Pred), _Pass_fn(_Proj));
            return _Rewrap_iterator(_Range, ::std:: move(_UResult));
        }
    };

     inline constexpr _Is_sorted_until_fn is_sorted_until{_Not_quite_object::_Construct_tag{}};
} 
#line 10551 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

 template <class _Ty, class _Pr>
[[nodiscard]] constexpr const _Ty& clamp(const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val, _Pr _Pred) {
    





#line 10561 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

    if constexpr (conjunction_v<is_scalar<_Ty>, disjunction<is_same<_Pr, less<>>, is_same<_Pr, less<_Ty>>>>) {
        
        const _Ty& _Tmp = static_cast<bool>(_Pred(_Val, _Min_val)) ? _Min_val : _Val;
        return static_cast<bool>(_Pred(_Max_val, _Val)) ? _Max_val : _Tmp;
    } else {

        if (static_cast<bool>(_Pred(_Max_val, _Val))) {
            return _Max_val;
        }

        if (static_cast<bool>(_Pred(_Val, _Min_val))) {
            return _Min_val;
        }

        return _Val;
    }
}

 template <class _Ty>
[[nodiscard]] constexpr const _Ty& clamp(const _Ty& _Val, const _Ty& _Min_val, const _Ty& _Max_val) {
    
    return ::std:: clamp(_Val, _Min_val, _Max_val, less{});
}


namespace ranges {
    class _Clamp_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <class _Ty, class _Pj = identity,
            indirect_strict_weak_order<projected<const _Ty*, _Pj>> _Pr = ranges::less>
        [[nodiscard]] constexpr const _Ty& operator()(
            const _Ty& _Val, const _Ty& _Lo, const _Ty& _Hi, _Pr _Pred = {}, _Pj _Proj = {}) const {
            ;
#line 10599 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"

            auto&& _Temp = ::std:: invoke(_Proj, _Val);
            if (::std:: invoke(_Pred, ::std:: forward<decltype(_Temp)>(_Temp), ::std:: invoke(_Proj, _Lo))) {
                return _Lo;
            }
            
            
            if (::std:: invoke(_Pred, ::std:: invoke(_Proj, _Hi), ::std:: forward<decltype(_Temp)>(_Temp))) {
                return _Hi;
            }

            return _Val;
        }
    };

     inline constexpr _Clamp_fn clamp{_Not_quite_object::_Construct_tag{}};

    class _Lexicographical_compare_fn : private _Not_quite_object {
    public:
        using _Not_quite_object::_Not_quite_object;

        template <input_iterator _It1, sentinel_for<_It1> _Se1, input_iterator _It2, sentinel_for<_It2> _Se2,
            class _Pj1 = identity, class _Pj2 = identity,
            indirect_strict_weak_order<projected<_It1, _Pj1>, projected<_It2, _Pj2>> _Pr = ranges::less>
        [[nodiscard]] constexpr bool operator()(_It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred = {},
            _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);

            return _Lexicographical_compare_unchecked(_Unwrap_iter<_Se1>(::std:: move(_First1)),
                _Unwrap_sent<_It1>(::std:: move(_Last1)), _Unwrap_iter<_Se2>(::std:: move(_First2)),
                _Unwrap_sent<_It2>(::std:: move(_Last2)), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

        template <input_range _Rng1, input_range _Rng2, class _Pj1 = identity, class _Pj2 = identity,
            indirect_strict_weak_order<projected<iterator_t<_Rng1>, _Pj1>, projected<iterator_t<_Rng2>, _Pj2>> _Pr =
                ranges::less>
        [[nodiscard]] constexpr bool operator()(
            _Rng1&& _Range1, _Rng2&& _Range2, _Pr _Pred = {}, _Pj1 _Proj1 = {}, _Pj2 _Proj2 = {}) const {
            return _Lexicographical_compare_unchecked(_Ubegin(_Range1), _Uend(_Range1), _Ubegin(_Range2),
                _Uend(_Range2), _Pass_fn(_Pred), _Pass_fn(_Proj1), _Pass_fn(_Proj2));
        }

    private:
        template <class _It1, class _Se1, class _It2, class _Se2, class _Pr, class _Pj1, class _Pj2>
        [[nodiscard]] static constexpr bool _Lexicographical_compare_unchecked(
            _It1 _First1, _Se1 _Last1, _It2 _First2, _Se2 _Last2, _Pr _Pred, _Pj1 _Proj1, _Pj2 _Proj2) {
            ;
            ;
            ;
            ;
            ;

            using _Memcmp_classification_pred = _Lex_compare_memcmp_classify<_It1, _It2, _Pr>;
            constexpr bool _Is_sized1         = sized_sentinel_for<_Se1, _It1>;
            constexpr bool _Is_sized2         = sized_sentinel_for<_Se2, _It2>;
            if constexpr (!is_void_v<_Memcmp_classification_pred> && _Sized_or_unreachable_sentinel_for<_Se1, _It1>
                          && _Sized_or_unreachable_sentinel_for<_Se2, _It2> && same_as<_Pj1, identity>
                          && same_as<_Pj2, identity> && (_Is_sized1 || _Is_sized2)) {
                if (!::std:: is_constant_evaluated()) {
                    size_t _Num1;
                    if constexpr (_Is_sized1) {
                        _Num1 = static_cast<size_t>(_Last1 - _First1);
                    } else {
                        _Num1 = 0xffffffffffffffffui64;
                    }

                    size_t _Num2;
                    if constexpr (_Is_sized2) {
                        _Num2 = static_cast<size_t>(_Last2 - _First2);
                    } else {
                        _Num2 = 0xffffffffffffffffui64;
                    }

                    const int _Ans = _Memcmp_count(_First1, _First2, (::std:: min)(_Num1, _Num2));
                    return _Memcmp_classification_pred{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
                }
            }

            for (;; ++_First1, (void) ++_First2) {
                if (_First2 == _Last2) {
                    return false;
                } else if (_First1 == _Last1) {
                    return true;
                } else if (::std:: invoke(_Pred, ::std:: invoke(_Proj1, *_First1), ::std:: invoke(_Proj2, *_First2))) {
                    return true;
                } else if (::std:: invoke(_Pred, ::std:: invoke(_Proj2, *_First2), ::std:: invoke(_Proj1, *_First1))) {
                    return false;
                }
            }
        }
    };

     inline constexpr _Lexicographical_compare_fn lexicographical_compare{
        _Not_quite_object::_Construct_tag{}};
} 
#line 10696 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 10697 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"



}







#pragma warning(pop)
#pragma pack(pop)
#line 10711 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#line 10712 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\algorithm"
#pragma external_header(pop)
#line 285 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iostream"









#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"











#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
#pragma vtordisp(push, 2) 

 extern "C++" template <class _Elem, class _Traits>
class basic_istream : virtual public basic_ios<_Elem, _Traits> { 
public:
    using _Myios = basic_ios<_Elem, _Traits>;
    using _Mysb  = basic_streambuf<_Elem, _Traits>;
    using _Iter  = istreambuf_iterator<_Elem, _Traits>;
    using _Ctype = ctype<_Elem>;
    using _Nget  = num_get<_Elem, _Iter>;







#line 38 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"

    explicit  basic_istream(_Mysb* _Strbuf, bool _Isstd = false) : _Chcount(0) {
        _Myios::init(_Strbuf, _Isstd);
    }

     basic_istream(_Uninitialized) {
        this->_Addstd(this);
    }

protected:
     basic_istream(basic_istream&& _Right) noexcept(false) : _Chcount(_Right._Chcount) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
        _Right._Chcount = 0;
    }

    basic_istream&  operator=(basic_istream&& _Right) noexcept  {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_istream& _Right) noexcept  {
        _Myios::swap(_Right);
        ::std:: swap(_Chcount, _Right._Chcount);
    }

public:
     basic_istream(const basic_istream&)            = delete;
    basic_istream&  operator=(const basic_istream&) = delete;

     ~basic_istream() noexcept override {}

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    class _Sentry_base {
    public:
         _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Lock();
            }
        }

         ~_Sentry_base() noexcept {
            const auto _Rdbuf = _Myistr.rdbuf();
            if (_Rdbuf) {
                _Rdbuf->_Unlock();
            }
        }

        basic_istream& _Myistr;

        _Sentry_base& operator=(const _Sentry_base&) = delete;
    };

    class sentry : public _Sentry_base {
    public:
        explicit  sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

        explicit  operator bool() const {
            return _Ok;
        }

         sentry(const sentry&)            = delete;
        sentry&  operator=(const sentry&) = delete;

    private:
        bool _Ok; 
    };

    bool  _Ipfx(bool _Noskip = false) { 
        if (!this->good()) {
            _Myios::setstate(ios_base::failbit);
            return false;
        }

        
        const auto _Tied = _Myios::tie();
        if (_Tied) {
            _Tied->flush();
        }

        bool _Eof = false;
        if (!_Noskip && this->flags() & ios_base::skipws) { 
            const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(this->getloc());

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _Eof = true;
                    break;
                } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {
                    break; 
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Eof) {
            _Myios::setstate(ios_base::eofbit | ios_base::failbit);
        }

        return this->good();
    }

    
    bool  ipfx(bool _Noskip = false) { 
        return _Ipfx(_Noskip);
    }

    
    void  isfx() {} 


















    basic_istream&  operator>>(basic_istream&(__cdecl* _Pfn)(basic_istream&) ) {
        
        return _Pfn(*this);
    }

    basic_istream&  operator>>(_Myios&(__cdecl* _Pfn)(_Myios&) ) { 
        _Pfn(*this);
        return *this;
    }

    basic_istream&  operator>>(ios_base&(__cdecl* _Pfn)(ios_base&) ) { 
        _Pfn(*this);
        return *this;
    }

private:
    template <class _Ty>
    basic_istream& _Common_extract_with_num_get(_Ty& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    template <class = void>
    void _Increment_gcount() noexcept {
        if (_Chcount != (numeric_limits<streamsize>::max)()) {
            ++_Chcount;
        }
    }

public:
    basic_istream&  operator>>(bool& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(short& _Val) { 
        ios_base::iostate _Err = ios_base::goodbit;
        const sentry _Ok(*this);

        if (_Ok) { 
            try {
            long _Lval;
            ::std:: use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
            if (_Lval < (-32768)) {
                _Err |= ios_base::failbit;
                _Val = (-32768);
            } else if (_Lval > 32767) {
                _Err |= ios_base::failbit;
                _Val = 32767;
            } else {
                _Val = static_cast<short>(_Lval);
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Err);
        return *this;
    }

    
    
    
    

    
    

    basic_istream&  operator>>(unsigned short& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(int& _Val) { 
        static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
        long _Result = _Val;
        _Common_extract_with_num_get(_Result);
        _Val = _Result;
        return *this;
    }

    basic_istream&  operator>>(unsigned int& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(unsigned long long& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(float& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(long double& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(void*& _Val) { 
        return _Common_extract_with_num_get(_Val);
    }

    basic_istream&  operator>>(_Mysb* _Strbuf) { 
        _Chcount = 0; 
        const sentry _Ok(*this, true);
        ios_base::iostate _State = ios_base::goodbit;
        if (_Ok && _Strbuf) { 
            try {
            for (int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                }
                
                try {
                if (_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta)))) {
                    break;
                }

                } catch (...) {
                break;
                }

                _Increment_gcount();
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) { 
            _State |= ios_base::failbit;
        }

        _Myios::setstate(_State);
        return *this;
    }

    int_type  get() { 
        int_type _Meta           = 0;
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            _Meta = _Myios::rdbuf()->sgetc();

            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            } else { 
                _Myios::rdbuf()->sbumpc();
                _Chcount = 1;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count) { 
        return get(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  get(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Traits::to_char_type(_Meta) == _Delim) {
                    break; 
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        *_Str = _Elem(); 
        return *this;
    }

    basic_istream&  get(_Elem& _Ch) { 
        int_type _Meta = get();
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _Ch = _Traits::to_char_type(_Meta);
        }

        return *this;
    }

    basic_istream&  get(_Mysb& _Strbuf) { 
        return get(_Strbuf, _Myios::widen('\n'));
    }

    basic_istream&  get(_Mysb& _Strbuf, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    try {
                    _Elem _Ch = _Traits::to_char_type(_Meta);
                    if (_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch))) {
                        break;
                    }
                    } catch (...) {
                    break;
                    }
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        if (_Chcount == 0) {
            _State |= ios_base::failbit;
        }
        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  getline(_Elem* _Str, streamsize _Count) {
        
        return getline(_Str, _Count, _Myios::widen('\n'));
    }

    basic_istream&  getline(_Elem* _Str, streamsize _Count, _Elem _Delim) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            int_type _Metadelim = _Traits::to_int_type(_Delim);

            try {
            int_type _Meta = _Myios::rdbuf()->sgetc();

            for (;; _Meta = _Myios::rdbuf()->snextc()) {
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State |= ios_base::eofbit;
                    break;
                } else if (_Meta == _Metadelim) { 
                    _Increment_gcount();
                    _Myios::rdbuf()->sbumpc();
                    break;
                } else if (--_Count <= 0) { 
                    _State |= ios_base::failbit;
                    break;
                } else { 
                    *_Str++ = _Traits::to_char_type(_Meta);
                    _Increment_gcount();
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        *_Str = _Elem(); 
        _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
        return *this;
    }

    basic_istream&  ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof()) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            for (;;) { 
                int_type _Meta;
                if (_Count != (numeric_limits<streamsize>::max)() && --_Count < 0) {
                    break; 
                } else if (_Traits::eq_int_type(_Traits::eof(),
                               _Meta = _Myios::rdbuf()->sbumpc())) { 
                    _State |= ios_base::eofbit;
                    break;
                } else { 
                    _Increment_gcount();
                    if (_Meta == _Metadelim) {
                        break; 
                    }
                }
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  read(_Elem* _Str, streamsize _Count) { 
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);

        if (_Ok && 0 < _Count) { 
            try {
            const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
            _Chcount              = _Num;

            if (_Num != _Count) {
                _State |= ios_base::eofbit | ios_base::failbit; 
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    streamsize  readsome(_Elem* _Str, streamsize _Count) {
        
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        const sentry _Ok(*this, true);
        streamsize _Num;

        if (!_Ok) {
            _State |= ios_base::failbit; 
        } else if ((_Num = _Myios::rdbuf()->in_avail()) < 0) {
            _State |= ios_base::eofbit; 
        } else if (0 < _Count && 0 < _Num) { 
            read(_Str, _Num < _Count ? _Num : _Count);
        }

        _Myios::setstate(_State);
        return gcount();
    }

    int_type  peek() {
        ios_base::iostate _State = ios_base::goodbit;
        _Chcount                 = 0;
        int_type _Meta           = 0;
        const sentry _Ok(*this, true);

        if (!_Ok) {
            _Meta = _Traits::eof(); 
        } else { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc())) {
                _State |= ios_base::eofbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return _Meta;
    }

    basic_istream&  putback(_Elem _Ch) { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch))) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  unget() { 
        _Chcount                    = 0;
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (_Ok) { 
            try {
            if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc())) {
                _State |= ios_base::badbit | _Oldstate;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    [[nodiscard]] streamsize  gcount() const noexcept  {
        
        return _Chcount;
    }

    int  sync() { 
        const sentry _Ok(*this, true);

        const auto _Rdbuf = _Myios::rdbuf();
        if (!_Rdbuf) {
            return -1;
        }

        ios_base::iostate _State = ios_base::goodbit;
        try {
        if (_Rdbuf->pubsync() == -1) {
            _State |= ios_base::badbit;
        }
        } catch (...) {
        _Myios::setstate(ios_base::badbit, true);
        return -1;
        }

        if (_State & ios_base::badbit) {
            _Myios::setstate(ios_base::badbit);
            return -1;
        }

        return 0;
    }

    basic_istream&  seekg(pos_type _Pos) { 
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1) {
                _State |= ios_base::failbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    basic_istream&  seekg(off_type _Off, ios_base::seekdir _Way) {
        
        ios_base::iostate _State    = ios_base::goodbit;
        ios_base::iostate _Oldstate = _Myios::rdstate();
        _Myios::clear(_Oldstate & ~ios_base::eofbit);
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            if (static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1) {
                _State |= ios_base::failbit;
            }
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        _Myios::setstate(_State);
        return *this;
    }

    pos_type  tellg() {
        const sentry _Ok(*this, true);

        if (!this->fail()) {
            try {
            return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            } catch (...) { _Myios::setstate(ios_base::badbit, true); }
        }

        return pos_type{off_type{-1}};
    }

private:
    streamsize _Chcount{}; 
};

#pragma vtordisp(pop) 























template class __declspec(dllimport) basic_istream<char, char_traits<char>>;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t>>;
#line 716 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"




#line 721 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"

 extern "C++" template <class _Elem, class _Traits>
class basic_iostream : public basic_istream<_Elem, _Traits>,
                       public basic_ostream<_Elem, _Traits> { 
public:
    using _Myis       = basic_istream<_Elem, _Traits>;
    using _Myos       = basic_ostream<_Elem, _Traits>;
    using _Myios      = basic_ios<_Elem, _Traits>;
    using char_type   = _Elem;
    using traits_type = _Traits;
    using int_type    = typename _Traits::int_type;
    using pos_type    = typename _Traits::pos_type;
    using off_type    = typename _Traits::off_type;

    explicit  basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf)
        : _Myis(_Strbuf, false), _Myos(_Noinit, false) {}

protected:
     basic_iostream(basic_iostream&& _Right) noexcept(false)
        : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false) {
        _Myios::init();
        _Myios::move(::std:: move(_Right));
    }

    basic_iostream&  operator=(basic_iostream&& _Right) noexcept  {
        this->swap(_Right);
        return *this;
    }

    void  swap(basic_iostream& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Myios::swap(_Right);
        }
    }

public:
     basic_iostream(const basic_iostream&)            = delete;
    basic_iostream&  operator=(const basic_iostream&) = delete;

     ~basic_iostream() noexcept override {}
};




template class __declspec(dllimport) basic_iostream<char, char_traits<char>>;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t>>;
#line 769 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"




#line 774 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"

template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(
    basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str) {
    using _Myis              = basic_istream<_Elem, _Traits>;
    using _Ctype             = ctype<_Elem>;
    ios_base::iostate _State = ios_base::goodbit;
    size_t _Current          = 0;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        const _Ctype& _Ctype_fac = ::std:: use_facet<_Ctype>(_Istr.getloc());

        try {
        size_t _Count       = _Size;
        const size_t _Width = static_cast<size_t>(_Istr.width());
        if (_Width > 0 && _Width < _Size) {
            _Count = _Width;
        }

        typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
        _Elem _Ch;

        for (; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void) ++_Current) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem()) {
                break; 
            } else {
                _Str[_Current] = _Traits::to_char_type(_Meta); 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }
    ; 
    _Str[_Current] = _Elem(); 
    _Istr.width(0);
    if (_Current == 0) {
        _State |= ios_base::failbit;
    }
    _Istr.setstate(_State);
    return _Istr;
}


#pragma warning(push)
#pragma warning(disable : 6001) 
 template <class _Elem, class _Traits, size_t _Size>
basic_istream<_Elem, _Traits>& operator>>(
    basic_istream<_Elem, _Traits>& _Istr,   _Elem (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, _Str);
}

 template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr,   signed char (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}

 template <class _Traits, size_t _Size>
basic_istream<char, _Traits>& operator>>(
    basic_istream<char, _Traits>& _Istr,   unsigned char (&_Str)[_Size]) {
    return _Istream_extract_into_buffer(_Istr, _Size, reinterpret_cast<char*>(_Str));
}
#pragma warning(pop)















#line 856 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"

 template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch) { 
    using _Myis = basic_istream<_Elem, _Traits>;

    typename _Myis::int_type _Meta;
    ios_base::iostate _State = ios_base::goodbit;
    const typename _Myis::sentry _Ok(_Istr);

    if (_Ok) { 
        try {
        _Meta = _Istr.rdbuf()->sbumpc();
        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            _State |= ios_base::eofbit | ios_base::failbit; 
        } else {
            _Ch = _Traits::to_char_type(_Meta); 
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
    }

    _Istr.setstate(_State);
    return _Istr;
}

 template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char& _Ch) {
    
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

 template <class _Traits>
basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char& _Ch) {
    
    return _Istr >> reinterpret_cast<char&>(_Ch);
}

template <class _Istr, class _Ty, class = void>
struct _Can_stream_in : false_type {};

template <class _Istr, class _Ty>
struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std:: declval<_Istr&>() >> ::std:: declval<_Ty>())>> : true_type {};

 template <class _Istr, class _Ty,
    enable_if_t<conjunction_v<is_convertible<_Istr*, ios_base*>, _Can_stream_in<_Istr, _Ty>>, int> = 0>
_Istr&& operator>>(_Istr&& _Is, _Ty&& _Val) { 
    _Is >> ::std:: forward<_Ty>(_Val);
    return ::std:: move(_Is);
}

 template <class _Elem, class _Traits>
basic_istream<_Elem, _Traits>& __cdecl ws(basic_istream<_Elem, _Traits>& _Istr) { 
    const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

    if (_Ok) { 
        ios_base::iostate _State = ios_base::goodbit;
        const auto& _Ctype_fac   = ::std:: use_facet<ctype<_Elem>>(_Istr.getloc());

        try {
        for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc()) {
            if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                _State |= ios_base::eofbit;
                break;
            } else if (!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta))) {
                break; 
            }
        }
        } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        _Istr.setstate(_State);
    }

    return _Istr;
}
}



#pragma warning(pop)
#pragma pack(pop)
#line 935 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"
#line 936 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\istream"
#pragma external_header(pop)
#line 11 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iostream"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {



















 extern "C++"  __declspec(dllimport) istream cin;
 extern "C++"  __declspec(dllimport) ostream cout;
 extern "C++"  __declspec(dllimport) ostream cerr;
 extern "C++"  __declspec(dllimport) ostream clog;
extern "C++"  __declspec(dllimport) istream* _Ptr_cin;
extern "C++"  __declspec(dllimport) ostream* _Ptr_cout;
extern "C++"  __declspec(dllimport) ostream* _Ptr_cerr;
extern "C++"  __declspec(dllimport) ostream* _Ptr_clog;

 extern "C++"  __declspec(dllimport) wistream wcin;
 extern "C++"  __declspec(dllimport) wostream wcout;
 extern "C++"  __declspec(dllimport) wostream wcerr;
 extern "C++"  __declspec(dllimport) wostream wclog;
extern "C++"  __declspec(dllimport) wistream* _Ptr_wcin;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wcout;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wcerr;
extern "C++"  __declspec(dllimport) wostream* _Ptr_wclog;












#line 68 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iostream"
}


#pragma warning(pop)
#pragma pack(pop)
#line 74 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iostream"
#line 75 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iostream"
#pragma external_header(pop)
#line 286 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"












#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {

 template <class _Elem, class _Traits, class _Alloc>
class basic_stringbuf
    : public basic_streambuf<_Elem, _Traits> { 
public:
    using allocator_type = _Alloc;
    using _Mysb          = basic_streambuf<_Elem, _Traits>;
    using _Mystr         = basic_string<_Elem, _Traits, _Alloc>;
    using _Mysize_type   = typename _Mystr::size_type;


    using _Mystr_view = basic_string_view<_Elem, _Traits>;
#line 33 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_stringbuf() : _Seekhigh(nullptr), _Mystate(_Getstate(ios_base::in | ios_base::out)), _Al() {}

    explicit basic_stringbuf(ios_base::openmode _Mode) : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al() {}

    explicit basic_stringbuf(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Al(_Str.get_allocator()) {
        _Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
    }


    explicit basic_stringbuf(const _Alloc& _Al_) : basic_stringbuf(ios_base::in | ios_base::out, _Al_) {}

    basic_stringbuf(ios_base::openmode _Mode, const _Alloc& _Al_)
        : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al(_Al_) {}

    explicit basic_stringbuf(_Mystr&& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Al(::std:: move(_Str._Getal())) {
        _Init_string_inplace(::std:: move(_Str), _Getstate(_Mode));
    }

    template <class _Alloc2>
    basic_stringbuf(const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode, const _Alloc& _Al_)
        : _Al(_Al_) {
        _Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
    }

    template <class _Alloc2>
    basic_stringbuf(const basic_string<_Elem, _Traits, _Alloc2>& _Str, const _Alloc& _Al_)
        : basic_stringbuf(_Str, ios_base::in | ios_base::out, _Al_) {}

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    explicit basic_stringbuf(
        const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : basic_stringbuf(_Str, _Mode, _Alloc{}) {}

    basic_stringbuf(basic_stringbuf&& _Right, const _Alloc& _Al_) : _Mystate(0), _Al(_Al_) {
        _Assign_rv(::std:: move(_Right));
    }
#line 73 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_stringbuf(basic_stringbuf&& _Right) : _Mystate(0) {
        _Assign_rv(::std:: move(_Right));
    }

    basic_stringbuf& operator=(basic_stringbuf&& _Right) noexcept  {
        _Assign_rv(::std:: move(_Right));
        return *this;
    }

    void _Assign_rv(basic_stringbuf&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            _Tidy();
            this->swap(_Right);
        }
    }

    void swap(basic_stringbuf& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            if constexpr (!allocator_traits<_Alloc>::propagate_on_container_swap::value) {
                ;
#line 95 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
            }

            _Mysb::swap(_Right);
            ::std:: swap(_Seekhigh, _Right._Seekhigh);
            ::std:: swap(_Mystate, _Right._Mystate);
            
            _Pocs(_Al, _Right._Al);
        }
    }

    basic_stringbuf(const basic_stringbuf&)            = delete;
    basic_stringbuf& operator=(const basic_stringbuf&) = delete;

    ~basic_stringbuf() noexcept override {
        _Tidy();
    }

    enum { 
        _Allocated   = 1, 
        _Constant    = 2, 
        _Noread      = 4, 
        _Append      = 8, 
        _Atend       = 16, 
        _From_rvalue = 32 
    };

    using int_type = typename _Traits::int_type;
    using pos_type = typename _Traits::pos_type;
    using off_type = typename _Traits::off_type;

    struct _Buffer_view {
        _Elem* _Ptr;
        _Mysize_type _Size;
        _Mysize_type _Res;
    };

    [[nodiscard]] _Buffer_view _Get_buffer_view() const noexcept {
        _Buffer_view _Result{};
        if ((!(_Mystate & _Constant) || (_Mystate & _From_rvalue)) && _Mysb::pptr()) {
            
            const auto _Base = _Mysb::pbase();
            _Result._Ptr     = _Base;
            _Result._Size    = static_cast<_Mysize_type>((::std:: max)(_Mysb::pptr(), _Seekhigh) - _Base);
            _Result._Res     = static_cast<_Mysize_type>(_Mysb::epptr() - _Base);
        } else if (!(_Mystate & _Noread) && _Mysb::gptr()) {
            
            const auto _Base = _Mysb::eback();
            _Result._Ptr     = _Base;
            _Result._Size    = static_cast<_Mysize_type>(_Mysb::egptr() - _Base);
            _Result._Res     = _Result._Size;
        }
        return _Result;
    }


    [[nodiscard]] _Mystr str() const&


#line 154 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
    {
        _Mystr _Result(_Al);
        const auto _View = _Get_buffer_view();
        if (_View._Ptr) {
            _Result.assign(_View._Ptr, _View._Size);
        }
        return _Result;
    }

    void str(const _Mystr& _Newstr) { 
        _Tidy();
        _Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
    }


    template <class _Alloc2, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc2> str(const _Alloc2& _Al) const {
        return basic_string<_Elem, _Traits, _Alloc2>{view(), _Al};
    }

    
    
    
    [[nodiscard]] _Mystr str() && {
        _Mystr _Result{_String_constructor_rvalue_allocator_tag{}, ::std:: move(_Al)};
        const auto _View = _Get_buffer_view();
        
        
        if (_View._Size == _View._Res) {
            
            _Result.assign(_View._Ptr, _View._Size);
        } else {
            if (_Result._Move_assign_from_buffer(_View._Ptr, _View._Size, _View._Res)) {
                _Mystate &= ~_Allocated;
            }
        }

        _Tidy();
        return _Result;
    }

    [[nodiscard]] _Mystr_view view() const noexcept {
        const auto _View = _Get_buffer_view();
        return _Mystr_view{_View._Ptr, _View._Size};
    }

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    void str(const basic_string<_Elem, _Traits, _Alloc2>& _Newstr) {
        _Tidy();
        _Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
    }

    void str(_Mystr&& _Newstr) {
        auto& _Newstr_al          = _Newstr._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alloc>;
        if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Newstr_al) {
                _Tidy();
                _Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
                return;
            }
        }

        _Tidy();
        _Pocma(_Al, _Newstr_al);
        _Init_string_inplace(::std:: move(_Newstr), _Mystate);
    }

    [[nodiscard]] allocator_type get_allocator() const noexcept {
        return _Al;
    }
#line 226 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

protected:
    int_type overflow(int_type _Meta = _Traits::eof()) override { 
        if (_Mystate & _Constant) {
            return _Traits::eof(); 
        }

        if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            return _Traits::not_eof(_Meta); 
        }

        const auto _Pptr  = _Mysb::pptr();
        const auto _Epptr = _Mysb::epptr();
        if (_Pptr && _Pptr < _Epptr) { 
            *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
            _Seekhigh        = _Pptr + 1;
            return _Meta;
        }

        
        size_t _Oldsize    = 0;
        const auto _Oldptr = _Mysb::eback();
        if (_Pptr) {
            _Oldsize = static_cast<size_t>(_Epptr - _Oldptr);
        }

        size_t _Newsize;
        if (_Oldsize < _MINSIZE) {
            _Newsize = _MINSIZE;
        } else if (_Oldsize < 2147483647 / 2) { 
            _Newsize = _Oldsize << 1;
        } else if (_Oldsize < 2147483647) {
            _Newsize = 2147483647;
        } else { 
            return _Traits::eof();
        }

        const auto _Newptr = _Unfancy(_Allocate_at_least_helper(_Al, _Newsize));
        _Traits::copy(_Newptr, _Oldptr, _Oldsize);

        const auto _New_pnext = _Newptr + _Oldsize;
        _Seekhigh             = _New_pnext + 1; 

        _Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);
        if (_Mystate & _Noread) { 
            _Mysb::setg(_Newptr, _Newptr, _Newptr);
        } else { 
            _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);
        }

        if (_Mystate & _Allocated) {
            _Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);
        }

        _Mystate |= _Allocated;
        *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
        return _Meta;
    }

    int_type pbackfail(int_type _Meta = _Traits::eof()) override { 
        const auto _Gptr = _Mysb::gptr();
        if (!_Gptr || _Gptr <= _Mysb::eback()
            || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])
                && (_Mystate & _Constant))) { 
            return _Traits::eof();
        }

        
        _Mysb::gbump(-1);
        if (!_Traits::eq_int_type(_Traits::eof(), _Meta)) {
            *_Mysb::gptr() = _Traits::to_char_type(_Meta);
        }

        return _Traits::not_eof(_Meta);
    }

    int_type underflow() override { 
        const auto _Gptr = _Mysb::gptr();
        if (!_Gptr) { 
            return _Traits::eof();
        }

        if (_Gptr < _Mysb::egptr()) {
            return _Traits::to_int_type(*_Gptr);
        }

        
        const auto _Pptr = _Mysb::pptr();
        if (!_Pptr || (_Mystate & _Noread)) { 
            return _Traits::eof();
        }

        const auto _Local_highwater = (::std:: max)(_Seekhigh, _Pptr);
        if (_Local_highwater <= _Gptr) { 
            return _Traits::eof();
        }

        _Seekhigh = _Local_highwater;
        _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Local_highwater);
        return _Traits::to_int_type(*_Mysb::gptr());
    }

    pos_type seekoff(
        off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {
        const bool _Need_read_but_cannot  = (_Mode & ios_base::in) != 0 && (_Mystate & _Noread) != 0;
        const bool _Need_write_but_cannot = (_Mode & ios_base::out) != 0 && (_Mystate & _Constant) != 0;
        if (_Need_read_but_cannot || _Need_write_but_cannot) {
            return pos_type{off_type{-1}};
        }

        
        const auto _Gptr_old = _Mysb::gptr();
        const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();
        if (_Pptr_old && _Seekhigh < _Pptr_old) { 
            _Seekhigh = _Pptr_old;
        }

        const auto _Seeklow  = _Mysb::eback();
        const auto _Seekdist = _Seekhigh - _Seeklow;
        off_type _Newoff;
        switch (_Way) {
        case ios_base::beg:
            _Newoff = 0;
            break;
        case ios_base::end:
            _Newoff = _Seekdist;
            break;
        case ios_base::cur:
            {
                constexpr auto _Both = ios_base::in | ios_base::out;
                if ((_Mode & _Both) != _Both) { 
                    if (_Mode & ios_base::in) {
                        if (_Gptr_old || !_Seeklow) {
                            _Newoff = _Gptr_old - _Seeklow;
                            break;
                        }
                    } else if ((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow)) {
                        _Newoff = _Pptr_old - _Seeklow;
                        break;
                    }
                }
            }

            [[fallthrough]];
        default:
            return pos_type{off_type{-1}};
        }

        if (static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist)) {
            return pos_type{off_type{-1}};
        }

        _Off += _Newoff;
        if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {
            return pos_type{off_type{-1}};
        }

        const auto _Newptr = _Seeklow + _Off; 
        if ((_Mode & ios_base::in) && _Gptr_old) {
            _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);
        }

        if ((_Mode & ios_base::out) && _Pptr_old) {
            _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());
        }

        return pos_type{_Off};
    }

    pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out) override {
        const bool _Need_read_but_cannot  = (_Mode & ios_base::in) != 0 && (_Mystate & _Noread) != 0;
        const bool _Need_write_but_cannot = (_Mode & ios_base::out) != 0 && (_Mystate & _Constant) != 0;
        if (_Need_read_but_cannot || _Need_write_but_cannot) {
            return pos_type{off_type{-1}};
        }

        
        const auto _Off      = static_cast<streamoff>(_Pos);
        const auto _Gptr_old = _Mysb::gptr();
        const auto _Pptr_old = (_Mystate & _Constant) ? nullptr : _Mysb::pptr();
        if (_Pptr_old && _Seekhigh < _Pptr_old) { 
            _Seekhigh = _Pptr_old;
        }

        const auto _Seeklow  = _Mysb::eback();
        const auto _Seekdist = _Seekhigh - _Seeklow;
        if (static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist)) {
            return pos_type{off_type{-1}};
        }

        if (_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old))) {
            return pos_type{off_type{-1}};
        }

        const auto _Newptr = _Seeklow + _Off; 
        if ((_Mode & ios_base::in) && _Gptr_old) {
            _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);
        }

        if ((_Mode & ios_base::out) && _Pptr_old) {
            _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());
        }

        return pos_type{_Off};
    }

    void _Init(const _Elem* _Ptr, const _Mysize_type _Count, int _State) {
        
        _State &= ~_From_rvalue;

        if (_Count > 2147483647) { 
            _Xbad_alloc();
        }

        if (_Count != 0 && (_State & (_Noread | _Constant)) != (_Noread | _Constant)) {
            
            _Mysize_type _Newsize = _Count;
            const auto _Pnew      = _Unfancy(_Allocate_at_least_helper(_Al, _Newsize));
            _Traits::copy(_Pnew, _Ptr, _Count);
            _Seekhigh = _Pnew + _Newsize;

            if (!(_State & _Noread)) {
                _Mysb::setg(_Pnew, _Pnew, _Seekhigh); 
            }

            if (!(_State & _Constant)) { 
                _Mysb::setp(_Pnew, (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew, _Seekhigh);

                if (_State & _Noread) { 
                    _Mysb::setg(_Pnew, _Pnew, _Pnew);
                }
            }

            _State |= _Allocated;
        } else {
            _Seekhigh = nullptr;
        }

        _Mystate = _State;
    }


    void _Init_string_inplace(_Mystr&& _Str, int _State) {
        if ((_State & _Noread) && (_State & _Constant)) { 
            _Seekhigh = nullptr;
            _Mystate  = _State | _From_rvalue;
            return;
        }

        
        auto [_Ptr, _Size, _Actual_allocation_size] = _Str._Release_to_buffer(_Al);
        _Elem* const _Pnew                          = _Unfancy(_Ptr);
        _Seekhigh                                   = _Pnew + _Size;
        auto _Next                                  = (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew;
        auto _End_buffer                            = _Pnew + _Actual_allocation_size;

        _Mysb::setp(_Pnew, _Next, _End_buffer);
        if (_State & _Noread) { 
            _Mysb::setg(_Pnew, _Pnew, _Pnew);
        } else {
            _Mysb::setg(_Pnew, _Pnew, _Seekhigh);
        }

        _Mystate = _State | _Allocated | _From_rvalue;
    }
#line 492 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    void _Tidy() noexcept { 
        if (_Mystate & _Allocated) {
            _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),
                static_cast<typename allocator_traits<allocator_type>::size_type>(
                    (_Mysb::pptr() ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
        }

        _Mysb::setg(nullptr, nullptr, nullptr);
        _Mysb::setp(nullptr, nullptr);
        _Seekhigh = nullptr;
        _Mystate &= ~_Allocated;
    }

private:
    using _Ptr_traits = pointer_traits<typename allocator_traits<allocator_type>::pointer>;

    enum { 
        _MINSIZE = 32
    };

    static int _Getstate(ios_base::openmode _Mode) noexcept { 
        int _State = 0;
        if (!(_Mode & ios_base::in)) {
            _State |= _Noread;
        }

        if (!(_Mode & ios_base::out)) {
            _State |= _Constant;
        }

        if (_Mode & ios_base::app) {
            _State |= _Append;
        }

        if (_Mode & ios_base::ate) {
            _State |= _Atend;
        }

        return _State;
    }

    
    _Elem* _Seekhigh; 
    int _Mystate; 
    allocator_type _Al; 
};

 template <class _Elem, class _Traits, class _Alloc>
void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left, basic_stringbuf<_Elem, _Traits, _Alloc>& _Right) noexcept
 {
    _Left.swap(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
class basic_istringstream : public basic_istream<_Elem, _Traits> { 
public:
    using _Mybase        = basic_istream<_Elem, _Traits>;
    using allocator_type = _Alloc;
    using _Mysb          = basic_stringbuf<_Elem, _Traits, _Alloc>;
    using _Mystr         = basic_string<_Elem, _Traits, _Alloc>;


    using _Mystr_view = basic_string_view<_Elem, _Traits>;
#line 557 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_istringstream() : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(ios_base::in) {}

    explicit basic_istringstream(ios_base::openmode _Mode)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::in) {}

    explicit basic_istringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::in) {}


    basic_istringstream(ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::in, _Al) {}

    explicit basic_istringstream(_Mystr&& _Str, ios_base::openmode _Mode = ios_base::in)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(::std:: move(_Str), _Mode | ios_base::in) {}

    template <class _Alloc2>
    basic_istringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, ios_base::in, _Al) {}

    template <class _Alloc2>
    basic_istringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::in, _Al) {}

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    explicit basic_istringstream(
        const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode = ios_base::in)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::in) {}
#line 586 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_istringstream(basic_istringstream&& _Right) : _Mybase(::std:: addressof(_Stringbuffer)) {
        _Assign_rv(::std:: move(_Right));
    }

    basic_istringstream& operator=(basic_istringstream&& _Right) noexcept  {
        _Assign_rv(::std:: move(_Right));
        return *this;
    }

    void _Assign_rv(basic_istringstream&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer._Assign_rv(::std:: move(_Right._Stringbuffer));
        }
    }

    void swap(basic_istringstream& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer.swap(_Right._Stringbuffer);
        }
    }

    basic_istringstream(const basic_istringstream&)            = delete;
    basic_istringstream& operator=(const basic_istringstream&) = delete;

    ~basic_istringstream() noexcept override {}

    [[nodiscard]] _Mysb* rdbuf() const noexcept  {
        return const_cast<_Mysb*>(::std:: addressof(_Stringbuffer));
    }


    [[nodiscard]] _Mystr str() const&


#line 624 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
    {
        return _Stringbuffer.str();
    }

    void str(const _Mystr& _Newstr) { 
        _Stringbuffer.str(_Newstr);
    }


    template <class _Alloc2, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc2> str(const _Alloc2& _Al) const {
        return _Stringbuffer.str(_Al);
    }

    [[nodiscard]] _Mystr str() && {
        return ::std:: move(_Stringbuffer).str();
    }

    [[nodiscard]] _Mystr_view view() const noexcept {
        return _Stringbuffer.view();
    }

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    void str(const basic_string<_Elem, _Traits, _Alloc2>& _Newstr) {
        _Stringbuffer.str(_Newstr);
    }

    void str(_Mystr&& _Newstr) {
        _Stringbuffer.str(::std:: move(_Newstr));
    }
#line 655 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

private:
    _Mysb _Stringbuffer;
};

 template <class _Elem, class _Traits, class _Alloc>
void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
    basic_istringstream<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
class basic_ostringstream : public basic_ostream<_Elem, _Traits> { 
public:
    using _Mybase        = basic_ostream<_Elem, _Traits>;
    using allocator_type = _Alloc;
    using _Mysb          = basic_stringbuf<_Elem, _Traits, _Alloc>;
    using _Mystr         = basic_string<_Elem, _Traits, _Alloc>;


    using _Mystr_view = basic_string_view<_Elem, _Traits>;
#line 677 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_ostringstream() : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(ios_base::out) {}

    explicit basic_ostringstream(ios_base::openmode _Mode)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::out) {}

    explicit basic_ostringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::out) {}


    basic_ostringstream(ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::out, _Al) {}

    explicit basic_ostringstream(_Mystr&& _Str, ios_base::openmode _Mode = ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(::std:: move(_Str), _Mode | ios_base::out) {}

    template <class _Alloc2>
    basic_ostringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, ios_base::out, _Al) {}

    template <class _Alloc2>
    basic_ostringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::out, _Al) {}

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    explicit basic_ostringstream(
        const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode = ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::out) {}
#line 706 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_ostringstream(basic_ostringstream&& _Right) : _Mybase(::std:: addressof(_Stringbuffer)) {
        _Assign_rv(::std:: move(_Right));
    }

    basic_ostringstream& operator=(basic_ostringstream&& _Right) noexcept  {
        _Assign_rv(::std:: move(_Right));
        return *this;
    }

    void _Assign_rv(basic_ostringstream&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer._Assign_rv(::std:: move(_Right._Stringbuffer));
        }
    }

    void swap(basic_ostringstream& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer.swap(_Right._Stringbuffer);
        }
    }

    basic_ostringstream(const basic_ostringstream&)            = delete;
    basic_ostringstream& operator=(const basic_ostringstream&) = delete;

    ~basic_ostringstream() noexcept override {}

    [[nodiscard]] _Mysb* rdbuf() const noexcept  {
        return const_cast<_Mysb*>(::std:: addressof(_Stringbuffer));
    }


    [[nodiscard]] _Mystr str() const&


#line 744 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
    {
        return _Stringbuffer.str();
    }

    void str(const _Mystr& _Newstr) { 
        _Stringbuffer.str(_Newstr);
    }


    template <class _Alloc2, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc2> str(const _Alloc2& _Al) const {
        return _Stringbuffer.str(_Al);
    }

    [[nodiscard]] _Mystr str() && {
        return ::std:: move(_Stringbuffer).str();
    }

    [[nodiscard]] _Mystr_view view() const noexcept {
        return _Stringbuffer.view();
    }

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    void str(const basic_string<_Elem, _Traits, _Alloc2>& _Newstr) {
        _Stringbuffer.str(_Newstr);
    }

    void str(_Mystr&& _Newstr) {
        _Stringbuffer.str(::std:: move(_Newstr));
    }
#line 775 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

private:
    _Mysb _Stringbuffer;
};

 template <class _Elem, class _Traits, class _Alloc>
void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
    basic_ostringstream<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}

 template <class _Elem, class _Traits, class _Alloc>
class basic_stringstream
    : public basic_iostream<_Elem, _Traits> { 
public:
    using _Mybase        = basic_iostream<_Elem, _Traits>;
    using char_type      = _Elem;
    using traits_type    = _Traits;
    using allocator_type = _Alloc;
    using int_type       = typename _Traits::int_type;
    using pos_type       = typename _Traits::pos_type;
    using off_type       = typename _Traits::off_type;
    using _Mysb          = basic_stringbuf<_Elem, _Traits, _Alloc>;
    using _Mystr         = basic_string<_Elem, _Traits, _Alloc>;


    using _Mystr_view = basic_string_view<_Elem, _Traits>;
#line 803 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_stringstream() : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(ios_base::in | ios_base::out) {}

    explicit basic_stringstream(ios_base::openmode _Mode)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode) {}

    explicit basic_stringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode) {}


    basic_stringstream(ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Mode, _Al) {}

    explicit basic_stringstream(_Mystr&& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(::std:: move(_Str), _Mode) {}

    template <class _Alloc2>
    basic_stringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, ios_base::in | ios_base::out, _Al) {}

    template <class _Alloc2>
    basic_stringstream(const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode, const _Alloc& _Al)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode, _Al) {}

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    explicit basic_stringstream(
        const basic_string<_Elem, _Traits, _Alloc2>& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Mybase(::std:: addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode) {}
#line 832 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

    basic_stringstream(basic_stringstream&& _Right) : _Mybase(::std:: addressof(_Stringbuffer)) {
        _Assign_rv(::std:: move(_Right));
    }

    basic_stringstream& operator=(basic_stringstream&& _Right) noexcept  {
        _Assign_rv(::std:: move(_Right));
        return *this;
    }

    void _Assign_rv(basic_stringstream&& _Right) noexcept {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer._Assign_rv(::std:: move(_Right._Stringbuffer));
        }
    }

    void swap(basic_stringstream& _Right) noexcept  {
        if (this != ::std:: addressof(_Right)) {
            _Mybase::swap(_Right);
            _Stringbuffer.swap(_Right._Stringbuffer);
        }
    }

    basic_stringstream(const basic_stringstream&)            = delete;
    basic_stringstream& operator=(const basic_stringstream&) = delete;

    ~basic_stringstream() noexcept override {}

    [[nodiscard]] _Mysb* rdbuf() const noexcept  {
        return const_cast<_Mysb*>(::std:: addressof(_Stringbuffer));
    }


    [[nodiscard]] _Mystr str() const&


#line 870 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
    {
        return _Stringbuffer.str();
    }

    void str(const _Mystr& _Newstr) { 
        _Stringbuffer.str(_Newstr);
    }


    template <class _Alloc2, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc2> str(const _Alloc2& _Al) const {
        return _Stringbuffer.str(_Al);
    }

    [[nodiscard]] _Mystr str() && {
        return ::std:: move(_Stringbuffer).str();
    }

    [[nodiscard]] _Mystr_view view() const noexcept {
        return _Stringbuffer.view();
    }

    template <class _Alloc2, enable_if_t<!is_same_v<_Alloc2, _Alloc>, int> = 0>
    void str(const basic_string<_Elem, _Traits, _Alloc2>& _Newstr) {
        _Stringbuffer.str(_Newstr);
    }

    void str(_Mystr&& _Newstr) {
        _Stringbuffer.str(::std:: move(_Newstr));
    }
#line 901 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"

private:
    _Mysb _Stringbuffer;
};

 template <class _Elem, class _Traits, class _Alloc>
void swap(basic_stringstream<_Elem, _Traits, _Alloc>& _Left,
    basic_stringstream<_Elem, _Traits, _Alloc>& _Right) noexcept  {
    _Left.swap(_Right);
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 917 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
#line 918 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\sstream"
#pragma external_header(pop)
#line 287 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"










































#line 44 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"





#line 50 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"















#line 66 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"

#line 68 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"






























#line 99 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"

#line 101 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port-arch.h"
#line 291 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\custom\\gtest-port.h"




































#line 38 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\custom\\gtest-port.h"
#line 292 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 301 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 305 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"























#line 329 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"















#line 345 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











#line 357 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 358 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"












#line 378 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 387 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 394 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











#line 406 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 410 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 418 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 419 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"







#pragma once






#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {





    
        
        struct _diskfree_t
        {
            unsigned total_clusters;
            unsigned avail_clusters;
            unsigned sectors_per_cluster;
            unsigned bytes_per_sector;
        };
    #line 35 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"

    

         
         
        __declspec(dllimport) unsigned __cdecl _getdiskfree(
               unsigned            _Drive,
              struct _diskfree_t* _DiskFree
            );

          __declspec(dllimport) int __cdecl _chdrive(  int _Drive);

          __declspec(dllimport) int __cdecl _getdrive(void);

          __declspec(dllimport) unsigned long __cdecl _getdrives(void);

    #line 52 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"
#line 53 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"








 
   
__declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd(
      char* _DstBuf,
                                  int   _SizeInBytes
    );

 
   
__declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd(
                                  int   _Drive,
      char* _DstBuf,
                                  int   _SizeInBytes
    );






  __declspec(dllimport) int __cdecl _chdir(  char const* _Path);

  __declspec(dllimport) int __cdecl _mkdir(  char const* _Path);

  __declspec(dllimport) int __cdecl _rmdir(  char const* _Path);





    

        
        

         
            __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getcwd" ". See online help for details."))
        __declspec(dllimport) char* __cdecl getcwd(
              char* _DstBuf,
                                          int   _SizeInBytes
            );

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chdir" ". See online help for details."))
        __declspec(dllimport) int __cdecl chdir(
              char const* _Path
            );

        

    #line 113 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_mkdir" ". See online help for details."))
    __declspec(dllimport) int __cdecl mkdir(
          char const* _Path
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmdir" ". See online help for details."))
    __declspec(dllimport) int __cdecl rmdir(
          char const* _Path
        );

#line 125 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#line 132 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\direct.h"
#pragma external_header(pop)
#line 426 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\io.h"







#pragma once



#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"








#pragma once




#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {












    
    
#line 34 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"

struct _finddata32_t
{
    unsigned    attrib;
    __time32_t  time_create;    
    __time32_t  time_access;    
    __time32_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct _finddata32i64_t
{
    unsigned    attrib;
    __time32_t  time_create;    
    __time32_t  time_access;    
    __time32_t  time_write;
    __int64     size;
    char        name[260];
};

struct _finddata64i32_t
{
    unsigned    attrib;
    __time64_t  time_create;    
    __time64_t  time_access;    
    __time64_t  time_write;
    _fsize_t    size;
    char        name[260];
};

struct __finddata64_t
{
    unsigned    attrib;
    __time64_t  time_create;    
    __time64_t  time_access;    
    __time64_t  time_write;
    __int64     size;
    char        name[260];
};



























    
    
    
    
#line 106 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"



     
    __declspec(dllimport) int __cdecl _access(
          char const* _FileName,
            int         _AccessMode
        );

    
    __declspec(dllimport) errno_t __cdecl _access_s(
          char const* _FileName,
            int         _AccessMode
        );

     
    __declspec(dllimport) int __cdecl _chmod(
          char const* _FileName,
            int         _Mode
        );

     
    __declspec(dllimport) int __cdecl _chsize(
          int  _FileHandle,
          long _Size
        );

    
    __declspec(dllimport) errno_t __cdecl _chsize_s(
          int     _FileHandle,
          __int64 _Size
        );

    
    __declspec(dllimport) int __cdecl _close(
          int _FileHandle
        );

    
    __declspec(dllimport) int __cdecl _commit(
          int _FileHandle
        );

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) int __cdecl _creat(
          char const* _FileName,
            int         _PermissionMode
        );

     
    __declspec(dllimport) int __cdecl _dup(
          int _FileHandle
        );

     
    __declspec(dllimport) int __cdecl _dup2(
          int _FileHandleSrc,
          int _FileHandleDst
        );

     
    __declspec(dllimport) int __cdecl _eof(
          int _FileHandle
        );

     
    __declspec(dllimport) long __cdecl _filelength(
          int _FileHandle
        );

     
     
    __declspec(dllimport) intptr_t __cdecl _findfirst32(
          char const*           _FileName,
           struct _finddata32_t* _FindData
        );

     
     
    __declspec(dllimport) int __cdecl _findnext32(
           intptr_t              _FindHandle,
          struct _finddata32_t* _FindData
        );

    
    __declspec(dllimport) int __cdecl _findclose(
          intptr_t _FindHandle
        );

    __declspec(dllimport) intptr_t __cdecl _get_osfhandle(
              int _FileHandle
            );

     
    __declspec(dllimport) int __cdecl _isatty(
          int _FileHandle
        );

    __declspec(dllimport) int __cdecl _locking(
              int  _FileHandle,
              int  _LockMode,
              long _NumOfBytes
            );

    
    __declspec(dllimport) long __cdecl _lseek(
          int  _FileHandle,
          long _Offset,
          int  _Origin
        );

     
    
    __declspec(dllimport) errno_t __cdecl _mktemp_s(
          char*  _TemplateName,
                              size_t _Size
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _mktemp_s(  char (&_TemplateName)[_Size]) throw() { return _mktemp_s(_TemplateName, _Size); } }
#line 228 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"

     
      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_mktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char * __cdecl _mktemp( char *_TemplateName);
#line 234 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"

    __declspec(dllimport) int __cdecl _open_osfhandle(
          intptr_t _OSFileHandle,
          int      _Flags
        );

    
         
         
        __declspec(dllimport) int __cdecl _pipe(
                 int*         _PtHandles,
                            unsigned int _PipeSize,
                            int          _TextMode
            );
    #line 249 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"

     
     
    __declspec(dllimport) int __cdecl _read(
                                       int          _FileHandle,
          void*        _DstBuf,
                                       unsigned int _MaxCharCount
        );

    __declspec(dllimport) int __cdecl remove(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl rename(
          char const* _OldFilename,
          char const* _NewFilename
        );

    __declspec(dllimport) int __cdecl _unlink(
          char const* _FileName
        );

     
    __declspec(dllimport) int __cdecl _setmode(
          int _FileHandle,
          int _Mode
        );

     
    __declspec(dllimport) long __cdecl _tell(
          int _FileHandle
        );

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_umask_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) int __cdecl _umask(
          int _Mode
        );

    
    __declspec(dllimport) errno_t __cdecl _umask_s(
           int  _NewMode,
          int* _OldMode
        );

    __declspec(dllimport) int __cdecl _write(
                                     int          _FileHandle,
          void const*  _Buf,
                                     unsigned int _MaxCharCount
        );

     
    __declspec(dllimport) __int64 __cdecl _filelengthi64(
          int _FileHandle
        );

     
     
    __declspec(dllimport) intptr_t __cdecl _findfirst32i64(
          char const*              _FileName,
           struct _finddata32i64_t* _FindData
        );

     
     
    __declspec(dllimport) intptr_t __cdecl _findfirst64i32(
          char const*              _FileName,
           struct _finddata64i32_t* _FindData
        );

     
     
    __declspec(dllimport) intptr_t __cdecl _findfirst64(
          char const*            _FileName,
           struct __finddata64_t* _FindData
        );

     
     
    __declspec(dllimport) int __cdecl _findnext32i64(
           intptr_t                 _FindHandle,
          struct _finddata32i64_t* _FindData
        );

     
     
    __declspec(dllimport) int __cdecl _findnext64i32(
           intptr_t                 _FindHandle,
          struct _finddata64i32_t* _FindData
        );

     
     
    __declspec(dllimport) int __cdecl _findnext64(
           intptr_t               _FindHandle,
          struct __finddata64_t* _FindData
        );

    
    __declspec(dllimport) __int64 __cdecl _lseeki64(
          int     _FileHandle,
          __int64 _Offset,
          int     _Origin
        );

     
    __declspec(dllimport) __int64 __cdecl _telli64(
          int _FileHandle
        );

    
    __declspec(dllimport) errno_t __cdecl _sopen_s(
           int*        _FileHandle,
          char const* _FileName,
            int         _OpenFlag,
            int         _ShareFlag,
            int         _PermissionMode
        );

     
    __declspec(dllimport) errno_t __cdecl _sopen_s_nolock(
           int*        _FileHandle,
          char const* _FileName,
            int         _OpenFlag,
            int         _ShareFlag,
            int         _PermissionMode
        );

    __declspec(dllimport) errno_t __cdecl _sopen_dispatch(
          char const* _FileName,
            int         _OFlag,
            int         _ShFlag,
            int         _PMode,
           int*        _PFileHandle,
            int         _BSecure
        );



    

        
        extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl _open(
              char const* const _FileName,
                int         const _OFlag,
                int         const _PMode = 0
            )
        {
            int _FileHandle;
            
            errno_t const _Result = _sopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
            return _Result ? -1 : _FileHandle;
        }

        extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl _sopen(
              char const* const _FileName,
                int         const _OFlag,
                int         const _ShFlag,
                int         const _PMode = 0
            )
        {
            int _FileHandle;
            
            errno_t const _Result = _sopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
            return _Result ? -1 : _FileHandle;
        }

    














#line 434 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"



    
        
        #pragma warning(push)
        #pragma warning(disable: 4141)

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_access" ". See online help for details."))
        __declspec(dllimport) int __cdecl access(
              char const* _FileName,
                int         _AccessMode
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chmod" ". See online help for details."))
        __declspec(dllimport) int __cdecl chmod(
              char const* _FileName,
                int         _AccessMode
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_chsize" ". See online help for details."))
        __declspec(dllimport) int __cdecl chsize(
              int  _FileHandle,
              long _Size
            );

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_close" ". See online help for details."))
        __declspec(dllimport) int __cdecl close(
              int _FileHandle
        );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_creat" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) int __cdecl creat(
              char const* _FileName,
                int         _PermissionMode
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_dup" ". See online help for details."))
        __declspec(dllimport) int __cdecl dup(
              int _FileHandle
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_dup2" ". See online help for details."))
        __declspec(dllimport) int __cdecl dup2(
              int _FileHandleSrc,
              int _FileHandleDst
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_eof" ". See online help for details."))
        __declspec(dllimport) int __cdecl eof(
              int _FileHandle
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_filelength" ". See online help for details."))
        __declspec(dllimport) long __cdecl filelength(
              int _FileHandle
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_isatty" ". See online help for details."))
        __declspec(dllimport) int __cdecl isatty(
              int _FileHandle
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_locking" ". See online help for details."))
        __declspec(dllimport) int __cdecl locking(
              int  _FileHandle,
              int  _LockMode,
              long _NumOfBytes
            );

         __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lseek" ". See online help for details."))
        __declspec(dllimport) long __cdecl lseek(
              int  _FileHandle,
              long _Offset,
              int  _Origin
            );

         
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_mktemp" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_mktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) char * __cdecl mktemp(
              char* _TemplateName
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_open" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) int __cdecl open(
              char const* _FileName,
                int         _OpenFlag,
            ...);

         
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_read" ". See online help for details."))
        __declspec(dllimport) int __cdecl read(
                                           int          _FileHandle,
              void*        _DstBuf,
                                           unsigned int _MaxCharCount
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_setmode" ". See online help for details."))
        __declspec(dllimport) int __cdecl setmode(
              int _FileHandle,
              int _Mode
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_sopen" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) int __cdecl sopen(
              char const* _FileName,
              int         _OpenFlag,
              int         _ShareFlag,
            ...);

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tell" ". See online help for details."))
        __declspec(dllimport) long __cdecl tell(
              int _FileHandle
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_umask" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_umask_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        __declspec(dllimport) int __cdecl umask(
              int _Mode
            );

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
        __declspec(dllimport) int __cdecl unlink(
              char const* _FileName
            );

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_write" ". See online help for details."))
        __declspec(dllimport) int __cdecl write(
                                         int          _FileHandle,
              void const*  _Buf,
                                         unsigned int _MaxCharCount
            );

        #pragma warning(pop)
    #line 568 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"
#line 569 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\corecrt_io.h"

} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 13 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\io.h"
#line 14 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\io.h"
#pragma external_header(pop)
#line 427 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 428 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 434 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



typedef struct _RTL_CRITICAL_SECTION GTEST_CRITICAL_SECTION;
#line 439 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 446 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




#line 451 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 458 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 460 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 461 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




#line 466 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"









#line 476 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











#line 488 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











































#line 532 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 533 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 542 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 546 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"













#line 560 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 567 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"












#line 580 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"









































#line 622 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 624 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 630 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











#line 642 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 651 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 659 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 660 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 669 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"










#line 680 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 681 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 689 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














#line 706 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 713 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 719 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 720 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 721 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 728 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




















































#line 781 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"























#line 805 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 807 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 809 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 819 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 821 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 822 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 835 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 845 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 853 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








#line 862 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"















#line 878 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














#line 893 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 897 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"


#line 900 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 906 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














#line 921 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 923 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




















#line 944 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 946 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"


























#line 973 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 980 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"









#line 990 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 992 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"


#line 995 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 997 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 1001 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 1005 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






#line 1012 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 1018 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 1020 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 1021 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"










#line 1032 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 1034 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"









#line 1044 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 1046 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"









#line 1056 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 1058 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

namespace testing {

class Message;





using ::std::get;
using ::std::make_tuple;
using ::std::tuple;
using ::std::tuple_size;
using ::std::tuple_element;
#line 1073 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

namespace internal {




class Secret;


























#line 1107 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"















































template <typename T1, typename T2>
struct StaticAssertTypeEqHelper;

template <typename T>
struct StaticAssertTypeEqHelper<T, T> {
  enum { value = true };
};


template <typename T, typename U>
struct IsSame {
  enum { value = false };
};
template <typename T>
struct IsSame<T, T> {
  enum { value = true };
};






#line 1178 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
typedef ::std::string string;
#line 1180 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 1184 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
typedef ::std::wstring wstring;
#line 1186 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



 bool IsTrue(bool condition);





template <typename T>
class scoped_ptr {
 public:
  typedef T element_type;

  explicit scoped_ptr(T* p = 0) : ptr_(p) {}
  ~scoped_ptr() { reset(); }

  T& operator*() const { return *ptr_; }
  T* operator->() const { return ptr_; }
  T* get() const { return ptr_; }

  T* release() {
    T* const ptr = ptr_;
    ptr_ = 0;
    return ptr;
  }

  void reset(T* p = 0) {
    if (p != ptr_) {
      if (IsTrue(sizeof(T) > 0)) {  
        delete ptr_;
      }
      ptr_ = p;
    }
  }

  friend void swap(scoped_ptr& a, scoped_ptr& b) {
    using std::swap;
    swap(a.ptr_, b.ptr_);
  }

 private:
  T* ptr_;

  scoped_ptr(scoped_ptr const &) = delete; void operator=(scoped_ptr const &) = delete;
};





#line 1238 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



class  RE {
 public:
  
  
  RE(const RE& other) { Init(other.pattern()); }

  
  RE(const ::std::string& regex) { Init(regex.c_str()); }  





#line 1255 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

  RE(const char* regex) { Init(regex); }  
  ~RE();

  
  const char* pattern() const { return pattern_; }

  
  
  
  
  
  
  
  static bool FullMatch(const ::std::string& str, const RE& re) {
    return FullMatch(str.c_str(), re);
  }
  static bool PartialMatch(const ::std::string& str, const RE& re) {
    return PartialMatch(str.c_str(), re);
  }










#line 1286 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

  static bool FullMatch(const char* str, const RE& re);
  static bool PartialMatch(const char* str, const RE& re);

 private:
  void Init(const char* regex);

  
  
  
  const char* pattern_;
  bool is_valid_;






#line 1305 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

  const char* full_pattern_;  

#line 1309 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

  void operator=(RE const &) = delete;
};

#line 1314 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



 ::std::string FormatFileLocation(const char* file, int line);




 ::std::string FormatCompilerIndependentFileLocation(const char* file,
                                                               int line);







enum GTestLogSeverity {
  GTEST_INFO,
  GTEST_WARNING,
  GTEST_ERROR,
  GTEST_FATAL
};




class  GTestLog {
 public:
  GTestLog(GTestLogSeverity severity, const char* file, int line);

  
  ~GTestLog();

  ::std::ostream& GetStream() { return ::std::cerr; }

 private:
  const GTestLogSeverity severity_;

  GTestLog(GTestLog const &) = delete; void operator=(GTestLog const &) = delete;
};







inline void LogToStderr() {}
inline void FlushInfoLog() { fflush(0); }

#line 1366 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"






















#line 1389 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














template <typename T>
struct AddReference { typedef T& type; };  
template <typename T>
struct AddReference<T&> { typedef T& type; };  

















template <typename T>
struct ConstRef { typedef const T& type; };
template <typename T>
struct ConstRef<T&> { typedef T& type; };






using std::forward;
using std::move;

template <typename T>
struct RvalueRef {
  typedef T&& type;
};












#line 1454 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





















template<typename To>
inline To ImplicitCast_(To x) { return x; }






















template<typename To, typename From>  
inline To DownCast_(From* f) {  
  
  
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4127))
  if (false) {
  __pragma(warning(pop))
    const To to = 0;
    ::testing::internal::ImplicitCast_<From*>(to);
  }


  
  switch (0) case 0: default: if (::testing::internal::IsTrue(f == 0 || dynamic_cast<To>(f) != 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h", 1514).GetStream() << "Condition " "f == NULL || dynamic_cast<To>(f) != NULL" " failed. ";
#line 1516 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
  return static_cast<To>(f);
}






template <class Derived, class Base>
Derived* CheckedDowncastToActualType(Base* base) {

  switch (0) case 0: default: if (::testing::internal::IsTrue(typeid(*base) == typeid(Derived))) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h", 1527).GetStream() << "Condition " "typeid(*base) == typeid(Derived)" " failed. ";
#line 1529 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 1533 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
  return dynamic_cast<Derived*>(base);  


#line 1537 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
}









 void CaptureStdout();
 std::string GetCapturedStdout();
 void CaptureStderr();
 std::string GetCapturedStderr();

#line 1553 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

 size_t GetFileSize(FILE* file);


 std::string ReadEntireFile(FILE* file);


 std::vector<std::string> GetArgvs();



std::vector<std::string> GetInjectableArgvs();

void SetInjectableArgvs(const std::vector<std::string>* new_argvs);
void SetInjectableArgvs(const std::vector<std::string>& new_argvs);


#line 1571 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
void ClearInjectableArgvs();

#line 1574 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














#line 1589 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 1595 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"











































#line 1639 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

 void SleepMilliseconds(int n);



class  AutoHandle {
 public:
  
  
  
  
  
  typedef void* Handle;
  AutoHandle();
  explicit AutoHandle(Handle handle);

  ~AutoHandle();

  Handle Get() const;
  void Reset();
  void Reset(Handle handle);

 private:
  
  bool IsCloseable() const;

  Handle handle_;

  AutoHandle(AutoHandle const &) = delete; void operator=(AutoHandle const &) = delete;
};







class  Notification {
 public:
  Notification();
  void Notify();
  void WaitForNotification();

 private:
  AutoHandle event_;

  Notification(Notification const &) = delete; void operator=(Notification const &) = delete;
};
#line 1688 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"


















































































#line 1771 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
         





#line 1778 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"















class  Mutex {
 public:
  enum MutexType { kStatic = 0, kDynamic = 1 };
  
  
  
  enum StaticConstructorSelector { kStaticMutex = 0 };

  
  
  
  explicit Mutex(StaticConstructorSelector ) {}

  Mutex();
  ~Mutex();

  void Lock();

  void Unlock();

  
  
  void AssertHeld();

 private:
  
  void ThreadSafeLazyInit();

  
  
  unsigned int owner_thread_id_;

  
  
  MutexType type_;
  long critical_section_init_phase_;  
  GTEST_CRITICAL_SECTION* critical_section_;

  Mutex(Mutex const &) = delete; void operator=(Mutex const &) = delete;
};












class GTestMutexLock {
 public:
  explicit GTestMutexLock(Mutex* mutex)
      : mutex_(mutex) { mutex_->Lock(); }

  ~GTestMutexLock() { mutex_->Unlock(); }

 private:
  Mutex* const mutex_;

  GTestMutexLock(GTestMutexLock const &) = delete; void operator=(GTestMutexLock const &) = delete;
};

typedef GTestMutexLock MutexLock;



class ThreadLocalValueHolderBase {
 public:
  virtual ~ThreadLocalValueHolderBase() {}
};



class ThreadLocalBase {
 public:
  
  
  
  
  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const = 0;

 protected:
  ThreadLocalBase() {}
  virtual ~ThreadLocalBase() {}

 private:
  ThreadLocalBase(ThreadLocalBase const &) = delete; void operator=(ThreadLocalBase const &) = delete;
};




class  ThreadLocalRegistry {
 public:
  
  
  static ThreadLocalValueHolderBase* GetValueOnCurrentThread(
      const ThreadLocalBase* thread_local_instance);

  
  static void OnThreadLocalDestroyed(
      const ThreadLocalBase* thread_local_instance);
};

class  ThreadWithParamBase {
 public:
  void Join();

 protected:
  class Runnable {
   public:
    virtual ~Runnable() {}
    virtual void Run() = 0;
  };

  ThreadWithParamBase(Runnable *runnable, Notification* thread_can_start);
  virtual ~ThreadWithParamBase();

 private:
  AutoHandle thread_;
};


template <typename T>
class ThreadWithParam : public ThreadWithParamBase {
 public:
  typedef void UserThreadFunc(T);

  ThreadWithParam(UserThreadFunc* func, T param, Notification* thread_can_start)
      : ThreadWithParamBase(new RunnableImpl(func, param), thread_can_start) {
  }
  virtual ~ThreadWithParam() {}

 private:
  class RunnableImpl : public Runnable {
   public:
    RunnableImpl(UserThreadFunc* func, T param)
        : func_(func),
          param_(param) {
    }
    virtual ~RunnableImpl() {}
    virtual void Run() {
      func_(param_);
    }

   private:
    UserThreadFunc* const func_;
    const T param_;

    RunnableImpl(RunnableImpl const &) = delete; void operator=(RunnableImpl const &) = delete;
  };

  ThreadWithParam(ThreadWithParam const &) = delete; void operator=(ThreadWithParam const &) = delete;
};




























template <typename T>
class ThreadLocal : public ThreadLocalBase {
 public:
  ThreadLocal() : default_factory_(new DefaultValueHolderFactory()) {}
  explicit ThreadLocal(const T& value)
      : default_factory_(new InstanceValueHolderFactory(value)) {}

  ~ThreadLocal() { ThreadLocalRegistry::OnThreadLocalDestroyed(this); }

  T* pointer() { return GetOrCreateValue(); }
  const T* pointer() const { return GetOrCreateValue(); }
  const T& get() const { return *pointer(); }
  void set(const T& value) { *pointer() = value; }

 private:
  
  
  class ValueHolder : public ThreadLocalValueHolderBase {
   public:
    ValueHolder() : value_() {}
    explicit ValueHolder(const T& value) : value_(value) {}

    T* pointer() { return &value_; }

   private:
    T value_;
    ValueHolder(ValueHolder const &) = delete; void operator=(ValueHolder const &) = delete;
  };


  T* GetOrCreateValue() const {
    return static_cast<ValueHolder*>(
        ThreadLocalRegistry::GetValueOnCurrentThread(this))->pointer();
  }

  virtual ThreadLocalValueHolderBase* NewValueForCurrentThread() const {
    return default_factory_->MakeNewHolder();
  }

  class ValueHolderFactory {
   public:
    ValueHolderFactory() {}
    virtual ~ValueHolderFactory() {}
    virtual ValueHolder* MakeNewHolder() const = 0;

   private:
    ValueHolderFactory(ValueHolderFactory const &) = delete; void operator=(ValueHolderFactory const &) = delete;
  };

  class DefaultValueHolderFactory : public ValueHolderFactory {
   public:
    DefaultValueHolderFactory() {}
    virtual ValueHolder* MakeNewHolder() const { return new ValueHolder(); }

   private:
    DefaultValueHolderFactory(DefaultValueHolderFactory const &) = delete; void operator=(DefaultValueHolderFactory const &) = delete;
  };

  class InstanceValueHolderFactory : public ValueHolderFactory {
   public:
    explicit InstanceValueHolderFactory(const T& value) : value_(value) {}
    virtual ValueHolder* MakeNewHolder() const {
      return new ValueHolder(value_);
    }

   private:
    const T value_;  

    InstanceValueHolderFactory(InstanceValueHolderFactory const &) = delete; void operator=(InstanceValueHolderFactory const &) = delete;
  };

  scoped_ptr<ValueHolderFactory> default_factory_;

  ThreadLocal(ThreadLocal const &) = delete; void operator=(ThreadLocal const &) = delete;
};




















































































































































































































#line 2266 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"














































#line 2313 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



 size_t GetThreadCount();











#line 2330 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

#line 2332 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







#line 2340 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

template <bool bool_value>
struct bool_constant {
  typedef bool_constant<bool_value> type;
  static const bool value = bool_value;
};
template <bool bool_value> const bool bool_constant<bool_value>::value;

typedef bool_constant<false> false_type;
typedef bool_constant<true> true_type;

template <typename T, typename U>
struct is_same : public false_type {};

template <typename T>
struct is_same<T, T> : public true_type {};


template <typename T>
struct is_pointer : public false_type {};

template <typename T>
struct is_pointer<T*> : public true_type {};

template <typename Iterator>
struct IteratorTraits {
  typedef typename Iterator::value_type value_type;
};


template <typename T>
struct IteratorTraits<T*> {
  typedef T value_type;
};

template <typename T>
struct IteratorTraits<const T*> {
  typedef T value_type;
};





typedef __int64 BiggestInt;




#line 2390 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








inline bool IsAlpha(char ch) {
  return isalpha(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsAlNum(char ch) {
  return isalnum(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsDigit(char ch) {
  return isdigit(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsLower(char ch) {
  return islower(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsSpace(char ch) {
  return isspace(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsUpper(char ch) {
  return isupper(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsXDigit(char ch) {
  return isxdigit(static_cast<unsigned char>(ch)) != 0;
}
inline bool IsXDigit(wchar_t ch) {
  const unsigned char low_byte = static_cast<unsigned char>(ch);
  return ch == low_byte && isxdigit(low_byte) != 0;
}

inline char ToLower(char ch) {
  return static_cast<char>(tolower(static_cast<unsigned char>(ch)));
}
inline char ToUpper(char ch) {
  return static_cast<char>(toupper(static_cast<unsigned char>(ch)));
}

inline std::string StripTrailingSpaces(std::string str) {
  std::string::iterator it = str.end();
  while (it != str.begin() && IsSpace(*--it))
    it = str.erase(it);
  return str;
}







namespace posix {





typedef struct _stat64i32 StatStruct;










#line 2462 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline int IsATTY(int fd) { return _isatty(fd); }
#line 2464 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline int StrCaseCmp(const char* s1, const char* s2) {
  return _stricmp(s1, s2);
}
inline char* StrDup(const char* src) { return _strdup(src); }
#line 2469 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 2475 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline int FileNo(FILE* file) { return _fileno(file); }
inline int Stat(const char* path, StatStruct* buf) { return _stat64i32(path, buf); }
inline int RmDir(const char* dir) { return _rmdir(dir); }
inline bool IsDir(const StatStruct& st) {
  return (0x4000 & st.st_mode) != 0;
}
#line 2482 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"















#line 2498 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



__pragma(warning(push)) __pragma(warning(disable: 4996))

inline const char* StrNCpy(char* dest, const char* src, size_t n) {
  return strncpy(dest, src, n);
}






inline int ChDir(const char* dir) { return chdir(dir); }
#line 2514 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline FILE* FOpen(const char* path, const char* mode) {
  return fopen(path, mode);
}

inline FILE *FReopen(const char* path, const char* mode, FILE* stream) {
  return freopen(path, mode, stream);
}
inline FILE* FDOpen(int fd, const char* mode) { return fdopen(fd, mode); }
#line 2523 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline int FClose(FILE* fp) { return fclose(fp); }

inline int Read(int fd, void* buf, unsigned int count) {
  return static_cast<int>(read(fd, buf, count));
}
inline int Write(int fd, const void* buf, unsigned int count) {
  return static_cast<int>(write(fd, buf, count));
}
inline int Close(int fd) { return close(fd); }
inline const char* StrError(int errnum) { return strerror(errnum); }
#line 2534 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline const char* GetEnv(const char* name) {




#line 2540 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"




#line 2545 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
  return getenv(name);
#line 2547 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
}

__pragma(warning(pop))






#line 2557 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
inline void Abort() { abort(); }
#line 2559 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"

}  
















#line 2578 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"








const BiggestInt kMaxBiggestInt =
    ~(static_cast<BiggestInt>(1) << (8*sizeof(BiggestInt) - 1));



















template <size_t size>
class TypeWithSize {
 public:
  
  
  typedef void UInt;
};


template <>
class TypeWithSize<4> {
 public:
  
  
  
  
  typedef int Int;
  typedef unsigned int UInt;
};


template <>
class TypeWithSize<8> {
 public:

  typedef __int64 Int;
  typedef unsigned __int64 UInt;



#line 2638 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
};


typedef TypeWithSize<4>::Int Int32;
typedef TypeWithSize<4>::UInt UInt32;
typedef TypeWithSize<8>::Int Int64;
typedef TypeWithSize<8>::UInt UInt64;
typedef TypeWithSize<8>::Int TimeInMillis;  






#line 2653 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



#line 2657 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"



















#line 2677 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"





#line 2683 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"







bool ParseInt32(const Message& src_text, const char* str, Int32* value);



bool BoolFromGTestEnv(const char* flag, bool default_val);
 Int32 Int32FromGTestEnv(const char* flag, Int32 default_val);
std::string OutputFlagAlsoCheckEnvVar();
const char* StringFromGTestEnv(const char* flag, const char* default_val);

}  
}  

#line 2703 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-port.h"
#line 41 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"






#line 48 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"



#line 52 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"




#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iomanip"














#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Elem>
struct _Fillobj { 
    _Fillobj(_Elem _Ch) : _Fill(_Ch) {}

    template <class _Elem2, class _Traits>
    friend basic_ostream<_Elem2, _Traits>& operator<<(basic_ostream<_Elem2, _Traits>& _Ostr, const _Fillobj& _Manip) {
        
        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for setfill");

        _Ostr.fill(_Manip._Fill);
        return _Ostr;
    }

    _Elem _Fill; 
};

 template <class _Elem>
[[nodiscard]] _Fillobj<_Elem> setfill(_Elem _Ch) {
    return _Fillobj<_Elem>(_Ch);
}

template <class _Money>
struct _Monobj { 
    _Monobj(_Money& _Val_arg, bool _Intl_arg) : _Val(_Val_arg), _Intl(_Intl_arg) {}

    template <class _Elem, class _Traits>
    friend basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Monobj& _Manip) {
        
        using _Myis   = basic_istream<_Elem, _Traits>;
        using _Iter   = istreambuf_iterator<_Elem, _Traits>;
        using _Mymget = money_get<_Elem, _Iter>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_Istr);

        if (_Ok) { 
            const _Mymget& _Mget_fac = ::std:: use_facet<_Mymget>(_Istr.getloc());
            try {
            _Mget_fac.get(_Iter(_Istr.rdbuf()), _Iter(nullptr), _Manip._Intl, _Istr, _State, _Manip._Val);
            } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    friend basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Monobj& _Manip) {
        
        using _Myos   = basic_ostream<_Elem, _Traits>;
        using _Iter   = ostreambuf_iterator<_Elem, _Traits>;
        using _Mymput = money_put<_Elem, _Iter>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_Ostr);

        if (_Ok) { 
            const _Mymput& _Mput_fac = ::std:: use_facet<_Mymput>(_Ostr.getloc());
            try {
            if (_Mput_fac.put(_Iter(_Ostr.rdbuf()), _Manip._Intl, _Ostr, _Ostr.fill(), _Manip._Val).failed()) {
                _State |= ios_base::badbit;
            }
            } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    _Money& _Val; 
    bool _Intl; 
};

 template <class _Money>
[[nodiscard]] _Monobj<_Money> get_money(_Money& _Val_arg, bool _Intl_arg = false) {
    return _Monobj<_Money>(_Val_arg, _Intl_arg);
}

 template <class _Money>
[[nodiscard]] _Monobj<const _Money> put_money(const _Money& _Val_arg, bool _Intl_arg = false) {
    return _Monobj<const _Money>(_Val_arg, _Intl_arg);
}

template <class _Elem, class _Ptr>
struct _Timeobj { 
    _Timeobj(_Ptr _Tptr_arg, const _Elem* _Fmt_arg) : _Tptr(_Tptr_arg), _Fmtfirst(_Fmt_arg) {
        for (_Fmtlast = _Fmtfirst; *_Fmtlast != 0; ++_Fmtlast) { 
        }
    }

    template <class _Elem2, class _Traits>
    friend basic_istream<_Elem2, _Traits>& operator>>(basic_istream<_Elem2, _Traits>& _Istr, const _Timeobj& _Manip) {
        
        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for get_time");

        using _Myis   = basic_istream<_Elem, _Traits>;
        using _Iter   = istreambuf_iterator<_Elem, _Traits>;
        using _Mytget = time_get<_Elem, _Iter>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_Istr);

        if (_Ok) { 
            const _Mytget& _Tget_fac = ::std:: use_facet<_Mytget>(_Istr.getloc());
            try {
            _Tget_fac.get(
                _Iter(_Istr.rdbuf()), _Iter(nullptr), _Istr, _State, _Manip._Tptr, _Manip._Fmtfirst, _Manip._Fmtlast);
            } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem2, class _Traits>
    friend basic_ostream<_Elem2, _Traits>& operator<<(basic_ostream<_Elem2, _Traits>& _Ostr, const _Timeobj& _Manip) {
        
        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for put_time");

        using _Myos   = basic_ostream<_Elem, _Traits>;
        using _Iter   = ostreambuf_iterator<_Elem, _Traits>;
        using _Mytput = time_put<_Elem, _Iter>;

        const typename _Myos::sentry _Ok(_Ostr);

        if (_Ok) { 
            const _Mytput& _Tput_fac = ::std:: use_facet<_Mytput>(_Ostr.getloc());
            try {
            if (_Tput_fac
                    .put(_Iter(_Ostr.rdbuf()), _Ostr, _Ostr.fill(), _Manip._Tptr, _Manip._Fmtfirst, _Manip._Fmtlast)
                    .failed()) {
                _Ostr.setstate(ios_base::badbit);
            }
            } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
        }

        return _Ostr;
    }

    _Ptr _Tptr; 
    const _Elem* _Fmtfirst; 
    const _Elem* _Fmtlast; 
};

 template <class _Elem>
[[nodiscard]] _Timeobj<_Elem, tm*> get_time(tm* _Tptr_arg, const _Elem* _Fmt_arg) {
    return _Timeobj<_Elem, tm*>(_Tptr_arg, _Fmt_arg);
}

 template <class _Elem>
[[nodiscard]] _Timeobj<_Elem, const tm*> put_time(const tm* _Tptr_arg, const _Elem* _Fmt_arg) {
    return _Timeobj<_Elem, const tm*>(_Tptr_arg, _Fmt_arg);
}

template <class _Elem, class _Traits, class _Sizet>
struct _Quote_out { 
    _Quote_out(const _Elem* _Ptr_obj, _Sizet _Size_obj, _Elem _Delim_obj, _Elem _Escape_obj)
        : _Ptr(_Ptr_obj), _Size(_Size_obj), _Delim(_Delim_obj), _Escape(_Escape_obj) {}

    _Quote_out(const _Quote_out&) = default;

    template <class _OsTraits, class _QuTraits = _Traits>
    friend basic_ostream<_Elem, _OsTraits>& operator<<(
        basic_ostream<_Elem, _OsTraits>& _Ostr, const _Quote_out& _Manip) {
        
        static_assert(
            is_void_v<_QuTraits> || is_same_v<_QuTraits, _OsTraits>, "quoted() traits must match basic_ostream traits");

        using _Myos = basic_ostream<_Elem, _OsTraits>;

        const _Elem* const _Last = _Manip._Ptr + _Manip._Size;

        _Sizet _Size = _Manip._Size + 2; 
        for (const _Elem* _Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr) {
            if (_OsTraits::eq(*_Ptr, _Manip._Delim) || _OsTraits::eq(*_Ptr, _Manip._Escape)) {
                ++_Size; 
            }
        }

        ios_base::iostate _State = ios_base::goodbit;

        _Sizet _Pad;
        if (_Ostr.width() <= 0 || static_cast<_Sizet>(_Ostr.width()) <= _Size) {
            _Pad = 0;
        } else {
            _Pad = static_cast<_Sizet>(_Ostr.width()) - _Size;
        }

        const typename _Myos::sentry _Ok(_Ostr);

        if (!_Ok) {
            _State |= ios_base::badbit;
        } else { 
            try {
            if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {
                for (; 0 < _Pad; --_Pad) { 
                    if (_OsTraits::eq_int_type(_OsTraits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit; 
                        break;
                    }
                }
            }

            if (_State == ios_base::goodbit
                && _OsTraits::eq_int_type(_OsTraits::eof(),
                    _Ostr.rdbuf()->sputc(_Manip._Delim))) { 
                _State |= ios_base::badbit;
            }

            for (const _Elem* _Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr) { 
                if ((_OsTraits::eq(*_Ptr, _Manip._Delim) || _OsTraits::eq(*_Ptr, _Manip._Escape))
                    && _State == ios_base::goodbit
                    && _OsTraits::eq_int_type(_OsTraits::eof(),
                        _Ostr.rdbuf()->sputc(_Manip._Escape))) { 
                    _State |= ios_base::badbit; 
                    break;
                }

                if (_State == ios_base::goodbit
                    && _OsTraits::eq_int_type(_OsTraits::eof(),
                        _Ostr.rdbuf()->sputc(*_Ptr))) { 
                    _State |= ios_base::badbit; 
                    break;
                }
            }

            if (_State == ios_base::goodbit
                && _OsTraits::eq_int_type(_OsTraits::eof(),
                    _Ostr.rdbuf()->sputc(_Manip._Delim))) { 
                _State |= ios_base::badbit;
            }

            if (_State == ios_base::goodbit) {
                for (; 0 < _Pad; --_Pad) { 
                    if (_OsTraits::eq_int_type(_OsTraits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
                        _State |= ios_base::badbit; 
                        break;
                    }
                }
            }

            _Ostr.width(0);
            } catch (...) { (_Ostr) .setstate(ios_base::badbit, true); }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    const _Elem* _Ptr; 
    _Sizet _Size; 
    _Elem _Delim; 
    _Elem _Escape; 

    _Quote_out& operator=(const _Quote_out&) = delete;
};

template <class _Elem, class _Traits, class _Alloc>
struct _Quote_in { 
    using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

    _Quote_in(_Mystr& _Str_obj, _Elem _Delim_obj, _Elem _Escape_obj)
        : _Str(_Str_obj), _Delim(_Delim_obj), _Escape(_Escape_obj) {}

    friend basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Quote_in& _Manip) {
        
        using _Out_type = _Quote_out<_Elem, _Traits, typename _Mystr::size_type>;

        return _Ostr << _Out_type{_Manip._Str.c_str(), _Manip._Str.size(), _Manip._Delim, _Manip._Escape};
    }

    friend basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Quote_in& _Manip) {
        
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr);

        if (_Ok) { 
            try {
            const auto _Buf   = _Istr.rdbuf();
            auto& _Str        = _Manip._Str;
            const auto _Delim = _Traits::to_int_type(_Manip._Delim);
            auto _Meta        = _Buf->sgetc();

            if (!_Traits::eq_int_type(_Meta, _Delim)) { 
                return _Istr >> _Str;
            }

            const auto _Escape = _Traits::to_int_type(_Manip._Escape);
            _Str.clear();
            for (;;) {
                _Meta = _Buf->snextc();
                if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                    _State = ios_base::eofbit | ios_base::failbit;
                    break;
                } else if (_Traits::eq_int_type(_Meta, _Escape)) { 
                    _Meta = _Buf->snextc();
                    if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { 
                        _State = ios_base::eofbit | ios_base::failbit;
                        break;
                    }
                } else if (_Traits::eq_int_type(_Meta, _Delim)) { 
                    if (_Traits::eq_int_type(_Traits::eof(), _Buf->sbumpc())) { 
                        _State = ios_base::eofbit;
                    }

                    break;
                }

                _Str.push_back(_Traits::to_char_type(_Meta));
            }
            } catch (...) { (_Istr) .setstate(ios_base::badbit, true); }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    _Mystr& _Str; 
    _Elem _Delim; 
    _Elem _Escape; 
};

 template <class _Elem>
[[nodiscard]] _Quote_out<_Elem, void, size_t> quoted(
    const _Elem* _Ptr, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\')) {
    const size_t _Size = char_traits<_Elem>::length(_Ptr);
    return {_Ptr, _Size, _Delim, _Escape};
}

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] _Quote_out<_Elem, _Traits, typename basic_string<_Elem, _Traits, _Alloc>::size_type> quoted(
    const basic_string<_Elem, _Traits, _Alloc>& _Str, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\')) {
    return {_Str.c_str(), _Str.size(), _Delim, _Escape};
}


 template <class _Elem, class _Traits>
[[nodiscard]] _Quote_out<_Elem, _Traits, size_t> quoted(
    const basic_string_view<_Elem, _Traits> _Str, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\')) {
    return {_Str.data(), _Str.size(), _Delim, _Escape};
}
#line 365 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iomanip"

 template <class _Elem, class _Traits, class _Alloc>
[[nodiscard]] _Quote_in<_Elem, _Traits, _Alloc> quoted(
    basic_string<_Elem, _Traits, _Alloc>& _Str, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\')) {
    return {_Str, _Delim, _Escape};
}

template <class _Arg>
struct _Smanip { 
    _Smanip(void(__cdecl* _Left)(ios_base&, _Arg), _Arg _Val) : _Pfun(_Left), _Manarg(_Val) {}

    template <class _Elem, class _Traits>
    friend basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Smanip& _Manip) {
        
        (*_Manip._Pfun)(_Istr, _Manip._Manarg);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    friend basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Smanip& _Manip) {
        
        (*_Manip._Pfun)(_Ostr, _Manip._Manarg);
        return _Ostr;
    }

    void(__cdecl* _Pfun)(ios_base&, _Arg); 
    _Arg _Manarg; 
};

 extern "C++" [[nodiscard]]  _Smanip<ios_base::fmtflags> __cdecl resetiosflags(ios_base::fmtflags);
 extern "C++" [[nodiscard]]  _Smanip<ios_base::fmtflags> __cdecl setiosflags(ios_base::fmtflags);
 extern "C++" [[nodiscard]]  _Smanip<int> __cdecl setbase(int);
 extern "C++" [[nodiscard]]  _Smanip<streamsize> __cdecl setprecision(streamsize);
 extern "C++" [[nodiscard]]  _Smanip<streamsize> __cdecl setw(streamsize);
}


#pragma warning(pop)
#pragma pack(pop)
#line 405 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iomanip"
#line 406 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\iomanip"
#pragma external_header(pop)
#line 57 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"

#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"











#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"












#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xnode_handle.h"













#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xnode_handle.h"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {

template <class _Iterator, class _NodeType>
struct _Insert_return_type {
    _Iterator position;
    bool inserted;
    _NodeType node;
};

template <class _Derived_type, class _KeyTy, class _ValueTy>
struct _Node_handle_map_base { 
    using key_type    = _KeyTy;
    using mapped_type = _ValueTy;

    key_type& key() const noexcept  {
        return _Datum().first;
    }
    mapped_type& mapped() const noexcept  {
        return _Datum().second;
    }

private:
    using _Pair_type = pair<key_type, mapped_type>;
    _Pair_type& _Datum() const {
        const auto& _Self = static_cast<const _Derived_type&>(*this);
        auto& _Data       = _Self._Getptr()->_Myval;
        
        
        return reinterpret_cast<_Pair_type&>(_Data);
    }
};

template <class _Derived_type, class _ValueTy>
struct _Node_handle_set_base { 
    using value_type = _ValueTy;

    value_type& value() const noexcept  {
        const auto& _Self = static_cast<const _Derived_type&>(*this);
        return _Self._Getptr()->_Myval;
    }
};

template <class _Node, class _Alloc, template <class...> class _Base, class... _Types>
class _Node_handle : public _Base<_Node_handle<_Node, _Alloc, _Base, _Types...>, _Types...> {
    
public:
    using allocator_type = _Alloc;

private:
    using _Alty_traits   = allocator_traits<_Alloc>;
    using _Alnode        = _Rebind_alloc_t<_Alloc, _Node>;
    using _Alnode_traits = allocator_traits<_Alnode>;
    using _Nodeptr       = typename _Alnode_traits::pointer;

    _Nodeptr _Ptr{};
    _Aligned_storage_t<sizeof(_Alloc), alignof(_Alloc)>
        _Alloc_storage; 

    void _Clear() noexcept { 
        if (_Ptr != nullptr) {
            _Alloc& _Al = _Getal();
            _Alty_traits::destroy(_Al, ::std:: addressof(_Ptr->_Myval));
            _Alnode _Node_alloc{_Al};
            _Node::_Freenode0(_Node_alloc, _Ptr);
            _Destroy_in_place(_Al);
            _Ptr = nullptr;
        }
    }

    _Node_handle(const _Nodeptr _Ptr_, const _Alloc& _Al) noexcept
        : _Ptr{_Ptr_} { 
                        
        ;
        _Construct_in_place(_Getal(), _Al);
    }

public:
    constexpr _Node_handle() noexcept : _Alloc_storage{} {}

    ~_Node_handle() noexcept {
        _Clear();
    }

    _Node_handle(_Node_handle&& _That) noexcept : _Ptr{_That._Ptr} { 
        if (_Ptr != nullptr) {
            _That._Ptr       = nullptr;
            _Alloc& _That_al = _That._Getal();
            _Construct_in_place(_Getal(), ::std:: move(_That_al));
            _Destroy_in_place(_That_al);
        }
    }

    _Node_handle& operator=(_Node_handle&& _That) noexcept  {
        
        if (_Ptr == nullptr) {
            if (_That._Ptr != nullptr) {
                _Alloc& _That_al = _That._Getal();
                _Construct_in_place(_Getal(), ::std:: move(_That_al));
                _Destroy_in_place(_That_al);
                _Ptr = ::std:: exchange(_That._Ptr, nullptr);
            }

            return *this;
        }

        if (_That._Ptr == nullptr || this == ::std:: addressof(_That)) {
            _Clear();
            return *this;
        }

        _Alloc& _Al = _Getal();
        _Alty_traits::destroy(_Al, ::std:: addressof(_Ptr->_Myval));
        _Alnode _Node_alloc{_Al};
        _Alnode_traits::deallocate(_Node_alloc, _Ptr, 1);

        _Alloc& _That_al = _That._Getal();
        _Pocma(_Al, _That_al);
        _Destroy_in_place(_That_al);

        _Ptr = ::std:: exchange(_That._Ptr, nullptr);
        return *this;
    }

    _Nodeptr _Getptr() const noexcept {
        return _Ptr;
    }

    _Alloc& _Getal() noexcept {
        return reinterpret_cast<_Alloc&>(_Alloc_storage);
    }
    const _Alloc& _Getal() const noexcept {
        ;
        return reinterpret_cast<const _Alloc&>(_Alloc_storage);
    }

    [[nodiscard]] allocator_type get_allocator() const noexcept  {
        ;
        return _Getal();
    }

    explicit operator bool() const noexcept {
        return _Ptr != nullptr;
    }

    [[nodiscard]] bool empty() const noexcept {
        return _Ptr == nullptr;
    }

    _Nodeptr _Release() noexcept { 
        ;
        _Destroy_in_place(_Getal());
        return ::std:: exchange(_Ptr, nullptr);
    }

    void swap(_Node_handle& _That) noexcept  {
        using ::std:: swap;
        if (_Ptr != nullptr) {
            if (_That._Ptr != nullptr) {
                _Pocs(_Getal(), _That._Getal());
            } else {
                _Alloc& _Al = _Getal();
                _Construct_in_place(_That._Getal(), ::std:: move(_Al));
                _Destroy_in_place(_Al);
            }
        } else {
            if (_That._Ptr == nullptr) {
                return;
            }

            _Alloc& _That_al = _That._Getal();
            _Construct_in_place(_Getal(), ::std:: move(_That_al));
            _Destroy_in_place(_That_al);
        }
        swap(_Ptr, _That._Ptr); 
    }
    friend void swap(_Node_handle& _Left, _Node_handle& _Right) noexcept  {
        _Left.swap(_Right);
    }

    static _Node_handle _Make(const _Nodeptr _Ptr, const allocator_type& _Al) {
        
        
        ;
        return _Node_handle{_Ptr, _Al};
    }
};

}


#pragma warning(pop)
#pragma pack(pop)
#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xnode_handle.h"
#line 216 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xnode_handle.h"
#pragma external_header(pop)
#line 14 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )




namespace std {
template <class _Mytree, class _Base = _Iterator_base0>
class _Tree_unchecked_const_iterator : public _Base {
public:
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::const_pointer;
    using reference       = const value_type&;

    _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

    _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {
        this->_Adopt(_Plist);
    }

    [[nodiscard]] reference operator*() const noexcept {
        return _Ptr->_Myval;
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Tree_unchecked_const_iterator& operator++() noexcept {
        if (_Ptr->_Right->_Isnil) { 
            _Nodeptr _Pnode;
            while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {
                _Ptr = _Pnode; 
            }

            _Ptr = _Pnode; 
        } else {
            _Ptr = _Mytree::_Min(_Ptr->_Right); 
        }

        return *this;
    }

    _Tree_unchecked_const_iterator operator++(int) noexcept {
        _Tree_unchecked_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Tree_unchecked_const_iterator& operator--() noexcept {
        if (_Ptr->_Isnil) {
            _Ptr = _Ptr->_Right; 
        } else if (_Ptr->_Left->_Isnil) { 
            _Nodeptr _Pnode;
            while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Left) {
                _Ptr = _Pnode; 
            }

            if (!_Ptr->_Isnil) { 
                _Ptr = _Pnode; 
            }
        } else {
            _Ptr = _Mytree::_Max(_Ptr->_Left); 
        }

        return *this;
    }

    _Tree_unchecked_const_iterator operator--(int) noexcept {
        _Tree_unchecked_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const _Tree_unchecked_const_iterator& _Right) const noexcept {
        return _Ptr == _Right._Ptr;
    }





#line 104 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    [[nodiscard]] bool operator==(_Default_sentinel) const noexcept {
        return !!_Ptr->_Isnil; 
                               
    }





#line 115 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    _Nodeptr _Ptr; 
};

template <class _Mytree>
class _Tree_unchecked_iterator : public _Tree_unchecked_const_iterator<_Mytree> {
public:
    using _Mybase           = _Tree_unchecked_const_iterator<_Mytree>;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::pointer;
    using reference       = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Tree_unchecked_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _Tree_unchecked_iterator operator++(int) noexcept {
        _Tree_unchecked_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Tree_unchecked_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Tree_unchecked_iterator operator--(int) noexcept {
        _Tree_unchecked_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }
};

template <class _Mytree>
class _Tree_const_iterator : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> {
public:
    using _Mybase           = _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;
    using pointer         = typename _Mytree::const_pointer;
    using reference       = const value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] reference operator*() const noexcept {




#line 184 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        return this->_Ptr->_Myval;
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Tree_const_iterator& operator++() noexcept {



#line 197 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        _Mybase::operator++();
        return *this;
    }

    _Tree_const_iterator operator++(int) noexcept {
        _Tree_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _Tree_const_iterator& operator--() noexcept {





#line 215 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        _Mybase::operator--();
#line 217 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        return *this;
    }

    _Tree_const_iterator operator--(int) noexcept {
        _Tree_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    [[nodiscard]] bool operator==(const _Tree_const_iterator& _Right) const noexcept {


#line 231 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        return this->_Ptr == _Right._Ptr;
    }





#line 240 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"





#line 246 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    using _Prevent_inheriting_unwrap = _Tree_const_iterator;

    [[nodiscard]] _Tree_unchecked_const_iterator<_Mytree> _Unwrapped() const noexcept {
        return _Tree_unchecked_const_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
    }

    void _Seek_to(const _Tree_unchecked_const_iterator<_Mytree> _It) noexcept {
        this->_Ptr = _It._Ptr;
    }
};

template <class _Mytree>
class _Tree_iterator : public _Tree_const_iterator<_Mytree> {
public:
    using _Mybase           = _Tree_const_iterator<_Mytree>;
    using iterator_category = bidirectional_iterator_tag;

    using _Nodeptr        = typename _Mytree::_Nodeptr;
    using value_type      = typename _Mytree::value_type;
    using difference_type = typename _Mytree::difference_type;

    using pointer   = typename _Mytree::pointer;
    using reference = value_type&;

    using _Mybase::_Mybase;

    [[nodiscard]] reference operator*() const noexcept {
        return const_cast<reference>(_Mybase::operator*());
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return pointer_traits<pointer>::pointer_to(**this);
    }

    _Tree_iterator& operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _Tree_iterator operator++(int) noexcept {
        _Tree_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _Tree_iterator& operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _Tree_iterator operator--(int) noexcept {
        _Tree_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    using _Prevent_inheriting_unwrap = _Tree_iterator;

    [[nodiscard]] _Tree_unchecked_iterator<_Mytree> _Unwrapped() const noexcept {
        return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));
    }
};

template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Nodeptr_type>
struct _Tree_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
    using _Nodeptr        = _Nodeptr_type;
};

template <class _Value_type, class _Voidptr>
struct _Tree_node {
    using _Nodeptr   = _Rebind_pointer_t<_Voidptr, _Tree_node>;
    using value_type = _Value_type;
    _Nodeptr _Left; 
    _Nodeptr _Parent; 
    _Nodeptr _Right; 
    char _Color; 
    char _Isnil; 
    value_type _Myval = 
        _Returns_exactly<value_type>(); 

    enum _Redbl { 
        _Red,
        _Black
    };

    _Tree_node()                             = default;
    _Tree_node(const _Tree_node&)            = delete;
    _Tree_node& operator=(const _Tree_node&) = delete;

    template <class _Alloc>
    static _Nodeptr _Buyheadnode(_Alloc& _Al) {
        static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buyheadnode call");
        const auto _Pnode = _Al.allocate(1);
        _Construct_in_place(_Pnode->_Left, _Pnode);
        _Construct_in_place(_Pnode->_Parent, _Pnode);
        _Construct_in_place(_Pnode->_Right, _Pnode);
        _Pnode->_Color = _Black;
        _Pnode->_Isnil = true;
        return _Pnode;
    }

    template <class _Alloc, class... _Valty>
    static _Nodeptr _Buynode(_Alloc& _Al, _Nodeptr _Myhead, _Valty&&... _Val) {
        
        static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Buynode call");
        _Alloc_construct_ptr<_Alloc> _Newnode(_Al);
        _Newnode._Allocate();
        allocator_traits<_Alloc>::construct(_Al, ::std:: addressof(_Newnode._Ptr->_Myval), ::std:: forward<_Valty>(_Val)...);
        _Construct_in_place(_Newnode._Ptr->_Left, _Myhead);
        _Construct_in_place(_Newnode._Ptr->_Parent, _Myhead);
        _Construct_in_place(_Newnode._Ptr->_Right, _Myhead);
        _Newnode._Ptr->_Color = _Red;
        _Newnode._Ptr->_Isnil = false;
        return _Newnode._Release();
    }

    template <class _Alloc>
    static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
        static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
        _Destroy_in_place(_Ptr->_Left);
        _Destroy_in_place(_Ptr->_Parent);
        _Destroy_in_place(_Ptr->_Right);
        allocator_traits<_Alloc>::deallocate(_Al, _Ptr, 1);
    }

    template <class _Alloc>
    static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {
        static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
        allocator_traits<_Alloc>::destroy(_Al, ::std:: addressof(_Ptr->_Myval));
        _Freenode0(_Al, _Ptr);
    }
};

template <class _Ty>
struct _Tree_simple_types : _Simple_types<_Ty> {
    using _Node    = _Tree_node<_Ty, void*>;
    using _Nodeptr = _Node*;
};

enum class _Tree_child {
    _Right, 
    _Left,
    _Unused 
};

template <class _Nodeptr>
struct _Tree_id {
    _Nodeptr _Parent; 
    _Tree_child _Child;
};

template <class _Nodeptr>
struct _Tree_find_result {
    _Tree_id<_Nodeptr> _Location;
    _Nodeptr _Bound;
};

template <class _Nodeptr>
struct _Tree_find_hint_result {
    _Tree_id<_Nodeptr> _Location;
    bool _Duplicate;
};

[[noreturn]] inline void _Throw_tree_length_error() {
    _Xlength_error("map/set too long");
}

template <class _Val_types>
class _Tree_val : public _Container_base {
public:
    using _Nodeptr = typename _Val_types::_Nodeptr;

    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Tree_val>;
    using const_iterator            = _Tree_const_iterator<_Tree_val>;

    _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

    enum _Redbl { 
        _Red,
        _Black
    };

    static _Nodeptr _Max(_Nodeptr _Pnode) noexcept { 
        while (!_Pnode->_Right->_Isnil) {
            _Pnode = _Pnode->_Right;
        }

        return _Pnode;
    }

    static _Nodeptr _Min(_Nodeptr _Pnode) noexcept { 
        while (!_Pnode->_Left->_Isnil) {
            _Pnode = _Pnode->_Left;
        }

        return _Pnode;
    }

    void _Lrotate(_Nodeptr _Wherenode) noexcept { 
        _Nodeptr _Pnode    = _Wherenode->_Right;
        _Wherenode->_Right = _Pnode->_Left;

        if (!_Pnode->_Left->_Isnil) {
            _Pnode->_Left->_Parent = _Wherenode;
        }

        _Pnode->_Parent = _Wherenode->_Parent;

        if (_Wherenode == _Myhead->_Parent) {
            _Myhead->_Parent = _Pnode;
        } else if (_Wherenode == _Wherenode->_Parent->_Left) {
            _Wherenode->_Parent->_Left = _Pnode;
        } else {
            _Wherenode->_Parent->_Right = _Pnode;
        }

        _Pnode->_Left       = _Wherenode;
        _Wherenode->_Parent = _Pnode;
    }

    void _Rrotate(_Nodeptr _Wherenode) noexcept { 
        _Nodeptr _Pnode   = _Wherenode->_Left;
        _Wherenode->_Left = _Pnode->_Right;

        if (!_Pnode->_Right->_Isnil) {
            _Pnode->_Right->_Parent = _Wherenode;
        }

        _Pnode->_Parent = _Wherenode->_Parent;

        if (_Wherenode == _Myhead->_Parent) {
            _Myhead->_Parent = _Pnode;
        } else if (_Wherenode == _Wherenode->_Parent->_Right) {
            _Wherenode->_Parent->_Right = _Pnode;
        } else {
            _Wherenode->_Parent->_Left = _Pnode;
        }

        _Pnode->_Right      = _Wherenode;
        _Wherenode->_Parent = _Pnode;
    }

    _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {
        _Nodeptr _Erasednode = _Where._Ptr; 
        ++_Where; 

        _Nodeptr _Fixnode; 
        _Nodeptr _Fixnodeparent; 
        _Nodeptr _Pnode = _Erasednode;

        if (_Pnode->_Left->_Isnil) {
            _Fixnode = _Pnode->_Right; 
        } else if (_Pnode->_Right->_Isnil) {
            _Fixnode = _Pnode->_Left; 
        } else { 
            _Pnode   = _Where._Ptr; 
            _Fixnode = _Pnode->_Right; 
        }

        if (_Pnode == _Erasednode) { 
            _Fixnodeparent = _Erasednode->_Parent;
            if (!_Fixnode->_Isnil) {
                _Fixnode->_Parent = _Fixnodeparent; 
            }

            if (_Myhead->_Parent == _Erasednode) {
                _Myhead->_Parent = _Fixnode; 
            } else if (_Fixnodeparent->_Left == _Erasednode) {
                _Fixnodeparent->_Left = _Fixnode; 
            } else {
                _Fixnodeparent->_Right = _Fixnode; 
            }

            if (_Myhead->_Left == _Erasednode) {
                _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent 
                                                  : _Min(_Fixnode); 
            }

            if (_Myhead->_Right == _Erasednode) {
                _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent 
                                                   : _Max(_Fixnode); 
            }
        } else { 
            _Erasednode->_Left->_Parent = _Pnode; 
            _Pnode->_Left               = _Erasednode->_Left; 

            if (_Pnode == _Erasednode->_Right) {
                _Fixnodeparent = _Pnode; 
            } else { 
                _Fixnodeparent = _Pnode->_Parent; 
                if (!_Fixnode->_Isnil) {
                    _Fixnode->_Parent = _Fixnodeparent; 
                }

                _Fixnodeparent->_Left        = _Fixnode; 
                _Pnode->_Right               = _Erasednode->_Right; 
                _Erasednode->_Right->_Parent = _Pnode; 
            }

            if (_Myhead->_Parent == _Erasednode) {
                _Myhead->_Parent = _Pnode; 
            } else if (_Erasednode->_Parent->_Left == _Erasednode) {
                _Erasednode->_Parent->_Left = _Pnode; 
            } else {
                _Erasednode->_Parent->_Right = _Pnode; 
            }

            _Pnode->_Parent = _Erasednode->_Parent; 
            ::std:: swap(_Pnode->_Color, _Erasednode->_Color); 
        }

        if (_Erasednode->_Color == _Black) { 
            for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {
                if (_Fixnode == _Fixnodeparent->_Left) { 
                    _Pnode = _Fixnodeparent->_Right;
                    if (_Pnode->_Color == _Red) { 
                        _Pnode->_Color         = _Black;
                        _Fixnodeparent->_Color = _Red;
                        _Lrotate(_Fixnodeparent);
                        _Pnode = _Fixnodeparent->_Right;
                    }

                    if (_Pnode->_Isnil) {
                        _Fixnode = _Fixnodeparent; 
                    } else if (_Pnode->_Left->_Color == _Black
                               && _Pnode->_Right->_Color == _Black) { 
                        _Pnode->_Color = _Red;
                        _Fixnode       = _Fixnodeparent;
                    } else { 
                        if (_Pnode->_Right->_Color == _Black) { 
                            _Pnode->_Left->_Color = _Black;
                            _Pnode->_Color        = _Red;
                            _Rrotate(_Pnode);
                            _Pnode = _Fixnodeparent->_Right;
                        }

                        _Pnode->_Color         = _Fixnodeparent->_Color;
                        _Fixnodeparent->_Color = _Black;
                        _Pnode->_Right->_Color = _Black;
                        _Lrotate(_Fixnodeparent);
                        break; 
                    }
                } else { 
                    _Pnode = _Fixnodeparent->_Left;
                    if (_Pnode->_Color == _Red) { 
                        _Pnode->_Color         = _Black;
                        _Fixnodeparent->_Color = _Red;
                        _Rrotate(_Fixnodeparent);
                        _Pnode = _Fixnodeparent->_Left;
                    }

                    if (_Pnode->_Isnil) {
                        _Fixnode = _Fixnodeparent; 
                    } else if (_Pnode->_Right->_Color == _Black
                               && _Pnode->_Left->_Color == _Black) { 
                        _Pnode->_Color = _Red;
                        _Fixnode       = _Fixnodeparent;
                    } else { 
                        if (_Pnode->_Left->_Color == _Black) { 
                            _Pnode->_Right->_Color = _Black;
                            _Pnode->_Color         = _Red;
                            _Lrotate(_Pnode);
                            _Pnode = _Fixnodeparent->_Left;
                        }

                        _Pnode->_Color         = _Fixnodeparent->_Color;
                        _Fixnodeparent->_Color = _Black;
                        _Pnode->_Left->_Color  = _Black;
                        _Rrotate(_Fixnodeparent);
                        break; 
                    }
                }
            }

            _Fixnode->_Color = _Black; 
        }

        if (0 < _Mysize) {
            --_Mysize;
        }

        return _Erasednode;
    }

    _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {
        ++_Mysize;
        const auto _Head  = _Myhead;
        _Newnode->_Parent = _Loc._Parent;
        if (_Loc._Parent == _Head) { 
            _Head->_Left     = _Newnode;
            _Head->_Parent   = _Newnode;
            _Head->_Right    = _Newnode;
            _Newnode->_Color = _Black; 
            return _Newnode;
        }

        ;
        if (_Loc._Child == _Tree_child::_Right) { 
            ;
            _Loc._Parent->_Right = _Newnode;
            if (_Loc._Parent == _Head->_Right) { 
                _Head->_Right = _Newnode;
            }
        } else { 
            ;
            _Loc._Parent->_Left = _Newnode;
            if (_Loc._Parent == _Head->_Left) { 
                _Head->_Left = _Newnode;
            }
        }

        for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {
            if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { 
                const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;
                if (_Parent_sibling->_Color == _Red) { 
                    _Pnode->_Parent->_Color          = _Black;
                    _Parent_sibling->_Color          = _Black;
                    _Pnode->_Parent->_Parent->_Color = _Red;
                    _Pnode                           = _Pnode->_Parent->_Parent;
                } else { 
                    if (_Pnode == _Pnode->_Parent->_Right) { 
                        _Pnode = _Pnode->_Parent;
                        _Lrotate(_Pnode);
                    }

                    _Pnode->_Parent->_Color          = _Black; 
                    _Pnode->_Parent->_Parent->_Color = _Red;
                    _Rrotate(_Pnode->_Parent->_Parent);
                }
            } else { 
                const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
                if (_Parent_sibling->_Color == _Red) { 
                    _Pnode->_Parent->_Color          = _Black;
                    _Parent_sibling->_Color          = _Black;
                    _Pnode->_Parent->_Parent->_Color = _Red;
                    _Pnode                           = _Pnode->_Parent->_Parent;
                } else { 
                    if (_Pnode == _Pnode->_Parent->_Left) { 
                        _Pnode = _Pnode->_Parent;
                        _Rrotate(_Pnode);
                    }

                    _Pnode->_Parent->_Color          = _Black; 
                    _Pnode->_Parent->_Parent->_Color = _Red;
                    _Lrotate(_Pnode->_Parent->_Parent);
                }
            }
        }

        _Head->_Parent->_Color = _Black; 
        return _Newnode;
    }

    void _Orphan_ptr(const _Nodeptr _Ptr) noexcept {












#line 728 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        (void) _Ptr;
#line 730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
    }

    template <class _Alnode>
    void _Erase_tree_and_orphan(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {
        while (!_Rootnode->_Isnil) { 
            _Erase_tree_and_orphan(_Al, _Rootnode->_Right);
            auto _To_delete = ::std:: exchange(_Rootnode, _Rootnode->_Left);
            _Orphan_ptr(_To_delete);
            _Alnode::value_type::_Freenode(_Al, _To_delete);
        }
    }

    template <class _Alnode>
    void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {
        while (!_Rootnode->_Isnil) { 
            _Erase_tree(_Al, _Rootnode->_Right);
            _Alnode::value_type::_Freenode(_Al, ::std:: exchange(_Rootnode, _Rootnode->_Left));
        }
    }

    template <class _Alnode>
    void _Erase_head(_Alnode& _Al) noexcept {
        this->_Orphan_all();
        _Erase_tree(_Al, _Myhead->_Parent);
        _Alnode::value_type::_Freenode0(_Al, _Myhead);
    }

    _Nodeptr _Myhead; 
    size_type _Mysize; 
};

template <class _Alnode, class _Scary_val>
struct _Tree_head_scoped_ptr { 
    _Alnode& _Al;
    _Scary_val* _Mycont;

    _Tree_head_scoped_ptr(_Alnode& _Al_, _Scary_val& _Mycont_) : _Al(_Al_), _Mycont(::std:: addressof(_Mycont_)) {
        _Mycont->_Myhead = _Alnode::value_type::_Buyheadnode(_Al);
    }

    void _Release() noexcept {
        _Mycont = nullptr;
    }

    ~_Tree_head_scoped_ptr() {
        if (_Mycont) {
            _Mycont->_Erase_head(_Al);
        }
    }
};

template <class _Alnode>
struct _Tree_temp_node_alloc : _Alloc_construct_ptr<_Alnode> {
    
    explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {
        _Alloc_construct_ptr<_Alnode>::_Allocate();
    }

    _Tree_temp_node_alloc(const _Tree_temp_node_alloc&)            = delete;
    _Tree_temp_node_alloc& operator=(const _Tree_temp_node_alloc&) = delete;
};

template <class _Alnode>
struct _Tree_temp_node : _Tree_temp_node_alloc<_Alnode> {
    
    using _Alnode_traits = allocator_traits<_Alnode>;
    using _Nodeptr       = typename _Alnode_traits::pointer;

    enum _Redbl { 
        _Red,
        _Black
    };

    template <class... _Valtys>
    explicit _Tree_temp_node(_Alnode& _Al_, _Nodeptr _Myhead, _Valtys&&... _Vals)
        : _Tree_temp_node_alloc<_Alnode>(_Al_) {
        _Alnode_traits::construct(this->_Al, ::std:: addressof(this->_Ptr->_Myval), ::std:: forward<_Valtys>(_Vals)...);
        _Construct_in_place(this->_Ptr->_Left, _Myhead);
        _Construct_in_place(this->_Ptr->_Parent, _Myhead);
        _Construct_in_place(this->_Ptr->_Right, _Myhead);
        this->_Ptr->_Color = _Red;
        this->_Ptr->_Isnil = false;
    }

    _Tree_temp_node(const _Tree_temp_node&)            = delete;
    _Tree_temp_node& operator=(const _Tree_temp_node&) = delete;

    ~_Tree_temp_node() {
        if (this->_Ptr) {
            _Destroy_in_place(this->_Ptr->_Left);
            _Destroy_in_place(this->_Ptr->_Parent);
            _Destroy_in_place(this->_Ptr->_Right);
            _Alnode_traits::destroy(this->_Al, ::std:: addressof(this->_Ptr->_Myval));
        }
    }
};

template <class _Traits>
class _Tree { 
public:
    using key_type       = typename _Traits::key_type;
    using value_type     = typename _Traits::value_type;
    using allocator_type = typename _Traits::allocator_type;

protected:
    using _Alty          = _Rebind_alloc_t<allocator_type, value_type>;
    using _Alty_traits   = allocator_traits<_Alty>;
    using _Node          = _Tree_node<value_type, typename _Alty_traits::void_pointer>;
    using _Alnode        = _Rebind_alloc_t<allocator_type, _Node>;
    using _Alnode_traits = allocator_traits<_Alnode>;
    using _Nodeptr       = typename _Alnode_traits::pointer;

    using _Scary_val = _Tree_val<conditional_t<_Is_simple_alloc_v<_Alnode>, _Tree_simple_types<value_type>,
        _Tree_iter_types<value_type, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
            typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Nodeptr>>>;

    static constexpr bool _Multi  = _Traits::_Multi;
    static constexpr bool _Is_set = is_same_v<key_type, value_type>;

    enum _Redbl { 
        _Red,
        _Black
    };

public:
    using value_compare = typename _Traits::value_compare;

    using key_compare = typename _Traits::key_compare;

    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = value_type&;
    using const_reference = const value_type&;

    using iterator       = conditional_t<_Is_set, _Tree_const_iterator<_Scary_val>, _Tree_iterator<_Scary_val>>;
    using const_iterator = _Tree_const_iterator<_Scary_val>;
    using _Unchecked_iterator =
        conditional_t<_Is_set, _Tree_unchecked_const_iterator<_Scary_val>, _Tree_unchecked_iterator<_Scary_val>>;
    using _Unchecked_const_iterator = _Tree_unchecked_const_iterator<_Scary_val>;

    using reverse_iterator       = ::std:: reverse_iterator<iterator>;
    using const_reverse_iterator = ::std:: reverse_iterator<const_iterator>;

    enum class _Strategy : bool {
        _Copy,
        _Move,
    };

    _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {
        _Alloc_sentinel_and_proxy();
    }

    _Tree(const key_compare& _Parg, const allocator_type& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Parg, _One_then_variadic_args_t{}, _Al) {
        _Alloc_sentinel_and_proxy();
    }

    template <class _Any_alloc>
    _Tree(const _Tree& _Right, _Any_alloc&& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), _One_then_variadic_args_t{},
            ::std:: forward<_Any_alloc>(_Al)) {
        auto&& _Alproxy   = _Fake_alloc;
        const auto _Scary = _Get_scary();
        _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, *_Scary);
        _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);
        _Copy<_Strategy::_Copy>(_Right);
        _Sentinel._Release();
        _Proxy._Release();
    }

    _Tree(_Tree&& _Right)
        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), 
            _One_then_variadic_args_t{}, ::std:: move(_Right._Getal())) {
        _Alloc_sentinel_and_proxy();
        _Swap_val_excluding_comp(_Right);
    }

    _Tree(_Tree&& _Right, const allocator_type& _Al)
        : _Mypair(_One_then_variadic_args_t{}, _Right.key_comp(), 
            _One_then_variadic_args_t{}, _Al) {
        if constexpr (!_Alnode_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                auto&& _Alproxy   = _Fake_alloc;
                const auto _Scary = _Get_scary();
                _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, *_Scary);
                _Tree_head_scoped_ptr<_Alnode, _Scary_val> _Sentinel(_Getal(), *_Scary);
                _Copy<_Strategy::_Move>(_Right);
                _Sentinel._Release();
                _Proxy._Release();
                return;
            }
        }

        _Alloc_sentinel_and_proxy();
        _Swap_val_excluding_comp(_Right);
    }

    _Tree& operator=(_Tree&& _Right) noexcept(
        _Choose_pocma_v<_Alnode> == _Pocma_values::_Equal_allocators && is_nothrow_move_assignable_v<key_compare>) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al                 = _Getal();
        auto& _Right_al           = _Right._Getal();
        constexpr auto _Pocma_val = _Choose_pocma_v<_Alnode>;
        if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
            if (_Al != _Right_al) {
                clear();
                _Getcomp()            = _Right._Getcomp(); 
                auto&& _Alproxy       = _Fake_alloc;
                auto&& _Right_alproxy = _Fake_alloc;
                _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
                const auto _Scary       = _Get_scary();
                const auto _Right_scary = _Right._Get_scary();
                const auto _Newhead     = ::std:: exchange(_Right_scary->_Myhead, _Node::_Buyheadnode(_Right_al));
                const auto _Newsize     = ::std:: exchange(_Right_scary->_Mysize, size_type{0});
                _Scary->_Erase_head(_Al);
                _Pocma(_Al, _Right_al);
                _Scary->_Myhead = _Newhead;
                _Scary->_Mysize = _Newsize;
                _Proxy._Bind(_Alproxy, _Scary);
                _Scary->_Swap_proxy_and_iterators(*_Right_scary);
                return *this;
            }
        } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
            if (_Al != _Right_al) {
                clear();
                _Getcomp() = _Right._Getcomp(); 
                _Copy<_Strategy::_Move>(_Right);
                return *this;
            }
        }

        clear();
        _Getcomp() = _Right._Getcomp(); 
        _Pocma(_Al, _Right_al);
        _Swap_val_excluding_comp(_Right);

        return *this;
    }

private:
    void _Swap_val_excluding_comp(_Tree& _Right) { 
        using ::std:: swap;
        const auto _Scary       = _Get_scary();
        const auto _Right_scary = _Right._Get_scary();
        _Scary->_Swap_proxy_and_iterators(*_Right_scary);
        swap(_Scary->_Myhead, _Right_scary->_Myhead); 
        ::std:: swap(_Scary->_Mysize, _Right_scary->_Mysize);
    }

protected:
    template <class... _Valtys>
    pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {
        using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
        const auto _Scary             = _Get_scary();
        _Tree_find_result<_Nodeptr> _Loc;
        _Nodeptr _Inserted;
        if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
            const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);
            _Loc                = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return {_Loc._Bound, false};
            }

            _Check_grow_by_1();
            _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, ::std:: forward<_Valtys>(_Vals)...)._Release();
            
        } else {
            _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, ::std:: forward<_Valtys>(_Vals)...);
            const auto& _Keyval = _Traits::_Kfn(_Newnode._Ptr->_Myval);
            if constexpr (_Multi) { 
                _Loc = _Find_upper_bound(_Keyval);
            } else {
                _Loc = _Find_lower_bound(_Keyval);
                if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                    return {_Loc._Bound, false};
                }
            }

            _Check_grow_by_1();
            
            _Inserted = _Newnode._Release();
        }

        return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};
    }

public:
    template <class... _Valtys>
    pair<iterator, bool> emplace(_Valtys&&... _Vals) {
        const auto _Result = _Emplace(::std:: forward<_Valtys>(_Vals)...);
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

protected:
    template <class... _Valtys>
    _Nodeptr _Emplace_hint(const _Nodeptr _Hint, _Valtys&&... _Vals) {
        using _In_place_key_extractor = typename _Traits::template _In_place_key_extractor<_Remove_cvref_t<_Valtys>...>;
        const auto _Scary             = _Get_scary();
        _Tree_find_hint_result<_Nodeptr> _Loc;
        _Nodeptr _Inserted;
        if constexpr (!_Multi && _In_place_key_extractor::_Extractable) {
            _Loc = _Find_hint(_Hint, _In_place_key_extractor::_Extract(_Vals...));
            if (_Loc._Duplicate) {
                return _Loc._Location._Parent;
            }

            _Check_grow_by_1();
            _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, ::std:: forward<_Valtys>(_Vals)...)._Release();
            
        } else {
            _Tree_temp_node<_Alnode> _Newnode(_Getal(), _Scary->_Myhead, ::std:: forward<_Valtys>(_Vals)...);
            _Loc = _Find_hint(_Hint, _Traits::_Kfn(_Newnode._Ptr->_Myval));
            if constexpr (!_Multi) {
                if (_Loc._Duplicate) {
                    return _Loc._Location._Parent;
                }
            }

            _Check_grow_by_1();
            
            _Inserted = _Newnode._Release();
        }

        return _Scary->_Insert_node(_Loc._Location, _Inserted);
    }

public:
    template <class... _Valtys>
    iterator emplace_hint(const_iterator _Where, _Valtys&&... _Vals) { 
        const auto _Scary = _Get_scary();


#line 1068 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        return iterator(_Emplace_hint(_Where._Ptr, ::std:: forward<_Valtys>(_Vals)...), _Scary);
    }

    ~_Tree() noexcept {
        const auto _Scary = _Get_scary();
        _Scary->_Erase_head(_Getal());



#line 1078 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
    }

public:
    _Tree& operator=(const _Tree& _Right) {
        if (this == ::std:: addressof(_Right)) {
            return *this;
        }

        auto& _Al       = _Getal();
        auto& _Right_al = _Right._Getal();
        if constexpr (_Choose_pocca_v<_Alnode>) {
            if (_Al != _Right_al) {
                clear();
                const auto _Scary = _Get_scary();
                _Scary->_Orphan_all();
                auto&& _Alproxy       = _Fake_alloc;
                auto&& _Right_alproxy = _Fake_alloc;
                _Container_proxy_ptr<_Alty> _Proxy(_Right_alproxy, _Leave_proxy_unbound{});
                auto _Right_al_non_const = _Right_al;
                auto _Newhead            = _Node::_Buyheadnode(_Right_al_non_const);
                _Node::_Freenode0(_Al, _Scary->_Myhead);
                _Pocca(_Al, _Right_al);
                _Scary->_Myhead = _Newhead;
                _Proxy._Bind(_Alproxy, _Scary);
                _Getcomp() = _Right._Getcomp();
                _Copy<_Strategy::_Copy>(_Right);
                return *this;
            }
        }

        clear();
        _Getcomp() = _Right._Getcomp();
        _Pocca(_Al, _Right_al);
        _Copy<_Strategy::_Copy>(_Right);

        return *this;
    }

    [[nodiscard]] iterator begin() noexcept {
        const auto _Scary = _Get_scary();
        return iterator(_Scary->_Myhead->_Left, _Scary);
    }

    [[nodiscard]] const_iterator begin() const noexcept {
        const auto _Scary = _Get_scary();
        return const_iterator(_Scary->_Myhead->_Left, _Scary);
    }

    [[nodiscard]] iterator end() noexcept {
        const auto _Scary = _Get_scary();
        return iterator(_Scary->_Myhead, _Scary);
    }

    [[nodiscard]] const_iterator end() const noexcept {
        const auto _Scary = _Get_scary();
        return const_iterator(_Scary->_Myhead, _Scary);
    }

    _Unchecked_iterator _Unchecked_begin() noexcept {
        return _Unchecked_iterator(_Get_scary()->_Myhead->_Left, nullptr);
    }

    _Unchecked_const_iterator _Unchecked_begin() const noexcept {
        return _Unchecked_const_iterator(_Get_scary()->_Myhead->_Left, nullptr);
    }

    _Default_sentinel _Unchecked_end() const noexcept {
        return {};
    }

    _Unchecked_const_iterator _Unchecked_end_iter() const noexcept {
        return _Unchecked_const_iterator(_Get_scary()->_Myhead, nullptr);
    }

    [[nodiscard]] reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    [[nodiscard]] reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    [[nodiscard]] const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    [[nodiscard]] const_iterator cbegin() const noexcept {
        return begin();
    }

    [[nodiscard]] const_iterator cend() const noexcept {
        return end();
    }

    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    [[nodiscard]] const_reverse_iterator crend() const noexcept {
        return rend();
    }

    [[nodiscard]] size_type size() const noexcept {
        return _Get_scary()->_Mysize;
    }

    [[nodiscard]] size_type max_size() const noexcept {
        return (::std:: min)(
            static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
    }

    [[nodiscard("This member function returns a bool indicating whether the container is empty and has no other effects. " "It is not useful to call this member function and discard the return value. " "Use the 'clear()' member function if you want to erase all elements.")]] bool empty() const noexcept {
        return _Get_scary()->_Mysize == 0;
    }

    [[nodiscard]] allocator_type get_allocator() const noexcept {
        return static_cast<allocator_type>(_Getal());
    }

    [[nodiscard]] key_compare key_comp() const {
        return _Getcomp();
    }

    [[nodiscard]] value_compare value_comp() const {
        return value_compare(key_comp());
    }

    template <bool _Multi2 = _Multi, enable_if_t<!_Multi2, int> = 0>
    pair<iterator, bool> insert(const value_type& _Val) {
        const auto _Result = _Emplace(_Val);
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

    template <bool _Multi2 = _Multi, enable_if_t<_Multi2, int> = 0>
    iterator insert(const value_type& _Val) {
        return iterator(_Emplace(_Val).first, _Get_scary());
    }

    template <bool _Multi2 = _Multi, enable_if_t<!_Multi2, int> = 0>
    pair<iterator, bool> insert(value_type&& _Val) {
        const auto _Result = _Emplace(::std:: move(_Val));
        return {iterator(_Result.first, _Get_scary()), _Result.second};
    }

    template <bool _Multi2 = _Multi, enable_if_t<_Multi2, int> = 0>
    iterator insert(value_type&& _Val) {
        return iterator(_Emplace(::std:: move(_Val)).first, _Get_scary());
    }

    iterator insert(const_iterator _Where, const value_type& _Val) {
        const auto _Scary = _Get_scary();


#line 1236 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        return iterator(_Emplace_hint(_Where._Ptr, _Val), _Scary);
    }

    iterator insert(const_iterator _Where, value_type&& _Val) {
        const auto _Scary = _Get_scary();


#line 1244 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        return iterator(_Emplace_hint(_Where._Ptr, ::std:: move(_Val)), _Scary);
    }

protected:
    template <class _Iter, class _Sent>
    void _Insert_range_unchecked(_Iter _First, const _Sent _Last) {
        const auto _Myhead = _Get_scary()->_Myhead;
        for (; _First != _Last; ++_First) {
            _Emplace_hint(_Myhead, *_First);
        }
    }

public:
    template <class _Iter>
    void insert(_Iter _First, _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        _Insert_range_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last));
    }


    template <_Container_compatible_range<value_type> _Rng>
    void insert_range(_Rng&& _Range) {
        _Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }
#line 1269 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    void insert(initializer_list<value_type> _Ilist) {
        _Insert_range_unchecked(_Ilist.begin(), _Ilist.end());
    }

private:
    _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {
        const auto _Scary                    = _Get_scary();
        _Unchecked_const_iterator _Successor = _Where;
        ++_Successor; 
        _Nodeptr _Erasednode = _Scary->_Extract(_Where); 
        _Scary->_Orphan_ptr(_Erasednode);
        _Node::_Freenode(_Getal(), _Erasednode); 
        return _Successor._Ptr; 
    }

    _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _First, _Unchecked_const_iterator _Last) noexcept {
        const auto _Begin = _Unchecked_begin();
        if (_First == _Begin && _Last._Ptr->_Isnil) {
            
            clear();
            return _Last._Ptr;
        }

        
        while (_First != _Last) {
            _Erase_unchecked(_First++);
        }

        return _Last._Ptr;
    }

    size_type _Erase(const pair<_Nodeptr, _Nodeptr> _Where) noexcept {
        const _Unchecked_const_iterator _First(_Where.first, nullptr);
        const _Unchecked_const_iterator _Last(_Where.second, nullptr);
        const auto _Num = static_cast<size_type>(::std:: distance(_First, _Last));
        _Erase_unchecked(_First, _Last);
        return _Num;
    }

public:
    template <class _Iter = iterator, enable_if_t<!is_same_v<_Iter, const_iterator>, int> = 0>
    iterator erase(iterator _Where) noexcept  {
        const auto _Scary = _Get_scary();



#line 1317 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);
    }

    iterator erase(const_iterator _Where) noexcept  {
        const auto _Scary = _Get_scary();



#line 1326 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);
    }

    iterator erase(const_iterator _First, const_iterator _Last) noexcept  {
        return iterator(_Erase_unchecked(_First._Unwrapped(), _Last._Unwrapped()), _Get_scary());
    }

    size_type erase(const key_type& _Keyval) noexcept(noexcept(_Eqrange(_Keyval)))  {
        return _Erase(_Eqrange(_Keyval));
    }


    template <class _Kx, class _Mycomp = key_compare,
        enable_if_t<conjunction_v<_Is_transparent<_Mycomp>,
                        negation<disjunction<is_convertible<_Kx, const_iterator>, is_convertible<_Kx, iterator>>>>,
            int> = 0>
    size_type erase(_Kx&& _Keyval) noexcept(noexcept(_Eqrange(_Keyval)))  {
        return _Erase(_Eqrange(_Keyval));
    }
#line 1346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    void clear() noexcept {
        const auto _Scary = _Get_scary();
        _Scary->_Orphan_ptr(nullptr);
        auto _Head = _Scary->_Myhead;
        _Scary->_Erase_tree(_Getal(), _Head->_Parent);
        _Head->_Parent  = _Head;
        _Head->_Left    = _Head;
        _Head->_Right   = _Head;
        _Scary->_Mysize = 0;
    }

private:
    template <class _Other>
    [[nodiscard]] _Nodeptr _Find(const _Other& _Keyval) const {
        const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);
        if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            return _Loc._Bound;
        }

        return _Get_scary()->_Myhead;
    }

public:
    [[nodiscard]] iterator find(const key_type& _Keyval) {
        return iterator(_Find(_Keyval), _Get_scary());
    }

    [[nodiscard]] const_iterator find(const key_type& _Keyval) const {
        return const_iterator(_Find(_Keyval), _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] iterator find(const _Other& _Keyval) {
        return iterator(_Find(_Keyval), _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] const_iterator find(const _Other& _Keyval) const {
        return const_iterator(_Find(_Keyval), _Get_scary());
    }


    [[nodiscard]] bool contains(const key_type& _Keyval) const {
        return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] bool contains(const _Other& _Keyval) const {
        return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
    }
#line 1398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    [[nodiscard]] size_type count(const key_type& _Keyval) const {
        if constexpr (_Multi) {
            const auto _Ans = _Eqrange(_Keyval);
            return static_cast<size_type>(::std:: distance(
                _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
        } else {
            return _Lower_bound_duplicate(_Find_lower_bound(_Keyval)._Bound, _Keyval);
        }
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] size_type count(const _Other& _Keyval) const {
        const auto _Ans = _Eqrange(_Keyval);
        return static_cast<size_type>(::std:: distance(
            _Unchecked_const_iterator(_Ans.first, nullptr), _Unchecked_const_iterator(_Ans.second, nullptr)));
    }

    [[nodiscard]] iterator lower_bound(const key_type& _Keyval) {
        return iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    [[nodiscard]] const_iterator lower_bound(const key_type& _Keyval) const {
        return const_iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] iterator lower_bound(const _Other& _Keyval) {
        return iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] const_iterator lower_bound(const _Other& _Keyval) const {
        return const_iterator(_Find_lower_bound(_Keyval)._Bound, _Get_scary());
    }

    [[nodiscard]] iterator upper_bound(const key_type& _Keyval) {
        return iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    [[nodiscard]] const_iterator upper_bound(const key_type& _Keyval) const {
        return const_iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] iterator upper_bound(const _Other& _Keyval) {
        return iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] const_iterator upper_bound(const _Other& _Keyval) const {
        return const_iterator(_Find_upper_bound(_Keyval)._Bound, _Get_scary());
    }

    [[nodiscard]] pair<iterator, iterator> equal_range(const key_type& _Keyval) {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {iterator(_Result.first, _Scary), iterator(_Result.second, _Scary)};
    }

    [[nodiscard]] pair<const_iterator, const_iterator> equal_range(const key_type& _Keyval) const {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {const_iterator(_Result.first, _Scary), const_iterator(_Result.second, _Scary)};
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] pair<iterator, iterator> equal_range(const _Other& _Keyval) {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {iterator(_Result.first, _Scary), iterator(_Result.second, _Scary)};
    }

    template <class _Other, class _Mycomp = key_compare, enable_if_t<_Is_transparent_v<_Mycomp>, int> = 0>
    [[nodiscard]] pair<const_iterator, const_iterator> equal_range(const _Other& _Keyval) const {
        const auto _Result = _Eqrange(_Keyval);
        const auto _Scary  = _Get_scary();
        return {const_iterator(_Result.first, _Scary), const_iterator(_Result.second, _Scary)};
    }

    void swap(_Tree& _Right) noexcept(_Is_nothrow_swappable<key_compare>::value)  {
        using ::std:: swap;
        if (this != ::std:: addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Swap_val_excluding_comp(_Right);
            swap(_Getcomp(), _Right._Getcomp()); 
        }
    }

protected:
    template <class _Keyty>
    _Tree_find_hint_result<_Nodeptr> _Find_hint(const _Nodeptr _Hint, const _Keyty& _Keyval) const {
        const auto& _Comp = _Getcomp();
        const auto _Head  = _Get_scary()->_Myhead;
        if constexpr (_Multi) { 
            if (_Hint->_Isnil) {
                
                if (_Head->_Parent->_Isnil || !static_cast<bool>(_Comp(_Keyval, _Traits::_Kfn(_Head->_Right->_Myval)))) {
                    return {{_Head->_Right, _Tree_child::_Right}, false};
                }

                
                return {_Find_upper_bound(_Keyval)._Location, false};
            }

            if (_Hint == _Head->_Left) {
                
                if (!static_cast<bool>(_Comp(_Traits::_Kfn(_Hint->_Myval), _Keyval))) {
                    return {{_Hint, _Tree_child::_Left}, false};
                }

                
                return {_Find_lower_bound(_Keyval)._Location, false};
            }

            if (!static_cast<bool>(_Comp(_Traits::_Kfn(_Hint->_Myval), _Keyval))) {
                
                const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (!static_cast<bool>(_Comp(_Keyval, _Traits::_Kfn(_Prev->_Myval)))) {
                    
                    if (_Prev->_Right->_Isnil) {
                        return {{_Prev, _Tree_child::_Right}, false};
                    } else {
                        return {{_Hint, _Tree_child::_Left}, false};
                    }
                }

                
                return {_Find_upper_bound(_Keyval)._Location, false};
            }

            
            return {_Find_lower_bound(_Keyval)._Location, false};
        } else { 
            if (_Hint->_Isnil) { 
                
                if (_Head->_Parent->_Isnil || static_cast<bool>(_Comp(_Traits::_Kfn(_Head->_Right->_Myval), _Keyval))) {
                    return {{_Head->_Right, _Tree_child::_Right}, false};
                }
            } else if (_Hint == _Head->_Left) {
                
                if (static_cast<bool>(_Comp(_Keyval, _Traits::_Kfn(_Hint->_Myval)))) {
                    return {{_Hint, _Tree_child::_Left}, false};
                }
            } else if (static_cast<bool>(_Comp(_Keyval, _Traits::_Kfn(_Hint->_Myval)))) {
                
                const auto _Prev = (--(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (static_cast<bool>(_Comp(_Traits::_Kfn(_Prev->_Myval), _Keyval))) {
                    
                    if (_Prev->_Right->_Isnil) {
                        return {{_Prev, _Tree_child::_Right}, false};
                    } else {
                        return {{_Hint, _Tree_child::_Left}, false};
                    }
                }
            } else if (static_cast<bool>(_Comp(_Traits::_Kfn(_Hint->_Myval), _Keyval))) {
                
                const auto _Next = (++(_Unchecked_const_iterator(_Hint, nullptr)))._Ptr;
                if (_Next->_Isnil || static_cast<bool>(_Comp(_Keyval, _Traits::_Kfn(_Next->_Myval)))) {
                    
                    if (_Hint->_Right->_Isnil) {
                        return {{_Hint, _Tree_child::_Right}, false};
                    }

                    return {{_Next, _Tree_child::_Left}, false};
                }
            } else {
                
                return {{_Hint, _Tree_child::_Right}, true};
            }

            const auto _Loc = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return {{_Loc._Bound, _Tree_child::_Unused}, true};
            }

            return {_Loc._Location, false};
        }
    }

    template <class _Keyty>
    _Tree_find_result<_Nodeptr> _Find_upper_bound(const _Keyty& _Keyval) const {
        const auto _Scary = _Get_scary();
        _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};
        _Nodeptr _Trynode = _Result._Location._Parent;
        while (!_Trynode->_Isnil) {
            _Result._Location._Parent = _Trynode;
            if (static_cast<bool>(_Getcomp()(_Keyval, _Traits::_Kfn(_Trynode->_Myval)))) {
                _Result._Location._Child = _Tree_child::_Left;
                _Result._Bound           = _Trynode;
                _Trynode                 = _Trynode->_Left;
            } else {
                _Result._Location._Child = _Tree_child::_Right;
                _Trynode                 = _Trynode->_Right;
            }
        }

        return _Result;
    }

    template <class _Keyty>
    bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {
        return !_Bound->_Isnil && !static_cast<bool>(_Getcomp()(_Keyval, _Traits::_Kfn(_Bound->_Myval)));
    }

    template <class _Keyty>
    _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {
        const auto _Scary = _Get_scary();
        _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};
        _Nodeptr _Trynode = _Result._Location._Parent;
        while (!_Trynode->_Isnil) {
            _Result._Location._Parent = _Trynode;
            if (static_cast<bool>(_Getcomp()(_Traits::_Kfn(_Trynode->_Myval), _Keyval))) {
                _Result._Location._Child = _Tree_child::_Right;
                _Trynode                 = _Trynode->_Right;
            } else {
                _Result._Location._Child = _Tree_child::_Left;
                _Result._Bound           = _Trynode;
                _Trynode                 = _Trynode->_Left;
            }
        }

        return _Result;
    }

    void _Check_grow_by_1() {
        if (max_size() == _Get_scary()->_Mysize) {
            _Throw_tree_length_error();
        }
    }

    template <_Strategy _Strat>
    void _Copy(const _Tree& _Right) { 
        const auto _Scary        = _Get_scary();
        const auto _Right_scary  = _Right._Get_scary();
        _Scary->_Myhead->_Parent = _Copy_nodes<_Strat>(_Right_scary->_Myhead->_Parent, _Scary->_Myhead);
        _Scary->_Mysize          = _Right_scary->_Mysize;
        if (!_Scary->_Myhead->_Parent->_Isnil) { 
            _Scary->_Myhead->_Left  = _Scary_val::_Min(_Scary->_Myhead->_Parent);
            _Scary->_Myhead->_Right = _Scary_val::_Max(_Scary->_Myhead->_Parent);
        } else { 
            _Scary->_Myhead->_Left  = _Scary->_Myhead;
            _Scary->_Myhead->_Right = _Scary->_Myhead;
        }
    }

    template <_Strategy _Strat, class _Ty>
    _Nodeptr _Copy_or_move(_Ty& _Val) {
        if constexpr (_Strat == _Strategy::_Copy) {
            return _Buynode(_Val);
        } else {
            if constexpr (_Is_set) {
                return _Buynode(::std:: move(_Val));
            } else {
                return _Buynode(::std:: move(const_cast<key_type&>(_Val.first)), ::std:: move(_Val.second));
            }
        }
    }

    template <_Strategy _Strat>
    _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode) {
        
        const auto _Scary = _Get_scary();
        _Nodeptr _Newroot = _Scary->_Myhead; 

        if (!_Rootnode->_Isnil) { 
            _Nodeptr _Pnode = _Copy_or_move<_Strat>(_Rootnode->_Myval);
            _Pnode->_Parent = _Wherenode;
            _Pnode->_Color  = _Rootnode->_Color;
            if (_Newroot->_Isnil) {
                _Newroot = _Pnode; 
            }

            try {
            _Pnode->_Left  = _Copy_nodes<_Strat>(_Rootnode->_Left, _Pnode);
            _Pnode->_Right = _Copy_nodes<_Strat>(_Rootnode->_Right, _Pnode);
            } catch (...) {
            _Scary->_Erase_tree_and_orphan(_Getal(), _Newroot); 
            throw;
            }
        }

        return _Newroot; 
    }

    template <class _Other>
    pair<_Nodeptr, _Nodeptr> _Eqrange(const _Other& _Keyval) const
        noexcept(_Nothrow_compare<key_compare, key_type, _Other>&& _Nothrow_compare<key_compare, _Other, key_type>) {
        
        const auto _Scary = _Get_scary();
        const auto& _Comp = _Getcomp();
        _Nodeptr _Pnode   = _Scary->_Myhead->_Parent;
        _Nodeptr _Lonode  = _Scary->_Myhead; 
        _Nodeptr _Hinode  = _Scary->_Myhead; 

        while (!_Pnode->_Isnil) {
            const auto& _Nodekey = _Traits::_Kfn(_Pnode->_Myval);
            if (static_cast<bool>(_Comp(_Nodekey, _Keyval))) {
                _Pnode = _Pnode->_Right; 
            } else { 
                if (_Hinode->_Isnil && static_cast<bool>(_Comp(_Keyval, _Nodekey))) {
                    _Hinode = _Pnode; 
                }

                _Lonode = _Pnode;
                _Pnode  = _Pnode->_Left; 
            }
        }

        _Pnode = _Hinode->_Isnil ? _Scary->_Myhead->_Parent : _Hinode->_Left; 
        while (!_Pnode->_Isnil) {
            if (static_cast<bool>(_Getcomp()(_Keyval, _Traits::_Kfn(_Pnode->_Myval)))) {
                
                _Hinode = _Pnode;
                _Pnode  = _Pnode->_Left; 
            } else {
                _Pnode = _Pnode->_Right; 
            }
        }

        return {_Lonode, _Hinode};
    }


public:
    using node_type = typename _Traits::node_type;

    node_type extract(const const_iterator _Where) {
        const auto _Scary = _Get_scary();


#line 1730 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        const auto _Ptr = _Scary->_Extract(_Where._Unwrapped());
        _Scary->_Orphan_ptr(_Ptr);
        return node_type::_Make(_Ptr, _Getal());
    }

    node_type extract(const key_type& _Keyval) {
        const const_iterator _Where = find(_Keyval);
        if (_Where == end()) {
            return node_type{};
        }

        return extract(_Where);
    }


    template <class _Kx, class _Mycomp = key_compare,
        enable_if_t<conjunction_v<_Is_transparent<_Mycomp>,
                        negation<disjunction<is_convertible<_Kx, const_iterator>, is_convertible<_Kx, iterator>>>>,
            int> = 0>
    node_type extract(_Kx&& _Keyval) {
        const const_iterator _Where = find(_Keyval);
        if (_Where == end()) {
            return node_type{};
        }

        return extract(_Where);
    }
#line 1759 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    auto insert(node_type&& _Handle) {
        if (_Handle.empty()) {
            if constexpr (_Multi) {
                return end();
            } else {
                return _Insert_return_type<iterator, node_type>{end(), false, {}};
            }
        }

        _Check_node_allocator(_Handle);
        const auto _Scary        = _Get_scary();
        const auto _Attempt_node = _Handle._Getptr();
        const auto& _Keyval      = _Traits::_Kfn(_Attempt_node->_Myval);
        _Tree_find_result<_Nodeptr> _Loc;
        if constexpr (_Multi) {
            _Loc = _Find_upper_bound(_Keyval);
        } else {
            _Loc = _Find_lower_bound(_Keyval);
            if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                return _Insert_return_type<iterator, node_type>{
                    iterator(_Loc._Bound, _Scary), false, ::std:: move(_Handle)};
            }
        }

        _Check_grow_by_1();

        

        _Attempt_node->_Left = _Scary->_Myhead;
        
        _Attempt_node->_Right = _Scary->_Myhead;
        _Attempt_node->_Color = _Red;

        const auto _Inserted = _Scary->_Insert_node(_Loc._Location, _Handle._Release());
        if constexpr (_Multi) {
            return iterator(_Inserted, _Scary);
        } else {
            return _Insert_return_type<iterator, node_type>{iterator(_Inserted, _Scary), true, ::std:: move(_Handle)};
        }
    }

    iterator insert(const const_iterator _Hint, node_type&& _Handle) {
        const auto _Scary = _Get_scary();


#line 1806 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
        if (_Handle.empty()) {
            return end();
        }

        _Check_node_allocator(_Handle);
        const auto _Attempt_node = _Handle._Getptr();
        const auto& _Keyval      = _Traits::_Kfn(_Attempt_node->_Myval);
        const auto _Loc          = _Find_hint(_Hint._Ptr, _Keyval);
        if (_Loc._Duplicate) {
            return iterator(_Loc._Location._Parent, _Scary);
        }

        _Check_grow_by_1();

        _Attempt_node->_Left = _Scary->_Myhead;
        
        _Attempt_node->_Right = _Scary->_Myhead;
        _Attempt_node->_Color = _Red;

        return iterator(_Scary->_Insert_node(_Loc._Location, _Handle._Release()), _Scary);
    }

    template <class>
    friend class _Tree;

    template <class _Other_traits>
    void merge(_Tree<_Other_traits>& _That) {
        static_assert(is_same_v<_Nodeptr, typename _Tree<_Other_traits>::_Nodeptr>,
            "merge() requires an argument with a compatible node type.");

        static_assert(is_same_v<allocator_type, typename _Tree<_Other_traits>::allocator_type>,
            "merge() requires an argument with the same allocator type.");

        if constexpr (is_same_v<_Tree, _Tree<_Other_traits>>) {
            if (this == ::std:: addressof(_That)) {
                return;
            }
        }





#line 1850 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

        const auto _Scary      = _Get_scary();
        const auto _Head       = _Scary->_Myhead;
        const auto _That_scary = _That._Get_scary();
        auto _First            = _That._Unchecked_begin();
        while (!_First._Ptr->_Isnil) {
            const auto _Attempt_node = _First._Ptr;
            ++_First;
            _Tree_find_result<_Nodeptr> _Loc;
            const auto& _Keyval = _Traits::_Kfn(_Attempt_node->_Myval);
            if constexpr (_Multi) {
                _Loc = _Find_upper_bound(_Keyval);
            } else {
                _Loc = _Find_lower_bound(_Keyval);
                if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
                    continue;
                }
            }

            _Check_grow_by_1();

            
            const auto _Extracted = _That_scary->_Extract(_Unchecked_const_iterator(_Attempt_node, nullptr));
            _Extracted->_Left     = _Head;
            
            _Extracted->_Right = _Head;
            _Extracted->_Color = _Red;

            const auto _Inserted = _Scary->_Insert_node(_Loc._Location, _Extracted);
            _Reparent_ptr(_Inserted, _That);
        }
    }

    template <class _Other_traits>
    void merge(_Tree<_Other_traits>&& _That) {
        static_assert(is_same_v<_Nodeptr, typename _Tree<_Other_traits>::_Nodeptr>,
            "merge() requires an argument with a compatible node type.");

        static_assert(is_same_v<allocator_type, typename _Tree<_Other_traits>::allocator_type>,
            "merge() requires an argument with the same allocator type.");

        merge(_That);
    }

protected:
    template <class _Other_traits>
    void _Reparent_ptr(const _Nodeptr _Ptr, _Tree<_Other_traits>& _Old_parent) {
        (void) _Ptr;
        (void) _Old_parent;
























#line 1924 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
    }

    void _Check_node_allocator(node_type& _Handle) const {
        (void) _Handle;


#line 1931 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
    }
#line 1933 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"

    void _Alloc_sentinel_and_proxy() {
        const auto _Scary = _Get_scary();
        auto&& _Alproxy   = _Fake_alloc;
        _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
        _Scary->_Myhead = _Node::_Buyheadnode(_Getal());
        _Proxy._Release();
    }

    template <class... _Valty>
    _Nodeptr _Buynode(_Valty&&... _Val) {
        return _Node::_Buynode(_Getal(), _Get_scary()->_Myhead, ::std:: forward<_Valty>(_Val)...);
    }

    key_compare& _Getcomp() noexcept {
        return _Mypair._Get_first();
    }

    const key_compare& _Getcomp() const noexcept {
        return _Mypair._Get_first();
    }

    _Alnode& _Getal() noexcept {
        return _Mypair._Myval2._Get_first();
    }

    const _Alnode& _Getal() const noexcept {
        return _Mypair._Myval2._Get_first();
    }

    _Scary_val* _Get_scary() noexcept {
        return ::std:: addressof(_Mypair._Myval2._Myval2);
    }

    const _Scary_val* _Get_scary() const noexcept {
        return ::std:: addressof(_Mypair._Myval2._Myval2);
    }

private:
    _Compressed_pair<key_compare, _Compressed_pair<_Alnode, _Scary_val>> _Mypair;
};
}



#pragma warning(pop)
#pragma pack(pop)
#line 1981 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
#line 1982 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\xtree"
#pragma external_header(pop)
#line 13 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"



#line 17 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {
template <class _Kty, 
    class _Ty, 
    class _Pr, 
    class _Alloc, 
    bool _Mfl> 
class _Tmap_traits { 
public:
    using key_type       = _Kty;
    using value_type     = pair<const _Kty, _Ty>;
    using key_compare    = _Pr;
    using allocator_type = _Alloc;

    using node_type = _Node_handle<_Tree_node<value_type, typename allocator_traits<_Alloc>::void_pointer>, _Alloc,
        _Node_handle_map_base, _Kty, _Ty>;
#line 40 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

    static constexpr bool _Multi = _Mfl;

    template <class... _Args>
    using _In_place_key_extractor = _In_place_key_extract_map<_Kty, _Args...>;

    class value_compare {
    public:
        using _Unnameable_first_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]  = value_type;
        using _Unnameable_second_argument [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]] = value_type;
        using _Unnameable_result [[deprecated( "warning STL4007: Many result_type typedefs " "and all argument_type, first_argument_type, and second_argument_type typedefs are deprecated in C++17. " "You can define _SILENCE_CXX17_ADAPTOR_TYPEDEFS_DEPRECATION_WARNING " "or _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS to suppress this warning.")]]          = bool;

        [[nodiscard]] bool operator()(const value_type& _Left, const value_type& _Right) const {
            
            return comp(_Left.first, _Right.first);
        }

    protected:
        friend _Tree<_Tmap_traits>;

        value_compare(key_compare _Pred) : comp(_Pred) {}

        key_compare comp; 
    };

    template <class _Ty1, class _Ty2>
    static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val) { 
        return _Val.first;
    }
};

 template <class _Kty, class _Ty, class _Pr = less<_Kty>, class _Alloc = allocator<pair<const _Kty, _Ty>>>
class map : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false>> {
    
public:
    static_assert(!1 || is_same_v<pair<const _Kty, _Ty>, typename _Alloc::value_type>,
        "map<Key, Value, Compare, Allocator>" " requires that Allocator's value_type match " "pair<const Key, Value>" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Kty>, "The C++ Standard forbids containers of non-object types "
                                     "because of [container.requirements].");

    using _Mybase                = _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false>>;
    using _Nodeptr               = typename _Mybase::_Nodeptr;
    using key_type               = _Kty;
    using mapped_type            = _Ty;
    using key_compare            = _Pr;
    using value_compare          = typename _Mybase::value_compare;
    using value_type             = pair<const _Kty, _Ty>;
    using allocator_type         = typename _Mybase::allocator_type;
    using size_type              = typename _Mybase::size_type;
    using difference_type        = typename _Mybase::difference_type;
    using pointer                = typename _Mybase::pointer;
    using const_pointer          = typename _Mybase::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using iterator               = typename _Mybase::iterator;
    using const_iterator         = typename _Mybase::const_iterator;
    using reverse_iterator       = typename _Mybase::reverse_iterator;
    using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

    using _Alnode        = typename _Mybase::_Alnode;
    using _Alnode_traits = typename _Mybase::_Alnode_traits;


    using insert_return_type = _Insert_return_type<iterator, typename _Mybase::node_type>;
#line 105 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

    map() : _Mybase(key_compare()) {}

    explicit map(const allocator_type& _Al) : _Mybase(key_compare(), _Al) {}

    map(const map& _Right) : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

    map(const map& _Right, const allocator_type& _Al) : _Mybase(_Right, _Al) {}

    explicit map(const key_compare& _Pred) : _Mybase(_Pred) {}

    map(const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {}

    template <class _Iter>
    map(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {
        insert(_First, _Last);
    }

    template <class _Iter>
    map(_Iter _First, _Iter _Last, const key_compare& _Pred) : _Mybase(_Pred) {
        insert(_First, _Last);
    }

    template <class _Iter>
    map(_Iter _First, _Iter _Last, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        insert(_First, _Last);
    }

    template <class _Iter>
    map(_Iter _First, _Iter _Last, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        insert(_First, _Last);
    }


    template <_Container_compatible_range<value_type> _Rng>
    map(from_range_t, _Rng&& _Range) : _Mybase(key_compare()) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    map(from_range_t, _Rng&& _Range, const key_compare& _Pred) : _Mybase(_Pred) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    map(from_range_t, _Rng&& _Range, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    map(from_range_t, _Rng&& _Range, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }
#line 159 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

    map& operator=(const map& _Right) {
        _Mybase::operator=(_Right);
        return *this;
    }

    map(map&& _Right) : _Mybase(::std:: move(_Right)) {}

    map(map&& _Right, const allocator_type& _Al) : _Mybase(::std:: move(_Right), _Al) {}

    map& operator=(map&& _Right) noexcept(_Alnode_traits::is_always_equal::value&& is_nothrow_move_assignable_v<_Pr>) {
        _Mybase::operator=(::std:: move(_Right));
        return *this;
    }

    mapped_type& operator[](key_type&& _Keyval) { 
        return _Try_emplace(::std:: move(_Keyval)).first->_Myval.second;
    }

    void swap(map& _Right) noexcept(noexcept(_Mybase::swap(_Right))) {
        _Mybase::swap(_Right);
    }

    using _Mybase::insert;

    template <class _Valty, enable_if_t<is_constructible_v<value_type, _Valty>, int> = 0>
    pair<iterator, bool> insert(_Valty&& _Val) {
        return this->emplace(::std:: forward<_Valty>(_Val));
    }

    template <class _Valty, enable_if_t<is_constructible_v<value_type, _Valty>, int> = 0>
    iterator insert(const_iterator _Where, _Valty&& _Val) {
        return this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val));
    }

private:
    template <class _Keyty, class... _Mappedty>
    pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {
        const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);
        if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            return {_Loc._Bound, false};
        }

        _Mybase::_Check_grow_by_1();

        const auto _Scary    = _Mybase::_Get_scary();
        const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,
            ::std:: forward_as_tuple(::std:: forward<_Keyty>(_Keyval)),
            ::std:: forward_as_tuple(::std:: forward<_Mappedty>(_Mapval)...))
                                   ._Release();

        
        return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};
    }

    template <class _Keyty, class... _Mappedty>
    _Nodeptr _Try_emplace_hint(const _Nodeptr _Hint, _Keyty&& _Keyval, _Mappedty&&... _Mapval) {
        const auto _Loc = _Mybase::_Find_hint(_Hint, _Keyval);
        if (_Loc._Duplicate) {
            return _Loc._Location._Parent;
        }

        _Mybase::_Check_grow_by_1();

        const auto _Scary    = _Mybase::_Get_scary();
        const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,
            ::std:: forward_as_tuple(::std:: forward<_Keyty>(_Keyval)),
            ::std:: forward_as_tuple(::std:: forward<_Mappedty>(_Mapval)...))
                                   ._Release();

        
        return _Scary->_Insert_node(_Loc._Location, _Inserted);
    }

public:
    template <class... _Mappedty>
    pair<iterator, bool> try_emplace(const key_type& _Keyval, _Mappedty&&... _Mapval) {
        const auto _Result = _Try_emplace(_Keyval, ::std:: forward<_Mappedty>(_Mapval)...);
        return {iterator(_Result.first, _Mybase::_Get_scary()), _Result.second};
    }

    template <class... _Mappedty>
    iterator try_emplace(const const_iterator _Hint, const key_type& _Keyval, _Mappedty&&... _Mapval) {
        return iterator(
            _Try_emplace_hint(_Hint._Ptr, _Keyval, ::std:: forward<_Mappedty>(_Mapval)...), _Mybase::_Get_scary());
    }

    template <class... _Mappedty>
    pair<iterator, bool> try_emplace(key_type&& _Keyval, _Mappedty&&... _Mapval) {
        const auto _Result = _Try_emplace(::std:: move(_Keyval), ::std:: forward<_Mappedty>(_Mapval)...);
        return {iterator(_Result.first, _Mybase::_Get_scary()), _Result.second};
    }

    template <class... _Mappedty>
    iterator try_emplace(const const_iterator _Hint, key_type&& _Keyval, _Mappedty&&... _Mapval) {
        return iterator(_Try_emplace_hint(_Hint._Ptr, ::std:: move(_Keyval), ::std:: forward<_Mappedty>(_Mapval)...),
            _Mybase::_Get_scary());
    }

private:
    template <class _Keyty, class _Mappedty>
    pair<_Nodeptr, bool> _Insert_or_assign(_Keyty&& _Keyval, _Mappedty&& _Mapval) {
        const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);
        if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            _Loc._Bound->_Myval.second = ::std:: forward<_Mappedty>(_Mapval);
            return {_Loc._Bound, false};
        }

        _Mybase::_Check_grow_by_1();

        const auto _Scary    = _Mybase::_Get_scary();
        const auto _Inserted = _Tree_temp_node<_Alnode>(
            _Mybase::_Getal(), _Scary->_Myhead, ::std:: forward<_Keyty>(_Keyval), ::std:: forward<_Mappedty>(_Mapval))
                                   ._Release();

        
        return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};
    }

    template <class _Keyty, class _Mappedty>
    _Nodeptr _Insert_or_assign_hint(const _Nodeptr _Hint, _Keyty&& _Keyval, _Mappedty&& _Mapval) {
        const auto _Loc = _Mybase::_Find_hint(_Hint, _Keyval);
        if (_Loc._Duplicate) {
            _Loc._Location._Parent->_Myval.second = ::std:: forward<_Mappedty>(_Mapval);
            return _Loc._Location._Parent;
        }

        _Mybase::_Check_grow_by_1();

        const auto _Scary    = _Mybase::_Get_scary();
        const auto _Inserted = _Tree_temp_node<_Alnode>(
            _Mybase::_Getal(), _Scary->_Myhead, ::std:: forward<_Keyty>(_Keyval), ::std:: forward<_Mappedty>(_Mapval))
                                   ._Release();

        
        return _Scary->_Insert_node(_Loc._Location, _Inserted);
    }

public:
    template <class _Mappedty>
    pair<iterator, bool> insert_or_assign(const key_type& _Keyval, _Mappedty&& _Mapval) {
        const auto _Result = _Insert_or_assign(_Keyval, ::std:: forward<_Mappedty>(_Mapval));
        return {iterator(_Result.first, _Mybase::_Get_scary()), _Result.second};
    }

    template <class _Mappedty>
    iterator insert_or_assign(const const_iterator _Hint, const key_type& _Keyval, _Mappedty&& _Mapval) {
        return iterator(
            _Insert_or_assign_hint(_Hint._Ptr, _Keyval, ::std:: forward<_Mappedty>(_Mapval)), _Mybase::_Get_scary());
    }

    template <class _Mappedty>
    pair<iterator, bool> insert_or_assign(key_type&& _Keyval, _Mappedty&& _Mapval) {
        const auto _Result = _Insert_or_assign(::std:: move(_Keyval), ::std:: forward<_Mappedty>(_Mapval));
        return {iterator(_Result.first, _Mybase::_Get_scary()), _Result.second};
    }

    template <class _Mappedty>
    iterator insert_or_assign(const const_iterator _Hint, key_type&& _Keyval, _Mappedty&& _Mapval) {
        return iterator(_Insert_or_assign_hint(_Hint._Ptr, ::std:: move(_Keyval), ::std:: forward<_Mappedty>(_Mapval)),
            _Mybase::_Get_scary());
    }

    map(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {
        insert(_Ilist);
    }

    map(initializer_list<value_type> _Ilist, const key_compare& _Pred) : _Mybase(_Pred) {
        insert(_Ilist);
    }

    map(initializer_list<value_type> _Ilist, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        insert(_Ilist);
    }

    map(initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
        : _Mybase(_Pred, _Al) {
        insert(_Ilist);
    }

    map& operator=(initializer_list<value_type> _Ilist) {
        _Mybase::clear();
        insert(_Ilist);
        return *this;
    }

    mapped_type& operator[](const key_type& _Keyval) {
        return _Try_emplace(_Keyval).first->_Myval.second;
    }

    [[nodiscard]] mapped_type& at(const key_type& _Keyval) {
        const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);
        if (!_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            _Xout_of_range("invalid map<K, T> key");
        }

        return _Loc._Bound->_Myval.second;
    }

    [[nodiscard]] const mapped_type& at(const key_type& _Keyval) const {
        const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);
        if (!_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {
            _Xout_of_range("invalid map<K, T> key");
        }

        return _Loc._Bound->_Myval.second;
    }

    using _Mybase::_Unchecked_begin;
    using _Mybase::_Unchecked_end;
};


template <class _Iter, class _Pr = less<_Guide_key_t<_Iter>>, class _Alloc = allocator<_Guide_pair_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
map(_Iter, _Iter, _Pr = _Pr(), _Alloc = _Alloc()) -> map<_Guide_key_t<_Iter>, _Guide_val_t<_Iter>, _Pr, _Alloc>;

template <class _Kty, class _Ty, class _Pr = less<_Kty>, class _Alloc = allocator<pair<const _Kty, _Ty>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
map(initializer_list<pair<_Kty, _Ty>>, _Pr = _Pr(), _Alloc = _Alloc()) -> map<_Kty, _Ty, _Pr, _Alloc>;

template <class _Iter, class _Alloc, enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
map(_Iter, _Iter, _Alloc) -> map<_Guide_key_t<_Iter>, _Guide_val_t<_Iter>, less<_Guide_key_t<_Iter>>, _Alloc>;

template <class _Kty, class _Ty, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
map(initializer_list<pair<_Kty, _Ty>>, _Alloc) -> map<_Kty, _Ty, less<_Kty>, _Alloc>;


template <::std::ranges:: input_range _Rng, class _Pr = less<_Range_key_type<_Rng>>,
    class _Alloc = allocator<_Range_to_alloc_type<_Rng>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
map(from_range_t, _Rng&&, _Pr = _Pr(), _Alloc = _Alloc())
    -> map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Pr, _Alloc>;

template <::std::ranges:: input_range _Rng, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
map(from_range_t, _Rng&&, _Alloc)
    -> map<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, less<_Range_key_type<_Rng>>, _Alloc>;
#line 397 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"
#line 398 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

 template <class _Kty, class _Ty, class _Pr, class _Alloc>
[[nodiscard]] bool operator==(const map<_Kty, _Ty, _Pr, _Alloc>& _Left, const map<_Kty, _Ty, _Pr, _Alloc>& _Right) {
    return _Left.size() == _Right.size()
        && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(), _Right._Unchecked_begin());
}






#line 411 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"


 template <class _Kty, class _Ty, class _Pr, class _Alloc>
[[nodiscard]] _Synth_three_way_result<pair<const _Kty, _Ty>> operator<=>(
    const map<_Kty, _Ty, _Pr, _Alloc>& _Left, const map<_Kty, _Ty, _Pr, _Alloc>& _Right) {
    return ::std:: lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(),
        _Right._Unchecked_begin(), _Right._Unchecked_end_iter(), _Synth_three_way{});
}





















#line 441 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

 template <class _Kty, class _Ty, class _Pr, class _Alloc>
void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left, map<_Kty, _Ty, _Pr, _Alloc>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class _Kty, class _Ty, class _Keylt, class _Alloc, class _Pr>
map<_Kty, _Ty, _Keylt, _Alloc>::size_type erase_if(map<_Kty, _Ty, _Keylt, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_nodes_if(_Cont, _Pass_fn(_Pred));
}
#line 454 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

 template <class _Kty, class _Ty, class _Pr = less<_Kty>, class _Alloc = allocator<pair<const _Kty, _Ty>>>
class multimap : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true>> {
    
public:
    static_assert(!1 || is_same_v<pair<const _Kty, _Ty>, typename _Alloc::value_type>,
        "multimap<Key, Value, Compare, Allocator>" " requires that Allocator's value_type match " "pair<const Key, Value>" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Kty>, "The C++ Standard forbids containers of non-object types "
                                     "because of [container.requirements].");

    using _Mybase                = _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true>>;
    using key_type               = _Kty;
    using mapped_type            = _Ty;
    using key_compare            = _Pr;
    using value_compare          = typename _Mybase::value_compare;
    using value_type             = pair<const _Kty, _Ty>;
    using allocator_type         = typename _Mybase::allocator_type;
    using size_type              = typename _Mybase::size_type;
    using difference_type        = typename _Mybase::difference_type;
    using pointer                = typename _Mybase::pointer;
    using const_pointer          = typename _Mybase::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using iterator               = typename _Mybase::iterator;
    using const_iterator         = typename _Mybase::const_iterator;
    using reverse_iterator       = typename _Mybase::reverse_iterator;
    using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

    using _Alnode        = typename _Mybase::_Alnode;
    using _Alnode_traits = typename _Mybase::_Alnode_traits;

    multimap() : _Mybase(key_compare()) {}

    explicit multimap(const allocator_type& _Al) : _Mybase(key_compare(), _Al) {}

    multimap(const multimap& _Right)
        : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

    multimap(const multimap& _Right, const allocator_type& _Al) : _Mybase(_Right, _Al) {}

    explicit multimap(const key_compare& _Pred) : _Mybase(_Pred) {}

    multimap(const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {}

    template <class _Iter>
    multimap(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {
        insert(_First, _Last);
    }

    template <class _Iter>
    multimap(_Iter _First, _Iter _Last, const key_compare& _Pred) : _Mybase(_Pred) {
        insert(_First, _Last);
    }

    template <class _Iter>
    multimap(_Iter _First, _Iter _Last, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        insert(_First, _Last);
    }

    template <class _Iter>
    multimap(_Iter _First, _Iter _Last, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        insert(_First, _Last);
    }


    template <_Container_compatible_range<value_type> _Rng>
    multimap(from_range_t, _Rng&& _Range) : _Mybase(key_compare()) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multimap(from_range_t, _Rng&& _Range, const key_compare& _Pred) : _Mybase(_Pred) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multimap(from_range_t, _Rng&& _Range, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multimap(from_range_t, _Rng&& _Range, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }
#line 539 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

    multimap& operator=(const multimap& _Right) {
        _Mybase::operator=(_Right);
        return *this;
    }

    multimap(multimap&& _Right) : _Mybase(::std:: move(_Right)) {}

    multimap(multimap&& _Right, const allocator_type& _Al) : _Mybase(::std:: move(_Right), _Al) {}

    multimap& operator=(multimap&& _Right) noexcept(
        _Alnode_traits::is_always_equal::value&& is_nothrow_move_assignable_v<_Pr>) {
        _Mybase::operator=(::std:: move(_Right));
        return *this;
    }

    template <class... _Valty>
    iterator emplace(_Valty&&... _Val) {
        return _Mybase::emplace(::std:: forward<_Valty>(_Val)...).first;
    }

    void swap(multimap& _Right) noexcept(noexcept(_Mybase::swap(_Right))) {
        _Mybase::swap(_Right);
    }

    using _Mybase::insert;

    template <class _Valty, enable_if_t<is_constructible_v<value_type, _Valty>, int> = 0>
    iterator insert(_Valty&& _Val) {
        return this->emplace(::std:: forward<_Valty>(_Val));
    }

    template <class _Valty, enable_if_t<is_constructible_v<value_type, _Valty>, int> = 0>
    iterator insert(const_iterator _Where, _Valty&& _Val) {
        return this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val));
    }

    multimap(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {
        insert(_Ilist);
    }

    multimap(initializer_list<value_type> _Ilist, const key_compare& _Pred) : _Mybase(_Pred) {
        insert(_Ilist);
    }

    multimap(initializer_list<value_type> _Ilist, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        insert(_Ilist);
    }

    multimap(initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
        : _Mybase(_Pred, _Al) {
        insert(_Ilist);
    }

    multimap& operator=(initializer_list<value_type> _Ilist) {
        _Mybase::clear();
        insert(_Ilist);
        return *this;
    }

    using _Mybase::_Unchecked_begin;
    using _Mybase::_Unchecked_end;
};


template <class _Iter, class _Pr = less<_Guide_key_t<_Iter>>, class _Alloc = allocator<_Guide_pair_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multimap(_Iter, _Iter, _Pr = _Pr(), _Alloc = _Alloc())
    -> multimap<_Guide_key_t<_Iter>, _Guide_val_t<_Iter>, _Pr, _Alloc>;

template <class _Kty, class _Ty, class _Pr = less<_Kty>, class _Alloc = allocator<pair<const _Kty, _Ty>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multimap(initializer_list<pair<_Kty, _Ty>>, _Pr = _Pr(), _Alloc = _Alloc()) -> multimap<_Kty, _Ty, _Pr, _Alloc>;

template <class _Iter, class _Alloc, enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
multimap(_Iter, _Iter, _Alloc) -> multimap<_Guide_key_t<_Iter>, _Guide_val_t<_Iter>, less<_Guide_key_t<_Iter>>, _Alloc>;

template <class _Kty, class _Ty, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
multimap(initializer_list<pair<_Kty, _Ty>>, _Alloc) -> multimap<_Kty, _Ty, less<_Kty>, _Alloc>;


template <::std::ranges:: input_range _Rng, class _Pr = less<_Range_key_type<_Rng>>,
    class _Alloc = allocator<_Range_to_alloc_type<_Rng>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multimap(from_range_t, _Rng&&, _Pr = _Pr(), _Alloc = _Alloc())
    -> multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, _Pr, _Alloc>;

template <::std::ranges:: input_range _Rng, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
multimap(from_range_t, _Rng&&, _Alloc)
    -> multimap<_Range_key_type<_Rng>, _Range_mapped_type<_Rng>, less<_Range_key_type<_Rng>>, _Alloc>;
#line 630 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"
#line 631 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

 template <class _Kty, class _Ty, class _Pr, class _Alloc>
[[nodiscard]] bool operator==(
    const multimap<_Kty, _Ty, _Pr, _Alloc>& _Left, const multimap<_Kty, _Ty, _Pr, _Alloc>& _Right) {
    return _Left.size() == _Right.size()
        && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(), _Right._Unchecked_begin());
}







#line 646 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"


 template <class _Kty, class _Ty, class _Pr, class _Alloc>
[[nodiscard]] _Synth_three_way_result<pair<const _Kty, _Ty>> operator<=>(
    const multimap<_Kty, _Ty, _Pr, _Alloc>& _Left, const multimap<_Kty, _Ty, _Pr, _Alloc>& _Right) {
    return ::std:: lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(),
        _Right._Unchecked_begin(), _Right._Unchecked_end_iter(), _Synth_three_way{});
}

























#line 680 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"

 template <class _Kty, class _Ty, class _Pr, class _Alloc>
void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left, multimap<_Kty, _Ty, _Pr, _Alloc>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class _Kty, class _Ty, class _Keylt, class _Alloc, class _Pr>
multimap<_Kty, _Ty, _Keylt, _Alloc>::size_type erase_if(multimap<_Kty, _Ty, _Keylt, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_nodes_if(_Cont, _Pass_fn(_Pred));
}
#line 693 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"


namespace pmr {
     template <class _Kty, class _Ty, class _Pr = less<_Kty>>
    using map = ::std:: map<_Kty, _Ty, _Pr, polymorphic_allocator<pair<const _Kty, _Ty>>>;

     template <class _Kty, class _Ty, class _Pr = less<_Kty>>
    using multimap = ::std:: multimap<_Kty, _Ty, _Pr, polymorphic_allocator<pair<const _Kty, _Ty>>>;
} 
#line 703 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"
}


#pragma warning(pop)
#pragma pack(pop)
#line 709 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"
#line 710 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\map"
#pragma external_header(pop)
#line 59 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
#pragma external_header(push)
#line 1 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"













#line 15 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning(disable : 4180 4412 4455 4494 4514 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4648 4702 4793 4820 4988 5026 5027 5045 6294    )



namespace std {
template <class _Kty, 
    class _Pr, 
    class _Alloc, 
    bool _Mfl> 
class _Tset_traits { 
public:
    using key_type       = _Kty;
    using value_type     = _Kty;
    using key_compare    = _Pr;
    using allocator_type = _Alloc;

    using node_type = _Node_handle<_Tree_node<value_type, typename allocator_traits<_Alloc>::void_pointer>, _Alloc,
        _Node_handle_set_base, _Kty>;
#line 37 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

    static constexpr bool _Multi = _Mfl;

    template <class... _Args>
    using _In_place_key_extractor = _In_place_key_extract_set<_Kty, _Args...>;

    using value_compare = key_compare;

    static const _Kty& _Kfn(const value_type& _Val) { 
        return _Val;
    }
};

 template <class _Kty, class _Pr = less<_Kty>, class _Alloc = allocator<_Kty>>
class set : public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false>> {
    
public:
    static_assert(!1 || is_same_v<_Kty, typename _Alloc::value_type>,
        "set<T, Compare, Allocator>" " requires that Allocator's value_type match " "T" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Kty>, "The C++ Standard forbids containers of non-object types "
                                     "because of [container.requirements].");

    using _Mybase                = _Tree<_Tset_traits<_Kty, _Pr, _Alloc, false>>;
    using key_type               = _Kty;
    using key_compare            = _Pr;
    using value_compare          = typename _Mybase::value_compare;
    using value_type             = typename _Mybase::value_type;
    using allocator_type         = typename _Mybase::allocator_type;
    using size_type              = typename _Mybase::size_type;
    using difference_type        = typename _Mybase::difference_type;
    using pointer                = typename _Mybase::pointer;
    using const_pointer          = typename _Mybase::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using iterator               = typename _Mybase::iterator;
    using const_iterator         = typename _Mybase::const_iterator;
    using reverse_iterator       = typename _Mybase::reverse_iterator;
    using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

    using _Alnode        = typename _Mybase::_Alnode;
    using _Alnode_traits = typename _Mybase::_Alnode_traits;


    using insert_return_type = _Insert_return_type<iterator, typename _Mybase::node_type>;
#line 82 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

    set() : _Mybase(key_compare()) {}

    explicit set(const allocator_type& _Al) : _Mybase(key_compare(), _Al) {}

    set(const set& _Right) : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

    set(const set& _Right, const allocator_type& _Al) : _Mybase(_Right, _Al) {}

    explicit set(const key_compare& _Pred) : _Mybase(_Pred) {}

    set(const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {}

    template <class _Iter>
    set(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    set(_Iter _First, _Iter _Last, const key_compare& _Pred) : _Mybase(_Pred) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    set(_Iter _First, _Iter _Last, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    set(_Iter _First, _Iter _Last, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->insert(_First, _Last);
    }


    template <_Container_compatible_range<value_type> _Rng>
    set(from_range_t, _Rng&& _Range) : _Mybase(key_compare()) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    set(from_range_t, _Rng&& _Range, const key_compare& _Pred) : _Mybase(_Pred) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    set(from_range_t, _Rng&& _Range, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    set(from_range_t, _Rng&& _Range, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }
#line 136 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

    set& operator=(const set& _Right) {
        _Mybase::operator=(_Right);
        return *this;
    }

    set(set&& _Right) : _Mybase(::std:: move(_Right)) {}

    set(set&& _Right, const allocator_type& _Al) : _Mybase(::std:: move(_Right), _Al) {}

    set& operator=(set&& _Right) noexcept(_Alnode_traits::is_always_equal::value&& is_nothrow_move_assignable_v<_Pr>) {
        _Mybase::operator=(::std:: move(_Right));
        return *this;
    }

    void swap(set& _Right) noexcept(noexcept(_Mybase::swap(_Right))) {
        _Mybase::swap(_Right);
    }

    set(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {
        this->insert(_Ilist);
    }

    set(initializer_list<value_type> _Ilist, const key_compare& _Pred) : _Mybase(_Pred) {
        this->insert(_Ilist);
    }

    set(initializer_list<value_type> _Ilist, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->insert(_Ilist);
    }

    set(initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
        : _Mybase(_Pred, _Al) {
        this->insert(_Ilist);
    }

    set& operator=(initializer_list<value_type> _Ilist) {
        this->clear();
        this->insert(_Ilist);
        return *this;
    }

    using _Mybase::_Unchecked_begin;
    using _Mybase::_Unchecked_end;
};


template <class _Iter, class _Pr = less<_Iter_value_t<_Iter>>, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
set(_Iter, _Iter, _Pr = _Pr(), _Alloc = _Alloc()) -> set<_Iter_value_t<_Iter>, _Pr, _Alloc>;

template <class _Kty, class _Pr = less<_Kty>, class _Alloc = allocator<_Kty>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
set(initializer_list<_Kty>, _Pr = _Pr(), _Alloc = _Alloc()) -> set<_Kty, _Pr, _Alloc>;

template <class _Iter, class _Alloc, enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
set(_Iter, _Iter, _Alloc) -> set<_Iter_value_t<_Iter>, less<_Iter_value_t<_Iter>>, _Alloc>;

template <class _Kty, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
set(initializer_list<_Kty>, _Alloc) -> set<_Kty, less<_Kty>, _Alloc>;


template <::std::ranges:: input_range _Rng, class _Pr = less<::std::ranges:: range_value_t<_Rng>>,
    class _Alloc = allocator<::std::ranges:: range_value_t<_Rng>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
set(from_range_t, _Rng&&, _Pr = _Pr(), _Alloc = _Alloc()) -> set<::std::ranges:: range_value_t<_Rng>, _Pr, _Alloc>;

template <::std::ranges:: input_range _Rng, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
set(from_range_t, _Rng&&, _Alloc) -> set<::std::ranges:: range_value_t<_Rng>, less<::std::ranges:: range_value_t<_Rng>>, _Alloc>;
#line 206 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"
#line 207 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

 template <class _Kty, class _Pr, class _Alloc>
[[nodiscard]] bool operator==(const set<_Kty, _Pr, _Alloc>& _Left, const set<_Kty, _Pr, _Alloc>& _Right) {
    return _Left.size() == _Right.size()
        && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(), _Right._Unchecked_begin());
}






#line 220 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"


 template <class _Kty, class _Pr, class _Alloc>
[[nodiscard]] _Synth_three_way_result<_Kty> operator<=>(
    const set<_Kty, _Pr, _Alloc>& _Left, const set<_Kty, _Pr, _Alloc>& _Right) {
    return ::std:: lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(),
        _Right._Unchecked_begin(), _Right._Unchecked_end_iter(), _Synth_three_way{});
}





















#line 250 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

 template <class _Kty, class _Pr, class _Alloc>
void swap(set<_Kty, _Pr, _Alloc>& _Left, set<_Kty, _Pr, _Alloc>& _Right) noexcept(noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class _Kty, class _Keylt, class _Alloc, class _Pr>
set<_Kty, _Keylt, _Alloc>::size_type erase_if(set<_Kty, _Keylt, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_nodes_if(_Cont, _Pass_fn(_Pred));
}
#line 262 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

 template <class _Kty, class _Pr = less<_Kty>, class _Alloc = allocator<_Kty>>
class multiset : public _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true>> {
    
public:
    static_assert(!1 || is_same_v<_Kty, typename _Alloc::value_type>,
        "multiset<T, Compare, Allocator>" " requires that Allocator's value_type match " "T" " (See N4950 [container.alloc.reqmts]/5)" " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0" " to suppress this error.");
    static_assert(is_object_v<_Kty>, "The C++ Standard forbids containers of non-object types "
                                     "because of [container.requirements].");

    using _Mybase                = _Tree<_Tset_traits<_Kty, _Pr, _Alloc, true>>;
    using key_type               = _Kty;
    using key_compare            = _Pr;
    using value_compare          = typename _Mybase::value_compare;
    using value_type             = typename _Mybase::value_type;
    using allocator_type         = typename _Mybase::allocator_type;
    using size_type              = typename _Mybase::size_type;
    using difference_type        = typename _Mybase::difference_type;
    using pointer                = typename _Mybase::pointer;
    using const_pointer          = typename _Mybase::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using iterator               = typename _Mybase::iterator;
    using const_iterator         = typename _Mybase::const_iterator;
    using reverse_iterator       = typename _Mybase::reverse_iterator;
    using const_reverse_iterator = typename _Mybase::const_reverse_iterator;

    using _Alnode        = typename _Mybase::_Alnode;
    using _Alnode_traits = typename _Mybase::_Alnode_traits;

    multiset() : _Mybase(key_compare()) {}

    explicit multiset(const allocator_type& _Al) : _Mybase(key_compare(), _Al) {}

    multiset(const multiset& _Right)
        : _Mybase(_Right, _Alnode_traits::select_on_container_copy_construction(_Right._Getal())) {}

    multiset(const multiset& _Right, const allocator_type& _Al) : _Mybase(_Right, _Al) {}

    explicit multiset(const key_compare& _Pred) : _Mybase(_Pred) {}

    multiset(const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {}

    template <class _Iter>
    multiset(_Iter _First, _Iter _Last) : _Mybase(key_compare()) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    multiset(_Iter _First, _Iter _Last, const key_compare& _Pred) : _Mybase(_Pred) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    multiset(_Iter _First, _Iter _Last, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->insert(_First, _Last);
    }

    template <class _Iter>
    multiset(_Iter _First, _Iter _Last, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->insert(_First, _Last);
    }


    template <_Container_compatible_range<value_type> _Rng>
    multiset(from_range_t, _Rng&& _Range) : _Mybase(key_compare()) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multiset(from_range_t, _Rng&& _Range, const key_compare& _Pred) : _Mybase(_Pred) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multiset(from_range_t, _Rng&& _Range, const key_compare& _Pred, const allocator_type& _Al) : _Mybase(_Pred, _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }

    template <_Container_compatible_range<value_type> _Rng>
    multiset(from_range_t, _Rng&& _Range, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->_Insert_range_unchecked(::std::ranges:: _Ubegin(_Range), ::std::ranges:: _Uend(_Range));
    }
#line 346 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

    multiset& operator=(const multiset& _Right) {
        _Mybase::operator=(_Right);
        return *this;
    }

    multiset(multiset&& _Right) : _Mybase(::std:: move(_Right)) {}

    multiset(multiset&& _Right, const allocator_type& _Al) : _Mybase(::std:: move(_Right), _Al) {}

    multiset& operator=(multiset&& _Right) noexcept(
        _Alnode_traits::is_always_equal::value&& is_nothrow_move_assignable_v<_Pr>) {
        _Mybase::operator=(::std:: move(_Right));
        return *this;
    }

    template <class... _Valty>
    iterator emplace(_Valty&&... _Val) {
        return _Mybase::emplace(::std:: forward<_Valty>(_Val)...).first;
    }

    void swap(multiset& _Right) noexcept(noexcept(_Mybase::swap(_Right))) {
        _Mybase::swap(_Right);
    }

    multiset(initializer_list<value_type> _Ilist) : _Mybase(key_compare()) {
        this->insert(_Ilist);
    }

    multiset(initializer_list<value_type> _Ilist, const key_compare& _Pred) : _Mybase(_Pred) {
        this->insert(_Ilist);
    }

    multiset(initializer_list<value_type> _Ilist, const allocator_type& _Al) : _Mybase(key_compare(), _Al) {
        this->insert(_Ilist);
    }

    multiset(initializer_list<value_type> _Ilist, const key_compare& _Pred, const allocator_type& _Al)
        : _Mybase(_Pred, _Al) {
        this->insert(_Ilist);
    }

    multiset& operator=(initializer_list<value_type> _Ilist) {
        this->clear();
        this->insert(_Ilist);
        return *this;
    }

    using _Mybase::_Unchecked_begin;
    using _Mybase::_Unchecked_end;
};


template <class _Iter, class _Pr = less<_Iter_value_t<_Iter>>, class _Alloc = allocator<_Iter_value_t<_Iter>>,
    enable_if_t<conjunction_v<_Is_iterator<_Iter>, negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multiset(_Iter, _Iter, _Pr = _Pr(), _Alloc = _Alloc()) -> multiset<_Iter_value_t<_Iter>, _Pr, _Alloc>;

template <class _Kty, class _Pr = less<_Kty>, class _Alloc = allocator<_Kty>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multiset(initializer_list<_Kty>, _Pr = _Pr(), _Alloc = _Alloc()) -> multiset<_Kty, _Pr, _Alloc>;

template <class _Iter, class _Alloc, enable_if_t<conjunction_v<_Is_iterator<_Iter>, _Is_allocator<_Alloc>>, int> = 0>
multiset(_Iter, _Iter, _Alloc) -> multiset<_Iter_value_t<_Iter>, less<_Iter_value_t<_Iter>>, _Alloc>;

template <class _Kty, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
multiset(initializer_list<_Kty>, _Alloc) -> multiset<_Kty, less<_Kty>, _Alloc>;


template <::std::ranges:: input_range _Rng, class _Pr = less<::std::ranges:: range_value_t<_Rng>>,
    class _Alloc = allocator<::std::ranges:: range_value_t<_Rng>>,
    enable_if_t<conjunction_v<negation<_Is_allocator<_Pr>>, _Is_allocator<_Alloc>>, int> = 0>
multiset(from_range_t, _Rng&&, _Pr = _Pr(), _Alloc = _Alloc()) -> multiset<::std::ranges:: range_value_t<_Rng>, _Pr, _Alloc>;

template <::std::ranges:: input_range _Rng, class _Alloc, enable_if_t<_Is_allocator<_Alloc>::value, int> = 0>
multiset(from_range_t, _Rng&&, _Alloc)
    -> multiset<::std::ranges:: range_value_t<_Rng>, less<::std::ranges:: range_value_t<_Rng>>, _Alloc>;
#line 423 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"
#line 424 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

 template <class _Kty, class _Pr, class _Alloc>
[[nodiscard]] bool operator==(const multiset<_Kty, _Pr, _Alloc>& _Left, const multiset<_Kty, _Pr, _Alloc>& _Right) {
    return _Left.size() == _Right.size()
        && ::std:: equal(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(), _Right._Unchecked_begin());
}






#line 437 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"


 template <class _Kty, class _Pr, class _Alloc>
[[nodiscard]] _Synth_three_way_result<_Kty> operator<=>(
    const multiset<_Kty, _Pr, _Alloc>& _Left, const multiset<_Kty, _Pr, _Alloc>& _Right) {
    return ::std:: lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end_iter(),
        _Right._Unchecked_begin(), _Right._Unchecked_end_iter(), _Synth_three_way{});
}





















#line 467 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"

 template <class _Kty, class _Pr, class _Alloc>
void swap(multiset<_Kty, _Pr, _Alloc>& _Left, multiset<_Kty, _Pr, _Alloc>& _Right) noexcept(
    noexcept(_Left.swap(_Right))) {
    _Left.swap(_Right);
}


 template <class _Kty, class _Keylt, class _Alloc, class _Pr>
multiset<_Kty, _Keylt, _Alloc>::size_type erase_if(multiset<_Kty, _Keylt, _Alloc>& _Cont, _Pr _Pred) {
    return _Erase_nodes_if(_Cont, _Pass_fn(_Pred));
}
#line 480 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"


namespace pmr {
     template <class _Kty, class _Pr = less<_Kty>>
    using set = ::std:: set<_Kty, _Pr, polymorphic_allocator<_Kty>>;

     template <class _Kty, class _Pr = less<_Kty>>
    using multiset = ::std:: multiset<_Kty, _Pr, polymorphic_allocator<_Kty>>;
} 
#line 490 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"
}


#pragma warning(pop)
#pragma pack(pop)
#line 496 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"
#line 497 "C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.38.33130\\include\\set"
#pragma external_header(pop)
#line 60 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"



#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"






















































__pragma(warning(push)) __pragma(warning(disable: 4251))



void operator<<(const testing::internal::Secret&, int);

namespace testing {



























class  Message {
 private:
  
  
  typedef std::ostream& (*BasicNarrowIoManip)(std::ostream&);

 public:
  
  Message();

  
  Message(const Message& msg) : ss_(new ::std::stringstream) {  
    *ss_ << msg.GetString();
  }

  
  explicit Message(const char* str) : ss_(new ::std::stringstream) {
    *ss_ << str;
  }








#line 117 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"
  
  template <typename T>
  inline Message& operator <<(const T& val) {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    using ::operator <<;
    *ss_ << val;
    return *this;
  }

  
  
  
  
  
  
  
  
  
  
  
  
  
  template <typename T>
  inline Message& operator <<(T* const& pointer) {  
    if (pointer == 0) {
      *ss_ << "(null)";
    } else {
      *ss_ << pointer;
    }
    return *this;
  }
#line 162 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"

  
  
  
  
  
  
  Message& operator <<(BasicNarrowIoManip val) {
    *ss_ << val;
    return *this;
  }

  
  Message& operator <<(bool b) {
    return *this << (b ? "true" : "false");
  }

  
  
  Message& operator <<(const wchar_t* wide_c_str);
  Message& operator <<(wchar_t* wide_c_str);


  
  
  Message& operator <<(const ::std::wstring& wstr);
#line 189 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"





#line 195 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"

  
  
  
  
  std::string GetString() const;

 private:





















#line 225 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"

  
  const internal::scoped_ptr< ::std::stringstream> ss_;

  
  
  void operator=(const Message&);
};


inline std::ostream& operator <<(std::ostream& os, const Message& sb) {
  return os << sb.GetString();
}

namespace internal {





template <typename T>
std::string StreamableToString(const T& streamable) {
  return (Message() << streamable).GetString();
}

}  
}  

__pragma(warning(pop))  

#line 256 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-message.h"
#line 64 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-filepath.h"










































#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-string.h"





















































namespace testing {
namespace internal {


class  String {
 public:
  

  
  
  
  
  
  
  
  static const char* CloneCString(const char* c_str);

























#line 96 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-string.h"

  
  
  
  
  
  static bool CStringEquals(const char* lhs, const char* rhs);

  
  
  
  
  static std::string ShowWideCString(const wchar_t* wide_c_str);

  
  
  
  
  
  
  static bool WideCStringEquals(const wchar_t* lhs, const wchar_t* rhs);

  
  
  
  
  
  
  static bool CaseInsensitiveCStringEquals(const char* lhs,
                                           const char* rhs);

  
  
  
  
  
  
  
  
  
  
  
  
  static bool CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
                                               const wchar_t* rhs);

  
  
  static bool EndsWithCaseInsensitive(
      const std::string& str, const std::string& suffix);

  
  static std::string FormatIntWidth2(int value);  

  
  static std::string FormatHexInt(int value);

  
  static std::string FormatByte(unsigned char value);

 private:
  String();  
};  



 std::string StringStreamToString(::std::stringstream* stream);

}  
}  

#line 168 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-string.h"
#line 44 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-filepath.h"


__pragma(warning(push)) __pragma(warning(disable: 4251))

namespace testing {
namespace internal {












class  FilePath {
 public:
  FilePath() : pathname_("") { }
  FilePath(const FilePath& rhs) : pathname_(rhs.pathname_) { }

  explicit FilePath(const std::string& pathname) : pathname_(pathname) {
    Normalize();
  }

  FilePath& operator=(const FilePath& rhs) {
    Set(rhs);
    return *this;
  }

  void Set(const FilePath& rhs) {
    pathname_ = rhs.pathname_;
  }

  const std::string& string() const { return pathname_; }
  const char* c_str() const { return pathname_.c_str(); }

  
  static FilePath GetCurrentDir();

  
  
  
  
  static FilePath MakeFileName(const FilePath& directory,
                               const FilePath& base_name,
                               int number,
                               const char* extension);

  
  
  
  static FilePath ConcatPaths(const FilePath& directory,
                              const FilePath& relative_path);

  
  
  
  
  
  
  
  
  static FilePath GenerateUniqueFileName(const FilePath& directory,
                                         const FilePath& base_name,
                                         const char* extension);

  
  bool IsEmpty() const { return pathname_.empty(); }

  
  
  
  FilePath RemoveTrailingPathSeparator() const;

  
  
  
  
  
  
  FilePath RemoveDirectoryName() const;

  
  
  
  
  
  
  FilePath RemoveFileName() const;

  
  
  
  
  FilePath RemoveExtension(const char* extension) const;

  
  
  
  
  bool CreateDirectoriesRecursively() const;

  
  
  
  
  bool CreateFolder() const;

  
  
  bool FileOrDirectoryExists() const;

  
  
  bool DirectoryExists() const;

  
  
  
  bool IsDirectory() const;

  
  
  bool IsRootDirectory() const;

  
  bool IsAbsolutePath() const;

 private:
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  void Normalize();

  
  
  
  const char* FindLastPathSeparator() const;

  std::string pathname_;
};  

}  
}  

__pragma(warning(pop))  

#line 212 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-filepath.h"
#line 65 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"





















































#line 55 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"

#line 57 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"

namespace testing {
namespace internal {





inline std::string CanonicalizeForStdLibVersioning(std::string s) {
  static const char prefix[] = "std::__";
  if (s.compare(0, strlen(prefix), prefix) == 0) {
    std::string::size_type end = s.find("::", strlen(prefix));
    if (end != s.npos) {
      
      s.erase(strlen("std"), end - strlen("std"));
    }
  }
  return s;
}




template <typename T>
std::string GetTypeName() {


  const char* const name = typeid(T).name();











#line 97 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"
  return name;
#line 99 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"





#line 105 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"
}







template <typename T1, typename T2>
struct AssertTypeEq;

template <typename T>
struct AssertTypeEq<T, T> {
  typedef bool type;
};





struct None {};









struct Types0 {};



template <typename T1>
struct Types1 {
  typedef T1 Head;
  typedef Types0 Tail;
};
template <typename T1, typename T2>
struct Types2 {
  typedef T1 Head;
  typedef Types1<T2> Tail;
};

template <typename T1, typename T2, typename T3>
struct Types3 {
  typedef T1 Head;
  typedef Types2<T2, T3> Tail;
};

template <typename T1, typename T2, typename T3, typename T4>
struct Types4 {
  typedef T1 Head;
  typedef Types3<T2, T3, T4> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct Types5 {
  typedef T1 Head;
  typedef Types4<T2, T3, T4, T5> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
struct Types6 {
  typedef T1 Head;
  typedef Types5<T2, T3, T4, T5, T6> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
struct Types7 {
  typedef T1 Head;
  typedef Types6<T2, T3, T4, T5, T6, T7> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
struct Types8 {
  typedef T1 Head;
  typedef Types7<T2, T3, T4, T5, T6, T7, T8> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
struct Types9 {
  typedef T1 Head;
  typedef Types8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
struct Types10 {
  typedef T1 Head;
  typedef Types9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
struct Types11 {
  typedef T1 Head;
  typedef Types10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
struct Types12 {
  typedef T1 Head;
  typedef Types11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
struct Types13 {
  typedef T1 Head;
  typedef Types12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
struct Types14 {
  typedef T1 Head;
  typedef Types13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
struct Types15 {
  typedef T1 Head;
  typedef Types14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
struct Types16 {
  typedef T1 Head;
  typedef Types15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
struct Types17 {
  typedef T1 Head;
  typedef Types16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
struct Types18 {
  typedef T1 Head;
  typedef Types17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
struct Types19 {
  typedef T1 Head;
  typedef Types18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
struct Types20 {
  typedef T1 Head;
  typedef Types19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
struct Types21 {
  typedef T1 Head;
  typedef Types20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
struct Types22 {
  typedef T1 Head;
  typedef Types21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
struct Types23 {
  typedef T1 Head;
  typedef Types22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
struct Types24 {
  typedef T1 Head;
  typedef Types23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
struct Types25 {
  typedef T1 Head;
  typedef Types24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
struct Types26 {
  typedef T1 Head;
  typedef Types25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
struct Types27 {
  typedef T1 Head;
  typedef Types26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
struct Types28 {
  typedef T1 Head;
  typedef Types27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
struct Types29 {
  typedef T1 Head;
  typedef Types28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
struct Types30 {
  typedef T1 Head;
  typedef Types29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
struct Types31 {
  typedef T1 Head;
  typedef Types30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
struct Types32 {
  typedef T1 Head;
  typedef Types31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
struct Types33 {
  typedef T1 Head;
  typedef Types32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
struct Types34 {
  typedef T1 Head;
  typedef Types33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
struct Types35 {
  typedef T1 Head;
  typedef Types34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
struct Types36 {
  typedef T1 Head;
  typedef Types35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
struct Types37 {
  typedef T1 Head;
  typedef Types36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
struct Types38 {
  typedef T1 Head;
  typedef Types37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
struct Types39 {
  typedef T1 Head;
  typedef Types38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
struct Types40 {
  typedef T1 Head;
  typedef Types39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
struct Types41 {
  typedef T1 Head;
  typedef Types40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
struct Types42 {
  typedef T1 Head;
  typedef Types41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
struct Types43 {
  typedef T1 Head;
  typedef Types42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
struct Types44 {
  typedef T1 Head;
  typedef Types43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
struct Types45 {
  typedef T1 Head;
  typedef Types44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
struct Types46 {
  typedef T1 Head;
  typedef Types45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
struct Types47 {
  typedef T1 Head;
  typedef Types46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
struct Types48 {
  typedef T1 Head;
  typedef Types47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
struct Types49 {
  typedef T1 Head;
  typedef Types48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48, T49> Tail;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
struct Types50 {
  typedef T1 Head;
  typedef Types49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
      T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
      T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
      T44, T45, T46, T47, T48, T49, T50> Tail;
};


}  














template <typename T1 = internal::None, typename T2 = internal::None,
    typename T3 = internal::None, typename T4 = internal::None,
    typename T5 = internal::None, typename T6 = internal::None,
    typename T7 = internal::None, typename T8 = internal::None,
    typename T9 = internal::None, typename T10 = internal::None,
    typename T11 = internal::None, typename T12 = internal::None,
    typename T13 = internal::None, typename T14 = internal::None,
    typename T15 = internal::None, typename T16 = internal::None,
    typename T17 = internal::None, typename T18 = internal::None,
    typename T19 = internal::None, typename T20 = internal::None,
    typename T21 = internal::None, typename T22 = internal::None,
    typename T23 = internal::None, typename T24 = internal::None,
    typename T25 = internal::None, typename T26 = internal::None,
    typename T27 = internal::None, typename T28 = internal::None,
    typename T29 = internal::None, typename T30 = internal::None,
    typename T31 = internal::None, typename T32 = internal::None,
    typename T33 = internal::None, typename T34 = internal::None,
    typename T35 = internal::None, typename T36 = internal::None,
    typename T37 = internal::None, typename T38 = internal::None,
    typename T39 = internal::None, typename T40 = internal::None,
    typename T41 = internal::None, typename T42 = internal::None,
    typename T43 = internal::None, typename T44 = internal::None,
    typename T45 = internal::None, typename T46 = internal::None,
    typename T47 = internal::None, typename T48 = internal::None,
    typename T49 = internal::None, typename T50 = internal::None>
struct Types {
  typedef internal::Types50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50> type;
};

template <>
struct Types<internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types0 type;
};
template <typename T1>
struct Types<T1, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types1<T1> type;
};
template <typename T1, typename T2>
struct Types<T1, T2, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types2<T1, T2> type;
};
template <typename T1, typename T2, typename T3>
struct Types<T1, T2, T3, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types3<T1, T2, T3> type;
};
template <typename T1, typename T2, typename T3, typename T4>
struct Types<T1, T2, T3, T4, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types4<T1, T2, T3, T4> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5>
struct Types<T1, T2, T3, T4, T5, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types5<T1, T2, T3, T4, T5> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
struct Types<T1, T2, T3, T4, T5, T6, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types6<T1, T2, T3, T4, T5, T6> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
struct Types<T1, T2, T3, T4, T5, T6, T7, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types7<T1, T2, T3, T4, T5, T6, T7> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types8<T1, T2, T3, T4, T5, T6, T7, T8> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, internal::None,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None, internal::None> {
  typedef internal::Types43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    internal::None, internal::None, internal::None, internal::None,
    internal::None, internal::None> {
  typedef internal::Types44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    internal::None, internal::None, internal::None, internal::None,
    internal::None> {
  typedef internal::Types45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, internal::None, internal::None, internal::None, internal::None> {
  typedef internal::Types46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, internal::None, internal::None, internal::None> {
  typedef internal::Types47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, T48, internal::None, internal::None> {
  typedef internal::Types48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48> type;
};
template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
struct Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15,
    T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
    T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
    T46, T47, T48, T49, internal::None> {
  typedef internal::Types49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49> type;
};

namespace internal {











template <template <typename T> class Tmpl>
struct TemplateSel {
  template <typename T>
  struct Bind {
    typedef Tmpl<T> type;
  };
};








template <typename T>
struct NoneT {};









struct Templates0 {};



template <template <typename T> class T1>
struct Templates1 {
  typedef TemplateSel<T1> Head;
  typedef Templates0 Tail;
};
template <template <typename T> class T1, template <typename T> class T2>
struct Templates2 {
  typedef TemplateSel<T1> Head;
  typedef Templates1<T2> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3>
struct Templates3 {
  typedef TemplateSel<T1> Head;
  typedef Templates2<T2, T3> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4>
struct Templates4 {
  typedef TemplateSel<T1> Head;
  typedef Templates3<T2, T3, T4> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5>
struct Templates5 {
  typedef TemplateSel<T1> Head;
  typedef Templates4<T2, T3, T4, T5> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6>
struct Templates6 {
  typedef TemplateSel<T1> Head;
  typedef Templates5<T2, T3, T4, T5, T6> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7>
struct Templates7 {
  typedef TemplateSel<T1> Head;
  typedef Templates6<T2, T3, T4, T5, T6, T7> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8>
struct Templates8 {
  typedef TemplateSel<T1> Head;
  typedef Templates7<T2, T3, T4, T5, T6, T7, T8> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9>
struct Templates9 {
  typedef TemplateSel<T1> Head;
  typedef Templates8<T2, T3, T4, T5, T6, T7, T8, T9> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10>
struct Templates10 {
  typedef TemplateSel<T1> Head;
  typedef Templates9<T2, T3, T4, T5, T6, T7, T8, T9, T10> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11>
struct Templates11 {
  typedef TemplateSel<T1> Head;
  typedef Templates10<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12>
struct Templates12 {
  typedef TemplateSel<T1> Head;
  typedef Templates11<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13>
struct Templates13 {
  typedef TemplateSel<T1> Head;
  typedef Templates12<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14>
struct Templates14 {
  typedef TemplateSel<T1> Head;
  typedef Templates13<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15>
struct Templates15 {
  typedef TemplateSel<T1> Head;
  typedef Templates14<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16>
struct Templates16 {
  typedef TemplateSel<T1> Head;
  typedef Templates15<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17>
struct Templates17 {
  typedef TemplateSel<T1> Head;
  typedef Templates16<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18>
struct Templates18 {
  typedef TemplateSel<T1> Head;
  typedef Templates17<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19>
struct Templates19 {
  typedef TemplateSel<T1> Head;
  typedef Templates18<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20>
struct Templates20 {
  typedef TemplateSel<T1> Head;
  typedef Templates19<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21>
struct Templates21 {
  typedef TemplateSel<T1> Head;
  typedef Templates20<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22>
struct Templates22 {
  typedef TemplateSel<T1> Head;
  typedef Templates21<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23>
struct Templates23 {
  typedef TemplateSel<T1> Head;
  typedef Templates22<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24>
struct Templates24 {
  typedef TemplateSel<T1> Head;
  typedef Templates23<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25>
struct Templates25 {
  typedef TemplateSel<T1> Head;
  typedef Templates24<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26>
struct Templates26 {
  typedef TemplateSel<T1> Head;
  typedef Templates25<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27>
struct Templates27 {
  typedef TemplateSel<T1> Head;
  typedef Templates26<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28>
struct Templates28 {
  typedef TemplateSel<T1> Head;
  typedef Templates27<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29>
struct Templates29 {
  typedef TemplateSel<T1> Head;
  typedef Templates28<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30>
struct Templates30 {
  typedef TemplateSel<T1> Head;
  typedef Templates29<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31>
struct Templates31 {
  typedef TemplateSel<T1> Head;
  typedef Templates30<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32>
struct Templates32 {
  typedef TemplateSel<T1> Head;
  typedef Templates31<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33>
struct Templates33 {
  typedef TemplateSel<T1> Head;
  typedef Templates32<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34>
struct Templates34 {
  typedef TemplateSel<T1> Head;
  typedef Templates33<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35>
struct Templates35 {
  typedef TemplateSel<T1> Head;
  typedef Templates34<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36>
struct Templates36 {
  typedef TemplateSel<T1> Head;
  typedef Templates35<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37>
struct Templates37 {
  typedef TemplateSel<T1> Head;
  typedef Templates36<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38>
struct Templates38 {
  typedef TemplateSel<T1> Head;
  typedef Templates37<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39>
struct Templates39 {
  typedef TemplateSel<T1> Head;
  typedef Templates38<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40>
struct Templates40 {
  typedef TemplateSel<T1> Head;
  typedef Templates39<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41>
struct Templates41 {
  typedef TemplateSel<T1> Head;
  typedef Templates40<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42>
struct Templates42 {
  typedef TemplateSel<T1> Head;
  typedef Templates41<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43>
struct Templates43 {
  typedef TemplateSel<T1> Head;
  typedef Templates42<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44>
struct Templates44 {
  typedef TemplateSel<T1> Head;
  typedef Templates43<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45>
struct Templates45 {
  typedef TemplateSel<T1> Head;
  typedef Templates44<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46>
struct Templates46 {
  typedef TemplateSel<T1> Head;
  typedef Templates45<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47>
struct Templates47 {
  typedef TemplateSel<T1> Head;
  typedef Templates46<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48>
struct Templates48 {
  typedef TemplateSel<T1> Head;
  typedef Templates47<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49>
struct Templates49 {
  typedef TemplateSel<T1> Head;
  typedef Templates48<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48, T49> Tail;
};

template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49, template <typename T> class T50>
struct Templates50 {
  typedef TemplateSel<T1> Head;
  typedef Templates49<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
      T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
      T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
      T43, T44, T45, T46, T47, T48, T49, T50> Tail;
};















template <template <typename T> class T1 = NoneT, template <typename T> class T2 = NoneT,
    template <typename T> class T3 = NoneT, template <typename T> class T4 = NoneT,
    template <typename T> class T5 = NoneT, template <typename T> class T6 = NoneT,
    template <typename T> class T7 = NoneT, template <typename T> class T8 = NoneT,
    template <typename T> class T9 = NoneT, template <typename T> class T10 = NoneT,
    template <typename T> class T11 = NoneT, template <typename T> class T12 = NoneT,
    template <typename T> class T13 = NoneT, template <typename T> class T14 = NoneT,
    template <typename T> class T15 = NoneT, template <typename T> class T16 = NoneT,
    template <typename T> class T17 = NoneT, template <typename T> class T18 = NoneT,
    template <typename T> class T19 = NoneT, template <typename T> class T20 = NoneT,
    template <typename T> class T21 = NoneT, template <typename T> class T22 = NoneT,
    template <typename T> class T23 = NoneT, template <typename T> class T24 = NoneT,
    template <typename T> class T25 = NoneT, template <typename T> class T26 = NoneT,
    template <typename T> class T27 = NoneT, template <typename T> class T28 = NoneT,
    template <typename T> class T29 = NoneT, template <typename T> class T30 = NoneT,
    template <typename T> class T31 = NoneT, template <typename T> class T32 = NoneT,
    template <typename T> class T33 = NoneT, template <typename T> class T34 = NoneT,
    template <typename T> class T35 = NoneT, template <typename T> class T36 = NoneT,
    template <typename T> class T37 = NoneT, template <typename T> class T38 = NoneT,
    template <typename T> class T39 = NoneT, template <typename T> class T40 = NoneT,
    template <typename T> class T41 = NoneT, template <typename T> class T42 = NoneT,
    template <typename T> class T43 = NoneT, template <typename T> class T44 = NoneT,
    template <typename T> class T45 = NoneT, template <typename T> class T46 = NoneT,
    template <typename T> class T47 = NoneT, template <typename T> class T48 = NoneT,
    template <typename T> class T49 = NoneT, template <typename T> class T50 = NoneT>
struct Templates {
  typedef Templates50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48, T49, T50> type;
};

template <>
struct Templates<NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates0 type;
};
template <template <typename T> class T1>
struct Templates<T1, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates1<T1> type;
};
template <template <typename T> class T1, template <typename T> class T2>
struct Templates<T1, T2, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates2<T1, T2> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3>
struct Templates<T1, T2, T3, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates3<T1, T2, T3> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4>
struct Templates<T1, T2, T3, T4, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates4<T1, T2, T3, T4> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5>
struct Templates<T1, T2, T3, T4, T5, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates5<T1, T2, T3, T4, T5> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6>
struct Templates<T1, T2, T3, T4, T5, T6, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates6<T1, T2, T3, T4, T5, T6> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7>
struct Templates<T1, T2, T3, T4, T5, T6, T7, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates7<T1, T2, T3, T4, T5, T6, T7> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates8<T1, T2, T3, T4, T5, T6, T7, T8> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates9<T1, T2, T3, T4, T5, T6, T7, T8, T9> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT> {
  typedef Templates21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT> {
  typedef Templates24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT> {
  typedef Templates28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT> {
  typedef Templates29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, NoneT, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, NoneT, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, NoneT, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, NoneT, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, NoneT,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    NoneT, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, NoneT, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, NoneT, NoneT, NoneT, NoneT> {
  typedef Templates46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, NoneT, NoneT, NoneT> {
  typedef Templates47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, T48, NoneT, NoneT> {
  typedef Templates48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48> type;
};
template <template <typename T> class T1, template <typename T> class T2, template <typename T> class T3,
    template <typename T> class T4, template <typename T> class T5, template <typename T> class T6,
    template <typename T> class T7, template <typename T> class T8, template <typename T> class T9,
    template <typename T> class T10, template <typename T> class T11, template <typename T> class T12,
    template <typename T> class T13, template <typename T> class T14, template <typename T> class T15,
    template <typename T> class T16, template <typename T> class T17, template <typename T> class T18,
    template <typename T> class T19, template <typename T> class T20, template <typename T> class T21,
    template <typename T> class T22, template <typename T> class T23, template <typename T> class T24,
    template <typename T> class T25, template <typename T> class T26, template <typename T> class T27,
    template <typename T> class T28, template <typename T> class T29, template <typename T> class T30,
    template <typename T> class T31, template <typename T> class T32, template <typename T> class T33,
    template <typename T> class T34, template <typename T> class T35, template <typename T> class T36,
    template <typename T> class T37, template <typename T> class T38, template <typename T> class T39,
    template <typename T> class T40, template <typename T> class T41, template <typename T> class T42,
    template <typename T> class T43, template <typename T> class T44, template <typename T> class T45,
    template <typename T> class T46, template <typename T> class T47, template <typename T> class T48,
    template <typename T> class T49>
struct Templates<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14,
    T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29,
    T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44,
    T45, T46, T47, T48, T49, NoneT> {
  typedef Templates49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
      T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
      T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
      T42, T43, T44, T45, T46, T47, T48, T49> type;
};





template <typename T>
struct TypeList {
  typedef Types1<T> type;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
struct TypeList<Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49, T50> > {
  typedef typename Types<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
      T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
      T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
      T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>::type type;
};

#line 3344 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"

}  
}  

#line 3349 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-type-util.h"
#line 67 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"















class ProtocolMessage;
namespace proto2 { class Message; }

namespace testing {



class AssertionResult;                 
class Message;                         
class Test;                            
class TestInfo;                        
class TestPartResult;                  
class UnitTest;                        

template <typename T>
::std::string PrintToString(const T& value);

namespace internal {

struct TraceInfo;                      
class TestInfoImpl;                    
class UnitTestImpl;                    



 extern const char kStackTraceMarker[];















char IsNullLiteralHelper(Secret* p);
char (&IsNullLiteralHelper(...))[2];  











#line 137 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"


 std::string AppendUserMessage(
    const std::string& gtest_msg, const Message& user_msg);




__pragma(warning(push)) __pragma(warning(disable: 4275))







class  GoogleTestFailureException : public ::std::runtime_error {
 public:
  explicit GoogleTestFailureException(const TestPartResult& failure);
};

__pragma(warning(pop))  

#line 161 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"

namespace edit_distance {





enum EditType { kMatch, kAdd, kRemove, kReplace };
 std::vector<EditType> CalculateOptimalEdits(
    const std::vector<size_t>& left, const std::vector<size_t>& right);


 std::vector<EditType> CalculateOptimalEdits(
    const std::vector<std::string>& left,
    const std::vector<std::string>& right);


 std::string CreateUnifiedDiff(const std::vector<std::string>& left,
                                         const std::vector<std::string>& right,
                                         size_t context = 2);

}  





 std::string DiffStrings(const std::string& left,
                                   const std::string& right,
                                   size_t* total_line_count);
















 AssertionResult EqFailure(const char* expected_expression,
                                     const char* actual_expression,
                                     const std::string& expected_value,
                                     const std::string& actual_value,
                                     bool ignoring_case);


 std::string GetBoolAssertionFailureMessage(
    const AssertionResult& assertion_result,
    const char* expression_text,
    const char* actual_predicate_value,
    const char* expected_predicate_value);






























template <typename RawType>
class FloatingPoint {
 public:
  
  
  typedef typename TypeWithSize<sizeof(RawType)>::UInt Bits;

  

  
  static const size_t kBitCount = 8*sizeof(RawType);

  
  static const size_t kFractionBitCount =
    std::numeric_limits<RawType>::digits - 1;

  
  static const size_t kExponentBitCount = kBitCount - 1 - kFractionBitCount;

  
  static const Bits kSignBitMask = static_cast<Bits>(1) << (kBitCount - 1);

  
  static const Bits kFractionBitMask =
    ~static_cast<Bits>(0) >> (kExponentBitCount + 1);

  
  static const Bits kExponentBitMask = ~(kSignBitMask | kFractionBitMask);

  
  
  
  
  
  
  
  
  
  
  
  
  static const size_t kMaxUlps = 4;

  
  
  
  
  
  
  explicit FloatingPoint(const RawType& x) { u_.value_ = x; }

  

  
  
  
  static RawType ReinterpretBits(const Bits bits) {
    FloatingPoint fp(0);
    fp.u_.bits_ = bits;
    return fp.u_.value_;
  }

  
  static RawType Infinity() {
    return ReinterpretBits(kExponentBitMask);
  }

  
  static RawType Max();

  

  
  const Bits &bits() const { return u_.bits_; }

  
  Bits exponent_bits() const { return kExponentBitMask & u_.bits_; }

  
  Bits fraction_bits() const { return kFractionBitMask & u_.bits_; }

  
  Bits sign_bit() const { return kSignBitMask & u_.bits_; }

  
  bool is_nan() const {
    
    
    return (exponent_bits() == kExponentBitMask) && (fraction_bits() != 0);
  }

  
  
  
  
  
  
  bool AlmostEquals(const FloatingPoint& rhs) const {
    
    
    if (is_nan() || rhs.is_nan()) return false;

    return DistanceBetweenSignAndMagnitudeNumbers(u_.bits_, rhs.u_.bits_)
        <= kMaxUlps;
  }

 private:
  
  union FloatingPointUnion {
    RawType value_;  
    Bits bits_;      
  };

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  static Bits SignAndMagnitudeToBiased(const Bits &sam) {
    if (kSignBitMask & sam) {
      
      return ~sam + 1;
    } else {
      
      return kSignBitMask | sam;
    }
  }

  
  
  static Bits DistanceBetweenSignAndMagnitudeNumbers(const Bits &sam1,
                                                     const Bits &sam2) {
    const Bits biased1 = SignAndMagnitudeToBiased(sam1);
    const Bits biased2 = SignAndMagnitudeToBiased(sam2);
    return (biased1 >= biased2) ? (biased1 - biased2) : (biased2 - biased1);
  }

  FloatingPointUnion u_;
};



template <>
inline float FloatingPoint<float>::Max() { return 3.402823466e+38F; }
template <>
inline double FloatingPoint<double>::Max() { return 1.7976931348623158e+308; }



typedef FloatingPoint<float> Float;
typedef FloatingPoint<double> Double;







typedef const void* TypeId;

template <typename T>
class TypeIdHelper {
 public:
  
  
  
  static bool dummy_;
};

template <typename T>
bool TypeIdHelper<T>::dummy_ = false;




template <typename T>
TypeId GetTypeId() {
  
  
  
  
  return &(TypeIdHelper<T>::dummy_);
}






 TypeId GetTestTypeId();



class TestFactoryBase {
 public:
  virtual ~TestFactoryBase() {}

  
  
  virtual Test* CreateTest() = 0;

 protected:
  TestFactoryBase() {}

 private:
  TestFactoryBase(TestFactoryBase const &) = delete; void operator=(TestFactoryBase const &) = delete;
};



template <class TestClass>
class TestFactoryImpl : public TestFactoryBase {
 public:
  virtual Test* CreateTest() { return new TestClass; }
};







 AssertionResult IsHRESULTSuccess(const char* expr,
                                            long hr);  
 AssertionResult IsHRESULTFailure(const char* expr,
                                            long hr);  

#line 487 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"


typedef void (*SetUpTestCaseFunc)();
typedef void (*TearDownTestCaseFunc)();

struct CodeLocation {
  CodeLocation(const std::string& a_file, int a_line)
      : file(a_file), line(a_line) {}

  std::string file;
  int line;
};



















 TestInfo* MakeAndRegisterTestInfo(
    const char* test_case_name,
    const char* name,
    const char* type_param,
    const char* value_param,
    CodeLocation code_location,
    TypeId fixture_class_id,
    SetUpTestCaseFunc set_up_tc,
    TearDownTestCaseFunc tear_down_tc,
    TestFactoryBase* factory);




 bool SkipPrefix(const char* prefix, const char** pstr);




__pragma(warning(push)) __pragma(warning(disable: 4251))


class  TypedTestCasePState {
 public:
  TypedTestCasePState() : registered_(false) {}

  
  
  
  bool AddTestName(const char* file, int line, const char* case_name,
                   const char* test_name) {
    if (registered_) {
      fprintf((__acrt_iob_func(2)), "%s Test %s must be defined before "
              "REGISTER_TYPED_TEST_CASE_P(%s, ...).\n",
              FormatFileLocation(file, line).c_str(), test_name, case_name);
      fflush((__acrt_iob_func(2)));
      posix::Abort();
    }
    registered_tests_.insert(
        ::std::make_pair(test_name, CodeLocation(file, line)));
    return true;
  }

  bool TestExists(const std::string& test_name) const {
    return registered_tests_.count(test_name) > 0;
  }

  const CodeLocation& GetCodeLocation(const std::string& test_name) const {
    RegisteredTestsMap::const_iterator it = registered_tests_.find(test_name);
    switch (0) case 0: default: if (::testing::internal::IsTrue(it != registered_tests_.end())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h", 567).GetStream() << "Condition " "it != registered_tests_.end()" " failed. ";
    return it->second;
  }

  
  
  
  const char* VerifyRegisteredTestNames(
      const char* file, int line, const char* registered_tests);

 private:
  typedef ::std::map<std::string, CodeLocation> RegisteredTestsMap;

  bool registered_;
  RegisteredTestsMap registered_tests_;
};

__pragma(warning(pop))  



inline const char* SkipComma(const char* str) {
  const char* comma = strchr(str, ',');
  if (comma == 0) {
    return 0;
  }
  while (IsSpace(*(++comma))) {}
  return comma;
}



inline std::string GetPrefixUntilComma(const char* str) {
  const char* comma = strchr(str, ',');
  return comma == 0 ? str : std::string(str, comma);
}



void SplitString(const ::std::string& str, char delimiter,
                 ::std::vector< ::std::string>* dest);



struct DefaultNameGenerator {
  template <typename T>
  static std::string GetName(int i) {
    return StreamableToString(i);
  }
};

template <typename Provided = DefaultNameGenerator>
struct NameGeneratorSelector {
  typedef Provided type;
};

template <typename NameGenerator>
void GenerateNamesRecursively(Types0, std::vector<std::string>*, int) {}

template <typename NameGenerator, typename Types>
void GenerateNamesRecursively(Types, std::vector<std::string>* result, int i) {
  result->push_back(NameGenerator::template GetName<typename Types::Head>(i));
  GenerateNamesRecursively<NameGenerator>(typename Types::Tail(), result,
                                          i + 1);
}

template <typename NameGenerator, typename Types>
std::vector<std::string> GenerateNames() {
  std::vector<std::string> result;
  GenerateNamesRecursively<NameGenerator>(Types(), &result, 0);
  return result;
}








template <template <typename T> class Fixture, class TestSel, typename Types>
class TypeParameterizedTest {
 public:
  
  
  
  
  static bool Register(const char* prefix, const CodeLocation& code_location,
                       const char* case_name, const char* test_names, int index,
                       const std::vector<std::string>& type_names =
                           GenerateNames<DefaultNameGenerator, Types>()) {
    typedef typename Types::Head Type;
    typedef Fixture<Type> FixtureClass;
    typedef typename TestSel::template Bind<Type>::type TestClass;

    
    
    MakeAndRegisterTestInfo(
        (std::string(prefix) + (prefix[0] == '\0' ? "" : "/") + case_name +
         "/" + type_names[index])
            .c_str(),
        StripTrailingSpaces(GetPrefixUntilComma(test_names)).c_str(),
        GetTypeName<Type>().c_str(),
        0,  
        code_location, GetTypeId<FixtureClass>(), TestClass::SetUpTestCase,
        TestClass::TearDownTestCase, new TestFactoryImpl<TestClass>);

    
    return TypeParameterizedTest<Fixture, TestSel,
                                 typename Types::Tail>::Register(prefix,
                                                                 code_location,
                                                                 case_name,
                                                                 test_names,
                                                                 index + 1,
                                                                 type_names);
  }
};


template <template <typename T> class Fixture, class TestSel>
class TypeParameterizedTest<Fixture, TestSel, Types0> {
 public:
  static bool Register(const char* , const CodeLocation&,
                       const char* , const char* ,
                       int ,
                       const std::vector<std::string>& =
                           std::vector<std::string>() ) {
    return true;
  }
};





template <template <typename T> class Fixture, typename Tests, typename Types>
class TypeParameterizedTestCase {
 public:
  static bool Register(const char* prefix, CodeLocation code_location,
                       const TypedTestCasePState* state, const char* case_name,
                       const char* test_names,
                       const std::vector<std::string>& type_names =
                           GenerateNames<DefaultNameGenerator, Types>()) {
    std::string test_name = StripTrailingSpaces(
        GetPrefixUntilComma(test_names));
    if (!state->TestExists(test_name)) {
      fprintf((__acrt_iob_func(2)), "Failed to get code location for test %s.%s at %s.",
              case_name, test_name.c_str(),
              FormatFileLocation(code_location.file.c_str(),
                                 code_location.line).c_str());
      fflush((__acrt_iob_func(2)));
      posix::Abort();
    }
    const CodeLocation& test_location = state->GetCodeLocation(test_name);

    typedef typename Tests::Head Head;

    
    TypeParameterizedTest<Fixture, Head, Types>::Register(
        prefix, test_location, case_name, test_names, 0, type_names);

    
    return TypeParameterizedTestCase<Fixture, typename Tests::Tail,
                                     Types>::Register(prefix, code_location,
                                                      state, case_name,
                                                      SkipComma(test_names),
                                                      type_names);
  }
};


template <template <typename T> class Fixture, typename Types>
class TypeParameterizedTestCase<Fixture, Templates0, Types> {
 public:
  static bool Register(const char* , const CodeLocation&,
                       const TypedTestCasePState* ,
                       const char* , const char* ,
                       const std::vector<std::string>& =
                           std::vector<std::string>() ) {
    return true;
  }
};

#line 751 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"











 std::string GetCurrentOsStackTraceExceptTop(
    UnitTest* unit_test, int skip_count);





 bool AlwaysTrue();


inline bool AlwaysFalse() { return !AlwaysTrue(); }




struct  ConstCharPtr {
  ConstCharPtr(const char* str) : value(str) {}
  operator bool() const { return true; }
  const char* value;
};






class  Random {
 public:
  static const UInt32 kMaxRange = 1u << 31;

  explicit Random(UInt32 seed) : state_(seed) {}

  void Reseed(UInt32 seed) { state_ = seed; }

  
  
  UInt32 Generate(UInt32 range);

 private:
  UInt32 state_;
  Random(Random const &) = delete; void operator=(Random const &) = delete;
};



template <typename T1, typename T2>
struct CompileAssertTypesEqual;

template <typename T>
struct CompileAssertTypesEqual<T, T> {
};




template <typename T>
struct RemoveReference { typedef T type; };  
template <typename T>
struct RemoveReference<T&> { typedef T type; };  









template <typename T>
struct RemoveConst { typedef T type; };  
template <typename T>
struct RemoveConst<const T> { typedef T type; };  




template <typename T, size_t N>
struct RemoveConst<const T[N]> {
  typedef typename RemoveConst<T>::type type[N];
};









#line 852 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"













template <typename From, typename To>
class ImplicitlyConvertible {
 private:
  
  

  
  
  
  static typename AddReference<From>::type MakeFrom();

  
  
  
  
  
  
  
  
  
  
  static char Helper(To);
  static char (&Helper(...))[2];  

  
  
 public:





#line 898 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
  
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4244))
  static const bool value =
      sizeof(Helper(ImplicitlyConvertible::MakeFrom())) == 1;
  __pragma(warning(pop))
#line 906 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
};
template <typename From, typename To>
const bool ImplicitlyConvertible<From, To>::value;




template <typename T>
struct IsAProtocolMessage
    : public bool_constant<
  ImplicitlyConvertible<const T*, const ::ProtocolMessage*>::value ||
  ImplicitlyConvertible<const T*, const ::proto2::Message*>::value> {
};

























typedef int IsContainer;

template <class C,
          class Iterator = decltype(::std::declval<const C&>().begin()),
          class = decltype(::std::declval<const C&>().end()),
          class = decltype(++::std::declval<Iterator&>()),
          class = decltype(*::std::declval<Iterator>()),
          class = typename C::const_iterator>
IsContainer IsContainerTest(int ) {
  return 0;
}







#line 963 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"

typedef char IsNotContainer;
template <class C>
IsNotContainer IsContainerTest(long ) { return '\0'; }





template <typename T>
struct IsHashTable {
 private:
  template <typename U>
  static char test(typename U::hasher*, typename U::reverse_iterator*);
  template <typename U>
  static int test(typename U::hasher*, ...);
  template <typename U>
  static char test(...);

 public:
  static const bool value = sizeof(test<T>(0, 0)) == sizeof(int);
};

template <typename T>
const bool IsHashTable<T>::value;

template<typename T>
struct VoidT {
    typedef void value_type;
};

template <typename T, typename = void>
struct HasValueType : false_type {};
template <typename T>
struct HasValueType<T, VoidT<typename T::value_type> > : true_type {
};

template <typename C,
          bool = sizeof(IsContainerTest<C>(0)) == sizeof(IsContainer),
          bool = HasValueType<C>::value>
struct IsRecursiveContainerImpl;

template <typename C, bool HV>
struct IsRecursiveContainerImpl<C, false, HV> : public false_type {};





template <typename C>
struct IsRecursiveContainerImpl<C, true, false> : public false_type {};

template <typename C>
struct IsRecursiveContainerImpl<C, true, true> {
  
  typedef typename IteratorTraits<typename C::const_iterator>::value_type
      value_type;


#line 1023 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
  typedef is_same<value_type, C> type;
};







template <typename C>
struct IsRecursiveContainer : public IsRecursiveContainerImpl<C>::type {};





template<bool> struct EnableIf;
template<> struct EnableIf<true> { typedef void type; };  







template <typename T, typename U>
bool ArrayEq(const T* lhs, size_t size, const U* rhs);


template <typename T, typename U>
inline bool ArrayEq(const T& lhs, const U& rhs) { return lhs == rhs; }


template <typename T, typename U, size_t N>
inline bool ArrayEq(const T(&lhs)[N], const U(&rhs)[N]) {
  return internal::ArrayEq(lhs, N, rhs);
}




template <typename T, typename U>
bool ArrayEq(const T* lhs, size_t size, const U* rhs) {
  for (size_t i = 0; i != size; i++) {
    if (!internal::ArrayEq(lhs[i], rhs[i]))
      return false;
  }
  return true;
}



template <typename Iter, typename Element>
Iter ArrayAwareFind(Iter begin, Iter end, const Element& elem) {
  for (Iter it = begin; it != end; ++it) {
    if (internal::ArrayEq(*it, elem))
      return it;
  }
  return end;
}





template <typename T, typename U>
void CopyArray(const T* from, size_t size, U* to);


template <typename T, typename U>
inline void CopyArray(const T& from, U* to) { *to = from; }


template <typename T, typename U, size_t N>
inline void CopyArray(const T(&from)[N], U(*to)[N]) {
  internal::CopyArray(from, N, *to);
}




template <typename T, typename U>
void CopyArray(const T* from, size_t size, U* to) {
  for (size_t i = 0; i != size; i++) {
    internal::CopyArray(from[i], to + i);
  }
}





struct RelationToSourceReference {};
struct RelationToSourceCopy {};









template <typename Element>
class NativeArray {
 public:
  
  typedef Element value_type;
  typedef Element* iterator;
  typedef const Element* const_iterator;

  
  NativeArray(const Element* array, size_t count, RelationToSourceReference) {
    InitRef(array, count);
  }

  
  NativeArray(const Element* array, size_t count, RelationToSourceCopy) {
    InitCopy(array, count);
  }

  
  NativeArray(const NativeArray& rhs) {
    (this->*rhs.clone_)(rhs.array_, rhs.size_);
  }

  ~NativeArray() {
    if (clone_ != &NativeArray::InitRef)
      delete[] array_;
  }

  
  size_t size() const { return size_; }
  const_iterator begin() const { return array_; }
  const_iterator end() const { return array_ + size_; }
  bool operator==(const NativeArray& rhs) const {
    return size() == rhs.size() &&
        ArrayEq(begin(), size(), rhs.begin());
  }

 private:
  enum {
    kCheckTypeIsNotConstOrAReference = StaticAssertTypeEqHelper<
        Element, typename ::testing::internal::RemoveConst<typename ::testing::internal::RemoveReference<Element>::type>::type>::value
  };

  
  void InitCopy(const Element* array, size_t a_size) {
    Element* const copy = new Element[a_size];
    CopyArray(array, a_size, copy);
    array_ = copy;
    size_ = a_size;
    clone_ = &NativeArray::InitCopy;
  }

  
  void InitRef(const Element* array, size_t a_size) {
    array_ = array;
    size_ = a_size;
    clone_ = &NativeArray::InitRef;
  }

  const Element* array_;
  size_t size_;
  void (NativeArray::*clone_)(const Element*, size_t);

  void operator=(NativeArray const &) = delete;
};

}  
}  








































































































































#line 1331 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-internal.h"
#line 60 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"








































#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-death-test-internal.h"










































namespace testing {
namespace internal {

 extern ::std::string FLAGS_gtest_internal_run_death_test;


const char kDeathTestStyleFlag[] = "death_test_style";
const char kDeathTestUseFork[] = "death_test_use_fork";
const char kInternalRunDeathTestFlag[] = "internal_run_death_test";




__pragma(warning(push)) __pragma(warning(disable: 4251))














class  DeathTest {
 public:
  
  
  
  
  
  
  
  
  static bool Create(const char* statement, const RE* regex,
                     const char* file, int line, DeathTest** test);
  DeathTest();
  virtual ~DeathTest() { }

  
  class ReturnSentinel {
   public:
    explicit ReturnSentinel(DeathTest* test) : test_(test) { }
    ~ReturnSentinel() { test_->Abort(TEST_ENCOUNTERED_RETURN_STATEMENT); }
   private:
    DeathTest* const test_;
    ReturnSentinel(ReturnSentinel const &) = delete; void operator=(ReturnSentinel const &) = delete;
  } ;

  
  
  
  
  
  enum TestRole { OVERSEE_TEST, EXECUTE_TEST };

  
  enum AbortReason {
    TEST_ENCOUNTERED_RETURN_STATEMENT,
    TEST_THREW_EXCEPTION,
    TEST_DID_NOT_DIE
  };

  
  virtual TestRole AssumeRole() = 0;

  
  virtual int Wait() = 0;

  
  
  
  
  
  
  
  virtual bool Passed(bool exit_status_ok) = 0;

  
  virtual void Abort(AbortReason reason) = 0;

  
  
  static const char* LastMessage();

  static void set_last_death_test_message(const std::string& message);

 private:
  
  static std::string last_death_test_message_;

  DeathTest(DeathTest const &) = delete; void operator=(DeathTest const &) = delete;
};

__pragma(warning(pop))  


class DeathTestFactory {
 public:
  virtual ~DeathTestFactory() { }
  virtual bool Create(const char* statement, const RE* regex,
                      const char* file, int line, DeathTest** test) = 0;
};


class DefaultDeathTestFactory : public DeathTestFactory {
 public:
  virtual bool Create(const char* statement, const RE* regex,
                      const char* file, int line, DeathTest** test);
};



 bool ExitedUnsuccessfully(int exit_status);
























#line 186 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-death-test-internal.h"
























































class InternalRunDeathTestFlag {
 public:
  InternalRunDeathTestFlag(const std::string& a_file,
                           int a_line,
                           int an_index,
                           int a_write_fd)
      : file_(a_file), line_(a_line), index_(an_index),
        write_fd_(a_write_fd) {}

  ~InternalRunDeathTestFlag() {
    if (write_fd_ >= 0)
      posix::Close(write_fd_);
  }

  const std::string& file() const { return file_; }
  int line() const { return line_; }
  int index() const { return index_; }
  int write_fd() const { return write_fd_; }

 private:
  std::string file_;
  int line_;
  int index_;
  int write_fd_;

  InternalRunDeathTestFlag(InternalRunDeathTestFlag const &) = delete; void operator=(InternalRunDeathTestFlag const &) = delete;
};




InternalRunDeathTestFlag* ParseInternalRunDeathTestFlag();

#line 276 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-death-test-internal.h"

}  
}  

#line 281 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-death-test-internal.h"
#line 42 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"

namespace testing {






 extern ::std::string FLAGS_gtest_death_test_style;



namespace internal {






 bool InDeathTestChild();

}  































































































































class  ExitedWithCode {
 public:
  explicit ExitedWithCode(int exit_code);
  bool operator()(int exit_status) const;
 private:
  
  void operator=(const ExitedWithCode& other);

  const int exit_code_;
};












#line 214 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"




























































#line 275 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"
#line 276 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"
































































#line 341 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"

}  

#line 345 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-death-test.h"
#line 62 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"


















































































































































































#line 180 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"





#line 186 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"


#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h"













































#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-linked_ptr.h"







































































#pragma external_header(push)
#line 1 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"









#line 11 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



#pragma warning(push)
#pragma warning(disable: 4324  4514 4574 4710 4793 4820 4995 4996 28719 28726 28727 )


__pragma(pack(push, 8)) extern "C" {







    














#line 42 "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.19041.0\\ucrt\\assert.h"



} __pragma(pack(pop))

#pragma warning(pop) 
#pragma external_header(pop)
#line 73 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-linked_ptr.h"



namespace testing {
namespace internal {


 extern ::testing::internal::Mutex g_linked_ptr_mutex;








class linked_ptr_internal {
 public:
  
  void join_new() {
    next_ = this;
  }

  
  
  
  
  
  
  
  
  
  

  
  void join(linked_ptr_internal const* ptr)
       {
    MutexLock lock(&g_linked_ptr_mutex);

    linked_ptr_internal const* p = ptr;
    while (p->next_ != ptr) {
      ((void)0);
#line 117 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-linked_ptr.h"
      p = p->next_;
    }
    p->next_ = this;
    next_ = ptr;
  }

  
  
  bool depart()
       {
    MutexLock lock(&g_linked_ptr_mutex);

    if (next_ == this) return true;
    linked_ptr_internal const* p = next_;
    while (p->next_ != this) {
      ((void)0);
#line 135 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-linked_ptr.h"
      p = p->next_;
    }
    p->next_ = next_;
    return false;
  }

 private:
  mutable linked_ptr_internal const* next_;
};

template <typename T>
class linked_ptr {
 public:
  typedef T element_type;

  
  
  explicit linked_ptr(T* ptr = 0) { capture(ptr); }
  ~linked_ptr() { depart(); }

  
  template <typename U> linked_ptr(linked_ptr<U> const& ptr) { copy(&ptr); }
  linked_ptr(linked_ptr const& ptr) {  
    ((void)0);
    copy(&ptr);
  }

  
  template <typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {
    depart();
    copy(&ptr);
    return *this;
  }

  linked_ptr& operator=(linked_ptr const& ptr) {
    if (&ptr != this) {
      depart();
      copy(&ptr);
    }
    return *this;
  }

  
  void reset(T* ptr = 0) {
    depart();
    capture(ptr);
  }
  T* get() const { return value_; }
  T* operator->() const { return value_; }
  T& operator*() const { return *value_; }

  bool operator==(T* p) const { return value_ == p; }
  bool operator!=(T* p) const { return value_ != p; }
  template <typename U>
  bool operator==(linked_ptr<U> const& ptr) const {
    return value_ == ptr.get();
  }
  template <typename U>
  bool operator!=(linked_ptr<U> const& ptr) const {
    return value_ != ptr.get();
  }

 private:
  template <typename U>
  friend class linked_ptr;

  T* value_;
  linked_ptr_internal link_;

  void depart() {
    if (link_.depart()) delete value_;
  }

  void capture(T* ptr) {
    value_ = ptr;
    link_.join_new();
  }

  template <typename U> void copy(linked_ptr<U> const* ptr) {
    value_ = ptr->get();
    if (value_)
      link_.join(&ptr->link_);
    else
      link_.join_new();
  }
};

template<typename T> inline
bool operator==(T* ptr, const linked_ptr<T>& x) {
  return ptr == x.get();
}

template<typename T> inline
bool operator!=(T* ptr, const linked_ptr<T>& x) {
  return ptr != x.get();
}




template <typename T>
linked_ptr<T> make_linked_ptr(T* ptr) {
  return linked_ptr<T>(ptr);
}

}  
}  

#line 244 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-linked_ptr.h"
#line 47 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"
















































































































#line 114 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"





#line 120 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

namespace testing {



namespace internal2 {



 void PrintBytesInObjectTo(const unsigned char* obj_bytes,
                                     size_t count,
                                     ::std::ostream* os);



enum TypeKind {
  kProtobuf,              
  kConvertibleToInteger,  
                          



#line 143 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"
  kOtherType  
};





template <typename T, TypeKind kTypeKind>
class TypeWithoutFormatter {
 public:
  
  static void PrintValue(const T& value, ::std::ostream* os) {
    PrintBytesInObjectTo(static_cast<const unsigned char*>(
                             reinterpret_cast<const void*>(&value)),
                         sizeof(value), os);
  }
};




const size_t kProtobufOneLinerMaxLength = 50;

template <typename T>
class TypeWithoutFormatter<T, kProtobuf> {
 public:
  static void PrintValue(const T& value, ::std::ostream* os) {
    std::string pretty_str = value.ShortDebugString();
    if (pretty_str.length() > kProtobufOneLinerMaxLength) {
      pretty_str = "\n" + value.DebugString();
    }
    *os << ("<" + pretty_str + ">");
  }
};

template <typename T>
class TypeWithoutFormatter<T, kConvertibleToInteger> {
 public:
  
  
  
  
  
  
  
  static void PrintValue(const T& value, ::std::ostream* os) {
    const internal::BiggestInt kBigInt = value;
    *os << kBigInt;
  }
};












#line 206 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

























template <typename Char, typename CharTraits, typename T>
::std::basic_ostream<Char, CharTraits>& operator<<(
    ::std::basic_ostream<Char, CharTraits>& os, const T& x) {
  TypeWithoutFormatter<T, (internal::IsAProtocolMessage<T>::value
                               ? kProtobuf
                               : internal::ImplicitlyConvertible<
                                     const T&, internal::BiggestInt>::value
                                     ? kConvertibleToInteger
                                     :





#line 246 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"
                                         kOtherType)>::PrintValue(x, &os);
  return os;
}

}  
}  



namespace testing_internal {



template <typename T>
void DefaultPrintNonContainerTo(const T& value, ::std::ostream* os) {
  
  
  
  
  
  
  
  
  
  
  
  using namespace ::testing::internal2;  

  
  
  
  
  
  
  
  
  
  
  
  
  
  *os << value;
}

}  

namespace testing {
namespace internal {
















template <typename ToPrint, typename OtherOperand>
class FormatForComparison {
 public:
  static ::std::string Format(const ToPrint& value) {
    return ::testing::PrintToString(value);
  }
};


template <typename ToPrint, size_t N, typename OtherOperand>
class FormatForComparison<ToPrint[N], OtherOperand> {
 public:
  static ::std::string Format(const ToPrint* value) {
    return FormatForComparison<const ToPrint*, OtherOperand>::Format(value);
  }
};













template <typename OtherOperand> class FormatForComparison<char*, OtherOperand> { public: static ::std::string Format(char* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<const char*, OtherOperand> { public: static ::std::string Format(const char* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<wchar_t*, OtherOperand> { public: static ::std::string Format(wchar_t* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };
template <typename OtherOperand> class FormatForComparison<const wchar_t*, OtherOperand> { public: static ::std::string Format(const wchar_t* value) { return ::testing::PrintToString(static_cast<const void*>(value)); } };















template <> class FormatForComparison<char*, ::std::string> { public: static ::std::string Format(char* value) { return ::testing::PrintToString(value); } };
template <> class FormatForComparison<const char*, ::std::string> { public: static ::std::string Format(const char* value) { return ::testing::PrintToString(value); } };




#line 365 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"




#line 370 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


template <> class FormatForComparison<wchar_t*, ::std::wstring> { public: static ::std::string Format(wchar_t* value) { return ::testing::PrintToString(value); } };
template <> class FormatForComparison<const wchar_t*, ::std::wstring> { public: static ::std::string Format(const wchar_t* value) { return ::testing::PrintToString(value); } };
#line 375 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"











template <typename T1, typename T2>
std::string FormatForComparisonFailureMessage(
    const T1& value, const T2& ) {
  return FormatForComparison<T1, T2>::Format(value);
}








template <typename T>
class UniversalPrinter;

template <typename T>
void UniversalPrint(const T& value, ::std::ostream* os);

enum DefaultPrinterType {
  kPrintContainer,
  kPrintPointer,
  kPrintFunctionPointer,
  kPrintOther,
};
template <DefaultPrinterType type> struct WrapPrinterType {};



template <typename C>
void DefaultPrintTo(WrapPrinterType<kPrintContainer> ,
                    const C& container, ::std::ostream* os) {
  const size_t kMaxCount = 32;  
  *os << '{';
  size_t count = 0;
  for (typename C::const_iterator it = container.begin();
       it != container.end(); ++it, ++count) {
    if (count > 0) {
      *os << ',';
      if (count == kMaxCount) {  
        *os << " ...";
        break;
      }
    }
    *os << ' ';
    
    
    internal::UniversalPrint(*it, os);
  }

  if (count > 0) {
    *os << ' ';
  }
  *os << '}';
}







template <typename T>
void DefaultPrintTo(WrapPrinterType<kPrintPointer> ,
                    T* p, ::std::ostream* os) {
  if (p == 0) {
    *os << "NULL";
  } else {
    
    
    
    *os << p;
  }
}
template <typename T>
void DefaultPrintTo(WrapPrinterType<kPrintFunctionPointer> ,
                    T* p, ::std::ostream* os) {
  if (p == 0) {
    *os << "NULL";
  } else {
    
    
    
    *os << reinterpret_cast<const void*>(p);
  }
}



template <typename T>
void DefaultPrintTo(WrapPrinterType<kPrintOther> ,
                    const T& value, ::std::ostream* os) {
  ::testing_internal::DefaultPrintNonContainerTo(value, os);
}












template <typename T>
void PrintTo(const T& value, ::std::ostream* os) {
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  DefaultPrintTo(
      WrapPrinterType <
                  (sizeof(IsContainerTest<T>(0)) == sizeof(IsContainer)) &&
              !IsRecursiveContainer<T>::value
          ? kPrintContainer
          : !is_pointer<T>::value
                ? kPrintOther

                : std::is_function<typename std::remove_pointer<T>::type>::value


#line 525 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"
                      ? kPrintFunctionPointer
                      : kPrintPointer > (),
      value, os);
}






 void PrintTo(unsigned char c, ::std::ostream* os);
 void PrintTo(signed char c, ::std::ostream* os);
inline void PrintTo(char c, ::std::ostream* os) {
  
  
  
  PrintTo(static_cast<unsigned char>(c), os);
}


inline void PrintTo(bool x, ::std::ostream* os) {
  *os << (x ? "true" : "false");
}








 void PrintTo(wchar_t wc, ::std::ostream* os);


 void PrintTo(const char* s, ::std::ostream* os);
inline void PrintTo(char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const char*>(s), os);
}



inline void PrintTo(const signed char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(signed char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(const unsigned char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}
inline void PrintTo(unsigned char* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const void*>(s), os);
}








 void PrintTo(const wchar_t* s, ::std::ostream* os);
inline void PrintTo(wchar_t* s, ::std::ostream* os) {
  PrintTo(ImplicitCast_<const wchar_t*>(s), os);
}
#line 591 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"






template <typename T>
void PrintRawArrayTo(const T a[], size_t count, ::std::ostream* os) {
  UniversalPrint(a[0], os);
  for (size_t i = 1; i != count; i++) {
    *os << ", ";
    UniversalPrint(a[i], os);
  }
}







#line 613 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

 void PrintStringTo(const ::std::string&s, ::std::ostream* os);
inline void PrintTo(const ::std::string& s, ::std::ostream* os) {
  PrintStringTo(s, os);
}







#line 626 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


 void PrintWideStringTo(const ::std::wstring&s, ::std::ostream* os);
inline void PrintTo(const ::std::wstring& s, ::std::ostream* os) {
  PrintWideStringTo(s, os);
}
#line 633 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"






#line 640 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


inline void PrintTo(std::nullptr_t, ::std::ostream* os) { *os << "(nullptr)"; }
#line 644 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"




template <typename T>
void PrintTupleTo(const T& t, ::std::ostream* os);
#line 651 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"











































































#line 727 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


template <typename... Types>
void PrintTo(const ::std::tuple<Types...>& t, ::std::ostream* os) {
  PrintTupleTo(t, os);
}
#line 734 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


template <typename T1, typename T2>
void PrintTo(const ::std::pair<T1, T2>& value, ::std::ostream* os) {
  *os << '(';
  
  
  UniversalPrinter<T1>::Print(value.first, os);
  *os << ", ";
  UniversalPrinter<T2>::Print(value.second, os);
  *os << ')';
}



template <typename T>
class UniversalPrinter {
 public:
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4180))

  
  
  
  static void Print(const T& value, ::std::ostream* os) {
    
    
    
    
    
    
    
    
    PrintTo(value, os);
  }

  __pragma(warning(pop))
};









































#line 815 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"



template <typename T>
void UniversalPrintArray(const T* begin, size_t len, ::std::ostream* os) {
  if (len == 0) {
    *os << "{}";
  } else {
    *os << "{ ";
    const size_t kThreshold = 18;
    const size_t kChunkSize = 8;
    
    
    
    
    if (len <= kThreshold) {
      PrintRawArrayTo(begin, len, os);
    } else {
      PrintRawArrayTo(begin, kChunkSize, os);
      *os << ", ..., ";
      PrintRawArrayTo(begin + len - kChunkSize, kChunkSize, os);
    }
    *os << " }";
  }
}

 void UniversalPrintArray(
    const char* begin, size_t len, ::std::ostream* os);


 void UniversalPrintArray(
    const wchar_t* begin, size_t len, ::std::ostream* os);


template <typename T, size_t N>
class UniversalPrinter<T[N]> {
 public:
  
  
  static void Print(const T (&a)[N], ::std::ostream* os) {
    UniversalPrintArray(a, N, os);
  }
};


template <typename T>
class UniversalPrinter<T&> {
 public:
  
  
  __pragma(warning(push)) __pragma(warning(disable: 4180))

  static void Print(const T& value, ::std::ostream* os) {
    
    
    *os << "@" << reinterpret_cast<const void*>(&value) << " ";

    
    UniversalPrint(value, os);
  }

  __pragma(warning(pop))
};





template <typename T>
class UniversalTersePrinter {
 public:
  static void Print(const T& value, ::std::ostream* os) {
    UniversalPrint(value, os);
  }
};
template <typename T>
class UniversalTersePrinter<T&> {
 public:
  static void Print(const T& value, ::std::ostream* os) {
    UniversalPrint(value, os);
  }
};
template <typename T, size_t N>
class UniversalTersePrinter<T[N]> {
 public:
  static void Print(const T (&value)[N], ::std::ostream* os) {
    UniversalPrinter<T[N]>::Print(value, os);
  }
};
template <>
class UniversalTersePrinter<const char*> {
 public:
  static void Print(const char* str, ::std::ostream* os) {
    if (str == 0) {
      *os << "NULL";
    } else {
      UniversalPrint(std::string(str), os);
    }
  }
};
template <>
class UniversalTersePrinter<char*> {
 public:
  static void Print(char* str, ::std::ostream* os) {
    UniversalTersePrinter<const char*>::Print(str, os);
  }
};


template <>
class UniversalTersePrinter<const wchar_t*> {
 public:
  static void Print(const wchar_t* str, ::std::ostream* os) {
    if (str == 0) {
      *os << "NULL";
    } else {
      UniversalPrint(::std::wstring(str), os);
    }
  }
};
#line 936 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

template <>
class UniversalTersePrinter<wchar_t*> {
 public:
  static void Print(wchar_t* str, ::std::ostream* os) {
    UniversalTersePrinter<const wchar_t*>::Print(str, os);
  }
};

template <typename T>
void UniversalTersePrint(const T& value, ::std::ostream* os) {
  UniversalTersePrinter<T>::Print(value, os);
}





template <typename T>
void UniversalPrint(const T& value, ::std::ostream* os) {
  
  
  typedef T T1;
  UniversalPrinter<T1>::Print(value, os);
}

typedef ::std::vector< ::std::string> Strings;








template <typename TupleT>
struct TuplePolicy;




















#line 994 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"


template <typename... Types>
struct TuplePolicy< ::std::tuple<Types...> > {
  typedef ::std::tuple<Types...> Tuple;
  static const size_t tuple_size = ::std::tuple_size<Tuple>::value;

  template <size_t I>
  struct tuple_element : ::std::tuple_element<I, Tuple> {};

  template <size_t I>
  static const typename ::std::tuple_element<I, Tuple>::type& get(
      const Tuple& tuple) {
    return ::std::get<I>(tuple);
  }
};
template <typename... Types>
const size_t TuplePolicy< ::std::tuple<Types...> >::tuple_size;
#line 1013 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"










template <size_t N>
struct TuplePrefixPrinter {
  
  template <typename Tuple>
  static void PrintPrefixTo(const Tuple& t, ::std::ostream* os) {
    TuplePrefixPrinter<N - 1>::PrintPrefixTo(t, os);
    __pragma(warning(push)) __pragma(warning(disable: 4127))
    if (N > 1) {
    __pragma(warning(pop))
      *os << ", ";
    }
    UniversalPrinter<
        typename TuplePolicy<Tuple>::template tuple_element<N - 1>::type>
        ::Print(TuplePolicy<Tuple>::template get<N - 1>(t), os);
  }

  
  
  template <typename Tuple>
  static void TersePrintPrefixToStrings(const Tuple& t, Strings* strings) {
    TuplePrefixPrinter<N - 1>::TersePrintPrefixToStrings(t, strings);
    ::std::stringstream ss;
    UniversalTersePrint(TuplePolicy<Tuple>::template get<N - 1>(t), &ss);
    strings->push_back(ss.str());
  }
};


template <>
struct TuplePrefixPrinter<0> {
  template <typename Tuple>
  static void PrintPrefixTo(const Tuple&, ::std::ostream*) {}

  template <typename Tuple>
  static void TersePrintPrefixToStrings(const Tuple&, Strings*) {}
};



template <typename Tuple>
void PrintTupleTo(const Tuple& t, ::std::ostream* os) {
  *os << "(";
  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::PrintPrefixTo(t, os);
  *os << ")";
}




template <typename Tuple>
Strings UniversalTersePrintTupleFieldsToStrings(const Tuple& value) {
  Strings result;
  TuplePrefixPrinter<TuplePolicy<Tuple>::tuple_size>::
      TersePrintPrefixToStrings(value, &result);
  return result;
}
#line 1080 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

}  









#line 1092 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

template <typename T>
::std::string PrintToString(const T& value) {
  ::std::stringstream ss;
  internal::UniversalTersePrinter<T>::Print(value, &ss);
  return ss.str();
}

}  




#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\custom\\gtest-printers.h"









































#line 43 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\custom\\gtest-printers.h"
#line 1106 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"

#line 1108 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-printers.h"
#line 49 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h"

namespace testing {



template <class ParamType>
struct TestParamInfo {
  TestParamInfo(const ParamType& a_param, size_t an_index) :
    param(a_param),
    index(an_index) {}
  ParamType param;
  size_t index;
};



struct PrintToStringParamName {
  template <class ParamType>
  std::string operator()(const TestParamInfo<ParamType>& info) const {
    return PrintToString(info.param);
  }
};

namespace internal {







 void ReportInvalidTestCaseType(const char* test_case_name,
                                          CodeLocation code_location);

template <typename> class ParamGeneratorInterface;
template <typename> class ParamGenerator;



template <typename T>
class ParamIteratorInterface {
 public:
  virtual ~ParamIteratorInterface() {}
  
  
  
  virtual const ParamGeneratorInterface<T>* BaseGenerator() const = 0;
  
  
  
  
  virtual void Advance() = 0;
  
  
  virtual ParamIteratorInterface* Clone() const = 0;
  
  
  
  
  virtual const T* Current() const = 0;
  
  
  
  virtual bool Equals(const ParamIteratorInterface& other) const = 0;
};




template <typename T>
class ParamIterator {
 public:
  typedef T value_type;
  typedef const T& reference;
  typedef ptrdiff_t difference_type;

  
  ParamIterator(const ParamIterator& other) : impl_(other.impl_->Clone()) {}
  ParamIterator& operator=(const ParamIterator& other) {
    if (this != &other)
      impl_.reset(other.impl_->Clone());
    return *this;
  }

  const T& operator*() const { return *impl_->Current(); }
  const T* operator->() const { return impl_->Current(); }
  
  ParamIterator& operator++() {
    impl_->Advance();
    return *this;
  }
  
  ParamIterator operator++(int ) {
    ParamIteratorInterface<T>* clone = impl_->Clone();
    impl_->Advance();
    return ParamIterator(clone);
  }
  bool operator==(const ParamIterator& other) const {
    return impl_.get() == other.impl_.get() || impl_->Equals(*other.impl_);
  }
  bool operator!=(const ParamIterator& other) const {
    return !(*this == other);
  }

 private:
  friend class ParamGenerator<T>;
  explicit ParamIterator(ParamIteratorInterface<T>* impl) : impl_(impl) {}
  scoped_ptr<ParamIteratorInterface<T> > impl_;
};



template <typename T>
class ParamGeneratorInterface {
 public:
  typedef T ParamType;

  virtual ~ParamGeneratorInterface() {}

  
  virtual ParamIteratorInterface<T>* Begin() const = 0;
  virtual ParamIteratorInterface<T>* End() const = 0;
};






template<typename T>
class ParamGenerator {
 public:
  typedef ParamIterator<T> iterator;

  explicit ParamGenerator(ParamGeneratorInterface<T>* impl) : impl_(impl) {}
  ParamGenerator(const ParamGenerator& other) : impl_(other.impl_) {}

  ParamGenerator& operator=(const ParamGenerator& other) {
    impl_ = other.impl_;
    return *this;
  }

  iterator begin() const { return iterator(impl_->Begin()); }
  iterator end() const { return iterator(impl_->End()); }

 private:
  linked_ptr<const ParamGeneratorInterface<T> > impl_;
};





template <typename T, typename IncrementT>
class RangeGenerator : public ParamGeneratorInterface<T> {
 public:
  RangeGenerator(T begin, T end, IncrementT step)
      : begin_(begin), end_(end),
        step_(step), end_index_(CalculateEndIndex(begin, end, step)) {}
  virtual ~RangeGenerator() {}

  virtual ParamIteratorInterface<T>* Begin() const {
    return new Iterator(this, begin_, 0, step_);
  }
  virtual ParamIteratorInterface<T>* End() const {
    return new Iterator(this, end_, end_index_, step_);
  }

 private:
  class Iterator : public ParamIteratorInterface<T> {
   public:
    Iterator(const ParamGeneratorInterface<T>* base, T value, int index,
             IncrementT step)
        : base_(base), value_(value), index_(index), step_(step) {}
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {
      return base_;
    }
    virtual void Advance() {
      value_ = static_cast<T>(value_ + step_);
      index_++;
    }
    virtual ParamIteratorInterface<T>* Clone() const {
      return new Iterator(*this);
    }
    virtual const T* Current() const { return &value_; }
    virtual bool Equals(const ParamIteratorInterface<T>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h", 239).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const int other_index =
          CheckedDowncastToActualType<const Iterator>(&other)->index_;
      return index_ == other_index;
    }

   private:
    Iterator(const Iterator& other)
        : ParamIteratorInterface<T>(),
          base_(other.base_), value_(other.value_), index_(other.index_),
          step_(other.step_) {}

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<T>* const base_;
    T value_;
    int index_;
    const IncrementT step_;
  };  

  static int CalculateEndIndex(const T& begin,
                               const T& end,
                               const IncrementT& step) {
    int end_index = 0;
    for (T i = begin; i < end; i = static_cast<T>(i + step))
      end_index++;
    return end_index;
  }

  
  void operator=(const RangeGenerator& other);

  const T begin_;
  const T end_;
  const IncrementT step_;
  
  
  const int end_index_;
};  






template <typename T>
class ValuesInIteratorRangeGenerator : public ParamGeneratorInterface<T> {
 public:
  template <typename ForwardIterator>
  ValuesInIteratorRangeGenerator(ForwardIterator begin, ForwardIterator end)
      : container_(begin, end) {}
  virtual ~ValuesInIteratorRangeGenerator() {}

  virtual ParamIteratorInterface<T>* Begin() const {
    return new Iterator(this, container_.begin());
  }
  virtual ParamIteratorInterface<T>* End() const {
    return new Iterator(this, container_.end());
  }

 private:
  typedef typename ::std::vector<T> ContainerType;

  class Iterator : public ParamIteratorInterface<T> {
   public:
    Iterator(const ParamGeneratorInterface<T>* base,
             typename ContainerType::const_iterator iterator)
        : base_(base), iterator_(iterator) {}
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<T>* BaseGenerator() const {
      return base_;
    }
    virtual void Advance() {
      ++iterator_;
      value_.reset();
    }
    virtual ParamIteratorInterface<T>* Clone() const {
      return new Iterator(*this);
    }
    
    
    
    
    
    
    
    virtual const T* Current() const {
      if (value_.get() == 0)
        value_.reset(new T(*iterator_));
      return value_.get();
    }
    virtual bool Equals(const ParamIteratorInterface<T>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h", 337).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      return iterator_ ==
          CheckedDowncastToActualType<const Iterator>(&other)->iterator_;
    }

   private:
    Iterator(const Iterator& other)
          
          
        : ParamIteratorInterface<T>(),
          base_(other.base_),
          iterator_(other.iterator_) {}

    const ParamGeneratorInterface<T>* const base_;
    typename ContainerType::const_iterator iterator_;
    
    
    
    
    
    mutable scoped_ptr<const T> value_;
  };  

  
  void operator=(const ValuesInIteratorRangeGenerator& other);

  const ContainerType container_;
};  





template <class ParamType>
std::string DefaultParamName(const TestParamInfo<ParamType>& info) {
  Message name_stream;
  name_stream << info.index;
  return name_stream.GetString();
}






template <class ParamType, class ParamNameGenFunctor>
ParamNameGenFunctor GetParamNameGen(ParamNameGenFunctor func) {
  return func;
}

template <class ParamType>
struct ParamNameGenFunc {
  typedef std::string Type(const TestParamInfo<ParamType>&);
};

template <class ParamType>
typename ParamNameGenFunc<ParamType>::Type *GetParamNameGen() {
  return DefaultParamName;
}





template <class TestClass>
class ParameterizedTestFactory : public TestFactoryBase {
 public:
  typedef typename TestClass::ParamType ParamType;
  explicit ParameterizedTestFactory(ParamType parameter) :
      parameter_(parameter) {}
  virtual Test* CreateTest() {
    TestClass::SetParam(&parameter_);
    return new TestClass();
  }

 private:
  const ParamType parameter_;

  ParameterizedTestFactory(ParameterizedTestFactory const &) = delete; void operator=(ParameterizedTestFactory const &) = delete;
};





template <class ParamType>
class TestMetaFactoryBase {
 public:
  virtual ~TestMetaFactoryBase() {}

  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) = 0;
};









template <class TestCase>
class TestMetaFactory
    : public TestMetaFactoryBase<typename TestCase::ParamType> {
 public:
  typedef typename TestCase::ParamType ParamType;

  TestMetaFactory() {}

  virtual TestFactoryBase* CreateTestFactory(ParamType parameter) {
    return new ParameterizedTestFactory<TestCase>(parameter);
  }

 private:
  TestMetaFactory(TestMetaFactory const &) = delete; void operator=(TestMetaFactory const &) = delete;
};











class ParameterizedTestCaseInfoBase {
 public:
  virtual ~ParameterizedTestCaseInfoBase() {}

  
  virtual const std::string& GetTestCaseName() const = 0;
  
  virtual TypeId GetTestCaseTypeId() const = 0;
  
  
  
  
  virtual void RegisterTests() = 0;

 protected:
  ParameterizedTestCaseInfoBase() {}

 private:
  ParameterizedTestCaseInfoBase(ParameterizedTestCaseInfoBase const &) = delete; void operator=(ParameterizedTestCaseInfoBase const &) = delete;
};








template <class TestCase>
class ParameterizedTestCaseInfo : public ParameterizedTestCaseInfoBase {
 public:
  
  
  
  typedef typename TestCase::ParamType ParamType;
  
  typedef ParamGenerator<ParamType>(GeneratorCreationFunc)();
  typedef typename ParamNameGenFunc<ParamType>::Type ParamNameGeneratorFunc;

  explicit ParameterizedTestCaseInfo(
      const char* name, CodeLocation code_location)
      : test_case_name_(name), code_location_(code_location) {}

  
  virtual const std::string& GetTestCaseName() const { return test_case_name_; }
  
  virtual TypeId GetTestCaseTypeId() const { return GetTypeId<TestCase>(); }
  
  
  
  
  
  
  void AddTestPattern(const char* test_case_name,
                      const char* test_base_name,
                      TestMetaFactoryBase<ParamType>* meta_factory) {
    tests_.push_back(linked_ptr<TestInfo>(new TestInfo(test_case_name,
                                                       test_base_name,
                                                       meta_factory)));
  }
  
  
  int AddTestCaseInstantiation(const std::string& instantiation_name,
                               GeneratorCreationFunc* func,
                               ParamNameGeneratorFunc* name_func,
                               const char* file, int line) {
    instantiations_.push_back(
        InstantiationInfo(instantiation_name, func, name_func, file, line));
    return 0;  
  }
  
  
  
  
  
  virtual void RegisterTests() {
    for (typename TestInfoContainer::iterator test_it = tests_.begin();
         test_it != tests_.end(); ++test_it) {
      linked_ptr<TestInfo> test_info = *test_it;
      for (typename InstantiationContainer::iterator gen_it =
               instantiations_.begin(); gen_it != instantiations_.end();
               ++gen_it) {
        const std::string& instantiation_name = gen_it->name;
        ParamGenerator<ParamType> generator((*gen_it->generator)());
        ParamNameGeneratorFunc* name_func = gen_it->name_func;
        const char* file = gen_it->file;
        int line = gen_it->line;

        std::string test_case_name;
        if ( !instantiation_name.empty() )
          test_case_name = instantiation_name + "/";
        test_case_name += test_info->test_case_base_name;

        size_t i = 0;
        std::set<std::string> test_param_names;
        for (typename ParamGenerator<ParamType>::iterator param_it =
                 generator.begin();
             param_it != generator.end(); ++param_it, ++i) {
          Message test_name_stream;

          std::string param_name = name_func(
              TestParamInfo<ParamType>(*param_it, i));

          switch (0) case 0: default: if (::testing::internal::IsTrue(IsValidParamName(param_name))) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h", 569).GetStream() << "Condition " "IsValidParamName(param_name)" " failed. "
              << "Parameterized test name '" << param_name
              << "' is invalid, in " << file
              << " line " << line << std::endl;

          switch (0) case 0: default: if (::testing::internal::IsTrue(test_param_names.count(param_name) == 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h", 574).GetStream() << "Condition " "test_param_names.count(param_name) == 0" " failed. "
              << "Duplicate parameterized test name '" << param_name
              << "', in " << file << " line " << line << std::endl;

          test_param_names.insert(param_name);

          test_name_stream << test_info->test_base_name << "/" << param_name;
          MakeAndRegisterTestInfo(
              test_case_name.c_str(),
              test_name_stream.GetString().c_str(),
              0,  
              PrintToString(*param_it).c_str(),
              code_location_,
              GetTestCaseTypeId(),
              TestCase::SetUpTestCase,
              TestCase::TearDownTestCase,
              test_info->test_meta_factory->CreateTestFactory(*param_it));
        }  
      }  
    }  
  }  

 private:
  
  
  struct TestInfo {
    TestInfo(const char* a_test_case_base_name,
             const char* a_test_base_name,
             TestMetaFactoryBase<ParamType>* a_test_meta_factory) :
        test_case_base_name(a_test_case_base_name),
        test_base_name(a_test_base_name),
        test_meta_factory(a_test_meta_factory) {}

    const std::string test_case_base_name;
    const std::string test_base_name;
    const scoped_ptr<TestMetaFactoryBase<ParamType> > test_meta_factory;
  };
  typedef ::std::vector<linked_ptr<TestInfo> > TestInfoContainer;
  
  
  
  struct InstantiationInfo {
      InstantiationInfo(const std::string &name_in,
                        GeneratorCreationFunc* generator_in,
                        ParamNameGeneratorFunc* name_func_in,
                        const char* file_in,
                        int line_in)
          : name(name_in),
            generator(generator_in),
            name_func(name_func_in),
            file(file_in),
            line(line_in) {}

      std::string name;
      GeneratorCreationFunc* generator;
      ParamNameGeneratorFunc* name_func;
      const char* file;
      int line;
  };
  typedef ::std::vector<InstantiationInfo> InstantiationContainer;

  static bool IsValidParamName(const std::string& name) {
    
    if (name.empty())
      return false;

    
    for (std::string::size_type index = 0; index < name.size(); ++index) {
      if (!isalnum(name[index]) && name[index] != '_')
        return false;
    }

    return true;
  }

  const std::string test_case_name_;
  CodeLocation code_location_;
  TestInfoContainer tests_;
  InstantiationContainer instantiations_;

  ParameterizedTestCaseInfo(ParameterizedTestCaseInfo const &) = delete; void operator=(ParameterizedTestCaseInfo const &) = delete;
};  







class ParameterizedTestCaseRegistry {
 public:
  ParameterizedTestCaseRegistry() {}
  ~ParameterizedTestCaseRegistry() {
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      delete *it;
    }
  }

  
  
  template <class TestCase>
  ParameterizedTestCaseInfo<TestCase>* GetTestCasePatternHolder(
      const char* test_case_name,
      CodeLocation code_location) {
    ParameterizedTestCaseInfo<TestCase>* typed_test_info = 0;
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      if ((*it)->GetTestCaseName() == test_case_name) {
        if ((*it)->GetTestCaseTypeId() != GetTypeId<TestCase>()) {
          
          
          
          ReportInvalidTestCaseType(test_case_name, code_location);
          posix::Abort();
        } else {
          
          
          
          typed_test_info = CheckedDowncastToActualType<
              ParameterizedTestCaseInfo<TestCase> >(*it);
        }
        break;
      }
    }
    if (typed_test_info == 0) {
      typed_test_info = new ParameterizedTestCaseInfo<TestCase>(
          test_case_name, code_location);
      test_case_infos_.push_back(typed_test_info);
    }
    return typed_test_info;
  }
  void RegisterTests() {
    for (TestCaseInfoContainer::iterator it = test_case_infos_.begin();
         it != test_case_infos_.end(); ++it) {
      (*it)->RegisterTests();
    }
  }

 private:
  typedef ::std::vector<ParameterizedTestCaseInfoBase*> TestCaseInfoContainer;

  TestCaseInfoContainer test_case_infos_;

  ParameterizedTestCaseRegistry(ParameterizedTestCaseRegistry const &) = delete; void operator=(ParameterizedTestCaseRegistry const &) = delete;
};

}  
}  

#line 725 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util.h"
#line 189 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"
#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h"




















































namespace testing {



template <typename ForwardIterator>
internal::ParamGenerator<
  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
ValuesIn(ForwardIterator begin, ForwardIterator end);

template <typename T, size_t N>
internal::ParamGenerator<T> ValuesIn(const T (&array)[N]);

template <class Container>
internal::ParamGenerator<typename Container::value_type> ValuesIn(
    const Container& container);

namespace internal {


template <typename T1>
class ValueArray1 {
 public:
  explicit ValueArray1(T1 v1) : v1_(v1) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_)};
    return ValuesIn(array);
  }

  ValueArray1(const ValueArray1& other) : v1_(other.v1_) {}

 private:
  
  void operator=(const ValueArray1& other);

  const T1 v1_;
};

template <typename T1, typename T2>
class ValueArray2 {
 public:
  ValueArray2(T1 v1, T2 v2) : v1_(v1), v2_(v2) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_)};
    return ValuesIn(array);
  }

  ValueArray2(const ValueArray2& other) : v1_(other.v1_), v2_(other.v2_) {}

 private:
  
  void operator=(const ValueArray2& other);

  const T1 v1_;
  const T2 v2_;
};

template <typename T1, typename T2, typename T3>
class ValueArray3 {
 public:
  ValueArray3(T1 v1, T2 v2, T3 v3) : v1_(v1), v2_(v2), v3_(v3) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_)};
    return ValuesIn(array);
  }

  ValueArray3(const ValueArray3& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_) {}

 private:
  
  void operator=(const ValueArray3& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
};

template <typename T1, typename T2, typename T3, typename T4>
class ValueArray4 {
 public:
  ValueArray4(T1 v1, T2 v2, T3 v3, T4 v4) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_)};
    return ValuesIn(array);
  }

  ValueArray4(const ValueArray4& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_) {}

 private:
  
  void operator=(const ValueArray4& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5>
class ValueArray5 {
 public:
  ValueArray5(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_)};
    return ValuesIn(array);
  }

  ValueArray5(const ValueArray5& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_) {}

 private:
  
  void operator=(const ValueArray5& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
class ValueArray6 {
 public:
  ValueArray6(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_)};
    return ValuesIn(array);
  }

  ValueArray6(const ValueArray6& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_) {}

 private:
  
  void operator=(const ValueArray6& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
class ValueArray7 {
 public:
  ValueArray7(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_)};
    return ValuesIn(array);
  }

  ValueArray7(const ValueArray7& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_) {}

 private:
  
  void operator=(const ValueArray7& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
class ValueArray8 {
 public:
  ValueArray8(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
      T8 v8) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_)};
    return ValuesIn(array);
  }

  ValueArray8(const ValueArray8& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_) {}

 private:
  
  void operator=(const ValueArray8& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
class ValueArray9 {
 public:
  ValueArray9(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
      T9 v9) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_)};
    return ValuesIn(array);
  }

  ValueArray9(const ValueArray9& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_) {}

 private:
  
  void operator=(const ValueArray9& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
class ValueArray10 {
 public:
  ValueArray10(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_)};
    return ValuesIn(array);
  }

  ValueArray10(const ValueArray10& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_) {}

 private:
  
  void operator=(const ValueArray10& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
class ValueArray11 {
 public:
  ValueArray11(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_)};
    return ValuesIn(array);
  }

  ValueArray11(const ValueArray11& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_) {}

 private:
  
  void operator=(const ValueArray11& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
class ValueArray12 {
 public:
  ValueArray12(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_)};
    return ValuesIn(array);
  }

  ValueArray12(const ValueArray12& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_) {}

 private:
  
  void operator=(const ValueArray12& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
class ValueArray13 {
 public:
  ValueArray13(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_)};
    return ValuesIn(array);
  }

  ValueArray13(const ValueArray13& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_) {}

 private:
  
  void operator=(const ValueArray13& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
class ValueArray14 {
 public:
  ValueArray14(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_)};
    return ValuesIn(array);
  }

  ValueArray14(const ValueArray14& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_) {}

 private:
  
  void operator=(const ValueArray14& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
class ValueArray15 {
 public:
  ValueArray15(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_)};
    return ValuesIn(array);
  }

  ValueArray15(const ValueArray15& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_) {}

 private:
  
  void operator=(const ValueArray15& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
class ValueArray16 {
 public:
  ValueArray16(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_)};
    return ValuesIn(array);
  }

  ValueArray16(const ValueArray16& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_) {}

 private:
  
  void operator=(const ValueArray16& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
class ValueArray17 {
 public:
  ValueArray17(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
      T17 v17) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_)};
    return ValuesIn(array);
  }

  ValueArray17(const ValueArray17& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_) {}

 private:
  
  void operator=(const ValueArray17& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
class ValueArray18 {
 public:
  ValueArray18(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_)};
    return ValuesIn(array);
  }

  ValueArray18(const ValueArray18& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_) {}

 private:
  
  void operator=(const ValueArray18& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
class ValueArray19 {
 public:
  ValueArray19(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_)};
    return ValuesIn(array);
  }

  ValueArray19(const ValueArray19& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_) {}

 private:
  
  void operator=(const ValueArray19& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
class ValueArray20 {
 public:
  ValueArray20(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_)};
    return ValuesIn(array);
  }

  ValueArray20(const ValueArray20& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_) {}

 private:
  
  void operator=(const ValueArray20& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
class ValueArray21 {
 public:
  ValueArray21(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_)};
    return ValuesIn(array);
  }

  ValueArray21(const ValueArray21& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_) {}

 private:
  
  void operator=(const ValueArray21& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
class ValueArray22 {
 public:
  ValueArray22(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_)};
    return ValuesIn(array);
  }

  ValueArray22(const ValueArray22& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_) {}

 private:
  
  void operator=(const ValueArray22& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
class ValueArray23 {
 public:
  ValueArray23(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_)};
    return ValuesIn(array);
  }

  ValueArray23(const ValueArray23& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_) {}

 private:
  
  void operator=(const ValueArray23& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
class ValueArray24 {
 public:
  ValueArray24(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_)};
    return ValuesIn(array);
  }

  ValueArray24(const ValueArray24& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_) {}

 private:
  
  void operator=(const ValueArray24& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
class ValueArray25 {
 public:
  ValueArray25(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
      T25 v25) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_)};
    return ValuesIn(array);
  }

  ValueArray25(const ValueArray25& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_) {}

 private:
  
  void operator=(const ValueArray25& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
class ValueArray26 {
 public:
  ValueArray26(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_)};
    return ValuesIn(array);
  }

  ValueArray26(const ValueArray26& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_) {}

 private:
  
  void operator=(const ValueArray26& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
class ValueArray27 {
 public:
  ValueArray27(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_)};
    return ValuesIn(array);
  }

  ValueArray27(const ValueArray27& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_) {}

 private:
  
  void operator=(const ValueArray27& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
class ValueArray28 {
 public:
  ValueArray28(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_)};
    return ValuesIn(array);
  }

  ValueArray28(const ValueArray28& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_) {}

 private:
  
  void operator=(const ValueArray28& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
class ValueArray29 {
 public:
  ValueArray29(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_)};
    return ValuesIn(array);
  }

  ValueArray29(const ValueArray29& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_) {}

 private:
  
  void operator=(const ValueArray29& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
class ValueArray30 {
 public:
  ValueArray30(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_)};
    return ValuesIn(array);
  }

  ValueArray30(const ValueArray30& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_) {}

 private:
  
  void operator=(const ValueArray30& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
class ValueArray31 {
 public:
  ValueArray31(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_)};
    return ValuesIn(array);
  }

  ValueArray31(const ValueArray31& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_) {}

 private:
  
  void operator=(const ValueArray31& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
class ValueArray32 {
 public:
  ValueArray32(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_)};
    return ValuesIn(array);
  }

  ValueArray32(const ValueArray32& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_) {}

 private:
  
  void operator=(const ValueArray32& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
class ValueArray33 {
 public:
  ValueArray33(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,
      T33 v33) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_)};
    return ValuesIn(array);
  }

  ValueArray33(const ValueArray33& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_) {}

 private:
  
  void operator=(const ValueArray33& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
class ValueArray34 {
 public:
  ValueArray34(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_)};
    return ValuesIn(array);
  }

  ValueArray34(const ValueArray34& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_) {}

 private:
  
  void operator=(const ValueArray34& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
class ValueArray35 {
 public:
  ValueArray35(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),
      v32_(v32), v33_(v33), v34_(v34), v35_(v35) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_)};
    return ValuesIn(array);
  }

  ValueArray35(const ValueArray35& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_) {}

 private:
  
  void operator=(const ValueArray35& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
class ValueArray36 {
 public:
  ValueArray36(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),
      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_)};
    return ValuesIn(array);
  }

  ValueArray36(const ValueArray36& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_) {}

 private:
  
  void operator=(const ValueArray36& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
class ValueArray37 {
 public:
  ValueArray37(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),
      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),
      v36_(v36), v37_(v37) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_)};
    return ValuesIn(array);
  }

  ValueArray37(const ValueArray37& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_) {}

 private:
  
  void operator=(const ValueArray37& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
class ValueArray38 {
 public:
  ValueArray38(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_)};
    return ValuesIn(array);
  }

  ValueArray38(const ValueArray38& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_) {}

 private:
  
  void operator=(const ValueArray38& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
class ValueArray39 {
 public:
  ValueArray39(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_)};
    return ValuesIn(array);
  }

  ValueArray39(const ValueArray39& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_) {}

 private:
  
  void operator=(const ValueArray39& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
class ValueArray40 {
 public:
  ValueArray40(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),
      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),
      v40_(v40) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_)};
    return ValuesIn(array);
  }

  ValueArray40(const ValueArray40& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_) {}

 private:
  
  void operator=(const ValueArray40& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
class ValueArray41 {
 public:
  ValueArray41(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,
      T41 v41) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_)};
    return ValuesIn(array);
  }

  ValueArray41(const ValueArray41& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_) {}

 private:
  
  void operator=(const ValueArray41& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
class ValueArray42 {
 public:
  ValueArray42(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_)};
    return ValuesIn(array);
  }

  ValueArray42(const ValueArray42& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_) {}

 private:
  
  void operator=(const ValueArray42& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
class ValueArray43 {
 public:
  ValueArray43(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6),
      v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13),
      v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19),
      v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25),
      v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31),
      v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37),
      v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_)};
    return ValuesIn(array);
  }

  ValueArray43(const ValueArray43& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_) {}

 private:
  
  void operator=(const ValueArray43& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
class ValueArray44 {
 public:
  ValueArray44(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5),
      v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12),
      v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17), v18_(v18),
      v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23), v24_(v24),
      v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29), v30_(v30),
      v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35), v36_(v36),
      v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41), v42_(v42),
      v43_(v43), v44_(v44) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_)};
    return ValuesIn(array);
  }

  ValueArray44(const ValueArray44& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_) {}

 private:
  
  void operator=(const ValueArray44& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
class ValueArray45 {
 public:
  ValueArray45(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45) : v1_(v1), v2_(v2), v3_(v3), v4_(v4),
      v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10), v11_(v11),
      v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16), v17_(v17),
      v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22), v23_(v23),
      v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28), v29_(v29),
      v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34), v35_(v35),
      v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40), v41_(v41),
      v42_(v42), v43_(v43), v44_(v44), v45_(v45) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_)};
    return ValuesIn(array);
  }

  ValueArray45(const ValueArray45& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_) {}

 private:
  
  void operator=(const ValueArray45& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
class ValueArray46 {
 public:
  ValueArray46(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) : v1_(v1), v2_(v2), v3_(v3),
      v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),
      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_)};
    return ValuesIn(array);
  }

  ValueArray46(const ValueArray46& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_), v46_(other.v46_) {}

 private:
  
  void operator=(const ValueArray46& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
class ValueArray47 {
 public:
  ValueArray47(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) : v1_(v1), v2_(v2),
      v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9), v10_(v10),
      v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15), v16_(v16),
      v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21), v22_(v22),
      v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27), v28_(v28),
      v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33), v34_(v34),
      v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39), v40_(v40),
      v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45), v46_(v46),
      v47_(v47) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_)};
    return ValuesIn(array);
  }

  ValueArray47(const ValueArray47& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_), v46_(other.v46_),
      v47_(other.v47_) {}

 private:
  
  void operator=(const ValueArray47& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
class ValueArray48 {
 public:
  ValueArray48(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48) : v1_(v1),
      v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7), v8_(v8), v9_(v9),
      v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14), v15_(v15),
      v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20), v21_(v21),
      v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26), v27_(v27),
      v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32), v33_(v33),
      v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38), v39_(v39),
      v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44), v45_(v45),
      v46_(v46), v47_(v47), v48_(v48) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_)};
    return ValuesIn(array);
  }

  ValueArray48(const ValueArray48& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_), v46_(other.v46_),
      v47_(other.v47_), v48_(other.v48_) {}

 private:
  
  void operator=(const ValueArray48& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
class ValueArray49 {
 public:
  ValueArray49(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48,
      T49 v49) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),
      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_), static_cast<T>(v49_)};
    return ValuesIn(array);
  }

  ValueArray49(const ValueArray49& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_), v46_(other.v46_),
      v47_(other.v47_), v48_(other.v48_), v49_(other.v49_) {}

 private:
  
  void operator=(const ValueArray49& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
  const T49 v49_;
};

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
class ValueArray50 {
 public:
  ValueArray50(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
      T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
      T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
      T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
      T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
      T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47, T48 v48, T49 v49,
      T50 v50) : v1_(v1), v2_(v2), v3_(v3), v4_(v4), v5_(v5), v6_(v6), v7_(v7),
      v8_(v8), v9_(v9), v10_(v10), v11_(v11), v12_(v12), v13_(v13), v14_(v14),
      v15_(v15), v16_(v16), v17_(v17), v18_(v18), v19_(v19), v20_(v20),
      v21_(v21), v22_(v22), v23_(v23), v24_(v24), v25_(v25), v26_(v26),
      v27_(v27), v28_(v28), v29_(v29), v30_(v30), v31_(v31), v32_(v32),
      v33_(v33), v34_(v34), v35_(v35), v36_(v36), v37_(v37), v38_(v38),
      v39_(v39), v40_(v40), v41_(v41), v42_(v42), v43_(v43), v44_(v44),
      v45_(v45), v46_(v46), v47_(v47), v48_(v48), v49_(v49), v50_(v50) {}

  template <typename T>
  operator ParamGenerator<T>() const {
    const T array[] = {static_cast<T>(v1_), static_cast<T>(v2_),
        static_cast<T>(v3_), static_cast<T>(v4_), static_cast<T>(v5_),
        static_cast<T>(v6_), static_cast<T>(v7_), static_cast<T>(v8_),
        static_cast<T>(v9_), static_cast<T>(v10_), static_cast<T>(v11_),
        static_cast<T>(v12_), static_cast<T>(v13_), static_cast<T>(v14_),
        static_cast<T>(v15_), static_cast<T>(v16_), static_cast<T>(v17_),
        static_cast<T>(v18_), static_cast<T>(v19_), static_cast<T>(v20_),
        static_cast<T>(v21_), static_cast<T>(v22_), static_cast<T>(v23_),
        static_cast<T>(v24_), static_cast<T>(v25_), static_cast<T>(v26_),
        static_cast<T>(v27_), static_cast<T>(v28_), static_cast<T>(v29_),
        static_cast<T>(v30_), static_cast<T>(v31_), static_cast<T>(v32_),
        static_cast<T>(v33_), static_cast<T>(v34_), static_cast<T>(v35_),
        static_cast<T>(v36_), static_cast<T>(v37_), static_cast<T>(v38_),
        static_cast<T>(v39_), static_cast<T>(v40_), static_cast<T>(v41_),
        static_cast<T>(v42_), static_cast<T>(v43_), static_cast<T>(v44_),
        static_cast<T>(v45_), static_cast<T>(v46_), static_cast<T>(v47_),
        static_cast<T>(v48_), static_cast<T>(v49_), static_cast<T>(v50_)};
    return ValuesIn(array);
  }

  ValueArray50(const ValueArray50& other) : v1_(other.v1_), v2_(other.v2_),
      v3_(other.v3_), v4_(other.v4_), v5_(other.v5_), v6_(other.v6_),
      v7_(other.v7_), v8_(other.v8_), v9_(other.v9_), v10_(other.v10_),
      v11_(other.v11_), v12_(other.v12_), v13_(other.v13_), v14_(other.v14_),
      v15_(other.v15_), v16_(other.v16_), v17_(other.v17_), v18_(other.v18_),
      v19_(other.v19_), v20_(other.v20_), v21_(other.v21_), v22_(other.v22_),
      v23_(other.v23_), v24_(other.v24_), v25_(other.v25_), v26_(other.v26_),
      v27_(other.v27_), v28_(other.v28_), v29_(other.v29_), v30_(other.v30_),
      v31_(other.v31_), v32_(other.v32_), v33_(other.v33_), v34_(other.v34_),
      v35_(other.v35_), v36_(other.v36_), v37_(other.v37_), v38_(other.v38_),
      v39_(other.v39_), v40_(other.v40_), v41_(other.v41_), v42_(other.v42_),
      v43_(other.v43_), v44_(other.v44_), v45_(other.v45_), v46_(other.v46_),
      v47_(other.v47_), v48_(other.v48_), v49_(other.v49_), v50_(other.v50_) {}

 private:
  
  void operator=(const ValueArray50& other);

  const T1 v1_;
  const T2 v2_;
  const T3 v3_;
  const T4 v4_;
  const T5 v5_;
  const T6 v6_;
  const T7 v7_;
  const T8 v8_;
  const T9 v9_;
  const T10 v10_;
  const T11 v11_;
  const T12 v12_;
  const T13 v13_;
  const T14 v14_;
  const T15 v15_;
  const T16 v16_;
  const T17 v17_;
  const T18 v18_;
  const T19 v19_;
  const T20 v20_;
  const T21 v21_;
  const T22 v22_;
  const T23 v23_;
  const T24 v24_;
  const T25 v25_;
  const T26 v26_;
  const T27 v27_;
  const T28 v28_;
  const T29 v29_;
  const T30 v30_;
  const T31 v31_;
  const T32 v32_;
  const T33 v33_;
  const T34 v34_;
  const T35 v35_;
  const T36 v36_;
  const T37 v37_;
  const T38 v38_;
  const T39 v39_;
  const T40 v40_;
  const T41 v41_;
  const T42 v42_;
  const T43 v43_;
  const T44 v44_;
  const T45 v45_;
  const T46 v46_;
  const T47 v47_;
  const T48 v48_;
  const T49 v49_;
  const T50 v50_;
};







template <typename T1, typename T2>
class CartesianProductGenerator2
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2> > {
 public:
  typedef ::testing::tuple<T1, T2> ParamType;

  CartesianProductGenerator2(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2)
      : g1_(g1), g2_(g2) {}
  virtual ~CartesianProductGenerator2() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current2_;
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 3623).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator2& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
};  


template <typename T1, typename T2, typename T3>
class CartesianProductGenerator3
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3> > {
 public:
  typedef ::testing::tuple<T1, T2, T3> ParamType;

  CartesianProductGenerator3(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3)
      : g1_(g1), g2_(g2), g3_(g3) {}
  virtual ~CartesianProductGenerator3() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current3_;
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 3746).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator3& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
};  


template <typename T1, typename T2, typename T3, typename T4>
class CartesianProductGenerator4
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4> ParamType;

  CartesianProductGenerator4(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}
  virtual ~CartesianProductGenerator4() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current4_;
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 3887).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator4& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5>
class CartesianProductGenerator5
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5> ParamType;

  CartesianProductGenerator5(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}
  virtual ~CartesianProductGenerator5() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current5_;
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 4045).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator5& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
class CartesianProductGenerator6
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5,
        T6> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6> ParamType;

  CartesianProductGenerator6(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}
  virtual ~CartesianProductGenerator6() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current6_;
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 4222).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator6& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
class CartesianProductGenerator7
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> ParamType;

  CartesianProductGenerator7(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}
  virtual ~CartesianProductGenerator7() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current7_;
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 4416).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator7& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
class CartesianProductGenerator8
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> ParamType;

  CartesianProductGenerator8(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),
          g8_(g8) {}
  virtual ~CartesianProductGenerator8() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current8_;
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 4629).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator8& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
class CartesianProductGenerator9
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8, T9> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9> ParamType;

  CartesianProductGenerator9(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9) {}
  virtual ~CartesianProductGenerator9() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end(), g9_, g9_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8,
      const ParamGenerator<T9>& g9,
      const typename ParamGenerator<T9>::iterator& current9)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),
          begin9_(g9.begin()), end9_(g9.end()), current9_(current9)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current9_;
      if (current9_ == end9_) {
        current9_ = begin9_;
        ++current8_;
      }
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 4858).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_ &&
          current9_ == typed_other->current9_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_),
        begin9_(other.begin9_),
        end9_(other.end9_),
        current9_(other.current9_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_,
            *current9_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_ ||
          current9_ == end9_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    const typename ParamGenerator<T9>::iterator begin9_;
    const typename ParamGenerator<T9>::iterator end9_;
    typename ParamGenerator<T9>::iterator current9_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator9& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
  const ParamGenerator<T9> g9_;
};  


template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
class CartesianProductGenerator10
    : public ParamGeneratorInterface< ::testing::tuple<T1, T2, T3, T4, T5, T6,
        T7, T8, T9, T10> > {
 public:
  typedef ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> ParamType;

  CartesianProductGenerator10(const ParamGenerator<T1>& g1,
      const ParamGenerator<T2>& g2, const ParamGenerator<T3>& g3,
      const ParamGenerator<T4>& g4, const ParamGenerator<T5>& g5,
      const ParamGenerator<T6>& g6, const ParamGenerator<T7>& g7,
      const ParamGenerator<T8>& g8, const ParamGenerator<T9>& g9,
      const ParamGenerator<T10>& g10)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9), g10_(g10) {}
  virtual ~CartesianProductGenerator10() {}

  virtual ParamIteratorInterface<ParamType>* Begin() const {
    return new Iterator(this, g1_, g1_.begin(), g2_, g2_.begin(), g3_,
        g3_.begin(), g4_, g4_.begin(), g5_, g5_.begin(), g6_, g6_.begin(), g7_,
        g7_.begin(), g8_, g8_.begin(), g9_, g9_.begin(), g10_, g10_.begin());
  }
  virtual ParamIteratorInterface<ParamType>* End() const {
    return new Iterator(this, g1_, g1_.end(), g2_, g2_.end(), g3_, g3_.end(),
        g4_, g4_.end(), g5_, g5_.end(), g6_, g6_.end(), g7_, g7_.end(), g8_,
        g8_.end(), g9_, g9_.end(), g10_, g10_.end());
  }

 private:
  class Iterator : public ParamIteratorInterface<ParamType> {
   public:
    Iterator(const ParamGeneratorInterface<ParamType>* base,
      const ParamGenerator<T1>& g1,
      const typename ParamGenerator<T1>::iterator& current1,
      const ParamGenerator<T2>& g2,
      const typename ParamGenerator<T2>::iterator& current2,
      const ParamGenerator<T3>& g3,
      const typename ParamGenerator<T3>::iterator& current3,
      const ParamGenerator<T4>& g4,
      const typename ParamGenerator<T4>::iterator& current4,
      const ParamGenerator<T5>& g5,
      const typename ParamGenerator<T5>::iterator& current5,
      const ParamGenerator<T6>& g6,
      const typename ParamGenerator<T6>::iterator& current6,
      const ParamGenerator<T7>& g7,
      const typename ParamGenerator<T7>::iterator& current7,
      const ParamGenerator<T8>& g8,
      const typename ParamGenerator<T8>::iterator& current8,
      const ParamGenerator<T9>& g9,
      const typename ParamGenerator<T9>::iterator& current9,
      const ParamGenerator<T10>& g10,
      const typename ParamGenerator<T10>::iterator& current10)
        : base_(base),
          begin1_(g1.begin()), end1_(g1.end()), current1_(current1),
          begin2_(g2.begin()), end2_(g2.end()), current2_(current2),
          begin3_(g3.begin()), end3_(g3.end()), current3_(current3),
          begin4_(g4.begin()), end4_(g4.end()), current4_(current4),
          begin5_(g5.begin()), end5_(g5.end()), current5_(current5),
          begin6_(g6.begin()), end6_(g6.end()), current6_(current6),
          begin7_(g7.begin()), end7_(g7.end()), current7_(current7),
          begin8_(g8.begin()), end8_(g8.end()), current8_(current8),
          begin9_(g9.begin()), end9_(g9.end()), current9_(current9),
          begin10_(g10.begin()), end10_(g10.end()), current10_(current10)    {
      ComputeCurrentValue();
    }
    virtual ~Iterator() {}

    virtual const ParamGeneratorInterface<ParamType>* BaseGenerator() const {
      return base_;
    }
    
    
    virtual void Advance() {
      ((void)0);
      ++current10_;
      if (current10_ == end10_) {
        current10_ = begin10_;
        ++current9_;
      }
      if (current9_ == end9_) {
        current9_ = begin9_;
        ++current8_;
      }
      if (current8_ == end8_) {
        current8_ = begin8_;
        ++current7_;
      }
      if (current7_ == end7_) {
        current7_ = begin7_;
        ++current6_;
      }
      if (current6_ == end6_) {
        current6_ = begin6_;
        ++current5_;
      }
      if (current5_ == end5_) {
        current5_ = begin5_;
        ++current4_;
      }
      if (current4_ == end4_) {
        current4_ = begin4_;
        ++current3_;
      }
      if (current3_ == end3_) {
        current3_ = begin3_;
        ++current2_;
      }
      if (current2_ == end2_) {
        current2_ = begin2_;
        ++current1_;
      }
      ComputeCurrentValue();
    }
    virtual ParamIteratorInterface<ParamType>* Clone() const {
      return new Iterator(*this);
    }
    virtual const ParamType* Current() const { return current_value_.get(); }
    virtual bool Equals(const ParamIteratorInterface<ParamType>& other) const {
      
      
      switch (0) case 0: default: if (::testing::internal::IsTrue(BaseGenerator() == other.BaseGenerator())) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h", 5105).GetStream() << "Condition " "BaseGenerator() == other.BaseGenerator()" " failed. "
          << "The program attempted to compare iterators "
          << "from different generators." << std::endl;
      const Iterator* typed_other =
          CheckedDowncastToActualType<const Iterator>(&other);
      
      
      
      return (AtEnd() && typed_other->AtEnd()) ||
         (
          current1_ == typed_other->current1_ &&
          current2_ == typed_other->current2_ &&
          current3_ == typed_other->current3_ &&
          current4_ == typed_other->current4_ &&
          current5_ == typed_other->current5_ &&
          current6_ == typed_other->current6_ &&
          current7_ == typed_other->current7_ &&
          current8_ == typed_other->current8_ &&
          current9_ == typed_other->current9_ &&
          current10_ == typed_other->current10_);
    }

   private:
    Iterator(const Iterator& other)
        : base_(other.base_),
        begin1_(other.begin1_),
        end1_(other.end1_),
        current1_(other.current1_),
        begin2_(other.begin2_),
        end2_(other.end2_),
        current2_(other.current2_),
        begin3_(other.begin3_),
        end3_(other.end3_),
        current3_(other.current3_),
        begin4_(other.begin4_),
        end4_(other.end4_),
        current4_(other.current4_),
        begin5_(other.begin5_),
        end5_(other.end5_),
        current5_(other.current5_),
        begin6_(other.begin6_),
        end6_(other.end6_),
        current6_(other.current6_),
        begin7_(other.begin7_),
        end7_(other.end7_),
        current7_(other.current7_),
        begin8_(other.begin8_),
        end8_(other.end8_),
        current8_(other.current8_),
        begin9_(other.begin9_),
        end9_(other.end9_),
        current9_(other.current9_),
        begin10_(other.begin10_),
        end10_(other.end10_),
        current10_(other.current10_) {
      ComputeCurrentValue();
    }

    void ComputeCurrentValue() {
      if (!AtEnd())
        current_value_.reset(new ParamType(*current1_, *current2_, *current3_,
            *current4_, *current5_, *current6_, *current7_, *current8_,
            *current9_, *current10_));
    }
    bool AtEnd() const {
      
      
      return
          current1_ == end1_ ||
          current2_ == end2_ ||
          current3_ == end3_ ||
          current4_ == end4_ ||
          current5_ == end5_ ||
          current6_ == end6_ ||
          current7_ == end7_ ||
          current8_ == end8_ ||
          current9_ == end9_ ||
          current10_ == end10_;
    }

    
    void operator=(const Iterator& other);

    const ParamGeneratorInterface<ParamType>* const base_;
    
    
    const typename ParamGenerator<T1>::iterator begin1_;
    const typename ParamGenerator<T1>::iterator end1_;
    typename ParamGenerator<T1>::iterator current1_;
    const typename ParamGenerator<T2>::iterator begin2_;
    const typename ParamGenerator<T2>::iterator end2_;
    typename ParamGenerator<T2>::iterator current2_;
    const typename ParamGenerator<T3>::iterator begin3_;
    const typename ParamGenerator<T3>::iterator end3_;
    typename ParamGenerator<T3>::iterator current3_;
    const typename ParamGenerator<T4>::iterator begin4_;
    const typename ParamGenerator<T4>::iterator end4_;
    typename ParamGenerator<T4>::iterator current4_;
    const typename ParamGenerator<T5>::iterator begin5_;
    const typename ParamGenerator<T5>::iterator end5_;
    typename ParamGenerator<T5>::iterator current5_;
    const typename ParamGenerator<T6>::iterator begin6_;
    const typename ParamGenerator<T6>::iterator end6_;
    typename ParamGenerator<T6>::iterator current6_;
    const typename ParamGenerator<T7>::iterator begin7_;
    const typename ParamGenerator<T7>::iterator end7_;
    typename ParamGenerator<T7>::iterator current7_;
    const typename ParamGenerator<T8>::iterator begin8_;
    const typename ParamGenerator<T8>::iterator end8_;
    typename ParamGenerator<T8>::iterator current8_;
    const typename ParamGenerator<T9>::iterator begin9_;
    const typename ParamGenerator<T9>::iterator end9_;
    typename ParamGenerator<T9>::iterator current9_;
    const typename ParamGenerator<T10>::iterator begin10_;
    const typename ParamGenerator<T10>::iterator end10_;
    typename ParamGenerator<T10>::iterator current10_;
    linked_ptr<ParamType> current_value_;
  };  

  
  void operator=(const CartesianProductGenerator10& other);

  const ParamGenerator<T1> g1_;
  const ParamGenerator<T2> g2_;
  const ParamGenerator<T3> g3_;
  const ParamGenerator<T4> g4_;
  const ParamGenerator<T5> g5_;
  const ParamGenerator<T6> g6_;
  const ParamGenerator<T7> g7_;
  const ParamGenerator<T8> g8_;
  const ParamGenerator<T9> g9_;
  const ParamGenerator<T10> g10_;
};  








template <class Generator1, class Generator2>
class CartesianProductHolder2 {
 public:
CartesianProductHolder2(const Generator1& g1, const Generator2& g2)
      : g1_(g1), g2_(g2) {}
  template <typename T1, typename T2>
  operator ParamGenerator< ::testing::tuple<T1, T2> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2> >(
        new CartesianProductGenerator2<T1, T2>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_)));
  }

 private:
  
  void operator=(const CartesianProductHolder2& other);

  const Generator1 g1_;
  const Generator2 g2_;
};  

template <class Generator1, class Generator2, class Generator3>
class CartesianProductHolder3 {
 public:
CartesianProductHolder3(const Generator1& g1, const Generator2& g2,
    const Generator3& g3)
      : g1_(g1), g2_(g2), g3_(g3) {}
  template <typename T1, typename T2, typename T3>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3> >(
        new CartesianProductGenerator3<T1, T2, T3>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_)));
  }

 private:
  
  void operator=(const CartesianProductHolder3& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4>
class CartesianProductHolder4 {
 public:
CartesianProductHolder4(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4) {}
  template <typename T1, typename T2, typename T3, typename T4>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4> >(
        new CartesianProductGenerator4<T1, T2, T3, T4>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_)));
  }

 private:
  
  void operator=(const CartesianProductHolder4& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5>
class CartesianProductHolder5 {
 public:
CartesianProductHolder5(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5> >(
        new CartesianProductGenerator5<T1, T2, T3, T4, T5>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_)));
  }

 private:
  
  void operator=(const CartesianProductHolder5& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6>
class CartesianProductHolder6 {
 public:
CartesianProductHolder6(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6> >(
        new CartesianProductGenerator6<T1, T2, T3, T4, T5, T6>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_)));
  }

 private:
  
  void operator=(const CartesianProductHolder6& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7>
class CartesianProductHolder7 {
 public:
CartesianProductHolder7(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6,
      T7> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7> >(
        new CartesianProductGenerator7<T1, T2, T3, T4, T5, T6, T7>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_)));
  }

 private:
  
  void operator=(const CartesianProductHolder7& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8>
class CartesianProductHolder8 {
 public:
CartesianProductHolder8(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7),
          g8_(g8) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7,
      T8> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8> >(
        new CartesianProductGenerator8<T1, T2, T3, T4, T5, T6, T7, T8>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_)));
  }

 private:
  
  void operator=(const CartesianProductHolder8& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8, class Generator9>
class CartesianProductHolder9 {
 public:
CartesianProductHolder9(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8,
    const Generator9& g9)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8, typename T9>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,
      T9> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8,
        T9> >(
        new CartesianProductGenerator9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_),
        static_cast<ParamGenerator<T9> >(g9_)));
  }

 private:
  
  void operator=(const CartesianProductHolder9& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
  const Generator9 g9_;
};  

template <class Generator1, class Generator2, class Generator3,
    class Generator4, class Generator5, class Generator6, class Generator7,
    class Generator8, class Generator9, class Generator10>
class CartesianProductHolder10 {
 public:
CartesianProductHolder10(const Generator1& g1, const Generator2& g2,
    const Generator3& g3, const Generator4& g4, const Generator5& g5,
    const Generator6& g6, const Generator7& g7, const Generator8& g8,
    const Generator9& g9, const Generator10& g10)
      : g1_(g1), g2_(g2), g3_(g3), g4_(g4), g5_(g5), g6_(g6), g7_(g7), g8_(g8),
          g9_(g9), g10_(g10) {}
  template <typename T1, typename T2, typename T3, typename T4, typename T5,
      typename T6, typename T7, typename T8, typename T9, typename T10>
  operator ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,
      T10> >() const {
    return ParamGenerator< ::testing::tuple<T1, T2, T3, T4, T5, T6, T7, T8, T9,
        T10> >(
        new CartesianProductGenerator10<T1, T2, T3, T4, T5, T6, T7, T8, T9,
            T10>(
        static_cast<ParamGenerator<T1> >(g1_),
        static_cast<ParamGenerator<T2> >(g2_),
        static_cast<ParamGenerator<T3> >(g3_),
        static_cast<ParamGenerator<T4> >(g4_),
        static_cast<ParamGenerator<T5> >(g5_),
        static_cast<ParamGenerator<T6> >(g6_),
        static_cast<ParamGenerator<T7> >(g7_),
        static_cast<ParamGenerator<T8> >(g8_),
        static_cast<ParamGenerator<T9> >(g9_),
        static_cast<ParamGenerator<T10> >(g10_)));
  }

 private:
  
  void operator=(const CartesianProductHolder10& other);

  const Generator1 g1_;
  const Generator2 g2_;
  const Generator3 g3_;
  const Generator4 g4_;
  const Generator5 g5_;
  const Generator6 g6_;
  const Generator7 g7_;
  const Generator8 g8_;
  const Generator9 g9_;
  const Generator10 g10_;
};  

#line 5548 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h"

}  
}  

#line 5553 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\internal\\gtest-param-util-generated.h"
#line 190 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"

namespace testing {











































template <typename T, typename IncrementT>
internal::ParamGenerator<T> Range(T start, T end, IncrementT step) {
  return internal::ParamGenerator<T>(
      new internal::RangeGenerator<T, IncrementT>(start, end, step));
}

template <typename T>
internal::ParamGenerator<T> Range(T start, T end) {
  return Range(start, end, 1);
}
























































template <typename ForwardIterator>
internal::ParamGenerator<
  typename ::testing::internal::IteratorTraits<ForwardIterator>::value_type>
ValuesIn(ForwardIterator begin, ForwardIterator end) {
  typedef typename ::testing::internal::IteratorTraits<ForwardIterator>
      ::value_type ParamType;
  return internal::ParamGenerator<ParamType>(
      new internal::ValuesInIteratorRangeGenerator<ParamType>(begin, end));
}

template <typename T, size_t N>
internal::ParamGenerator<T> ValuesIn(const T (&array)[N]) {
  return ValuesIn(array, array + N);
}

template <class Container>
internal::ParamGenerator<typename Container::value_type> ValuesIn(
    const Container& container) {
  return ValuesIn(container.begin(), container.end());
}




















template <typename T1>
internal::ValueArray1<T1> Values(T1 v1) {
  return internal::ValueArray1<T1>(v1);
}

template <typename T1, typename T2>
internal::ValueArray2<T1, T2> Values(T1 v1, T2 v2) {
  return internal::ValueArray2<T1, T2>(v1, v2);
}

template <typename T1, typename T2, typename T3>
internal::ValueArray3<T1, T2, T3> Values(T1 v1, T2 v2, T3 v3) {
  return internal::ValueArray3<T1, T2, T3>(v1, v2, v3);
}

template <typename T1, typename T2, typename T3, typename T4>
internal::ValueArray4<T1, T2, T3, T4> Values(T1 v1, T2 v2, T3 v3, T4 v4) {
  return internal::ValueArray4<T1, T2, T3, T4>(v1, v2, v3, v4);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5>
internal::ValueArray5<T1, T2, T3, T4, T5> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5) {
  return internal::ValueArray5<T1, T2, T3, T4, T5>(v1, v2, v3, v4, v5);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6>
internal::ValueArray6<T1, T2, T3, T4, T5, T6> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6) {
  return internal::ValueArray6<T1, T2, T3, T4, T5, T6>(v1, v2, v3, v4, v5, v6);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7>
internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7) {
  return internal::ValueArray7<T1, T2, T3, T4, T5, T6, T7>(v1, v2, v3, v4, v5,
      v6, v7);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8>
internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8) {
  return internal::ValueArray8<T1, T2, T3, T4, T5, T6, T7, T8>(v1, v2, v3, v4,
      v5, v6, v7, v8);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9>
internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9) {
  return internal::ValueArray9<T1, T2, T3, T4, T5, T6, T7, T8, T9>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10>
internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10) {
  return internal::ValueArray10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11>
internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
    T11> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11) {
  return internal::ValueArray11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
      T11>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12>
internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
    T12> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12) {
  return internal::ValueArray12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13>
internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
    T13> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13) {
  return internal::ValueArray13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14>
internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14) {
  return internal::ValueArray14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15>
internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15) {
  return internal::ValueArray15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16>
internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16) {
  return internal::ValueArray16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17>
internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17) {
  return internal::ValueArray17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18>
internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18) {
  return internal::ValueArray18<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19>
internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19) {
  return internal::ValueArray19<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20>
internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20) {
  return internal::ValueArray20<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21>
internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21) {
  return internal::ValueArray21<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22>
internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22) {
  return internal::ValueArray22<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23>
internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23) {
  return internal::ValueArray23<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24>
internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24) {
  return internal::ValueArray24<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24>(v1, v2,
      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
      v19, v20, v21, v22, v23, v24);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25>
internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,
    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,
    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25) {
  return internal::ValueArray25<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,
      v18, v19, v20, v21, v22, v23, v24, v25);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26>
internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
    T26> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26) {
  return internal::ValueArray26<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27>
internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26,
    T27> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27) {
  return internal::ValueArray27<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28>
internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27,
    T28> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28) {
  return internal::ValueArray28<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,
      v28);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29>
internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29) {
  return internal::ValueArray29<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27, v28, v29);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30>
internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30) {
  return internal::ValueArray30<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,
      v26, v27, v28, v29, v30);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31>
internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31) {
  return internal::ValueArray31<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,
      v25, v26, v27, v28, v29, v30, v31);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32>
internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32) {
  return internal::ValueArray32<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33>
internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33) {
  return internal::ValueArray33<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34>
internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,
    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,
    T31 v31, T32 v32, T33 v33, T34 v34) {
  return internal::ValueArray34<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,
      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35>
internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35) {
  return internal::ValueArray35<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36>
internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36) {
  return internal::ValueArray36<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37>
internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37> Values(T1 v1, T2 v2, T3 v3,
    T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37) {
  return internal::ValueArray37<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37>(v1, v2, v3,
      v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36, v37);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38>
internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37, T38 v38) {
  return internal::ValueArray38<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38>(v1, v2,
      v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,
      v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32,
      v33, v34, v35, v36, v37, v38);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39>
internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39> Values(T1 v1, T2 v2,
    T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12,
    T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20,
    T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28,
    T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36,
    T37 v37, T38 v38, T39 v39) {
  return internal::ValueArray39<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39>(v1,
      v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,
      v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31,
      v32, v33, v34, v35, v36, v37, v38, v39);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40>
internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40> Values(T1 v1,
    T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11,
    T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19,
    T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27,
    T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35,
    T36 v36, T37 v37, T38 v38, T39 v39, T40 v40) {
  return internal::ValueArray40<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15,
      v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29,
      v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41>
internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40,
    T41> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41) {
  return internal::ValueArray41<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,
      v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,
      v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42>
internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41,
    T42> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42) {
  return internal::ValueArray42<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
      v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27,
      v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41,
      v42);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43>
internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42,
    T43> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42, T43 v43) {
  return internal::ValueArray43<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
      v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26,
      v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40,
      v41, v42, v43);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44>
internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8, T9 v9,
    T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16, T17 v17,
    T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24, T25 v25,
    T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32, T33 v33,
    T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40, T41 v41,
    T42 v42, T43 v43, T44 v44) {
  return internal::ValueArray44<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
      v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,
      v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39,
      v40, v41, v42, v43, v44);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45>
internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7, T8 v8,
    T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15, T16 v16,
    T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23, T24 v24,
    T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31, T32 v32,
    T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39, T40 v40,
    T41 v41, T42 v42, T43 v43, T44 v44, T45 v45) {
  return internal::ValueArray45<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45>(v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,
      v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,
      v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38,
      v39, v40, v41, v42, v43, v44, v45);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46>
internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46) {
  return internal::ValueArray46<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46>(v1, v2, v3, v4, v5, v6, v7, v8, v9,
      v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,
      v38, v39, v40, v41, v42, v43, v44, v45, v46);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47>
internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6, T7 v7,
    T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47) {
  return internal::ValueArray47<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47>(v1, v2, v3, v4, v5, v6, v7, v8,
      v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23,
      v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37,
      v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48>
internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5, T6 v6,
    T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14, T15 v15,
    T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22, T23 v23,
    T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30, T31 v31,
    T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38, T39 v39,
    T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46, T47 v47,
    T48 v48) {
  return internal::ValueArray48<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48>(v1, v2, v3, v4, v5, v6, v7,
      v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,
      v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36,
      v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49>
internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49> Values(T1 v1, T2 v2, T3 v3, T4 v4, T5 v5,
    T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13, T14 v14,
    T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21, T22 v22,
    T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29, T30 v30,
    T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37, T38 v38,
    T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45, T46 v46,
    T47 v47, T48 v48, T49 v49) {
  return internal::ValueArray49<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49>(v1, v2, v3, v4, v5, v6,
      v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
      v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35,
      v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49);
}

template <typename T1, typename T2, typename T3, typename T4, typename T5,
    typename T6, typename T7, typename T8, typename T9, typename T10,
    typename T11, typename T12, typename T13, typename T14, typename T15,
    typename T16, typename T17, typename T18, typename T19, typename T20,
    typename T21, typename T22, typename T23, typename T24, typename T25,
    typename T26, typename T27, typename T28, typename T29, typename T30,
    typename T31, typename T32, typename T33, typename T34, typename T35,
    typename T36, typename T37, typename T38, typename T39, typename T40,
    typename T41, typename T42, typename T43, typename T44, typename T45,
    typename T46, typename T47, typename T48, typename T49, typename T50>
internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13,
    T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28,
    T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43,
    T44, T45, T46, T47, T48, T49, T50> Values(T1 v1, T2 v2, T3 v3, T4 v4,
    T5 v5, T6 v6, T7 v7, T8 v8, T9 v9, T10 v10, T11 v11, T12 v12, T13 v13,
    T14 v14, T15 v15, T16 v16, T17 v17, T18 v18, T19 v19, T20 v20, T21 v21,
    T22 v22, T23 v23, T24 v24, T25 v25, T26 v26, T27 v27, T28 v28, T29 v29,
    T30 v30, T31 v31, T32 v32, T33 v33, T34 v34, T35 v35, T36 v36, T37 v37,
    T38 v38, T39 v39, T40 v40, T41 v41, T42 v42, T43 v43, T44 v44, T45 v45,
    T46 v46, T47 v47, T48 v48, T49 v49, T50 v50) {
  return internal::ValueArray50<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11,
      T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25,
      T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39,
      T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50>(v1, v2, v3, v4,
      v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,
      v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33,
      v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47,
      v48, v49, v50);
}





















inline internal::ParamGenerator<bool> Bool() {
  return Values(false, true);
}


















































template <typename Generator1, typename Generator2>
internal::CartesianProductHolder2<Generator1, Generator2> Combine(
    const Generator1& g1, const Generator2& g2) {
  return internal::CartesianProductHolder2<Generator1, Generator2>(
      g1, g2);
}

template <typename Generator1, typename Generator2, typename Generator3>
internal::CartesianProductHolder3<Generator1, Generator2, Generator3> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3) {
  return internal::CartesianProductHolder3<Generator1, Generator2, Generator3>(
      g1, g2, g3);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4>
internal::CartesianProductHolder4<Generator1, Generator2, Generator3,
    Generator4> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4) {
  return internal::CartesianProductHolder4<Generator1, Generator2, Generator3,
      Generator4>(
      g1, g2, g3, g4);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5>
internal::CartesianProductHolder5<Generator1, Generator2, Generator3,
    Generator4, Generator5> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5) {
  return internal::CartesianProductHolder5<Generator1, Generator2, Generator3,
      Generator4, Generator5>(
      g1, g2, g3, g4, g5);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6>
internal::CartesianProductHolder6<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6) {
  return internal::CartesianProductHolder6<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6>(
      g1, g2, g3, g4, g5, g6);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7>
internal::CartesianProductHolder7<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7) {
  return internal::CartesianProductHolder7<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7>(
      g1, g2, g3, g4, g5, g6, g7);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8>
internal::CartesianProductHolder8<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8) {
  return internal::CartesianProductHolder8<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8>(
      g1, g2, g3, g4, g5, g6, g7, g8);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8, typename Generator9>
internal::CartesianProductHolder9<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8,
    Generator9> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8, const Generator9& g9) {
  return internal::CartesianProductHolder9<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9>(
      g1, g2, g3, g4, g5, g6, g7, g8, g9);
}

template <typename Generator1, typename Generator2, typename Generator3,
    typename Generator4, typename Generator5, typename Generator6,
    typename Generator7, typename Generator8, typename Generator9,
    typename Generator10>
internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
    Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,
    Generator10> Combine(
    const Generator1& g1, const Generator2& g2, const Generator3& g3,
        const Generator4& g4, const Generator5& g5, const Generator6& g6,
        const Generator7& g7, const Generator8& g8, const Generator9& g9,
        const Generator10& g10) {
  return internal::CartesianProductHolder10<Generator1, Generator2, Generator3,
      Generator4, Generator5, Generator6, Generator7, Generator8, Generator9,
      Generator10>(
      g1, g2, g3, g4, g5, g6, g7, g8, g9, g10);
}
#line 1371 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"





























































}  

#line 1435 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-param-test.h"
#line 64 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest_prod.h"




























































#line 62 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest_prod.h"
#line 66 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-test-part.h"








































__pragma(warning(push)) __pragma(warning(disable: 4251))

namespace testing {





class  TestPartResult {
 public:
  
  
  enum Type {
    kSuccess,          
    kNonFatalFailure,  
    kFatalFailure      
  };

  
  
  
  TestPartResult(Type a_type,
                 const char* a_file_name,
                 int a_line_number,
                 const char* a_message)
      : type_(a_type),
        file_name_(a_file_name == 0 ? "" : a_file_name),
        line_number_(a_line_number),
        summary_(ExtractSummary(a_message)),
        message_(a_message) {
  }

  
  Type type() const { return type_; }

  
  
  const char* file_name() const {
    return file_name_.empty() ? 0 : file_name_.c_str();
  }

  
  
  int line_number() const { return line_number_; }

  
  const char* summary() const { return summary_.c_str(); }

  
  const char* message() const { return message_.c_str(); }

  
  bool passed() const { return type_ == kSuccess; }

  
  bool failed() const { return type_ != kSuccess; }

  
  bool nonfatally_failed() const { return type_ == kNonFatalFailure; }

  
  bool fatally_failed() const { return type_ == kFatalFailure; }

 private:
  Type type_;

  
  
  static std::string ExtractSummary(const char* message);

  
  
  std::string file_name_;
  
  
  int line_number_;
  std::string summary_;  
  std::string message_;  
};


std::ostream& operator<<(std::ostream& os, const TestPartResult& result);





class  TestPartResultArray {
 public:
  TestPartResultArray() {}

  
  void Append(const TestPartResult& result);

  
  const TestPartResult& GetTestPartResult(int index) const;

  
  int size() const;

 private:
  std::vector<TestPartResult> array_;

  TestPartResultArray(TestPartResultArray const &) = delete; void operator=(TestPartResultArray const &) = delete;
};


class  TestPartResultReporterInterface {
 public:
  virtual ~TestPartResultReporterInterface() {}

  virtual void ReportTestPartResult(const TestPartResult& result) = 0;
};

namespace internal {







class  HasNewFatalFailureHelper
    : public TestPartResultReporterInterface {
 public:
  HasNewFatalFailureHelper();
  virtual ~HasNewFatalFailureHelper();
  virtual void ReportTestPartResult(const TestPartResult& result);
  bool has_new_fatal_failure() const { return has_new_fatal_failure_; }
 private:
  bool has_new_fatal_failure_;
  TestPartResultReporterInterface* original_reporter_;

  HasNewFatalFailureHelper(HasNewFatalFailureHelper const &) = delete; void operator=(HasNewFatalFailureHelper const &) = delete;
};

}  

}  

__pragma(warning(pop))  

#line 184 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-test-part.h"
#line 67 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"







































































































#line 105 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"


































































#line 172 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"























































#line 228 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"












































































#line 305 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"

#line 307 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest-typed-test.h"
#line 68 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"


__pragma(warning(push)) __pragma(warning(disable: 4251))
















namespace testing {




#pragma warning(push)
#pragma warning(disable:4805)
#pragma warning(disable:4100)
#line 96 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"





 extern bool FLAGS_gtest_also_run_disabled_tests;


 extern bool FLAGS_gtest_break_on_failure;



 extern bool FLAGS_gtest_catch_exceptions;




 extern ::std::string FLAGS_gtest_color;



 extern ::std::string FLAGS_gtest_filter;



 extern bool FLAGS_gtest_install_failure_signal_handler;



 extern bool FLAGS_gtest_list_tests;



 extern ::std::string FLAGS_gtest_output;



 extern bool FLAGS_gtest_print_time;


 extern bool FLAGS_gtest_print_utf8;


 extern ::testing::internal::Int32 FLAGS_gtest_random_seed;



 extern ::testing::internal::Int32 FLAGS_gtest_repeat;



 extern bool FLAGS_gtest_show_internal_stack_frames;


 extern bool FLAGS_gtest_shuffle;



 extern ::testing::internal::Int32 FLAGS_gtest_stack_trace_depth;




 extern bool FLAGS_gtest_throw_on_failure;




 extern ::std::string FLAGS_gtest_stream_result_to;


 extern ::std::string FLAGS_gtest_flagfile;
#line 169 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"


const int kMaxStackTraceDepth = 100;

namespace internal {

class AssertHelper;
class DefaultGlobalTestPartResultReporter;
class ExecDeathTest;
class NoExecDeathTest;
class FinalSuccessChecker;
class GTestFlagSaver;
class StreamingListenerTest;
class TestResultAccessor;
class TestEventListenersAccessor;
class TestEventRepeater;
class UnitTestRecordPropertyTestHelper;
class WindowsDeathTest;
class FuchsiaDeathTest;
class UnitTestImpl* GetUnitTestImpl();
void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
                                    const std::string& message);

}  




class Test;
class TestCase;
class TestInfo;
class UnitTest;
















































































class  AssertionResult {
 public:
  
  
  AssertionResult(const AssertionResult& other);



#line 290 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

  
  
  
  
  
  
  
  template <typename T>
  explicit AssertionResult(
      const T& success,
      typename internal::EnableIf<
          !internal::ImplicitlyConvertible<T, AssertionResult>::value>::type*
           = 0)
      : success_(success) {}



#line 309 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

  
  AssertionResult& operator=(AssertionResult other) {
    swap(other);
    return *this;
  }

  
  operator bool() const { return success_; }  

  
  AssertionResult operator!() const;

  
  
  
  
  const char* message() const {
    return message_.get() != 0 ?  message_->c_str() : "";
  }
  
  
  const char* failure_message() const { return message(); }

  
  template <typename T> AssertionResult& operator<<(const T& value) {
    AppendMessage(Message() << value);
    return *this;
  }

  
  
  AssertionResult& operator<<(
      ::std::ostream& (*basic_manipulator)(::std::ostream& stream)) {
    AppendMessage(Message() << basic_manipulator);
    return *this;
  }

 private:
  
  void AppendMessage(const Message& a_message) {
    if (message_.get() == 0)
      message_.reset(new ::std::string);
    message_->append(a_message.GetString().c_str());
  }

  
  void swap(AssertionResult& other);

  
  bool success_;
  
  
  
  
  internal::scoped_ptr< ::std::string> message_;
};


 AssertionResult AssertionSuccess();


 AssertionResult AssertionFailure();



 AssertionResult AssertionFailure(const Message& msg);

}  




#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest_pred_impl.h"







































#line 1 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 41 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest_pred_impl.h"

namespace testing {









































template <typename Pred,
          typename T1>
AssertionResult AssertPred1Helper(const char* pred_text,
                                  const char* e1,
                                  Pred pred,
                                  const T1& v1) {
  if (pred(v1)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1;
}





























template <typename Pred,
          typename T1,
          typename T2>
AssertionResult AssertPred2Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2) {
  if (pred(v1, v2)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2;
}































template <typename Pred,
          typename T1,
          typename T2,
          typename T3>
AssertionResult AssertPred3Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3) {
  if (pred(v1, v2, v3)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3;
}

































template <typename Pred,
          typename T1,
          typename T2,
          typename T3,
          typename T4>
AssertionResult AssertPred4Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  const char* e4,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3,
                                  const T4& v4) {
  if (pred(v1, v2, v3, v4)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ", "
                            << e4 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3
                            << "\n" << e4 << " evaluates to " << v4;
}



































template <typename Pred,
          typename T1,
          typename T2,
          typename T3,
          typename T4,
          typename T5>
AssertionResult AssertPred5Helper(const char* pred_text,
                                  const char* e1,
                                  const char* e2,
                                  const char* e3,
                                  const char* e4,
                                  const char* e5,
                                  Pred pred,
                                  const T1& v1,
                                  const T2& v2,
                                  const T3& v3,
                                  const T4& v4,
                                  const T5& v5) {
  if (pred(v1, v2, v3, v4, v5)) return AssertionSuccess();

  return AssertionFailure() << pred_text << "("
                            << e1 << ", "
                            << e2 << ", "
                            << e3 << ", "
                            << e4 << ", "
                            << e5 << ") evaluates to false, where"
                            << "\n" << e1 << " evaluates to " << v1
                            << "\n" << e2 << " evaluates to " << v2
                            << "\n" << e3 << " evaluates to " << v3
                            << "\n" << e4 << " evaluates to " << v4
                            << "\n" << e5 << " evaluates to " << v5;
}



































}  

#line 360 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest_pred_impl.h"
#line 383 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

namespace testing {
























class  Test {
 public:
  friend class TestInfo;

  
  
  typedef internal::SetUpTestCaseFunc SetUpTestCaseFunc;
  typedef internal::TearDownTestCaseFunc TearDownTestCaseFunc;

  
  virtual ~Test();

  
  
  
  
  
  
  static void SetUpTestCase() {}

  
  
  
  
  
  
  static void TearDownTestCase() {}

  
  static bool HasFatalFailure();

  
  static bool HasNonfatalFailure();

  
  
  static bool HasFailure() { return HasFatalFailure() || HasNonfatalFailure(); }

  
  
  
  
  
  
  
  
  
  
  
  
  
  static void RecordProperty(const std::string& key, const std::string& value);
  static void RecordProperty(const std::string& key, int value);

 protected:
  
  Test();

  
  virtual void SetUp();

  
  virtual void TearDown();

 private:
  
  
  static bool HasSameFixtureClass();

  
  
  
  
  
  
  virtual void TestBody() = 0;

  
  void Run();

  
  
  void DeleteSelf_() { delete this; }

  const internal::scoped_ptr< ::testing::internal::GTestFlagSaver > gtest_flag_saver_;

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  struct Setup_should_be_spelled_SetUp {};
  virtual Setup_should_be_spelled_SetUp* Setup() { return 0; }

  
  Test(Test const &) = delete; void operator=(Test const &) = delete;
};

typedef internal::TimeInMillis TimeInMillis;





class TestProperty {
 public:
  
  
  
  TestProperty(const std::string& a_key, const std::string& a_value) :
    key_(a_key), value_(a_value) {
  }

  
  const char* key() const {
    return key_.c_str();
  }

  
  const char* value() const {
    return value_.c_str();
  }

  
  void SetValue(const std::string& new_value) {
    value_ = new_value;
  }

 private:
  
  std::string key_;
  
  std::string value_;
};







class  TestResult {
 public:
  
  TestResult();

  
  ~TestResult();

  
  
  int total_part_count() const;

  
  int test_property_count() const;

  
  bool Passed() const { return !Failed(); }

  
  bool Failed() const;

  
  bool HasFatalFailure() const;

  
  bool HasNonfatalFailure() const;

  
  TimeInMillis elapsed_time() const { return elapsed_time_; }

  
  
  const TestPartResult& GetTestPartResult(int i) const;

  
  
  
  const TestProperty& GetTestProperty(int i) const;

 private:
  friend class TestInfo;
  friend class TestCase;
  friend class UnitTest;
  friend class internal::DefaultGlobalTestPartResultReporter;
  friend class internal::ExecDeathTest;
  friend class internal::TestResultAccessor;
  friend class internal::UnitTestImpl;
  friend class internal::WindowsDeathTest;
  friend class internal::FuchsiaDeathTest;

  
  const std::vector<TestPartResult>& test_part_results() const {
    return test_part_results_;
  }

  
  const std::vector<TestProperty>& test_properties() const {
    return test_properties_;
  }

  
  void set_elapsed_time(TimeInMillis elapsed) { elapsed_time_ = elapsed; }

  
  
  
  
  
  
  void RecordProperty(const std::string& xml_element,
                      const TestProperty& test_property);

  
  
  
  static bool ValidateTestProperty(const std::string& xml_element,
                                   const TestProperty& test_property);

  
  void AddTestPartResult(const TestPartResult& test_part_result);

  
  int death_test_count() const { return death_test_count_; }

  
  int increment_death_test_count() { return ++death_test_count_; }

  
  void ClearTestPartResults();

  
  void Clear();

  
  
  internal::Mutex test_properites_mutex_;

  
  std::vector<TestPartResult> test_part_results_;
  
  std::vector<TestProperty> test_properties_;
  
  int death_test_count_;
  
  TimeInMillis elapsed_time_;

  
  TestResult(TestResult const &) = delete; void operator=(TestResult const &) = delete;
};  












class  TestInfo {
 public:
  
  
  ~TestInfo();

  
  const char* test_case_name() const { return test_case_name_.c_str(); }

  
  const char* name() const { return name_.c_str(); }

  
  
  const char* type_param() const {
    if (type_param_.get() != 0)
      return type_param_->c_str();
    return 0;
  }

  
  
  const char* value_param() const {
    if (value_param_.get() != 0)
      return value_param_->c_str();
    return 0;
  }

  
  const char* file() const { return location_.file.c_str(); }

  
  int line() const { return location_.line; }

  
  bool is_in_another_shard() const { return is_in_another_shard_; }

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  bool should_run() const { return should_run_; }

  
  bool is_reportable() const {
    
    
    return matches_filter_ && !is_in_another_shard_;
  }

  
  const TestResult* result() const { return &result_; }

 private:

  friend class internal::DefaultDeathTestFactory;
#line 751 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
  friend class Test;
  friend class TestCase;
  friend class internal::UnitTestImpl;
  friend class internal::StreamingListenerTest;
  friend TestInfo* internal::MakeAndRegisterTestInfo(
      const char* test_case_name,
      const char* name,
      const char* type_param,
      const char* value_param,
      internal::CodeLocation code_location,
      internal::TypeId fixture_class_id,
      Test::SetUpTestCaseFunc set_up_tc,
      Test::TearDownTestCaseFunc tear_down_tc,
      internal::TestFactoryBase* factory);

  
  
  TestInfo(const std::string& test_case_name,
           const std::string& name,
           const char* a_type_param,   
           const char* a_value_param,  
           internal::CodeLocation a_code_location,
           internal::TypeId fixture_class_id,
           internal::TestFactoryBase* factory);

  
  
  int increment_death_test_count() {
    return result_.increment_death_test_count();
  }

  
  
  void Run();

  static void ClearTestResult(TestInfo* test_info) {
    test_info->result_.Clear();
  }

  
  const std::string test_case_name_;     
  const std::string name_;               
  
  
  const internal::scoped_ptr<const ::std::string> type_param_;
  
  
  const internal::scoped_ptr<const ::std::string> value_param_;
  internal::CodeLocation location_;
  const internal::TypeId fixture_class_id_;   
  bool should_run_;                 
  bool is_disabled_;                
  bool matches_filter_;             
                                    
  bool is_in_another_shard_;        
  internal::TestFactoryBase* const factory_;  
                                              

  
  
  TestResult result_;

  TestInfo(TestInfo const &) = delete; void operator=(TestInfo const &) = delete;
};




class  TestCase {
 public:
  
  
  
  
  
  
  
  
  
  
  
  
  TestCase(const char* name, const char* a_type_param,
           Test::SetUpTestCaseFunc set_up_tc,
           Test::TearDownTestCaseFunc tear_down_tc);

  
  virtual ~TestCase();

  
  const char* name() const { return name_.c_str(); }

  
  
  const char* type_param() const {
    if (type_param_.get() != 0)
      return type_param_->c_str();
    return 0;
  }

  
  bool should_run() const { return should_run_; }

  
  int successful_test_count() const;

  
  int failed_test_count() const;

  
  int reportable_disabled_test_count() const;

  
  int disabled_test_count() const;

  
  int reportable_test_count() const;

  
  int test_to_run_count() const;

  
  int total_test_count() const;

  
  bool Passed() const { return !Failed(); }

  
  bool Failed() const { return failed_test_count() > 0; }

  
  TimeInMillis elapsed_time() const { return elapsed_time_; }

  
  
  const TestInfo* GetTestInfo(int i) const;

  
  
  const TestResult& ad_hoc_test_result() const { return ad_hoc_test_result_; }

 private:
  friend class Test;
  friend class internal::UnitTestImpl;

  
  std::vector<TestInfo*>& test_info_list() { return test_info_list_; }

  
  const std::vector<TestInfo*>& test_info_list() const {
    return test_info_list_;
  }

  
  
  TestInfo* GetMutableTestInfo(int i);

  
  void set_should_run(bool should) { should_run_ = should; }

  
  
  void AddTestInfo(TestInfo * test_info);

  
  void ClearResult();

  
  static void ClearTestCaseResult(TestCase* test_case) {
    test_case->ClearResult();
  }

  
  void Run();

  
  
  void RunSetUpTestCase() { (*set_up_tc_)(); }

  
  
  void RunTearDownTestCase() { (*tear_down_tc_)(); }

  
  static bool TestPassed(const TestInfo* test_info) {
    return test_info->should_run() && test_info->result()->Passed();
  }

  
  static bool TestFailed(const TestInfo* test_info) {
    return test_info->should_run() && test_info->result()->Failed();
  }

  
  
  static bool TestReportableDisabled(const TestInfo* test_info) {
    return test_info->is_reportable() && test_info->is_disabled_;
  }

  
  static bool TestDisabled(const TestInfo* test_info) {
    return test_info->is_disabled_;
  }

  
  static bool TestReportable(const TestInfo* test_info) {
    return test_info->is_reportable();
  }

  
  static bool ShouldRunTest(const TestInfo* test_info) {
    return test_info->should_run();
  }

  
  void ShuffleTests(internal::Random* random);

  
  void UnshuffleTests();

  
  std::string name_;
  
  
  const internal::scoped_ptr<const ::std::string> type_param_;
  
  
  std::vector<TestInfo*> test_info_list_;
  
  
  
  std::vector<int> test_indices_;
  
  Test::SetUpTestCaseFunc set_up_tc_;
  
  Test::TearDownTestCaseFunc tear_down_tc_;
  
  bool should_run_;
  
  TimeInMillis elapsed_time_;
  
  
  TestResult ad_hoc_test_result_;

  
  TestCase(TestCase const &) = delete; void operator=(TestCase const &) = delete;
};















class Environment {
 public:
  
  virtual ~Environment() {}

  
  virtual void SetUp() {}

  
  virtual void TearDown() {}
 private:
  
  
  struct Setup_should_be_spelled_SetUp {};
  virtual Setup_should_be_spelled_SetUp* Setup() { return 0; }
};




class  AssertionException
    : public internal::GoogleTestFailureException {
 public:
  explicit AssertionException(const TestPartResult& result)
      : GoogleTestFailureException(result) {}
};

#line 1041 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



class TestEventListener {
 public:
  virtual ~TestEventListener() {}

  
  virtual void OnTestProgramStart(const UnitTest& unit_test) = 0;

  
  
  
  virtual void OnTestIterationStart(const UnitTest& unit_test,
                                    int iteration) = 0;

  
  virtual void OnEnvironmentsSetUpStart(const UnitTest& unit_test) = 0;

  
  virtual void OnEnvironmentsSetUpEnd(const UnitTest& unit_test) = 0;

  
  virtual void OnTestCaseStart(const TestCase& test_case) = 0;

  
  virtual void OnTestStart(const TestInfo& test_info) = 0;

  
  
  
  virtual void OnTestPartResult(const TestPartResult& test_part_result) = 0;

  
  virtual void OnTestEnd(const TestInfo& test_info) = 0;

  
  virtual void OnTestCaseEnd(const TestCase& test_case) = 0;

  
  virtual void OnEnvironmentsTearDownStart(const UnitTest& unit_test) = 0;

  
  virtual void OnEnvironmentsTearDownEnd(const UnitTest& unit_test) = 0;

  
  virtual void OnTestIterationEnd(const UnitTest& unit_test,
                                  int iteration) = 0;

  
  virtual void OnTestProgramEnd(const UnitTest& unit_test) = 0;
};






class EmptyTestEventListener : public TestEventListener {
 public:
  virtual void OnTestProgramStart(const UnitTest& ) {}
  virtual void OnTestIterationStart(const UnitTest& ,
                                    int ) {}
  virtual void OnEnvironmentsSetUpStart(const UnitTest& ) {}
  virtual void OnEnvironmentsSetUpEnd(const UnitTest& ) {}
  virtual void OnTestCaseStart(const TestCase& ) {}
  virtual void OnTestStart(const TestInfo& ) {}
  virtual void OnTestPartResult(const TestPartResult& ) {}
  virtual void OnTestEnd(const TestInfo& ) {}
  virtual void OnTestCaseEnd(const TestCase& ) {}
  virtual void OnEnvironmentsTearDownStart(const UnitTest& ) {}
  virtual void OnEnvironmentsTearDownEnd(const UnitTest& ) {}
  virtual void OnTestIterationEnd(const UnitTest& ,
                                  int ) {}
  virtual void OnTestProgramEnd(const UnitTest& ) {}
};


class  TestEventListeners {
 public:
  TestEventListeners();
  ~TestEventListeners();

  
  
  
  void Append(TestEventListener* listener);

  
  
  
  TestEventListener* Release(TestEventListener* listener);

  
  
  
  
  
  TestEventListener* default_result_printer() const {
    return default_result_printer_;
  }

  
  
  
  
  
  
  
  TestEventListener* default_xml_generator() const {
    return default_xml_generator_;
  }

 private:
  friend class TestCase;
  friend class TestInfo;
  friend class internal::DefaultGlobalTestPartResultReporter;
  friend class internal::NoExecDeathTest;
  friend class internal::TestEventListenersAccessor;
  friend class internal::UnitTestImpl;

  
  
  TestEventListener* repeater();

  
  
  
  
  
  void SetDefaultResultPrinter(TestEventListener* listener);

  
  
  
  
  
  void SetDefaultXmlGenerator(TestEventListener* listener);

  
  
  bool EventForwardingEnabled() const;
  void SuppressEventForwarding();

  
  internal::TestEventRepeater* repeater_;
  
  TestEventListener* default_result_printer_;
  
  TestEventListener* default_xml_generator_;

  
  TestEventListeners(TestEventListeners const &) = delete; void operator=(TestEventListeners const &) = delete;
};











class  UnitTest {
 public:
  
  
  
  static UnitTest* GetInstance();

  
  
  
  
  
  
  int Run() ;

  
  
  const char* original_working_dir() const;

  
  
  const TestCase* current_test_case() const
      ;

  
  
  const TestInfo* current_test_info() const
      ;

  
  int random_seed() const;

  
  
  
  
  internal::ParameterizedTestCaseRegistry& parameterized_test_registry()
      ;

  
  int successful_test_case_count() const;

  
  int failed_test_case_count() const;

  
  int total_test_case_count() const;

  
  
  int test_case_to_run_count() const;

  
  int successful_test_count() const;

  
  int failed_test_count() const;

  
  int reportable_disabled_test_count() const;

  
  int disabled_test_count() const;

  
  int reportable_test_count() const;

  
  int total_test_count() const;

  
  int test_to_run_count() const;

  
  
  TimeInMillis start_timestamp() const;

  
  TimeInMillis elapsed_time() const;

  
  bool Passed() const;

  
  
  bool Failed() const;

  
  
  const TestCase* GetTestCase(int i) const;

  
  
  const TestResult& ad_hoc_test_result() const;

  
  
  TestEventListeners& listeners();

 private:
  
  
  
  
  
  
  
  
  
  Environment* AddEnvironment(Environment* env);

  
  
  
  
  void AddTestPartResult(TestPartResult::Type result_type,
                         const char* file_name,
                         int line_number,
                         const std::string& message,
                         const std::string& os_stack_trace)
      ;

  
  
  
  
  
  void RecordProperty(const std::string& key, const std::string& value);

  
  
  TestCase* GetMutableTestCase(int i);

  
  internal::UnitTestImpl* impl() { return impl_; }
  const internal::UnitTestImpl* impl() const { return impl_; }

  
  
  friend class ScopedTrace;
  friend class Test;
  friend class internal::AssertHelper;
  friend class internal::StreamingListenerTest;
  friend class internal::UnitTestRecordPropertyTestHelper;
  friend Environment* AddGlobalTestEnvironment(Environment* env);
  friend internal::UnitTestImpl* internal::GetUnitTestImpl();
  friend void internal::ReportFailureInUnknownLocation(
      TestPartResult::Type result_type,
      const std::string& message);

  
  UnitTest();

  
  virtual ~UnitTest();

  
  
  void PushGTestTrace(const internal::TraceInfo& trace)
      ;

  
  void PopGTestTrace()
      ;

  
  
  mutable internal::Mutex mutex_;

  
  
  
  
  internal::UnitTestImpl* impl_;

  
  UnitTest(UnitTest const &) = delete; void operator=(UnitTest const &) = delete;
};



















inline Environment* AddGlobalTestEnvironment(Environment* env) {
  return UnitTest::GetInstance()->AddEnvironment(env);
}










 void InitGoogleTest(int* argc, char** argv);



 void InitGoogleTest(int* argc, wchar_t** argv);

namespace internal {




template <typename T1, typename T2>
AssertionResult CmpHelperEQFailure(const char* lhs_expression,
                                   const char* rhs_expression,
                                   const T1& lhs, const T2& rhs) {
  return EqFailure(lhs_expression,
                   rhs_expression,
                   FormatForComparisonFailureMessage(lhs, rhs),
                   FormatForComparisonFailureMessage(rhs, lhs),
                   false);
}


template <typename T1, typename T2>
AssertionResult CmpHelperEQ(const char* lhs_expression,
                            const char* rhs_expression,
                            const T1& lhs,
                            const T2& rhs) {
  if (lhs == rhs) {
    return AssertionSuccess();
  }

  return CmpHelperEQFailure(lhs_expression, rhs_expression, lhs, rhs);
}




 AssertionResult CmpHelperEQ(const char* lhs_expression,
                                       const char* rhs_expression,
                                       BiggestInt lhs,
                                       BiggestInt rhs);





template <bool lhs_is_null_literal>
class EqHelper {
 public:
  
  template <typename T1, typename T2>
  static AssertionResult Compare(const char* lhs_expression,
                                 const char* rhs_expression,
                                 const T1& lhs,
                                 const T2& rhs) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }

  
  
  
  
  
  
  static AssertionResult Compare(const char* lhs_expression,
                                 const char* rhs_expression,
                                 BiggestInt lhs,
                                 BiggestInt rhs) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }
};



template <>
class EqHelper<true> {
 public:
  
  
  
  
  template <typename T1, typename T2>
  static AssertionResult Compare(
      const char* lhs_expression,
      const char* rhs_expression,
      const T1& lhs,
      const T2& rhs,
      
      
      
      
      
      typename EnableIf<!is_pointer<T2>::value>::type* = 0) {
    return CmpHelperEQ(lhs_expression, rhs_expression, lhs, rhs);
  }

  
  
  template <typename T>
  static AssertionResult Compare(
      const char* lhs_expression,
      const char* rhs_expression,
      
      
      
      
      
      
      Secret* ,
      T* rhs) {
    
    return CmpHelperEQ(lhs_expression, rhs_expression,
                       static_cast<T*>(0), rhs);
  }
};




template <typename T1, typename T2>
AssertionResult CmpHelperOpFailure(const char* expr1, const char* expr2,
                                   const T1& val1, const T2& val2,
                                   const char* op) {
  return AssertionFailure()
         << "Expected: (" << expr1 << ") " << op << " (" << expr2
         << "), actual: " << FormatForComparisonFailureMessage(val1, val2)
         << " vs " << FormatForComparisonFailureMessage(val2, val1);
}




























template <typename T1, typename T2>AssertionResult CmpHelperNE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 != val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "!="); }} AssertionResult CmpHelperNE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperLE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 <= val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "<="); }} AssertionResult CmpHelperLE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperLT(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 < val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, "<"); }} AssertionResult CmpHelperLT( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperGE(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 >= val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, ">="); }} AssertionResult CmpHelperGE( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);

template <typename T1, typename T2>AssertionResult CmpHelperGT(const char* expr1, const char* expr2, const T1& val1, const T2& val2) { if (val1 > val2) { return AssertionSuccess(); } else { return CmpHelperOpFailure(expr1, expr2, val1, val2, ">"); }} AssertionResult CmpHelperGT( const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2);






 AssertionResult CmpHelperSTREQ(const char* s1_expression,
                                          const char* s2_expression,
                                          const char* s1,
                                          const char* s2);




 AssertionResult CmpHelperSTRCASEEQ(const char* s1_expression,
                                              const char* s2_expression,
                                              const char* s1,
                                              const char* s2);




 AssertionResult CmpHelperSTRNE(const char* s1_expression,
                                          const char* s2_expression,
                                          const char* s1,
                                          const char* s2);




 AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
                                              const char* s2_expression,
                                              const char* s1,
                                              const char* s2);





 AssertionResult CmpHelperSTREQ(const char* s1_expression,
                                          const char* s2_expression,
                                          const wchar_t* s1,
                                          const wchar_t* s2);




 AssertionResult CmpHelperSTRNE(const char* s1_expression,
                                          const char* s2_expression,
                                          const wchar_t* s1,
                                          const wchar_t* s2);

}  









 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const char* needle, const char* haystack);
 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const wchar_t* needle, const wchar_t* haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const char* needle, const char* haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const wchar_t* needle, const wchar_t* haystack);
 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::string& needle, const ::std::string& haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::string& needle, const ::std::string& haystack);


 AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::wstring& needle, const ::std::wstring& haystack);
 AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
    const ::std::wstring& needle, const ::std::wstring& haystack);
#line 1671 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

namespace internal {








template <typename RawType>
AssertionResult CmpHelperFloatingPointEQ(const char* lhs_expression,
                                         const char* rhs_expression,
                                         RawType lhs_value,
                                         RawType rhs_value) {
  const FloatingPoint<RawType> lhs(lhs_value), rhs(rhs_value);

  if (lhs.AlmostEquals(rhs)) {
    return AssertionSuccess();
  }

  ::std::stringstream lhs_ss;
  lhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
         << lhs_value;

  ::std::stringstream rhs_ss;
  rhs_ss << std::setprecision(std::numeric_limits<RawType>::digits10 + 2)
         << rhs_value;

  return EqFailure(lhs_expression,
                   rhs_expression,
                   StringStreamToString(&lhs_ss),
                   StringStreamToString(&rhs_ss),
                   false);
}




 AssertionResult DoubleNearPredFormat(const char* expr1,
                                                const char* expr2,
                                                const char* abs_error_expr,
                                                double val1,
                                                double val2,
                                                double abs_error);



class  AssertHelper {
 public:
  
  AssertHelper(TestPartResult::Type type,
               const char* file,
               int line,
               const char* message);
  ~AssertHelper();

  
  
  void operator=(const Message& message) const;

 private:
  
  
  
  
  struct AssertHelperData {
    AssertHelperData(TestPartResult::Type t,
                     const char* srcfile,
                     int line_num,
                     const char* msg)
        : type(t), file(srcfile), line(line_num), message(msg) { }

    TestPartResult::Type const type;
    const char* const file;
    int const line;
    std::string const message;

   private:
    AssertHelperData(AssertHelperData const &) = delete; void operator=(AssertHelperData const &) = delete;
  };

  AssertHelperData* const data_;

  AssertHelper(AssertHelper const &) = delete; void operator=(AssertHelper const &) = delete;
};

}  



































template <typename T>
class WithParamInterface {
 public:
  typedef T ParamType;
  virtual ~WithParamInterface() {}

  
  
  
  
  
  const ParamType& GetParam() const {
    switch (0) case 0: default: if (::testing::internal::IsTrue(parameter_ != 0)) ; else ::testing::internal::GTestLog(::testing::internal::GTEST_FATAL, "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h", 1806).GetStream() << "Condition " "parameter_ != NULL" " failed. "
        << "GetParam() can only be called inside a value-parameterized test "
        << "-- did you intend to write TEST_P instead of TEST_F?";
    return *parameter_;
  }

 private:
  
  
  static void SetParam(const ParamType* parameter) {
    parameter_ = parameter;
  }

  
  static const ParamType* parameter_;

  
  template <class TestClass> friend class internal::ParameterizedTestFactory;
};

template <typename T>
const T* WithParamInterface<T>::parameter_ = 0;




template <typename T>
class TestWithParam : public Test, public WithParamInterface<T> {
};




































#line 1872 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"








#line 1881 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
























































































































#line 2002 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



#line 2006 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



#line 2010 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



#line 2014 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



#line 2018 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"



#line 2022 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
















































































 AssertionResult FloatLE(const char* expr1, const char* expr2,
                                   float val1, float val2);
 AssertionResult DoubleLE(const char* expr1, const char* expr2,
                                    double val1, double val2);

























#line 2132 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"


























class  ScopedTrace {
 public:
  
  

  
  
  template <typename T>
  ScopedTrace(const char* file, int line, const T& message) {
    PushTrace(file, line, (Message() << message).GetString());
  }

  
  ScopedTrace(const char* file, int line, const char* message) {
    PushTrace(file, line, message ? message : "(null)");
  }





#line 2180 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

  ScopedTrace(const char* file, int line, const std::string& message) {
    PushTrace(file, line, message);
  }

  
  
  
  
  ~ScopedTrace();

 private:
  void PushTrace(const char* file, int line, std::string message);

  ScopedTrace(ScopedTrace const &) = delete; void operator=(ScopedTrace const &) = delete;
} ;  
                            
                            



















































template <typename T1, typename T2>
bool StaticAssertTypeEq() {
  (void)internal::StaticAssertTypeEqHelper<T1, T2>();
  return true;
}


































#line 2289 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

































 std::string TempDir();


#pragma warning(pop)
#line 2327 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"

}  









int RUN_ALL_TESTS() ;

inline int RUN_ALL_TESTS() {
  return ::testing::UnitTest::GetInstance()->Run();
}

__pragma(warning(pop))  

#line 2347 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\packages\\Microsoft.googletest.v140.windesktop.msvcstl.static.rt-dyn.1.8.1.6\\build\\native\\include\\gtest\\gtest.h"
#line 8 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\Quick-Union-Find\\pch.h"
#line 3 "C:\\Users\\Israel\\Meu Drive\\development\\projects\\cpp\\Quick-Union-find\\Quick-Union-Find\\Quick-Union-Find\\UnionFind_model.ixx"


export __preprocessed_module unionfind;

export import :quickfind;
export import :quickunion;




